<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KVO和KVC</title>
      <link href="/2019/07/02/KVO%E5%92%8CKVC/"/>
      <url>/2019/07/02/KVO%E5%92%8CKVC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read." />    <label for="pass">Please enter the password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19Dhp3togjoOePiq9aQY5jiRNMeunfUKmkVhXC5PJRWCNrr8OdFkRWv2hHA90ib4HW335rl7w8PGAWF5qLR5Uk0xgK6t3tjhlJb78xBYEibb21WC7m5P+lfxxXUSHvtWpSGlIVe6SmehUH99rHD2NxiSy7qSvu6/tQqGoRWyyD48/dcIWYC38815JFyq7S19GMTZitwyV2dbWASEuj186mvNEHezV0zrscZIDZVScQHAhe/p7IyS9DeQCUH/e9dUL7pHuz7sIfF2rWRF7ULQlxtGUYSPG79dUrp+EF5QzyeocyABFjnqaVZYQKBVapGCeaDzAiKqFq5Igv7s3egzW78l3h1BquxSmBgP/ujA3cpJJWF2aDCX/gmvm7M/QGnd5BCgP8zhskioyoj9TfhUlp+xFUESZSxXBgTbe/NljQxyW54KylMaiPJRUS61MaAqLW5e06ybf2N7Vt/fCSEgAmnNw0Vfk92Rf/bIjmsgfoQThh7z9TqOA9vb50J3aS8qZ2Mfh5Fnzu1aUUWmru53BMKXK/g6sr5CHqLHRyvn83mFoWL/GfnSPkHcNiOP/bJMDLX5YWpLizxKVy2b4hm4uA+v0JXiQIYdCEoEkxxvbKT+Q9TfIHyk3VlNqyniiMS7Zud/F04kSUNLPo/l17cyaVmSGog2eUl+ukYpFtfF9neXNxBK1e6MOWYmI1bgH5J+eLghmZ07X5yDiJAdED4pF4sGApOMNF2XWJvs0YAcJKdKO2sG7jKQBj3VAX+/mW0V16cPbpySFtn5C6BRUEEFUsJ+qomYu9lAiEcMzek+GMonRPEBXrW/N3HChBTiNicBaS1kJFOMsvWIkfYRGYXAZ32oGI1nDd4bFsClrfC+l0LUkm4OjnLatInAPKnsyUYr5qTYsycvfUiaDETAvsJgIjOSq6Ck9t1AnsAq+gveQORbC3f1HWevnTbF8jERZU4dxP2tDGGZOEm01y4zsvn/8Cu+f0b40E611uwRUEF3As0HsYnFkk2DN/1HvSVTuwLSwKj9kCZdJ91tCdNq6hVf2SqQHkk00+KqfG27AbMwZgHYmb6cCElXqJZ+y6E3c8adpWjnC3fjtCNF8yFcI2Z1ANBBde0QlcID9lmYEvKc+0aJod0C1lNPl5LKI+3IGB/G/bBH7k1rUaa+PnW8J7i4WyfW0KpVKJrYL6asP5MJJDWqNzBuv+GDD7UtqOoR6PhVhBLUCekuPOuOWue+iN29SoGQJHHOVlnLQf69rcIb0kMLMKkNX9iion/IK/1QdM9SXoWgYx5zO/9drz72CY6KAJnah+cUwWHbMFBmkmpmMbrzXhiN4R1POdtWTPgyrDA/zB9chHFvpnNxy/rURSNRKdwnKx4ekYs7sUhkhrA0SrekJLSdo1SQUAhvsS21YcZwQeD3cNr6mRBMldMyo6d8hjRVnh1nVXSCAd/fw+x2+vUxRC/a63OORqUXof4sh6dn5ahhQq5K+uu/7dVXnX1+AJOV34vNCQOcfUzvJBoT1d/7lPfNlzFwFb04pQP48D6+AeYJ0uysvbtHJ8nt4LzRpJogMlrRLtz4FKxBlcIctQSWnQb78TCxgMBh3qmkaHEOamy428OZ0Xaf2B/0MF5VQYRTqpZ/m35EL4E8KpFEKIa/qr/KIX8nO8UUM7IDr0UuwzoQI7JNO5HN5Q8NCck5mf2ArcO2JampnhVPl/GybM60aJxBEHe5sXqu7vyBSgBg+Edt1QlC1BBtlFqdl29UJasL+0svrq1Or/6VIAFuPkNInSL514BiJ736MpLIHHwqmaYvNgyqZA3pmd9QIhQsF20cJsGeGCG43ZEKsKs16xnSHVwuvy4dp5/NSMo1S2IbVQEii6l4iW3BMU/d256fC9IvMZjtObH03sscO/1ryunN5pqf3p0ekgOI8+J585w2Mk9KHzO6ilQK5WbQ6XSoQVe+Q1QfLPydzWLXbl/NqFFZ+KeOb5//pN5guYr0mHvjDpO1663+iT3dJ6QmPfJXMmrQfL7dSzZC/6fGTByV2IBMuS7kM3TO6FQdY7hKe/1cff1VZ4BNv3CiArMccf1CSv2/Q1dYay5hDxG/GPKPcJ6TrUKcGoBTg7ZSjgy6ZK5LF8LFHEzeoMcF4tkOLMi57k6Hm7246di2Gdcu1L/8z5qFP2H97s2gBe2LRarLLoZxnJYAxWdt74IBIxOOzdtF92nRj//OJ9pg/1UBmfMJtcZIPH6vjG4w7hLptrHW6OIshSqX9HX74EdGJdL5p0esgFzbiZ7+mDy/5VYYt6cCcRCpBi8Wytj3exUo9E8Bl1QuD79ook9E5K1TvrZlFNKIDL00Y9Uf2FJ2Km9JLeohrlKZI6A5MEsbELaR782IvW9a8CeMW+dtNGbhjYY3fksm1riyqEyvEhy4+0a+aSA9Mpsx6NTFK/vhn6IcyXtJaZO08HhcKklux43/iLQQm8YdA17yqSIB+FgY13F5elffUau41NEon8sZpBzgTY8LxSfgtTLKKsr8zFgMKkybanNTtJ2IpUkfY+UQ0nwOxIaXyBunJsAecSuaHlqC7UbkOih0rPilXnFR7exDnTdog5Scb3G9rNuK2SB9LutdaDm21H9PRSwiZ7Vf92z8c8YEt21s2SnwPP1Q3a72PBNMeppidEUiJbby6AJ5vgWq2OstkraI+uowWqZn90V5P1SJa19AH3zCXeP1KCI4JFZdZrvK2MGw4PKp1X9Eqycl6tuvsnieA932XJMXG5ILqMyuCPhP640mq2N68B+dC/3YVzCMceK/LEfOnnQQeYknNq4vF4WhyiO6Nzu6L1T7D1DIYtWn1TyUI7S8yE4ixONtYUdu8pOW+vR7iKNTi3qUM+5PWKFs/kc/ibIHOo9BilhiOqspsLou4gnMQxV9fNlDF4QkX5tz9f24h4/K0Y1EtnLchhf6vGQJ274iHh2EElnqThC6blce1D+pw1WUGVWRK74vfnmIpabmb0FvWfT2bLOI880xTmOozxBLNU7PDewTgiIv3wWte5AgAeJLl4GBjh9CGXeBaL09WhNwc/YOwP0YTIm+M8Tm02THZ2V9f+IHn9sKelV/oDeyTv1KAO87DpfriRqi0rhbYtagV/Uvp4jdHfoyhJPVm/Yzn0Tbss5+nu/BnJd81suySY+xieSaIV9QO0VgZds7ThDPtsg04B+lxM63vGhpdLGhuYN0+T8hg0a8IG/NipdvPPeve29FcY+uZbBEsteJ4bYPCStvONWORgE4K7a+f6I4zg2dP7skdsAd6SingG2LqvAHJ7EcQibvLP2rRYMBHE9Qyuv1z3EZSroh5E69ivBrSHYwBDvtQ9V1xqlHoFho38ZVengO6t7b5motmqCTADO1Q3jT8j/COmBaz2/jkvqV8AlHalwL6gcpy5zilrnf+s2AJMCnHQ1BpQV9PbeplfRtD7Ya92aGnRB/w8iwV9knoVmdlbNfMRGXuWcFRmBJCg7iglkQ1NzRVudbX8C53T8LL6cQXCLxVS6b+4cqP0brUH6O9ynBjxz2LfeifGI3gSkustXkl6Y1V1ZugcdPomoec+D28jnMqGMktdwQ/0/1mnmfi5YYMt4LNwfMir8UuznqKiNPjEO+qjDr2xuQse/ivC6TlGhkU9UiMLjlZa8z68j4SHzxYk2/bryd6YtC8eT084/U1s3RjYQQ1G1Z5IL8Xc4NNdPRM25JssCIjSsm71jCIMZi1hu9D2EpzlTpVoyNCEm7oq3fnHavkgNjnv5wX8xFVGFP1r1IZBWBhljDCmD4kTr7OgEvZB4TfIFbk5tiIzBAMX9hpyqkgZ6wh8+6BNf8zKhKvXIBG37YYmNFXgF1UECX+wnn2HVTsAtjOATa5bHsCr9IeRJhw98uaMlVVy8LLsLhO4BrgfO5X4J0SQtykQ+v/v3WvdLo/nXq0W90VNyMvN9W9twu1Ag91PX3v05IQ8dnt+eV6u/iMVNut4wSSmL7qS7BirLQecAX1vus6+eUogAbA8+kDksYszb8P8PUCR1DsQB0AWkOt5XYfA7LDU0u4kXebMzrXICa+wX2mOLC44vJXwlDxqf0k4B1wRhtIjTcJDnrM+mx4Uu+f2wnAPrDJT6ka1R8Nlhcs+K0tpR+clNI67G6WCYHiMcRU0/DhepFBXQgVRcy/pD97wF2WR61eqM7dFN6sv5ZelYjiW1ZGMCrUeAmOdqR17qy0GWXvJrdBg0hdijV6Q7+bjFOGxCD2cxG7VNxeXES/dNC1oz5UdDuvfYfdLLVCBv6hEYWUWCdaJX5ZLBmG4rqGhuec4nN5P5ZwHoeEci9oGdFGNCEWGwRufNw3K8YAPk5HHxK2guOI2rDV4jvjuEB9eiSDtumFAPpvGkwhoKwlwdBrTWHW7vP0EITrDOuonCL7l9X4K8ICOseTVSDeprEOeLImWL3XjhD41zNs0B7VQbXTqJD4I2VMmgD6Pscw5ia7+aQx0l/hVNrrzGdnmcXwA0WXvPLQGAh4LVQpngq7bfE+VXo+NRweKD3HAZUI6i6HZyYUN4Extl9EVbODICLTF4hVb5xSjiZhqHjirL3YwxB33+tfjvYV/QkAq9rCkX6z2qSl6psx+RVoRSGHsVZUU8pkgEq9Z31TErym3rmbT5lfpiqz72H2cVrW7TNkUVsCGboWC6LsH82MLrE6QKlWcEi0ydPtgpu11J9pkaXHSCliU23IaOG8ULDjngiNF5vxtNubiaBbdqLj1Vm3vaJx48DXnXomE2KdVEUQIDXbBXrZDHoObgGt5lPZLo+lDqczYPeBViFHjZRhNJE7p9nG+7oyrD0EUMvRkbVK4E1YZ/bJwf3XUIYUEaWtS444FRpu79Ur0ZtTZ/v2Gt+4s3BDn1GA8hJtPD19EYvLkPy3nXh7VEf03TVnsBXQczl0y5DKLXtXOtekahCUK7nT1kjv3SIoXDk20UR74g1CjTOR70BMXLZatMidf8oghizxiAn0j3f0JXzrTZIrjfGsYdb70OSYnn5UT0Ry7ACxjdtD3hASRLI3xqC7dAzjFS5AtWlYET8gkYViyBeddPcDG+t+zdBF/eJwFC2bKJLwGT180RJ3sycdnf4x0EIT20SgLgLDzg+mmqVZWl6+xK6D5LGcox/1cQHl5yzFJtas734B00GzkUvoUSBIDiVM5qU87ukWLl5mDoAD9Atp8ihRQcpqOwsDExggyH/NPy2mbGYHRHrvNQ0rkh9FGRBefcdF6cglCfJn+lhwdIgzwcKS27upPNi8grEjb2FEFurAI9JcL028A6Vc8BYjrNYt/NYbHLjr5dXBcRPkdB3Lwn7wMQjPOEezt7QOl8UtvPTBJ4diRfnnH69gkkx+z2PA2upP6OUn6kal60T1dv3o7XGDo8X7tPg7c+0ningjLYnyqOUgPF8Kxx2cJ0R6P3XSKWVn0ykUNeCKnDIF7O9+6J+zb73RZd9ITEgWMKFEIPXBPKr+cQ21wx+1FqLBqvxK8LjwOwlLuB5yaeoSIxkMTqxPbQrTM44OOLvwSSaCX54wAg04YtfM/K83h/g+825Ik5GU1ilBto47ZdgfrN176xDGl9D+ifnVz5WM/swiPz/FextAMUkFjarATtduRyF84CrinHO+SxqbhBsr0ozo0DUAcxwVcEDhHm6sbxBRDravfCZOJ1mgu810IdVrZhE1AfAlbOvA3z1CcnhJwq4hdQvFwOgk/NCDUWc7yn4r0/iAz+rjTWuFsBN0btZ9mKYIlasZMn4pXjx7nzALkL97WRVoKJFqXJP/RfYdOT5V0kJ1dlvd0jfR3YzyqWzOW4egrbKfhrSdCsDFYSVDwMZxwfdrXUrZWt2E0A0zanqc+7pm3CxSShnrAZ0F4CXNCgNxQT1DAzhgzLaneDirMAxdSJokiVNR0XGHkZWeWWtsMOlnGnej4t/Cz0gfhIi5JaA/En+A+PSmxrVi/7QaoGa1qKJZctW6k7Sibena1SgcWYZl+e2C3fxWbekEISG22Z3tOEeIOsRGCHnEwJw+IbT9YXmwl/KV9rnfOaSJo2vpRYCqlulegJMoim9Jz4RhsjhiKcVMIXsg/JOKtFe2mkoHTPl8A1HtdOOyd+AmMRgZQwThFZ4ArcMYpVjXOX6gGCZi9KTieC79dCCFmex2CcL6yh1SYw6PjnMrSaFMlhEFHgx9NWuUF8QbNZKBCj8HjN0TG0nCaEHCK1Qu7kdL0FZzVhlT3EGcM4JRrdPJ8a568gAN8mpulXf+WlNtLLtiqr9GlBP+muGCMotRSs0Ihv9gvBzMEdil1zeMMm9DWU9YlMvaQjjrsKC3R8y/cGP6PNufZaQo3etVnmf/nA3s9jpxhuJZMJyipYIh7Z/hu5n5QULtTXH4Cd9SKuACSN950ejs3fXl3VANCyAysfN7aSIWPqZhoHH/+MEx+qqq82i1ay7Q//7C+PNjN9II7zXS3eFKeV4/YPMEoouD2WQg3/NEf/zgZayvT9lVcXOTSeURWhddr/RKAhqY+HX9gPW3bZTIuuJjraVyezy0iqMO1QTZ54MPya8HCupqpnn+0fodal3qTnCQXXeskT7I93nQyGou8uKrv14nsA7hidKw7/I1/Pajzwv5G+KB92thMOnIXPS2tK3OHaO7Z/iG2sgmrFfcwcHPdO21fsnUfEmFaW/66Wu6LMqqzJ4249rXGH6iYDHZN1hSQUYZztKkAXwd6IBMY6CvlZIysATAtneeL3xOvB4uY5wsvwC6nkdLFumTkZERTGzDqv8FkyY1f4ns3/9dO6NCbUgnATtPVJgcBpc+Cgu6b/wovQfTE1WZaW+t1XK4L5er70g1FfZ30GP6ATxqJbJokFzKPslJgzCI+b9TmEBWCHschznLEPCQDZCCQL5ApbeQtw6m3ybybZHE0OiZH1zDYFTjnTNwM0pbKqeEPGvpy0U9/OTZ4PhIF0ddqZacGaWs/1nKXsb2MZ7EaEMVSwSpdgRg2BqKHfmi+zfqyV/SXF5ZHbO0yizx5JzzUhdeg6AkgQMavFCyOOe90QPcl9U5dvIlo5XI6nyfNT/g83Y6uVFANB6rbZQC/xSNTHzxTQhqSvn4u3cASFXskJcPzn76McDI0XJQ14rG2dOM1taNRr0FJFtxK6M89/LGYWr9LgyaJHCvlU4a3qNDilcKZ5Am0zo/88DikxqwU5QnGRjtPOVoikfIcdn44hhocg8vFeGEmL7RWcoAKaaCHw+DC+Naho507Bn66Ltgc90UqEyE9lJvQe7OZdL/duPEnMncXoCrSAEC6/U2g0O/qwLxB08tzHecBVRxQtvLQ5Pf41J3kJm+WiqkQNBWDEqGW2KIS+B+Fypokgjo0pyh6+VtmDcCaJWJpnKTFrRxLKlhg7VA5EAgk84aFslPep7qFcmM0jvq0+E3M3EKoUjZ6b/Au74hYJsK9b3pwPLedc21jLDCXl3Bk+ZwCopX0uqtB1/SRzNUFDm4DRQCq5oV1DSWR864unzvG+iwnSWUADfm1WvGFAESnlgX4gJOrGpPygG2Bl+8y0u9SrjqhOXrwuW02C7e3ABqllTGCZX/UIkvblGJMLwkK1C9ML7ZOP/xCu2hWHhMj04FQMZA+pDkvYhS5muzkIuMXjPpt/iqMi8lSm57km2tNWZr94TSB1X8Nu2L0QeX0lPBFU3u92/cCLTFlPISfDehr9AV/ymDwj2a7fDFGDIYoN1crGE5WOtt/XrSgTZlN6ipBTyi9xvmaeqJdWQwVmVwMSMVz6//Wlsu8xqVlXCbm1Gi3e7q61qwwDFYRgBBrem97ZwVR0GraAmVdPJ9HIwRSFNuVVdKcmqF6hisydi9l8idA4CTozkCD+hHNAepsTV2XTNNm9jQqo4ijYozJyqAvkzhMMnDx2PVfHsTAt7f4o//ivD735W7Z8zYgSKkq/xcbB5dJ8sHeNGu/Q3HZwNhltTa6ltNfaRuC4A0RAYTVw7v8QUcFggYNC/lM3IquGC5z6mCPfikCk08E5kexBaaO5dqMOdJ6msq4WccyNyOtBvoPa/w6wY3zaXFdx2llfTkt6R3Fkb/2VOsFfmS3fG83DS7B460H7iXjutOnLBs+hxhxk5gq3S/S3liBLB90nkN96kqWaY9y8LYn6pCdSlKQp7MKoqCFDUqQdnrdm0dvt0F8RU0LXpr6iPd1ZJungCT+/ejlKvXz+69jF8AgMGAvKqVoCExwl3Yxv2wpfUHMeDoAwnqrFZy7vEX9FjdU11UHZ8fQW1F8m25G3duz8SKnIKdal2OASiP3Yxw/sGGAaVgHTUNjQKZd2RGg5gq+tEr9vIvp9dKIF4sx1jrd8J+eozOX4ctAjElftFFqYg1orth/CU95T0Mwcx55hM/ptKAgKra1lIfa0YF6H76Kcm/lhYvenCHMedKGPTi19RLidptcR2SBMbQT11IpWq7mZmb3aZ9g84JnhPT5bJ5YjjpQS+xzVoQO7bZBIJ830F6gBx7Nker+9RDlfl3u+OCfD3lFA11rgSyWFWD3zbLzzyIB8azc4GI92KjEkYH5xwc/714bHFFf92vmuuCdzri7sX+tsrCRK3EElbAoFrOnVNo0XIncRbRdg9M0iQ+Yn6jLlXIQUYfXFtmzkkf+JfbQPiZVacP8TJVdeN3BdgoieJh2EJyiVEpAcuKE86PWDD3zbDNHaNW2t2L2KmEB6qZU+A663WnyTBMkyVSSBcFHeSvGxmlnfor8Il6Msbj2NLbC96ihRSRy1EOlfITi/lQLzBflpZq8bR7J2fn2x5LHYGhlvtmSPTDzCsqtPX3EJD03AJHs21rXRyFpfAENk9bQ4JfBmdNSq0mq/aNAN2IguEvJ+PqTSK9xWZb4+B32ZQ6psqdLY2WVmuWyFNRKrqxNQbdQQEkxWrwveZpShCxJ2DyisK+eXwy3VguTO5mpjmSgD/vro44NyN9xzREKeHJXMy/5cfstPAx84Sp3xRIjyeHg2NHYHuiZHhf+gJqD7AUIBYop7PLeNC2HVoiH2xFURuxa7en9LK4O1hVNpoFxIPvYExenKVLi4t616URO06bw9kS22r5jEK/OTrB28ik3d8t2MN/h3pgYkw/Nh2oBe99TiyJvsAb83WnGWdtefeoIWI6XwlPRY28GOJ6xvjkKMTLk2MvE3G6vbVzkSuo/oS190RWvfKq1ODiVVSEaHgTEr9C+u0dW8V9k2OFRldVgJI0/3L5npypa4WzGzJORL78uvfUb8cv1OH3qReufE27Sg6aTY+37/SeqF9CO8mfHnq/RNrzI/MWKugs+mfaQSnQF04TsahdQGHOzObqNbuQmVLCtXmOp8089oGdxQ1NrZYOOjd6lj9aE72T/FOKtHfIru5lv8owVS3X5ZtCg0SKw+stEzEFHVGzyPvN5H3J+Vn9/KmCcOAXbC+sJL4cf7tYV+zN7D4yjZDQAOTfPlg7kVPhPVNXgejDlin4tLBDB5Ezmb+avfFGt3ZvrxoJ9cXpLQ453rqGz1QXxzLslEEjKWX+2sM2MAH8zfeVKxjpgJj1FaJ7zg7gUkaOStRUPnbtOXCzaoVzawXClneeJvXhE9fs2hwORUd8AydDG+85MbD+b6gFMmRaWY2sef3NhVSulScGC3jbml0dpuPrpE3ZhFMdqSMrUpzCJmPNQZfjiAfPh4eM8UKRJFZsgw3AYMvHocmHaEDg5KSRkcsvCa+iIae0RNVIoHKhFUYVJhgDT7aCA1A+EGF0XYh9/wUCJAQTbjDMor4ZNPamkMxULSckTFvYnVyXERqPI3vSILBRcyebJ5Op1cGT2N8WAXtLa5xp1axjIRtKtA85rd8HQzHQdTSujCtDDzZUY8gGhWnX08GpWieYYdtJ8WPaAuEvi+3Y84UgNaWvFOvpIxVUzav43UU6GtgfbzuX31iw4pGPabc2/YNN3bdsRvHLgVQ5KZiNC0nVrIUQFci3pjjnNkbAhf+PQLieefIxNcwU+pAisc+E5288ZeRf6i9lJx359XQq/i4+WPBu7cAfSi3gOwtd6/hNLNGoBGduqGoeC32WhyEAd36lud8XMnI9VcVwKQMX7E1+kG6gRgMVUpp3/KPfmK7gbXaQ4uEm/1q4r+7y/FBBrZj75NWDgJx5bBHED7tS/qAUHgFR/3RtwoMZnjOeJZjvzMDlQgmm5hnlLNqY2Z/CmvXR/bCNd15EVlP3i/eNHHJZe5VULK1AAgsqPBsLVtemxfJc94uqEFPfuxB02kRIlkSmU7pNXJN0OChL6TkwUhNDLwMvG86m6IiLm8w+O0ouqot9tuFUd+7f2XuYXMZvC+FIdubv6h+w+Rd7rEcr61NMv7agBgRIiOX5E0KWwGFCI12uDYFeQtABeIHCVjS+ld2m+3qIjXzMfdAtA0w8HYHjyn6qDT1PzcAvfCPsCGUdb2StSMD+v3S01c513npoHHmlMYriqwSC50dhZeEYMfa47hIhQTli6T8bm0RuSN2w6MsEn3TrHr1vi9BXWdqdlIUDbSUDrOlX75a6NjnDzvJXlYoevjPt60x/E/iRE/L73tVs4aBnIpPfLImAXOFLcelByfUCycRyGG+WLxtCINvPg8nSj7mL065ZWtXFPAY6J0EIXvMgQr9Jp9xqHzdjzP92a5AKpQYXqMaT7qozlqZmNc8ADtlHKfkMzoiZWAre48qDmy2EdVuqbKu71Jq/Ih6+yMJ1J6ShAHvGMzUSUOHGgYbmgMI5l+qToyWCAtLdvTJTUA5ytZkQYlTzaDMr4Jy46+LrYczb4pitucpFYfrsxgrGQ3ioXyvo6AX2NWk2v6w/Oa6ssYrjFEARthfA08knkVWx2oUg9v2r+IvUd64wdcVvPbtm/iwXsaBzKmjGAvKxWOaAJshsy4rptlGtCkzdlMsa2IOaNA2hVP2X8hvlZO4aL+S/wZ9ULu58oiyBjxw7t4yo29jcXLQiGKFCXW4T9W9mGPWl+T5LXFftxd0vEK0AO2Cv5TkOQUOG5YpsNkpPdelPs6SvjnhiOdP9N5LmSvbQcJEmAO31YTjy0IQqiEVMhQKnEbC2nU7gj3hjQPLogHppAFUMbjaZEG821ItmNwWeCQOev7YqKJNfPXl7bqkc+truX11z8BrxqzlAs/GBjENonDGY118jtK4ApueF9GaxepVQbyHaozBws9QRmINq28JUf1QqU4hu9sC84wtSo9OyZBu54WfeHAFKxPqrFImgD1yJkc3qaocGHEWBMqLDgWIk0MI/XJWWquYypAsJ5CqS/P6IRPb54MzHCXxmmG9ZO1q0Xw/Vkkny8QeuQAaG2/Sx2EeTA8Mo0rPE7r/SzxkPhKhr+bkSoM4986X/gLrrtA7qkwOMR0rXWUzRHk7adp5cFlLAnmOk3SJIxSOgxJfbIe+kcGHUmasQO3sjwUETM1Gzohw400II/SVYYiP3w8D+AnsTQWOe+vxKzM8t6ZySzSBh+YvlwA54SMQ8u9Uc6OtRQuLa/sx2rmYkR4+ZIu61HH9VOSpWQXVoAVG4TTs1572Rw5LOuZvIhlHpCknG1RI8q26gvVcfQGAd5QwiMcPrwltGXNHBVCK2U4jV+eYnEKoBzLUCs77Mrg9M9J3wVkYxO6SbnReewG5ML7THrjU5UfP0WB3/w/CPmvWIIalOKfrZRaDq397lNewU1c4qzKCNvL4p+2dLLaj0ywR3vSKleZ3N1GMibjCPy2z45sgqU/K5SpbeJ9J1//shmFG+0usJ/5Hx81slhROMpWX6f1voVYGr6kxcbjiSxawTsDZMau0BAiw8rcjadMP3bZeRd3u3F3zaR9qeb5tfKzfCRPP9s+oe4DTXExOjHU3252bR78nYp1ICb7Wv+qoTVF/+ueEJDKnDq/goLZzHQkp++BezLOKWIJzVO4hZCWalr7m5tnu6+toZBfH6FyJq8BNMKZy9Ai8IBR8o2ynmjaPfqBT5GWTuYAK77HeAAXk6K4HwFw20yvGG8Km7tPpsZvfgNM+8m0S7VYa8e5pZQMHgNTx6RPXCjdnrRkoVl8ZCQMFfR8I0XmW3r9YROFkaVCN8JJ8YdOnWb/U1stvtQbZ6yKyZX3W9NNJnv1vT7yzJPc336UZxg5Onc14KSaHaw2oIQqgavwA4NFoPjvC7kYG2dJoGGg5+ia0b39ommEnStWSiueVfWUpluwHKB3MeWONas5SqNFCTyF1u3ZMt6LSLN1oY2cQCrNkxeAXGXv7gnFu7R/3FQuk2B27pdMzfqieYCZln9xQ5JcPGDiLaMM0HoU99I6IfRGBo/QjSfhoCxzRp56rIKJobrDT3HsrjoQ/N45Yp1YBvA+LjpsL3FBAYiq+XVIQtaY4Y+1MD49wKkzdbg7S/ibz/CnLVwowhNC19gdHJErOU7rCIWSg5MldhcgdXJEmOnEeTBMr1u1ZWSF93Y41zBuHNAo8TO5iT8c+dpaUmP/1GbLTwMXDTvm3Gyc6Le09hBOThYi5Ej1AXST7mPOQxXHhEl8Tt4A1vQGoqOF6uHgNxSPEdsKnWrwgmxf+2csgoUaTLDMftaQuVkVMcqtTsLgXhFA+tDSuAZVPzM4XBKGx+ZKonYKuTf4eeJrc0zZxhiyrThrfF50RjZS0zGSzaWci1QZf0dAzYiGGSabpVU127DwQR6Qg8fokfGl49onjFKu+hMc4QG/NROCHBkPUp74K/tAGfRr+yxoK5VGr3JtBfe/ZFSMGtojiKDm6dKlFh5dhWTJRwP4IzY2MhKxsGc8/lBOqhzlZeTqbUQOHb+8dNs/eD9Pw4BiaxmnDNIBFHD6uflXZlkUD4+3/r0vVPdXCe2u/DTepPtCMxQVtYAKvmL3J+BVpesXy1bevYwuTrD3HVQ9SGvnex6D7IMIXjTZK59gxkBq/RG619zBBewgPlWeMAk+KjyoIlIcpiUTuTfZamOmN1BNRDhamDNynWpzdkoU45MOVQ5E0MfMoN7Y5gR6jw0yUoScIixtxSj1Mw8/MtO9Jzv1OET+WdZu/oizmdcYcAp85gW71GAlVjInLEqvrDqlMXYyE6AuzJmPqQH1exqtk3D+QqHN4JyYoGhrbRJLNslTZfV7D7k11GT/m0n7GfXrXz0NqxM4NTwhfn2mL4Od/rKvvAmfvIvvymDLzPFL4NhZX4Tej/SJgdxnQz8swJV7mnlkovpNN7qvglxG1wQN3jn819PHs88WmAa2FOBkvhaurhQmPw/BA/RyHFd6tjhXzHG2TvRBiu750Z+dFDgdV2PhLi+UyEBXNQUkNrOAMdMqW8+3Zwd7pzMLuksJtrahs+WJ95elew9077LJQjAk++e7UnR03pu7vSdeRiGcoWuN08tLvwatcKeCoQbzx29bpUMhxPcqhOOLaLVuvTKdFEjWwiuFr7JQQ0fCLQu55Y1qL2ihls1+Bdg27PjGyNb7HVpGgtXMRPM6yLbqlhjrzfI3c+On1t9dXWF7W3SrLRkduWhuvYt4VMe5gbOBrkS8H7UcX2gCfEARI4UF9KrUO6PnjZBYRLG+pG3dpUIETzAS5i5naPoOm9X8mkwEUT+Kk/nJf3OOsYrheiCcMFwQBH0TFGgCidLlWsq0NW7/GTQWDdzXLQBuPQLRRcGOVKg+qaRkOPDzhqKojqBCYsG89yf4rx5+J+S2i08sJkjXfsp8cBM12jLuMg/PeR+2kdGCmrEDpMQLr8wWkalJjx3YYvG67x/vISBwj6JVnt8mp7xSfkpU3iOPtFpVwihaogGFdQynOTQ5Osj+H05N5SPpHDATCnLGXMM41XhioXud6U180vQs71e93QGk+p31V4iUnPVUNc9fDVs3KrMrI31gD0kiG22nAKwNcZlESPk2RB0xDvaErgNJkee1R8vRvy5dGf74Kz+0AEsQB7ZkzIVCEVIjOWeWAjZfBhURyFpy2wdt0MQZ4QdF6giWnq8BexCbQx5+sDvxUfzNaIQmISmK2kiqKH+JHo1Kkop/5h6yELyB/pAB31akYX0dZJli9Fyhk3lRO0OnZgZWvX8ZfAEetLNyYdUONo/dLYrcx6UGKJ/7V3O0NMK3xdpeb+Li4fLJqlutFJYy9f5v0LXEkvRl60dorWb6oFxniEWVUCm9u3DTiE9HltO7bJUUQuQnl6knhbWNdwLlNmepWxjHlGvkg3RG/UHU/6ULSliq7HZAkDhT/y4oP98OJIY8eSWl4Z4lCQ28DfOE47XWeL/OLe8iUAeXiJeixJysZx+Fqc1lbrdFX/cFPyOOZXAnu2c7pmDvna2fULSvAFEslAM7RRr25/YhpQizh+GvfFLyNckKy8RZ4YFRUUALzQoe+XNpSJYtPB9mrzpKS9R7EEJEFotH1IWGXlZYnWjPJfF8Mr8r1/vF7AzA+42zcuZGtcPwkI+9n0wZ4XB0WESFBcLBTfbj5L59gao5CRKUVPDY1pGtB7QFxtmR104cdZ7rkguUuZRTyETU9Ijla2ziCD2FJMsL6lb9x6A1uW59LI9bHKoQAtVD4ZpAwhkXVrtX+smjOzuRE/xsW87C9J3+1q+AhwsAd8VRT0N9a3zIyzdwVy6g8xq4MkQUcxg9SNCWsHSg1ygD1z32csIoSykBG3U9lmPnCIyyBmi//fItLIFYQealduQWE9Jya+JU/03ea1dg5vmhGn+0q7rmyFWL494r5BBNoat3c7uPYlunbvvKIvepluyBN4OY3mZWBr9q3I8H6VXaCWgB24Fhn/M1//RgRcGCbGNRvOqOO4Ppt8xgfMyL7YcCjUymYCyKmjU6iJOgOZ87DHyPa7goNFk/OQl6f7Zmedg2yvmV/PlBQ4166Nr6KsxomBsyQ0pEYGxYAJYyarH2k/08kyPsTOoIr4+8Ob0IRghEgPu797iMe951uONaClewui1i3iYn8T3nA9IKevqCQ+/JtbaRasH4YOWypnSZxOcGtERDG+uwgRGRJX+78gtwRlOpYQOK9YKvh5hyjpYA0mzRq8f4Q9hgH8og+pbxn8iiA9bMhl58a8OvqBx3S6lCEY1Wuk1yrGVU3KieCRuEsS4TYv3klz/23FV5L5T7LcnJBlviiL+e9N3dcZGllEgGzBmN36CKg5kXDsE5FFO7ffM8bN6OmdmQvSt4Ze5aA6pvazkoalAvb64iAjOawlhDfe8UsLKY+/5eZZCpDbRdaIvhBe+I1YdePj63t0Qx+6cVbW85/lgfPxZvMILrxgeoRf7uGdjC7gwDnHUoSghXf80SRmZl6BgsyellWLS9tr92ZJo0dvNd9Lb/giGriapPbVJvsOC1aMWqzcPZWFKTxvWmYyTZoVTKzjYTUePAKBvtWj3DH0+W430dpeFTTna/pL97WBn7hIl+rkfdnCT789LcOe2JVj6E+SvITgBee+ausNxkirmH6POOftKzsq9+Iq36kP/5RblMzx1VlXK9sH9rR5pkWpA+GBMvDGVXjZnJVsSfqnV2dbSIOfmYvhRXNL58EA+wtQoIV5zoWqX+NGex1LikROFHYKkE8blJJ6Z2g2JhzctByUGQrfVMEFytwzVILqsZgbFidLoIueyIJ1h5zV9K0AaP8mDqbzUY50c/5qkWkKP4fvN+ekcUvJ1tLofwX1u/lJL8OehWGFtcz1nki+FuA/8f+SU5BUatwPqLn1WZvnkkhyenWkhWmzQYsX5J74ehaVWIsSpkyl6DPvXDRWq2x8I2vHMAaVchQ+/HZtXl5hmDHcaHCX6v2fgnczYrFWYFZ5OgW6mCJScDL1mWt6pbk1uFnlEvjNNLoTuktAl0iSdN42bzwGK1VaxE2IWI3YRyfqHziEO1WFp8DeXTpTSve4U9+l6mhGYm53QRAZFhAZcJrxp7K872CG1MZVKALOI7ZvFpxpB9Pn42M1wF2s19qRh9/TvdGqBe1VhYlQ6HXkXjkWlQLc60aGsumMwf1xODcLtPfbnpRqhgE9FuQhKIkETjEtJ2IBPiMsP/sQxxy6R3SPelKPjVGX0sM17xNzdt76bCJZ672sASyfQLYnmrka5TlnEzqOfwJCVht6/6QhmIUiT4dckqDrFX0yO774+zVNxkcGhgqVtwaIscCUnswZXGQlPckYgmh9EqovNUCodPTIZ4ilyII1SuxkZEP57fGS9/RrATY17RLwfl4Gf8ZxexlQhH5euMvwnp8Ckq9yL5pa2Nyz7dC5aepkHNqHb78ynb7H/4M6JUDVkwNWDb9+jHpRBAc9rf2KwVjoNF9LepJwXDA9J/ASvXV37HMr9YJhxpfubrBsjo9DbyKZoIYEbO2WEpzcgqR9Cf395ff05syRsNbJH7z9GXyAO+FqFrfzrLDulKlAo6xmw6oqoE0GCnUXZ1yWDpZ4Dx34tMp7zqDoLoBkti/1w7Ch6/P3Bj+tCqY4tBTwjSYF6Mt7ggSllOkoYBxBjmWcBi1UkdIsPJTOVQV/M5n2uJ/pnZtuPhMDY+vdcPzbFwuM8tvlmw4I/Pa7tc/7dbjobHhRZ8pBsqSTPWoa/JgQXokHj8iXlbJ4PP8bndSyBwY6L5Wo07W6BYX/xmNqZT/ObN32vBt3rVKRseBFxauvfxNHDjrbcuIliTvySdDJE9VMR7rzCqA7Fy+PPUzeWMUTbW7KgGCIJ/BZKWHA9+X11GrGjMjdtjYN8j0JOl3bypB1yDEBFQf+3ftUQxVOoHBiyxdXuoawsuzkkiLKGZ3ax9PLU0rPoZEOKdVuTWOxmiE3TgTHEi3Nqmwlee3WHsffUj5PKSItY8D5tvd14tn9zUQGsOOQD9SDbrOZk2yJoTVxPweKkf4bIXewxHG4CPRcue8mva6QhMfVyjtC9Z7XLZ0w+95VBZJrw+Rn/I5VLueW4yQnpdQxvELfLa8aGUDYbDF2HkMhbdQanyleA3XH5uI4ocFS2l3IwFbsylAk8GvNP1nkbrRN54XyAY8FkKTYxYmVKGvuE42b09R1X5+HK04Cybd74JVx8FuMQFTccz6zD/AlipgeNNiUIdkz7HbqK4pe010lE5dQzG4z9pGIPoFKDRtRvpSLgk/mozuoLfBNV86eQxTA9j1dQK5sGgqCjiFGVf2U+ZDc8e9QMi5E6yMLT9+xziR2slJufUyk/+Lt/hA9/9nV2OEjCkuWjNpzgt80QT5jg4KWAPm+tlneSuv7YydTDyE4W0AYXa4zg3osdY3vE34Rj3CRme55yhumCaQ1jjwY6vasfXA3VzkGFNX8hbq50CLQpHRaWHdf8BvBmOuAC9y6h1FqIEAMGXoqkVkY/+KrRJI/r5k/T5ad9bTHfWpdWkBi1lWRCm6CiHxU7CI+b1Sd/2nCfmVsR9R5n1RUYjRTjHASl0/YepSjuzcKBH2IKUYWV/yj0Lby19kn1j4U1sj5Ggj5tcbrQJ3xDiI8q5lLz4uz8G0ez+ZlGiGllVNH/SH0mXOKX5QcgLV/78+4fI8sy8Gfi/m0B8KOlb2uXw1+E10X8SH4Lbc8N58i9TuSOYYsOgAM2/HH1z//4BCJx1QPN9yrpE1GQYYM9vD3W/HKUkhXqpBUh6I65KszlRK/aRWGRVCuJ1YIEmZgZ4Ud1gMogcjx3zRRpbHn51/qBgvCH3fojWUCCCP8426EWMAZSp41PutHHOHN677kziGFG0LB0TtJnSL1ju9vn2i6zuFzeTmjPlKNTVHEqxpiPcXXk2T85peY7KJpg6qMmGvX1/CyZRSzn9b83vIA1GfZvkiQlYBF9CZM/dV0fE5mJbNjwfIhkYnHB+ZjNJkfjz+F3lkD+kSx/YFlUVyt6H5D02pIc1y+wq+4lZiIjMh3CSl4v2s2vfjBxDJ//Jnu9nhe6QjTp5xw8hnebepgfr7IlDnDqHbgj7AnNHY2OMnGAFbkG7x3DN9ECV0vDLpn+jYlLckUlWJYu4QLex/sDnahUDT1mQpEcf/hV8h8uzWmuHm+jK8U1m7Oa7HDZJuffsZyMMr8rLpAp6NjhlbIIQUFcCYo1Wv4vwr4LckLLRdy9U6hmYnJsZib61jakAXmAZx8G5ogTx7b45tCAmf26TIfdyqJs/LSpBUMFobF4D9RZG4RbjuTzz78tg24CWlzkk/XK47zY321hSTt4OJDIvOUReu4Qm8/KTQPl5RKbaO5+b3I/FzTAgvOp+vG4bT+0NfCH+qDNHfHAbOu2RbItO+pUz/YQ6KAg2WYGSLzZTs3pYJpclwIczshuuKaOclOjgCoQ/KEzTkCd+LgjnsjR5gJf9HnmaO/j//lo6tVYhiQypfOw78nxMiTW1/BRh2yyS1vAPMQIkCzMl1Q7awJFtZ3OEXZUSVi8+4WUelKTaF2FfvGnU7FffQiCxDkI3TV7EYwCwN9xqcYY2agVnmRM98ByqaEbF7G9IpltbNIFm1X8s1+nukTVAzSu2gASJ/CADvjnOKLBvtiXLi+79FLsTMcjfXzmukdn3x1Bc4vtKN3Bk5MEpYjCN8OQnAii8C+nv2blNGVeDo4vkf3mEuwslvqD8ax+Wm0UTEhR/nHizEFtqc/2xm0hBr1YeM1+HEu7kmOnfYTSk2fPUZVlfknvkkSawXYzxflDH4MpYyHZ8Xm/g/extH5PthTMtF385uPEasImg/RTtT1OjCZdy9t5NITStoTa1szBuZFLP21ve09+EBa7YCJ9i9noCrnylq7mAelBPr6cITgkqGKdSq0d+WYJydGs0KuUa+4QrAkX4HZv5cwE4i97Wiz+VC9H9YCGdnlENOQqeWwuxhSVde5Or0MApWNyN5a1zD/EAHbBpCpMqAam1/3NoxexB/4pKgO6k96y9X1WYitwb9vgctz4wHDK7KBreAIz4RotGZN/wikwa6br9gKVpJtDxhWnGsC2+4z1otlLIWubv/bNlfZoM10ZoHfpUnjCTcogBgtIKQSVjQRWVaJ7PksxRb/BHPJhXDVA+m150a/jdIpfh5BcIF8AnDgBzMbPTuGUg/KMlsXj4zYIodkQ0yIyeR+zMCV7n04DpBJi4rDIqtQkAhW0tvPk4+VcrtwlUFr21sPT5OJ9Vt2Kiu+8eOkEiRSx3GZVEyqM3ByIr29+IzEk/818lCFzBVtxqeo9fQclDUe+MLDskEMxO/32ykpNSU+vCwv+QFwijWuGLM0nPbFLxDvYudhFIdODpfUlpjjpwL2gD8F+E4Hg8DObiS2eEpqfZX+JIaOqeRimY3IwG20yyITF+HqwdOsaB+sTIZBAlPnh7YbOGB5d1Hr8WwzrUl3rp6waYaHllNaNvQaYR+1HlhatyNKDJgDFIwZMIjOFbshiji2SmlwKedjjWu3UP+sT9ItcDsyDxFBM0xi4kFaHP7TyPrE/gEJomLrIl4tg6QGoyN4DsNHOl1Fb55LLeSlNBJfhrN+QldQGoLSss8PqZ2u9KQqVh33XZxrIBkVrC2tVbo1OEUXnHAJdJdYOhXJmFzE+pYCkxt5uyGf81bauB+5Bf9hLlMP78H7prH1Ls+frM/J7lwrA5KlyDrPIxbsSCWasAXjGlq5heP/sgxJbm90Kzdl9UpU7Hcmnl/MPL46aYvKqZGl1GiXKVjRfOauEM1MtufXA7JG4HNhaakiBjvQFjj+P6ompJ+7DJyJmjXjV0XH33L7AN2RRzEkL3wvIXWG50wp/tzvzr+52e4srOiqqGC0s4O5zRQgTMke9cjAHOJZ5UkeCmyJjZGIhYIHtsofpV85ErinWiNlcpYJ8t4WmQQIjobaK36YBK4ZFLs8K2N2YAdxQtfUB5Hv4JJZcs9lSK+zPskKc3OyfvcBR1y8r5gUlr7UpeNSNFEQ0HvrQF0b5RQf1Diwam6+NxNPxmhxiuvLDEEbve+26K8YXBfkuVrb47dkmyL9nCx2T+cSdNAj0QXrPDG2wfyZ0dBjesahey/Yujs6T9/VF18sge3r3fx9zxR4onY10gKGKH9R4C2sv1VFpDGtMzGw1P6bF3oTKEUrKEtAvEjudvITvZ3+x6BxsH6vtqVkYI0AOusf4Qxr8z1aGVkpuDbaXkTGV6VSNLS0KcEiBe8n+KV2vAZMKCRyan+DxcYdZKQmDJgntDVPJJXz4EiaGcu640VxZYAYO2iz4vV3U2Q8Hc2Mq1JOLID1ntqOe8KKf+zWK/nqIOoJPNV+E/heWkdv79+EkbC7ZAwdxkFp9PFT06h7dNy8tPzXk21gsKYszvKOUHGixjWZZHLBHXyJLiAYI78nceqoUbxtA316w+6eNu7W+uVyGM12LhLdOruwa782nh7Q8ooqr5Me1bO2uvW/PZGzV+SKxEnDGwgUPHRAhonivl+EYNOlzrh2sJwZCTUJ2ILlj/CVcp+f31S8Q7v4MKgCPsaP0nxi62M34TW8b9GraBClogl8o3jJ/rmqYjPlVn9/0GkgH1wulnN+QFgfo5xiqYfACmKTbldVmTL04kYgKnONbmedx+bEHTbbKLM52FjkUB7nM6qdFIuNWKtVs+jklZ/bSu7DDI1o8fdiLYJ6yAYiomE3WX0H5jvm2kgs8m0hhwLyjHoGLjEjnCZyvNjF58OZ5jjxl5aCL+4b/s9C/+G5MwPsxqlo3r2GkIQRbgQjGY8PMEr7T8VL8kgOGDb9B8J2fFDKt8vY2d5MmZVg/MAq5UGOSytU3Ho9Q33HKhUzv6RxyijMhBYCisUTmPwV52+L54DUNaJtfj+hsMVnrp3Kz9de6zb3Hypf3Erk9LS66ch8kKm6rQ9fgdtblZoalaDbo/XWsvAy6RM86hdKVnK22omgLG+pr85+OUvkwrLV21My2G7PYUsvNVabFrBIqDTJ8H6ya340zrkn5G/ts9tA5pF+IPlgGvvRGY8lbAotDRFl/T3HVTj4RmQWRgBuKETVFDup7LgEAHEIcH+KFX5kGkDrfFeMG5OrVPScDOPj1EArKZQg4wda8dDv6aNPT1IxirFbmnPBld0V7DXmPJ+34IPn66EUqWfbDaOcsh1V7th3hqFvlSd9gz0xkK6D5C9j3fr0gukBcljeFpCJ92NtkmlQTRIRYGRiI3mWshhChkY8ndNkW5iENpbmJHB9CguL+iJvg7BHVgzG8AC3aQLvPVtPC3SsNUVDIPa7VHJuzam50QxSMJz8Xcy+FgHRtgZd4a7ogtUO1+hhtfWVa1PFOa/ARdpIlkZPua6rlXDc6Xa/+P6rAElUbWpEintWsL6SpOE2IS1WMGh48sPofcnCxAdq1HhJ1LyBKnAGhO1GlGiXaMN+RrIuLYFmmeokpPcm/Xi8VjFRKDUzPQpIrMsgHwzuv9UBI1kPRv30E4gTs0uCg5YLDHCoIOd12iQPigf/OPgqgJ+cnCjkSq8JXbDs1sjypF9YgoxAg+U7REAYwGL3qIjYChcf42FMT4DEHBh+2qj61+Mt52KKFzooj6637Ms34CO0LG17JnvAn5C4joi4PzZ/5lWkCqu+WFer/DV8vQScX9CPp+xVb/T49DqF2fRX+Ya9Okh4C64RotunpjFfQQOosKalxp+WAscvdc2Tl06RFf9jgkjz9htc+crUQ9/uvxz/Ep7qKzYDgXNdZZJsHQIBCaGB5TjeEg8jkWJ8lAnFsE2XoyrhHs6dn8In5beoAoIKEL/FO9UjfpEjYhZiNTF5ThnDU0voWazVT9+mQxKOejNdYOVV08nAX4NqfNQBXZjWDFIPgIRXXY1tspqjSHAqzRlOqRyE6ET4XJHzdHIbVB2bAxQIxSlerg1DEZ8sTIlMxCmbn6v41Ck8di/8pzEUNMSXuVMxHDLuPKyluE2iH0pKbE/8ymMze4GHnZGbX8JARFxBVIf/ei0V/lkA8cEHJq3U40youJIS4E1Nzmgj5nZLD7jglS2Gx4ng7Jx2+M6MNjherEMPUb3nloTbatjcA3I3lowmgTLAZpHvebLoeQvZqL9iHR/BuiXMB1de10T1AxgnJTCy57zbfl+J7TYgS1jnu/hIN33GT+oXrAnP35cG4lPSDpI4lGa/l4gvLxVMFmHYeimkPpWLqF0gwoFDzuzLmtQkBK5s5EXGxKeDHQ/X1Fxk9gr/VnqSfgmA6heOcE/fg1EYZhkrmT7+O9lJ5TQDyOBbHmkdS1e9ED6KVbAbhEJ9xvegxjtdt8ENgqfY5G7SX+elXcCQWaC7/wc30bvKzXSi4IzyYrjB5w3eo3TkemyOT9bj1fZl0oAtPUNhbncTPBTEhBhBKERJADV84LNTjb6JGX0zmQlIcL87MTyvMB9AfEQlP/Lp9LG3tfPuFsE8Zk7X5ZkwOzu0UnJc3PF+Z1u1Mb/Gs+egIVUBCex71kSctggRnOzY5jTD9uMzqHlyDGsdc43bHeOosITEmWCCsyNGRTg459rPbVf4bJkvJdsjr2r3k/scHZCbg3tUqJJ6CK/2SWLuX+iTKvMQMnC5oVqwuD4bso21zpN/WIeWK7L8R1DffbGdIH1yShmY6RYILQwbUpRxbknUGQp1UIn99giUWV6nKTIzqErbySzZCZJfUgZWAO7fQ4L7Tt13SgQ9FCAeZz9xfLi+atYifltt6UsFwUaAI1eohQd90ca+Myifppe5BQhcSiV+GW1X3VmHsFBly8nCnv132tgPi54YMDwgsD4E+xwptGD8/m58kbn28P2FODToUXUsBDTkVAT5ta1pjHje7eXp0Hp6vehLltyP7v7p0nNm3RMYXND2+8PYVw8J7Gz2i59eqQ6JzINXhHk6In34d9j2D+Mp4XZOtuCbwLmDft6TRTRWoyancx4J1K5KCCjGbvW0hpOA7+/dcaCCNDdouzpD5wol0VbgyGb5HNPYcHev3biGZKD24bn+YEYRxcoMO6rXm9/WZjMXisuHZsxY0xu3V5BCLJ7fThWZ136SpASNzFGnT9KI9enyDeAr8QfXQ+HrpMjloo7PwKxJMHQMUPklhBi/b+ua44zRb92muQZExuXGa2Ka0+daLAz2dFQX6xxZ7r4fH2+2RqZg50gzw7Eue6KKBSoyqrEKdDBLGZ92xz9vGcjxaOpnPT1JvBBw6fEin9NM1WX90axaFfJ6Vjl7kdvOyY1h9HPqKpjHYME7xsaUDXmXO8F5Zbu4cJn/oWqv2biQAEqs5lECWEvg3evsbmgHVbH69g0g46F7rpa16NYYC9dsqCie1SxflDzhclDbLMhVM3NX9DcliAil3MB3aq29+4ZgiUM3kVcbAG98as6P7I9GPAmLT4je8kxihsQY7CaZsqJIyFH/gAehxbx7OOl/c09G+73fs0cQ7kzdhKfW6aqZPIo1X4j0ioyF3EKkijqocD5pxblGtppVoZOG0g1AiI6HllbmKziaavNThsaGkrUrdnp++/kZpQVzQSO2eJn3nd8H+elCj/K5DKz5+MU7YpKDJob3T6WMOFFrQfA8qEXRFIJtklqNLyo5w3I3N/sHhhCmmrGaJIu/I3kiZ64wSfB+5Iffe0Dzb+zttEo+gvL4OhSJ3vds0vE3oEmEn164Hv4Ntcitsxahyt4HaUq5MwN3rjSQ8Njvq1qbUDsGCDzUWyerVvHBN+rf0YO+lLSglT0othfId9hHf2dDOnX3Xqju6WHrKzpmxQJZFiCr0nB1j1SLCkHMjCkUWHU0IlneiCSQJHhRd205PGiTWYFR32zn27RA2h3tlBS4tefd56STafFp6H+BcJ3IP5j7wm9WJ7yEez18h9hsg1X5sCc/PQNZA5PA1oCz1kjZnyR18Roq1vgWRRhYxGXTt/ci9sdeETZOgitrwA9Q67bfPO3HzseUaFP6casg8SqJ9iBaBGAb9S3WLTwde89H0qFAaHm56mbvQYwCqYFJxTmUfVdBo2KJChrZ4VXFJjGy5NF5Z/P8A7I97QhYgWoHBBoAIKxzxtO6mOgkKxbALpnyDFWmXGfRJFoCmOrvSgAeDkyILKuGIAApAe7gNYiepfHUVCNqat87QRSDIWcrDusJuZFTOOtpbAk4bd5OQ+STuwigz4ai4Cu2FUaCvBg6pSu6UwBVk90OH45EqaC31WVogyGdYBpQZAO10uVc3uUVvEEDqVBxSZJrQDNH0GzzqeBmRc14Y1SrHMKISgpS+XLX0Tz9pEC05WS2hPXg2IwBzweSR6N1xZmE2qVVlUbREXiK38QqlCEC0P4bjI0XSe0+DIZrDdgQOY6o1f9lG7GVZF1VNULRAnNp8M0B9txmC9RtNQ2Drc26yE0HsO2H68fJzCyngc78uqT7soe2T2jf9c3pHR4WWBzC23Tu+f9DsdiuZ51agdX9cJ77Ck27Ndh7sHOIyT0wPex42ewkmcqKEZ0dbOIXSYxle2j/JAvsX7uwDNiPWdbqE9AmhyJuh4wBruJyH+AK5bXFcGEwQ67oxLyAcNigtEstytV2qW2P32KKAcj7B+IU7Gvs/BeuZQ+YkBmkvy0zlbHiT+COW1RDRs1hHYSiLhlzxvxr8l/HdCBRDyibZKB/avq5ez6qhgRzniAqHBwKZnuCjTTnmnrzyf/9ED2fgyLuNwzHkFwEmmRMQ6PZ/UIGfy+xfWVu/QlcxLbSGkhOMBdEWD+qF0+QrS7lrQcokILy6w+CmVbhakCdb1/NpblzLVtb1VpBdv8i3ngJhKWpnW6UOHKxL25HV51JriBssU3YLSmLFjAyYgCZNpLlt11W88sZopXM7rnhME+ve1IHZ8gcNuCRDzEVZRrv2/p+3f+vBt2lRu49TKBapGgrNAMINYHe0HFy9PTgHsaRy89NtqqO8bJZVOlU/Su8rOJWhEM0A0FPDLqa70LaT5ofx46nx8vtVl64L6YKFubqtZX3crsZSWyJaX2oNre6VgsiJQnv2+2XOxPA5lRkeSBG1ALFTZxhCBw0LMT/GrpH5ARVh7PdZ8xJsylvFydkGLRHXQIulGoc7IGdE8Cd/mzWksA66m+8nDcvaeQ5PlkyIDTbvc+bVqMpwoUsX4yAlNOpSAgrATa4apIPaqVdAMckidhaVqm4uQRi16PeiYaIsh8rO1OXWPCkddizp2lLjbUumbDyQACl/RAzfFUpK8HjC0/YVPty9jcNjQtRsX/ghyYHztSTMuOy7iN+RMLnkeZ6g3QiMdYuMncMGTNGpU86ZwmH/2S8qB2QUXeAhRlnfosrclvhNMSUqHJhGHX5fiCjOGnBjdl5+ArY5LJW1wooxC2E15E5yewGcSINiJxE9xYscvGO7ovhHKDoJhrksTOWhw4kVI08Yq+tgcn0tFrw4tjnIINRGQIx5ZUEPR5oNYLn4GHugIXNK5/Sx347I0LBH7VIBel84nqz0n1NPyAcZpInbfgWl/4T2E8u3CZWh8xCjBJcx1su8BcaywBEdONFeVBxogElpYc8pSKmF9bAmTuspfM2YubC7/QurdE06CzjyjyY2O9QQq0GxFPnRNYgAmnEtEH2WjIwDwP/JU6MAL+FtYZ5xudtdMcQytvEf0S8b0OJ/DiswsuGGo/bHOOFfufn+CaXfSeYwxdIeyK4RKCHHp9IBAH2BPtOhCuKCQi3PdPW7m8ZLeSM3rbHk3l7Di8qptGSUeewuLKsxidTgAsRrSfWpNCcAUo9tTVvKYb4Ye9QcfBt0SpxFL3b1w032fPF/09UweMOvcB+ufZ4e+aqO1+P2hwaC26WdZdoj/tURs8no1kPAwHHegxTSVq787eWmLCu/TwH+gGlLuYR1jgzmrfvr8HRP7i/aY8/JDCQn6Ox7+dT6Dc5PT+x1awT/f+Jj6nZhNRVBl7hcUMQh499RiPJQOT/qPF6KOw4fc7i2+hZiNX8fck/1XQ2yWdUR2evzmI1Qgv8muhD9Aap8rirQKpm/gsHDFo9A8Y25huf/mNeyEoNWDv42FKv+njLJh6hh0HMo4ryqtULfjezk4m0WixKGuLUplGyA1t7NbyRGR+6/XhuMp/aNHb6drTEYsBWQ9ryH4wh/8VV8Y4MD5qEfe7hhEqolUy7feAZe2BR8p3CnVAtHv7kSvMG9catbdl9AIGv1zu8uO2ifpJejVQNAXpUJjHQyjWK3LtR0/gBUmLbAWiN73K2BJEq/Gb99lnAWBDuFRUDc/WfYMhoIGQB8TfkA9VL1mVvs9kSIpnpQzIVdD5NPBNxyCZFspvhlq3vHUzjJvJFTJd4TPwFOdDIk/ovICM1SvlbS25BvUUoavO/NFHCxFa1lcRKgsrOKikOKYdOlV7AifYUZwx8yrutPVBuqAtFdDn3sCfepX2UlIi/Z3iB0XppnIP4Ybc6X3K4X+w/Ap6VXJQo0o1fqIGtJglSgNSPo8iwdT2icC5V92tctY6ZVREBAzehK2YB4USmCZkoojS52NOWiq2/jykj9PtND0Sbu+ulh6eM2Z2aECh7s/YI3QIbXjIJNfTY3ig0DJA9Gu+zmZM+hI3sC5wuZ0ypxg7D8SX/bvXnEkGUn3VvpDkES5ydLN9feRQSL1rwj3QWkIj1HCpqQUEeqORZOJHuaYpulY0IcY1NbMkpKW4xwQ/40=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>71</title>
      <link href="/2019/07/01/%E6%97%A5%E8%AE%B0/71/"/>
      <url>/2019/07/01/%E6%97%A5%E8%AE%B0/71/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="规划任务"><a href="#规划任务" class="headerlink" title="规划任务"></a>规划任务</h3><p>在glo管理issues<br>在blink发布issues<br>在igantt跟踪进度</p><h3 id="将要做的工作"><a href="#将要做的工作" class="headerlink" title="将要做的工作"></a>将要做的工作</h3><p>工作总结<br>旅游计划<br>swift playground学习</p><h3 id="列入issues计划的标准"><a href="#列入issues计划的标准" class="headerlink" title="列入issues计划的标准"></a>列入issues计划的标准</h3><p>标题：下一步的意图<br>时间：完成的具体时间<br>目标：对里程碑有关键作用</p><h3 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h3><ol><li>电子巡查开发总结</li><li>旅游计划安排</li><li>学习swift开发</li></ol><p><img src="https://www.plantuml.com/plantuml/svg/AyaioKbLu7goU_VJheKlrYrysZ69wsd7xAUxTpsRlktbz2tlzymoCZ2qr3KmrpKmL32mj3Ari3Arr3QmC31Gu4hDIoa1wUVAIKqhKSX8JKn9BU82YKAO0000"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定制开源的CLImageEditor图片编辑工具</title>
      <link href="/2019/06/14/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E5%AE%9A%E5%88%B6%E5%BC%80%E6%BA%90%E7%9A%84CLImageEditor%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/06/14/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E5%AE%9A%E5%88%B6%E5%BC%80%E6%BA%90%E7%9A%84CLImageEditor%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="定制图片编辑器"><a href="#定制图片编辑器" class="headerlink" title="定制图片编辑器"></a>定制图片编辑器</h3><p><a href="https://blog.csdn.net/cjh965063777/article/details/51880966" target="_blank" rel="noopener">关于Other Link Flag的有关说明</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other link 添加-ObjC</span><br></pre></td></tr></table></figure></p><p><img src="https://www.plantuml.com/plantuml/svg/pHfhLzp6zRj-XKhFIM3DGklqat1y6d0SapYsJy7EXoR5OdSMP6kbhQJ5k0xdW6FUuCKnnW_ym8vjI69lS1DZM1x-CTtHxdxAN-YT6MaqadOnQS_fAH-GD7FldJltVMVMqHmToRXu3qzju9rHjxHGkNUjwsHtLXr07wSrnxJmybvbUhAoirJTku7VFCFZRoGTPHnv4AbfP4du_beO_56fydYql3LRtfpvTMUEKQvDti3VpjNkZxglhkAPHzLlTgK_jidkz4qyD-vEBU3n5vN5jShsjVBsngSd168znpvhKsDBb3TVbdVV4enNstZgHrYbjZn1o4ojbpUtQu-tAij5z_O6MNsoLBc-3c2mAJmr0S202-_kqfRxyottzWhvFxq7Y31OkrsiFRdphz6h4Z1QVJvM6v-lx1PDPn1PiguP5u6Uk_YJEpScqiCpAzNTtVF9q_qNkiwJJPtjPbkM3iC6RywNT--xhySgQxFUA9CnBjrq2mlblULoQQAy-HG_ktqCPKsfyk95UNEqlFa3-VfrvzxvqBR9u7csSQAcbJ5W8ksZbUP4D3DbgZapRGieAN-iKdnSMPWexpselbwIa97sz2ZPAHKiuOEsFqXIJarTX6Nb9eBVT4LAwQfjoqtdD7IfopGSozHrP3N9gYqJW7DTiZGYlUyXWPGCCqqU6LC7mkJ5KhDa8AMR-JGyqwgZzgisUZzOAAfrIlp2e9s-A5-H_FL3qg0GYBu2Y0n_oIH-zT0TNGKxWdSwT4WEuVGEeYoI4mvvT8G1UarJxpOo9inwRmoWhyzzUAqskeBlhlNrqP7Vvonr8AlAMTMwA2TbPjeUiMOjtQ8PclE5vWnwMrBscKeZ7GseJWEOOw5Ps1rr76QwV7_DGoOWMIXZ8NkGRA87EOvc3DWTe9DwSgCoeCAZOjXFTbhwI1pLv-gex7FlI_9KJuzZmT9oeZzlf7LqIWsaVBQxozH1Kp07AX-mJ82W8t408lz-rGhD1gIfTbAciJzoBnfszeVe0UPJ3aftvXqdHkqu6BaSfaQ6V83EqwTFohQZEdcxKxLEQEaqCWBa7d-YnxaC3cM7FdsZal7ahdjh7SJjMHLeCYxhH4l8L06Ybt7qEJBotGxA9bgotXincUF4pnH7jGQGewWfHpCDnRTc9MOEliKpMu2F_KmXh01Hiy8CIIKX6T4_TKZLTBK_cEhwvBXkgaJ0QJDr4QLFvRFzg8wgDL0pvVICwWm6ygL3iZ0TO7vaMUfbcBBp_OHDEvZvFEyG5evfL2ggTLbEc3dwAlXwCbdT6ySptpFTU7jFoiq-Iw0EeDfh8N02EsLfb41704MNJxJOfWM6rHFY8PdaOIIW6r44OERx_G-YprvFr8g5KddBreQ2G153zVLy74m7Nhk8gfNVl52mpdyRq4DLmzsrSrtKp21Ly6pI5xBtEhc51VUXL6ExJ19tIn4KWYudY3EGDz_B81UBgcnlnrCFyEeidbjYxBcl2zNLAM2lrLtSmqzNAplVu_M2Lw1uigFnbGHbocomMfIY5oiYQE3zkawybOYuqvi6hDAjsZTh7WfR3qzDklDFM7GF4R4lgJaFc-YAY0jiKMac7jQ2s1T5695aNxQXT5f7j1S61U7-Pi4cvKzF27jYqzv71yU73nPSINYI4-2j6StATZf6On3LI26TGq2KX43c82iQAq4oPxkzzH8j_3MOYz1j2TRU1yPVt3Es_rlRgKtELxyRhuTY8OYhwV-TjS6VOJe8aaTEDZE2KT4fg8Mzje8k3qihCYuikHjJxUMt3_3BEr0s3RT3er2x_Gijfmb751CgPxm-1fjqhp_3XUzQlL9vSwQyi-BEJTU-BUBbXzNrRygbMMWOA0hKiPIN65CXbiXVTV87lFdSAvrvV2AzmjmuNlZHdHvrxqyJVeftG3nCMd9y3PbxcY1lwbkVdY0-SOKlM2VPSqNYYRjfIxtq5oX553orKhlxrDCIC53vURko_SXTUODt2XpBLvFCqPgxFY5FK7xAOOeXrJWBrOIz9iR9VnJD2M8GqSTVLgV_wJvuItTfQyCfMb456-KIeTLKfwbQQMBi59p2zfEXa6IYjJNTebW5iv8cOreAfN129OMbfGJ0oShg62WC5-xK9WkUhpBnUhqQQ98shQHNV3ZBvqCHilTo3Wm6_edQ6Ps6xLPNd-F23MPk_JgKAno2wg7vRrq2MotDVfcPQ6dXW2Fy3Gmb6udDP6LUW14E1F5uW7t7GDMjiL5IbBRMMIIiXIu48GJqhJCjm5UMV0chr8d-v8_lXChzGElm9TvDFSeTf13o29QHWtK8mRQsem7pmLHWL6OooI3gJH9iNxvUx1gHk8lmqiYc6z2o0xHk8tsdi4-XXEe4tw2Wn4c4mdaa34_KHi0fA77NAAZFm6c_4EMCuC9FO7wUtHPVUIxCAHFLSyeEV8GeK_-NE6z7lauc-VAHOHzN4eILIEPp84kE4P_YM5o4Oj_P55HuiNQ5CjnrqkzPwjSU3LiAl_IFL_vdk_qQ1naECIYPWmY3uVRDw_yYn5cvGx25SiUhtKETTrAEXwb6dLSTumZLuuVEMDeGDDBC_c0WvuVLGq9RGQtIhzQ5-Zv2cSwSr6o7kQDkw_0UfmOT04L1zkbCYDY8HDDdlmawpf8CoXXYVbNUV5fPdITvSQU0NnMgYwpKaTd15KmfmLbTT7TjsVBcI_VDDfvPmS-lbZSXTtzNMHbZ1BHCy-_-2ipAcltnt_Egtcio4r3-B7hILmpulVVani3SERvgWHXWW4tcFStBx9oCS2ap3d3nOUNwUclr-XieJ9YxmL1vRxQrScq3Brol5lSgkqNUm9OtIwTEIxmCe4HF4MjhOWSUJK7SOyEX3gUjam7Ho150oa8a87RN59uIf_jroCN2V0nmfF6KJ-FIeEQWWz48Vur4zXPAO-BUBWpsUzORmuMuv9tOUQ647H_wWpGc2LMaECm7MNdbuGV02gioMMNPBjQA45eWzqj2s8aZotw3muw7guNxUFuMEKYkYtWWD7Qw5iAGQEID354ms62mZ28VoP03A1fvFxHG-cWYWQUMyNOfaJZIJgQEVcd04YmUCUFbIpFxbRmeuaTiM5U94sMe0j7QwBtgsqdlSC1cq-wZXVBc3n7wNngij8yCWmoWRNgwL5szwdD0CpSBGjvUszh86FCOMHB5cqocpKj6agTWYUVY8ryJB38B3pv_k4uE3vAccCmF_uPiVlZTvSiXUR_32pd1TDiXmB_Zb9cjbSltwrgADJsXP1C_7HOMLovvEI58DkBHC6mgd-i8zvlkD11VyovpeWWf7Qa6GO4IUdCSMX86pLebTgCXbCdjh1l62rDuQmCNvyWr3AsMXTvIf8w6KIhl8BA7BZERqn79bPsaibQyYffKqNwY9uzMg0S-jYmID11va6_n72zl8ujiNIYv3ya-ZKGBfN7Sj3v3bvKqogXvdNNZzBnBEaZDTY2368AWfB0qz65Jqq7w4z81NrrpVof0viGxAqoEGP3rZopPcMQYJzSCzjxH60PyoZm9S7Q7KCUpKmvljku4H0EOYFCiddzuFTMtJskBeqAhHdMQDyvOw9Zv4QjxehF4dYp2bU9N7z0UvKpDSEX7Ot17i6RMBO_TYq9RQB-bOGfqI8X5PzBUU6YH1frwKlIasAZdBlMWITaRFIi9wYfkNdIoihXTUR78eghYdv-uI-luoKCcT4y0mW7JOH-0TURGCRYptqClJIS_Q9D3npwrqQkryNdjpA1f35E0F_a0xfszojCICpzs1ShQIl3vskICUtqwbZbiUf0r146lBQLhERlNx2JtERRyeNpgT8UNJQJOcKdZVkT03Su1tB2H0kjTdNdXgxPOh2pVgJtU899OcdJllwZktSJZpzp74-GCvd4HLCBg2E6qITHpBcyF-jT8TGhoFhQRu2149_iXiWjjXmNzkfiIkY7051sONbCbClncAjItPpHT5wwrGdFzfWMQYCpwrp9iyWijxL-wC2R8BZxIjG43qhL3bSA_Ec8RgPUzVAyWlZg4VA4epOA44Yr3lEkADrd48fJcm3fOIzHHp_Dwo5qsEHgZMsgXLzjr0BL_WFqTPzG_LuVfdXKIQ4yWRM3GKGvYGLvUV3p1pk_sjH9oT-gWJiSG0riVz1P8Ru17v75CI_UgEOMiTNKBJsupq5RtxQZxopQpraPuPrI3uBcpItXcpSURVu8VBBWhas9SlprRtNt13hAz7oqykjQ0fPHcGSmx5omWqg45G_NklKhfBOWa7e-pvX15xQH6faYISDeJYO-1fmGT2VDGBl9peKanUCf-15r-I_PBLSFSE7AWog8eeGhqEEEac9_y0M8cBYtoMLnwNlln3lnlPNLEUMiMUaJoQn9M9b6vLLvE1xG_y1dWCetn43fKZaT1xrI5XmyY4fkDnM98Wyg4tk97Q3Mwn8-Ul_Yd9BsXo1DSftE0u_5eKmUgirxS2Iw4ms2H2CJlvOCrpN3eQLXfWTOgfLNMpBEEXPxlR_cvijwDLv_DFpf4KaAwSBoenHD6Y9WVqu2K3nWGQcl3unlbxIMHC_VwAhXRMvj0fUiabTKPBNKHMHwnL7Ya8mHEH1A2peG6Ea8SXWYg1jB3jBgudnCwHBzqO1-Wd0f5VGm8vAfh9F4p0FOHJncnQbD86Vpd78f_mWwnF_mJZmX680We_P7mUnE1GYOy8wgvtLtPSkUBbL-Uu9rRh41YVR2eiFYwW-Obpyb8wKVxD2EDXadXssquQ01PaCnWG5ODQ4l0XBrxDV-puo09XtTneUZ7etFUXlZP3IapViJZcs-3m7uHNQQNDb-0hdjWAyg-42T0ZVj3T0sgnW1YxQdd0M9U7M717_e0P6NK5AeJylmm5GrzVj3oVndWBUw4iPMqbcOy4BAA-3CE7ixUYSe3csWuuM3tJXf2s1Een8gm0z9XLGglRMBbshkt1Bv1-21FuWKGHRcPrErK8aado6zYDEHHqBjumuMVtUqRK7Q8BYDqBmrJDWI4S1tEigNW0pHdquFaOLnuusLVcbX3gHSlbu0-IzaUK-HSS7FMu-l9jUhg55ihm8Eso6ELDaJ-pqLfsG59u-NjykvDnf2VwKCPF3Y6vu6HbVtqyqh89KUauCWfT4jpE3h1Mo29qQ7dUaU52ac1v062X0934XgCH39yONDOYTHFKhISI4GHwchuI-FTAgxdhIQXBX8VUusBK-GQO642pnUgnM9Tj0Gx5ZmQiyCHQUJV"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://www.plantuml.com/plantuml/svg/fLFTSj906BtFK-oC5zxWtuKtJE55gfDPo5QXQSA4nPbw1TOYz2-WG1bGAzLQnb4AOv6sfFLbs4suuXNyDWaGnAjwaPdixZdd-xwpPsc2gWJPbJxxKMA35ZywOTTLjdqoRlN7xxEyzsfys1aVrraXpp-M99MiKVISO8KOqgFxY9kbqTMNqKM3xRHuFsUtTpsqtNZj4uYc-709PwYkPJPYn40FfRiuJdKZ5DCpceADpL1SrwYXgo6YqGJT32cOuXXE4yc58R-nSXqXd4ORM4EI1_HFe5bne1h89_32DzQy4Nj9EjM0iNgc2qjDKMxxOeicfuBEsLU-jUqBAeJYX3f5LyzvvL9iltmsrRpO6Ws7hW1EhqkYiNkhTs8gZgy_ZOfsmixl9fWPj5TG4oym9M8EII4Bozb2DIIWpyMI58MzeMohvjoKUV6I_spFyJ0cGEPuKPitptcjAoZ5DxpTOXyEW-M0iL11JQ4mixBiTDTpYfarvomNw2Wb0UHV5PpJ_FYul5m1658a4baEIIIoM9ecGSf5ySzPi8XNkto_CoyDvn9yG328ubLUMOF0eBYkwaO4DgEox0cmqW4pwwAllUBuRSVU-SMpEMQMdVx0kpzPNdaWkD4dshB6n2gmwtUpjB7yFl_U4hRtp8crDx8QF7l0FmqcLd4c4nmOKhGu62J5Ju1N768rdmfI5E32Qf4g4XM6phsCWNS1F-081SaBhXkkwsnuvNGwGU_1zS0JVFnVL-0z31IUscvNZdZ13xZJwKA2PFalPsR__gFo9MvhrZBzjePvIdy0"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> 电子巡查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电子巡查项目设计</title>
      <link href="/2019/06/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/06/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- TOC GFM --><ul><li><a href="#工期预估">工期预估</a><ul><li><a href="#整改">整改</a></li><li><a href="#录入">录入</a></li></ul></li><li><a href="#用例">用例</a></li><li><a href="#时序图">时序图</a></li><li><a href="#类图">类图</a></li><li><a href="#活动图">活动图</a></li></ul><!-- /TOC --><h3 id="工期预估"><a href="#工期预估" class="headerlink" title="工期预估"></a>工期预估</h3><h4 id="整改"><a href="#整改" class="headerlink" title="整改"></a>整改</h4><p>二级布局器入口配置/电子巡查底部详情 1<br>复用旧版电子整改管理列表(新增过滤器)待定页 1<br>电子巡查记录(列表/过滤器) 1<br>复用/详情页(数据源变更,新增视频类型) 1天</p><h4 id="录入"><a href="#录入" class="headerlink" title="录入"></a>录入</h4><p>电子巡查录入:<br>重构录入界面UI/详情页UI(待定问题图片布局) 2天<br>图片编辑器 1天<br>检查 1<br>联调接口串联业务层 1天<br><img src="https://www.plantuml.com/plantuml/svg/XPBFRjD04CRl-nHxuuAbfW8aBZn3fHoZ75RsjZ5OjkNTYWAg56ZJ94t_0KaZsgQH6qB2WRGWghPA22-JNTjlmJhh9hPJYPizytspCxyPeY83msK8g4x5XrU_PZ-Es8tBsrrsq-LdxSdeoXiqWOfDYXrOm4Z33WYA9_xVSd1Mv3y_-9VRRE0-PfKTlzUH8RvNzKezTj1cvpLsEcQLJo8x6GxPhilxBcir0JQrg1Im7UibLYaa53cKmEMbp7DbwPcIoK2GNJSrz0OY1qFLi0ZMG1RHTISLKvH4rtyQhDHL591RZEOX8Z1dcOPkuXL47Sl8GsYPy5s1h6r2Q20Y6dWAHNq2Sa5vdvzlIwFNs0jQ5zBkO8AfuUGZUIQIIw5_-OrlbGBtMceDHyCKwSQ2-7JiLSlUwDWVVsHV-b9iwohMT44vhUQTeXWXSE-2OfNNliyCbarroynYG-1RT4rkV_dlwvFR4q5TVFXNM_oWomuxzvrPj12Qml5VhsucpI9bmcWaR_YPjzfvM42sZKq24KqXV4IWMATO0niLMQ_66xzv_OvLchxR3zSG_H_kof1yVbNVM35qGYF-zgiP_YVtGqzjti3rZdPIJcbCJfjOTankJtjyoC6-xdlrldncjh2mhxGm3YyELJhU5jR-Jp8QvW6ICn0HHJ2_B-L5x810x9R2nFnOGFnmmbJgBC32dSZ2icim1pejEyS54kp2v1GEY1Y5WTdi_m00"></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>用例图<br>截屏–标记–分组到检项–更新电子巡查</p><p><img src="https://www.plantuml.com/plantuml/svg/XLNBKkDM4DtVhr3DQiPbcHecAzMO_Np0V01bb4328sNCtWp6RoCJ_21W7YOYzb0WO82nBTlmC-ehQJM_aBxg6wD0kK9vmrM_pkdJtQcbrBAkkBK7kAf2hyrFpc5SX-rpfty0nRPRwpgF9JXyP0bzDQKdbKLzVa5FCiXddRxfz2zujmr7JNvq3jQnktD3zkv1XXk6ztJ3tiSKT7OBENwQywmRT7E76JORKxXHTMoJaZ1zTK76PHlhUc9-NLT-JIdpwyeRdhz0VyrF7tXFEU-fvNPBKDs1dIxVpS2M0URzZr4PK_FcTrxS0wE1DK3BffpipIJSodpojo0WYqHaGOK1l-j68anLbnPKbRrdyJYSs6uxpVSgphZ57pOnMJpEeDKD1tNwHO7AJnVSsj2zh47l7BPxJC4_nEZdAkwNGPJNhdbvqpzhUOLlaC_nofd0Z3wyaUEjox0Fbb4RW9d3OgGRBpLuxH5_O7QYl5donfTH2a81MIm6nhK85Yeq5cDKZ_kjwGwpCpBHLTCPx_7J7emCw6_1RJh4IM9HJqn8uN-biVL-Uq0jUkPbTYelrmDomcv3TXkiWVTqwBNBiiTWbNc-Yl0WbtK6eclOARH0QRt89UXqxB9hTzn32yNd3lVuSIOAnXSllGKx9t0S2109n383Xi0yGFW_HdclrnKnReTE_qgK8TyBMFuKafxXR_o-C9_I2NyyZg4FxtdZvlCdJUhZ9I48-GEIyfeB98cCoP608zueHNmzMdxxGTPBcO8H-lmfq8COc7mFtIRvnP3LRuAFiwy-KWGC5RBw45DGWv0RFbkP7JJqpp9U9n-O_1HJLFNZpskhAIMnjhoMZ2VrXJbKjZCwbJKXWk89cBVU_RdVjFop_OypmdmEmKvX5gdL2ALZsvhWDQclJjXEwkiRowaGsoGTqUhM39WPjvhbZG7AD23QinxTiHMsWJ_AOQjfZV27-vvbahlS6Y_QEU4AyYPlN943vM2yK89YLtehv89WnAzlq_CqzAeQYJZzYjHdiSlJcvI0GaSYgXeMNs9jPMKfJ4Um3ec-VpsG1rvj-OVPi8A4Qavi76r4m2jMb1nvgu9x5FxiJXNeQTk_A8S9ZGejtXfU9-kVxLBhgUbCXWpY__yO9HOtbfznK8-eLB7lntN24OBdFBNvvZMjX2YCqj0foSxkNqFrRrw_nuKu0yOkBYndE1JtOIge0POezH6GJI5WXEgtAQXdjA1I3-wGiUizz2XyrElTuLhrSdVqFqwaVnJiw71UQOKBmD-kq1FExNHA60eUvseEZnUg9pX7T9fGWdYi6DuqyJMuHPg2ToMyDh05i7b0Lua59i8ssD7QPDNIdfLha_QtiA9Lfj6-cUmOH8HBXSazfoQNVbbCeR6SH8tuaSgNZq5AagOc9HF8G4eY0Coa0PM7pTU8MTZ-xWmRZbro2rzPy45Ol0tJ_axZXGw_g-D0KUFf-R_M4_hVQQxL5chQtGy__mC0"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://www.plantuml.com/plantuml/svg/VL7BJjj05DtxA-O36ecr9NVF1_01nXw9GB2HcRHbvxGaDgd8GuH7crIXa8Ye8YMea40Wz6TyPy9VCEEPsCw6pOmzzznppZsNv4a18zQwXs439hzfjm-pOoZtwUaOfdLelsWMTWZsq0OsRUnfqRGolxg4-jVeeIRFkLzcF_TPgmlD6JG7jDFzGCSXBTr0lVdgbtWDgWFgbsXd2k6O_qQp8rORQTYn5QTc5edh5BVNkSoAPbh4zH0D_t1nPEwYJQ9PhaCyju3eUJ3_Eu997yeJKTeslIs5PwqdTjqIZxPdVkQaYkOae9rhyKpm5pv6GXKzLAFdS_Wn4BNYJi6DdQoxHSSslJr4BtqHXInR6zZQubKUH9xi8HcGA1JokqG8vJ-P10kZcmJbSXzZNxeqAubOxGOkleaesY_i8D1idEqo38CUFD9_0rarZ9Gpdb0SCQySJPVW5AGcbbTg8Fh_2uPdMIq5JFXa9ZeF2OQdq0kMM5LWydgFLG4pBx5hFfKAUJ5Lehl8Mv7bSl3imzLt2KyT96jPV2mtG-zsVjT_3Gv5qn94BKoNX3HiGBNBHS8Akts2tZvhLB9k4vbKUR5nTSUaOjb8HxHzHqz6QwjP1WLx0m00"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://www.plantuml.com/plantuml/svg/XLLRJnj757xk_eeHJ-3Kk2HlIng9Muih4r0S8qL2HSFks1vblUlkZab95GaLKX8ACRGXGS64ca1ZLI85bHOQS_apdlNorB_GixFhNMDmYn2S_SvbpdpdCemoZI1-kiQVxjRNbYusj-i7LRvnvdo0txAaaJH3MO9LOagyLE4ljkpISxwuvSoTrj_CywsFzV9ixNZHETzmoalE-Lwj-ixtj5_jy-stdgaizNGZ-zsilRKBeUrAcM--viLrU-DGjl_w_kBurnW_dkC7ixMJTRxqIhe9niMLsiUTsl4RlbYM_L35LUVF8tljq7xvTmm-mALMhOBUEyCfblZocaHqrKzNKZHiMQXZ33FJq4PrZUfad9970uRk0XenEn2sa24K27qd8VY9Hld1MtlsVRqw3xA0lZ2D74h3d_61NW7SJIQPIVKCYbZCC4bS_QGLpXhvkpX719oAtyTJcZWPHLX35Ah9ISGNJksrVJXjSj8xltFQe6gNeb7buHYcZxFOw5CODVGhsaJXMuhrJBCMDQa7u7mJovtn19qcL4yR5efqQI37GPQUDDW94eBx1s27HzO0qJH1aG92UtxwHqSJY5g3X66g-Kp4TKOon1IUzsVo7XCZmmdyU6R0fLua7S_X386qD40zkTTdBBJnQADJOrc36PVXHZ562k8IVQQ9PsvxcOyOAj5Gv4w4CfApXAQtBUEeCzxliTX5ft0ghnbOzRxbJc3JWew2RlAyfpH3UUWxkbntVft5kWgjbCedm6qGCzpb5G7Ol4IcruK1fU5d2x50wXD9DnX1pCWZ8zraAUpupdBzPOKVbM6Ml462ENHfjdyvuYV5VqwMU76nld7Cd_vX_xnSEorTp5QTirNa3WPouxOKML0LL3adY6jRwbYiH-OlAlQpSuHkoZ3AzUSB2DsIaVF-XuljrJR5RvqQvgwSNZ-WQmI1-5pHhxte12Yv-wzXLDyxuolBpj7l_6o-9LZURGpWADkmTSvBzSgFrzgAc2bJyqmJekqoIOPPmO86zYfFrDPqCrGDyjWuj7_Q4oG9f7cuj8ROspH8eO6WsBK1x_O4XwUAKSrb8DkcS0--zBeXISnfVtrPGcmVyGQQnYOooJS5OZ7vg-7KlSGzxwFTGDmGNP_59b6Rbmw467AdppHqgYJnD97zrfUR4WmjuhgL1pbiB_3_d-uABz-NpyUlr648Q3GLae8R_wVItRojwgItgA-5hxDF60fsDy1LNCzGLb2lEe3vTVWOLQnMR9ogn6yJ2gDYfh52cdVk8D581ZCIJ6N8slNxwyhMlwJ0gXekJZV-PJK4RrL3OaGlv527-_I9BDpdpq_1nGP96XSqXZv7dtqQYrrKrvqFEu5o1ES1j3TtdONVU6aVXZjG9GbMie7INYdL3xS3PO9QBF1xzjefLzn4mWSg4etUyLzhIUJJ3FXZq0o9Lqi0GGmP-SjOl2QkVaBt8VTPl8nu-q0itiRStkxk3jUax4eCzXlGqEEw0TRFz66ggaG7xC5GKWftQiCLoIqfo1DwOwbEw8sbEg7ValsTAWM38-xYNLHgj8KHZOgm_m80"></p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p><img src="https://www.plantuml.com/plantuml/svg/LOvVIiD048VVvnJxc5oXEKqX6ne8KTezWANQf56eOYmjjJR-Wo0LX59iIT9S9ZCRdxo2swmMdAUPttpVxWXNU9pHqrfU3scqetLAcxvCBy7ZZc0TthPv5oYwhOen9Lii1nWjwq7ndLzf1-TxEGgqgLV0VVlNWvveTmMqA7nJdAMQXhF0TGpTcanqk0ygOFyIPiWuawlO1ARgw76lnmsQ17I_alcatj_WBFr3cXHV0Wtwjkj0goeN-3xLdlfJZwP-fYvZd3-OwiQJqoE_ZQeyEHpwV4RBrw_77OP3cPqVaiyCemJ33opky4AjDbQZ_W00"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> 电子巡查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暂存机制时序图</title>
      <link href="/2019/05/31/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E6%9A%82%E5%AD%98%E6%9C%BA%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
      <url>/2019/05/31/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E6%9A%82%E5%AD%98%E6%9C%BA%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h2><p><img src="https://www.plantuml.com/plantuml/svg/TPJDRjf058NtynIpYrJ1ebrQfG_HDt3mj44YEB5Df7G5g2Zy1gAGXX2YX40KLrM0I2rG0-5bPgx9AgzGspF-IL1P63Ft7kOxPwvjf8mqmN0-OLQ3NJwX9CaOHCCxH5Q8XkXoPRTC-t5kTxxRhMjsihIj5LpTGQEnNesT4dsgigv9vttx9azd3r2-N_TgJZChJkdo5FxaRREAMAD0PyVhNF5bqP6JXggzB6hRQZQZoDfXBAbc34rDnvnzKyPXJ94DULlMIIY2rWXgULbdfL-iMKS1XeJZyK_uOpoEO5A2_0YHZ2AmqTOx_i4EEkkFeNqCPezTdMEnleKy3iocFRY-OoTjBEjuJtP140V1qCyvfVLmp9PdRbKZILLJaC35KAtRnNikIttRaLNaasCdHcQTkgNKxbTbEv3GMOKkRjY5wPQoUsdLOmrawz4K7Wj2gP7zg78-PvKUTElELUXreXquvuGI2Kx2Yua4uYwyR3YoHAqM6tP4M-s8pWS8yPBN9VWbpFleBEU6apgG3UBNCF9lN87d2akEJRjyz7vNLKWQpiPG7uOwRfmtkXBVhIGoyAHXUn26VnFk8y7bR_WnrWtPoEg93qWXcwh8Md0Ov0sB6rIZIQr145Ga0YzjYJsqMS7Kiv_9VfReXl0KKee9YFnspyYxHdcTeHdTykbvxls5SWwwPVU9y3pRbGdaylyFYfDmptmW-0Hk6eeil0NXio49lpv9k2cl8p52aMrdnUUBmQjj8pt2tgne_xIucKqqyS-lsBpG_FVA5rLrlX0Rrg3KT9zOll0F"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> 电子巡查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拍照业务活动图</title>
      <link href="/2019/05/31/%E6%8B%8D%E7%85%A7%E4%B8%9A%E5%8A%A1%E6%B4%BB%E5%8A%A8%E5%9B%BE/"/>
      <url>/2019/05/31/%E6%8B%8D%E7%85%A7%E4%B8%9A%E5%8A%A1%E6%B4%BB%E5%8A%A8%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h2><p><img src="https://www.plantuml.com/plantuml/svg/lPBDJi904CVl-nHxB1SUe3tx19uyDdGh6zjYsYN66yO8YM3WeeaVXsf0EG160mQnyZJTRJdv2kv70HCQkR67JMRcF_l_pMG99Ww2x7gSTEgiUPLSlB39MT9lqlivA26F81-MaMaX7opE-ydtUzLrM1ZHgCrk6l7Nnq_KeiFd-3Fa-NGqJqUFx66mUAe3v5bP7m01CNq2TFMy0R0DjNXQOxUl_APHM82aZ3m0-LbfP11FB-CeL06sjPEgKaBj50K5cLKzxKuywoePSWB4fPQbwZh1GHaRGAGrsdrBnxsiiAZLQ6Dc24viopfSSz7kdU2IIhlY7srX4n9e7fhulo6uaNfBBrLS5nE3hwLol7RcdcpOovopEG_szWlBwPF1GC0DUxbBM55k06pGvX1lRrhHoyfo0X7ydK92pbfvaBjQ8oSe5dVkhZwHl4NY5m00"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/17/%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/"/>
      <url>/2019/05/17/%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们的管理结构：总监&gt; 部门经理&gt;组长&gt;项目经理&gt;开发</p><p>我做过java开发（web，android,黑莓），目前主要做iOS，担任项目主程，分析理解产品需求，预研具体的技术实现，解决重要的技术问题，完成核心功能的编码研发，有一定的沟通管理能力，负责组内任务分解、工作分配、代码审查，最后确保按时按量交付。<br>每天会利用10分钟沟通昨天成果和今天计划，明确组员每天任务，把控工作进度，做到及时检查，确保在开发阶段按照设计文档和原型无偏差。</p><p>我之前也是开发出身，后面做了项目经理，开始管理小团队，再后面做小组组长，管理下面的项目经理，我们的组织结构是：总监&gt;部门经理&gt;组长&gt;项目经理或系统设计师&gt;开发，关于管理永远也有谈不完的话题，分享下我个人的一些经验之谈吧：<br>1，让合适的人做合适的事情<br>虽然都是开发，但有人适合做前端，有人适合写脚本，有人适合写后端 ，有人其实合适做沟通，因此要努力去识别小组人员的特长，然后发挥他们的特长<br>2，懂得放权     当时我小组人员最多有二个项目经理，两个系统设计师，四五个开发人员，我每天就只抓项目经理和系统设计师的工作，项目经理和设计师则要去指导和检查开发人员的工作，其实这对你的手下也是一种培养，将来他们才能成为你的左膀右臂3，不同岗位工程师，职责明确<br>团队里面开发，设计分工要明确。<br>设计师的主要职责就是要设计出能服务于整个团队的框架或工具、担任主程、负责代码审查等，<br>项目经理就要负责沟通、协调的工作，开发人员就适合照着项目经理和设计师的设计原型照着样子去开发就行了，千万别让他们去做一些沟通或者设计的工作。如果你发现某个开发设计也很强，那你要考虑是否升他做系统设计师，而不是还做开发了<br>4，晨会<br>每天上班前利用10分钟时间，团队围成一团，沟通下昨天的成果和今天的计划，目的有两个，首先对开发人员每天的计划要明确；其次，上级要对下级的工作要时刻把控，不能发生偏差<br>5，检查     即使照着设计文档或原型，开发人员的成果还是会出现偏差或错误，因此要及时检查。检查的方式也采用逐级检查的方式，组员检查项目经理或设计师，设计师检查开发人员。检查的目的仅且仅当为了尽快找出BUG，让组员成长的方式，千万别弄巧成拙，让组员感觉是在找他麻烦<br>6，犒劳<br>周末到了，三不五时也要组织组员聚聚餐，爬爬山，唱唱歌，实在不行也要买点人性化的礼物给组员，比如电视盒子，移动电源，电影票等等，千万别让组员觉得你只会管他们，丝毫不会关怀他们。当然前提是你有经费<br>7，阶段性的沟通<br>一周找一个组员沟通，并且把每次沟通的记录记下来。每个人都会迷茫，一定要站在他的角度，把他当前的表现，发展瓶颈以及下一步的努力方向跟他分析下，我相信只要你是真心为组员着想一定能找出每个组员的优点和缺点，真心跟他们沟通，他们会感谢你的.一口气敲了这么多，其实还有很多未提到，其实最关键的就是几个指标：团队氛围一定要好，不要搞内部矛盾组员上进意识要培养工作要有松有驰帮助组员成长，而不只是关心你的项目进度自己要躬亲示范，以身作则以上是关于团队管理的，有空再补充下技术上的管理。最后送你一句：团队是带出来的，不是管出来的，谢邀。</p>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>草稿</title>
      <link href="/2019/05/17/%E7%BB%8F%E5%8E%86/"/>
      <url>/2019/05/17/%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>个人项目</p><p>iResearcher</p><p>简明扼要<br>高度匹配</p><p>简历核心目的：</p><ol><li>简明扼要介绍自己，真诚</li><li>匹配度，定制不同岗位的信息</li></ol><p>由项目展开</p><ol><li>PBB Reader （macOS／iOS）</li></ol><ul><li>开发播放器中的经历</li><li>学到什么</li><li></li></ul><p>场景-&gt;任务-&gt;方法-&gt;结果<br>STAR</p><ol start="2"><li>iResearcher</li></ol>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计划月周日目标，整理到trello中执行</title>
      <link href="/2019/05/17/%E8%AE%A1%E5%88%92%E6%9C%88%E5%91%A8%E6%97%A5/"/>
      <url>/2019/05/17/%E8%AE%A1%E5%88%92%E6%9C%88%E5%91%A8%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="月"><a href="#月" class="headerlink" title="月"></a>月</h3><ol><li>求职计划</li></ol><ul><li>每天坚持投递三份简历，争取一周两次面试机会<br>达到目标的途径：</li></ul><ul><li>整理简历，增加亮点，定投简历，达到至少不同职位的三版简历。<br>  可参考知乎，豆瓣，狗聘等平台</li></ul><ol start="2"><li>旅游／同城</li></ol><ul><li>在豆瓣／活动行等APP上找感兴趣的同城活动，参加三次同城活动</li><li>参加一个山哥户外／钢七连 ／周末去哪儿郊游</li><li>读书会/电影（3次）</li><li>一次租车自驾行</li></ul><ol start="3"><li><p>阅读<br> 三本书：两本管理书，一本小说<br> 小强升职记（升级版）+《搞定3》+《高效能人士的七个习惯》</p></li><li><p>学习<br> 以objc为资料根据9大模块分配任务，学习研究，做思维导图并产出12篇博客</p></li><li><p>月购清单</p><ul><li>黑头针，洗面扑，防晒霜</li><li>洗牙，眼科检查</li><li>置买衣物</li></ul></li></ol><h3 id="周"><a href="#周" class="headerlink" title="周"></a>周</h3><ul><li><p>学习知识<br>  网络层，第二周UI。第三周消息传递，第四周：动画，第五周：架构</p></li><li><p>读书<br>  书名，阅读目标：思维导图做阅读笔记</p></li><li><p>健身</p><ol><li>学习游泳</li><li>坚持keep</li></ol></li><li><p>总结<br>  周三，周五，周日总结</p></li></ul><p>周购买清单</p><pre><code>- 水果/零食</code></pre><h3 id="日执行"><a href="#日执行" class="headerlink" title="日执行"></a>日执行</h3><ol start="3"><li>个人魅力<br>坚持皮肤保养，饮食有度<br>早：米粥／皮肤护理／乘车读书／导图整理/录音自训/思维训练<br>午：素食／理财置业／导图整理<br>晚：搭讪技巧／情感梳理／导图整理</li></ol><h3 id="当前任务"><a href="#当前任务" class="headerlink" title="当前任务"></a>当前任务</h3><p>hexo 知识管理系统</p><p>trello 时间管理系统</p><p>教训：要多表达，总结技术问题，表达问题</p><p>录制视频</p><p>使用trello来整理工作，日常安排等</p>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;#标题#&gt;</title>
      <link href="/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/"/>
      <url>/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>多线程</li><li>优化</li><li>运行时</li><li></li><li><p>简述一下KVC和KVO使用场景，使用过程中需要注意些什么？</p></li><li>使用cocoapods引入第三方库时，sdk之间的出现冲突如何解决？</li><li>在项目中关于TCP或者UDP编程的使用过程</li><li>请描述下ARC原理<br>ARC的规则就是只要对象没有强指针引用，就会被释放掉，换而言之 只要还有一个强引用指针变量指向对象，那么这个对象就会存在内存中。弱指针指向的对象，会被自动变成空指针（nil指针），从而不会引发野指针错误。<br>原理是:在编译代码的时候为你自动在合适的位置插入release 和 autorelease, (运行时处理垃圾回收就如何MRC一样).</li><li>MRC和ARC是如何破循环引用的</li><li>使用索引的缺点用哪些？</li><li>使用过HTTP请求的那些方法，什么时候使用get，post，put？</li><li>描述一下TCP建立连接的过程，断开连接的过程，为什么是三次握手？</li><li>发布后的版本，怎么搜集crash日志？不实用bugly等第三方平台或者这些第三方平台是怎么搜集crash 日志的？</li><li>说一下runtime，为什么OC里面是发消息，而C/C++是函数调用？</li><li>说下OC发消息的过程</li><li>什么是OC对象，union是OC对象吗，block 是OC对象吗</li><li>id是什么类型</li><li>解决过的最精彩的crash问题？</li><li>子线程中调用connection方法，为什么不回调？</li><li>autorelease变量什么时候释放发？<br>autorelease对象内存的管理放到autoreleasepool中, 当pool drain时,回收内存. (这是基于 objective-c的运行时特性和垃圾回收机制)</li><li><p>GCD和NSOperation的区别？</p></li><li><p>weak和assign的区别<br>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。<br>assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。<br>assign 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入<strong>栈</strong>中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入<strong>堆</strong>中，需要我们自己手动管理内存或通过ARC管理。<br>weak 适用于delegate和block等引用类型，不会导致野指针问题，也不会循环引用，非常安全。</p></li><li>堆和栈的区别<br>栈：遵循先进后出原则，<br>栈有两种分配方式：静态分配和动态分配<ul><li>静态分配是系统编译器完成的，比如局部变量的分配</li><li>动态分配是有alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动态分配也由系统编译器进行释放，不需要程序员手动管理<br>堆：遵循先进先出原则，堆是动态分配和回收内存的，没有静态分配的堆<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2></li></ul></li></ol><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>加油</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> &lt;#工具#&gt; </tag>
            
            <tag> &lt;#管理#&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;#标题#&gt;</title>
      <link href="/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/"/>
      <url>/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="githubCard"><a href="#githubCard" class="headerlink" title="githubCard"></a>githubCard</h2><div id="badge-container-huos3203-<#库名#>-<#哈希值#>" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-<#库名#>-<#哈希值#>", "huos3203", "<#库名#>", "<#哈希值#>", false);</script><h2 id="音乐欣赏"><a href="#音乐欣赏" class="headerlink" title="音乐欣赏"></a>音乐欣赏</h2>        <div id="aplayer-OqyadAsu" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;width:70%;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-OqyadAsu"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "<#歌曲名#>",              author: "<#歌手名#>",              url: "/images/<#音频文件名#>",              pic: "/images/<#封面图#>.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h2 id="岗位理解"><a href="#岗位理解" class="headerlink" title="岗位理解"></a>岗位理解</h2><p>在工程项目管理上收获很大，之前开发中使用过cocoapods项目管理工具，它支持私库：头文件及静态库，在源码库中支持pod私库配置，执行pod发布命令即可将组件库源码发布到私库中。 组件依赖：在主工程中添加依赖库配置文件。通过安装命令就可以将依赖库清单文件中的组件自动集成到主工程中。由于它将主工程加入到一个新的工作空间中，实现项目集成，造成工程的配置修改，所以也被称为侵入式管理。</p><p>对比金和工程中的项目组件开发管理，使用了oc运行时的反射类方式来弱化项目的依赖，很好的解决了</p><h2 id="工作成果"><a href="#工作成果" class="headerlink" title="工作成果"></a>工作成果</h2><h2 id="工作安排"><a href="#工作安排" class="headerlink" title="工作安排"></a>工作安排</h2><h2 id="个人金和职业规划"><a href="#个人金和职业规划" class="headerlink" title="个人金和职业规划"></a>个人金和职业规划</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两个领导，一人人资老大，整个过程一脸懵，不知道憋了几天的心理战怎么会这么失败。</p><p>教训：要多表达，总结技术问题，表达问题</p><p>录音自训<br>思维训练</p><p>录制视频</p><p>使用trello来整理工作，日常安排等</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> &lt;#工具#&gt; </tag>
            
            <tag> &lt;#管理#&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;#标题#&gt;</title>
      <link href="/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/"/>
      <url>/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://www.plantuml.com/plantuml/svg/xLPVRnD747-_Jt7Y9Cw6jLsGgagMSq8gGdqeVK1zgwXriS-n6_iEsHTHYQOYQKmSnubJIEB4v7-T9XJy9vX24iVnbxdTEp_n5JgxU-Sa1OIAUEn8bdPdPsTsPdxpEvifCws94MaiaoRxstXZ5ZyzxU-is4yRPB59IXEtRqgA4DDqKykAIKsDQraX8k6rVLAluTeKUTF1nIsoDOrhhy1Eq-EkZI1VuIBQ1ntyHukip5FtwnNHrSk2J4ysPiEnj9hB8NKuPsRLc8bID5H2ZMb8rNN3LCsKeIDD7yl03QVHwrSQU7Cpx0luxRq9iZQ3V9BVwgsJOWtvVlNZKjvJN_NZ_0jOoOB08a2EDE32dAH48XAPUOOFbd3po3dObXH5LBtpmdDcya0814233pR8mpsxCyMK8kXaN7ZKhoxQB_uC150mY8Q6K3GgGqq6RxDwZVvk2mpWGaJAqGnY8IyzfkDUmQMzrvAKC0-yCGjdG_JquSarg6KqIjVJNRBK6iIFHZyKA36cnmRsdcSVACgJeBXs8GhorDSlgFt2k22JbLExTXpgLnUSIXbE4Fp8yX5fBxcbgC-8ED_kBpPmlS8HmljtrZRUgsGghWrA7d9Tq2G06W4GaOE2dkVRThjZ7_TmRPgqzn4kDwtEBku-mHDLUt7VEfqbwxlmOEjm7XTQtDhfRP3vNUkm3Yq9o0BWH1ClGLhC0twKnuqZIRd4k-egtLP3U5ohEjkbyshNm_lCt_LAKIvIUt0bCM4OPqOkniyml_OSjqwjRWyI2RCOLdVExZR28hUNF75V497IMi8CPLCZIJDa6lT2muPf6Xbei960GsFu9urXI8f8_PqrP-Obl130pFgGKREZSUE-xZJhjDR5BVjbvUr9cIolMTqdiC25hVvg3UeCQ-jm5XSUypLfxv2__nfeHFouzCttjx_bu-mbUfa9JOo1iN2MgBlY1fTXI76-Rk_DkMPRR_19EVoT4TVG7NYwge-aDNJBI0D7e5jPDQEXhzF6M1pTL4rrMCrfif2BgK18aEnNNtx1fkL-AcucGqcDrWGUTK-DZQeZj5GP8pwMrlXaHEXCivVma33JzAxa_5OYgqrMg0U2wCedyO5t-R_nWdVhy_E3v_a3FF6Hm9-5BxmOuy0SWdo3YuX_xrA7puxxbLSkEFZGkXlHDRm1c0S0vA2Xj9in8nECwHpR_FA5tb5SiSalJjgJHv14sFUBuhSxUsIcXtnN_1HiXGKH-Go_Cr657OAehwtEieH-HkFeAlfH1D80VBEhWO0VD-XEV7jIyWM3VcUr2ZlAuovZmPU4rPBE_-On94_v18hfXMUDEXlMO11W9FqWWHDuy5r92LoqFU_cdHXGLFAwG2QQOAXyb0XqCPtIH_z50PmGWL7wqqKOztF3IrkZC147P0lVU5mkyZiNY4jnHVw_t9zORe6B-uyfOO3gFV-OdAagPNzsZTly0m00"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> &lt;#工具#&gt; </tag>
            
            <tag> &lt;#管理#&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;#标题#&gt;</title>
      <link href="/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/"/>
      <url>/2019/05/17/%3C#%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5#%3E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://www.plantuml.com/plantuml/svg/xLPVRnD747-_Jt7Y9Cw6jLsGgagMSq8gGdqeVK1zgwXriS-n6_iEsHTHYQOYQKmSnubJIEB4v7-T9XJy9vX24iVnbxdTEp_n5JgxU-Sa1OIAUEn8bdPdPsTsPdxpEvifCws94MaiaoRxstXZ5ZyzxU-is4yRPB59IXEtRqgA4DDqKykAIKsDQraX8k6rVLAluTeKUTF1nIsoDOrhhy1Eq-EkZI1VuIBQ1ntyHukip5FtwnNHrSk2J4ysPiEnj9hB8NKuPsRLc8bID5H2ZMb8rNN3LCsKeIDD7yl03QVHwrSQU7Cpx0luxRq9iZQ3V9BVwgsJOWtvVlNZKjvJN_NZ_0jOoOB08a2EDE32dAH48XAPUOOFbd3po3dObXH5LBtpmdDcya0814233pR8mpsxCyMK8kXaN7ZKhoxQB_uC150mY8Q6K3GgGqq6RxDwZVvk2mpWGaJAqGnY8IyzfkDUmQMzrvAKC0-yCGjdG_JquSarg6KqIjVJNRBK6iIFHZyKA36cnmRsdcSVACgJeBXs8GhorDSlgFt2k22JbLExTXpgLnUSIXbE4Fp8yX5fBxcbgC-8ED_kBpPmlS8HmljtrZRUgsGghWrA7d9Tq2G06W4GaOE2dkVRThjZ7_TmRPgqzn4kDwtEBku-mHDLUt7VEfqbwxlmOEjm7XTQtDhfRP3vNUkm3Yq9o0BWH1ClGLhC0twKnuqZIRd4k-egtLP3U5ohEjkbyshNm_lCt_LAKIvIUt0bCM4OPqOkniyml_OSjqwjRWyI2RCOLdVExZR28hUNF75V497IMi8CPLCZIJDa6lT2muPf6Xbei960GsFu9urXI8f8_PqrP-Obl130pFgGKREZSUE-xZJhjDR5BVjbvUr9cIolMTqdiC25hVvg3UeCQ-jm5XSUypLfxv2__nfeHFouzCttjx_bu-mbUfa9JOo1iN2MgBlY1fTXI76-Rk_DkMPRR_19EVoT4TVG7NYwge-aDNJBI0D7e5jPDQEXhzF6M1pTL4rrMCrfif2BgK18aEnNNtx1fkL-AcucGqcDrWGUTK-DZQeZj5GP8pwMrlXaHEXCivVma33JzAxa_5OYgqrMg0U2wCedyO5t-R_nWdVhy_E3v_a3FF6Hm9-5BxmOuy0SWdo3YuX_xrA7puxxbLSkEFZGkXlHDRm1c0S0vA2Xj9in8nECwHpR_FA5tb5SiSalJjgJHv14sFUBuhSxUsIcXtnN_1HiXGKH-Go_Cr657OAehwtEieH-HkFeAlfH1D80VBEhWO0VD-XEV7jIyWM3VcUr2ZlAuovZmPU4rPBE_-On94_v18hfXMUDEXlMO11W9FqWWHDuy5r92LoqFU_cdHXGLFAwG2QQOAXyb0XqCPtIH_z50PmGWL7wqqKOztF3IrkZC147P0lVU5mkyZiNY4jnHVw_t9zORe6B-uyfOO3gFV-OdAagPNzsZTly0m00"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> &lt;#工具#&gt; </tag>
            
            <tag> &lt;#管理#&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/17/%E5%85%B6%E4%BB%96/Playground%E4%B8%AD%E4%BD%BF%E7%94%A8XCPlaygroundModule/"/>
      <url>/2019/05/17/%E5%85%B6%E4%BB%96/Playground%E4%B8%AD%E4%BD%BF%E7%94%A8XCPlaygroundModule/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH命令安装及使用</title>
      <link href="/2019/02/27/shell/SSH%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/27/shell/SSH%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>写下这篇文章的目的是为了更清楚的讲解和展现ssh的用法和操作，避免网上庞杂的文章和材料影响新手的学习过程。所以如果你是为老手，可以略过这篇文章了。</p><!-- TOC GFM --><ul><li><a href="#ssh介绍">SSH介绍</a></li><li><a href="#安装使用">安装使用</a><ul><li><a href="#openssh的安装">OpenSSH的安装</a></li><li><a href="#使用">使用</a><ul><li><a href="#配置和启动ssh服务">配置和启动ssh服务</a></li><li><a href="#登录到远程主机">登录到远程主机</a></li><li><a href="#配置使用key登录ssh服务器ssh免密码登录">配置使用key登录ssh服务器ssh免密码登录</a></li><li><a href="#总结">总结</a></li></ul></li></ul></li><li><a href="#本章总结">本章总结</a></li><li><a href="#更多参考内容">更多参考内容</a></li></ul><!-- /TOC --><h2 id="SSH介绍"><a href="#SSH介绍" class="headerlink" title="SSH介绍"></a>SSH介绍</h2><ol><li>什么是ssh？<br>ssh是“Secure Shell”的简写，Secure Shell协议是国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）制定的一个标准。目的是为了创建一个工作在应用层和传输层基础上的安全协议。避免数据的的明文传输。</li><li>什么是OpenSSH？<br>前边说了，ssh是网络协议，而OpenSSH就是其中的一个具体实现。OpenSSH是由OpenBSD管理的项目之一，不过Openssh是跨平台的，支持linux、unix*，甚至windows。<br>所以实际应用中，我们用到的ssh基本上都是Openssh。</li><li>OpenSSH有哪些功能？<br>Secure Shell 是一个通信协议，在这个协议之上可以实现很多种应用层协议。从OpenSSH官网来看，OpenSSH提供了以下几个应用：<br> 1、ssh，登录远程服务器、在远程服务器上执行命令。<br> 2、scp，在两台主机之间实现文件拷贝。<br> 3、sftp，基于openssh实现的类似ftp程序。</li></ol><p>除此之外，OpenSSH还提供了几个命令行工具，用来方便进行ssh操作：<br>1、ssh-add<br>2、ssh-keysign<br>3、ssh-keyscan<br>4、ssh-keygen</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>下文将讲述这些命令的实际用法。</p><h3 id="OpenSSH的安装"><a href="#OpenSSH的安装" class="headerlink" title="OpenSSH的安装"></a>OpenSSH的安装</h3><p>大部分linux发行版都默认包含了OpenSSH客户端和服务器端，一些linux桌面发行版没有安装openssh服务器端。<br>如果没有安装，我们可以通过linux发行版的软件包管理工具进行安装。简单来说就是：<br>apt-get系列：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh openssh-server</span><br></pre></td></tr></table></figure></p><p>yum系列：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install openssh openssh-server</span><br></pre></td></tr></table></figure></p><p>其他系列：自己百度下。<br>备注：openssh是客户端、openssh-server是服务器端。不同的发行版名称可能不同，需要自己确认一下。<br>安装完毕之后，系统中就应该会有ssh命令了。这个时候就可以使用ssh来进行远程主机的管理了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置和启动ssh服务"><a href="#配置和启动ssh服务" class="headerlink" title="配置和启动ssh服务"></a>配置和启动ssh服务</h4><p>在使用之前我们需要对ssh服务进行配置，在大多数linux系统中，ssh服务的配置文件为：/etc/ssh/sshd_config<br>使用vim进行编辑：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>以下地方根据实际情况进行修改（yes为允许、no为禁止）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes  #是否允许root账户登录</span><br><span class="line">PasswordAuthentication yes  #是否允许使用密码校验登录</span><br><span class="line">RSAAuthentication yes  </span><br><span class="line">PubkeyAuthentication yes  #是否允许使用key登录</span><br></pre></td></tr></table></figure></p><p>然后使用系统服务管理命令启动服务，在大部分linux系统下，命令为：service 或者 systemctl<br>启动ssh服务命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# service sshd restart</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# systemctl  restart sshd</span><br></pre></td></tr></table></figure></p><h4 id="登录到远程主机"><a href="#登录到远程主机" class="headerlink" title="登录到远程主机"></a>登录到远程主机</h4><p>命令格式为：ssh  用户名@远程主机的ip地址:远程主机端口<br>示例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh  root@192.168.0.1:22</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@192.168.0.1</span><br></pre></td></tr></table></figure></p><blockquote><p>注：ssh默认端口为22，远程主机为默认端口时，可省略端口号。</p></blockquote><p>执行上述命令之后，首次登陆会询问是否保存秘钥，输入yes即可。然后会提示输入密码，输入该用户对应的远程主机密码即可。</p><h4 id="配置使用key登录ssh服务器ssh免密码登录"><a href="#配置使用key登录ssh服务器ssh免密码登录" class="headerlink" title="配置使用key登录ssh服务器ssh免密码登录"></a>配置使用key登录ssh服务器ssh免密码登录</h4><p>使用key登录，需三个步骤：</p><ol><li>修改ssh服务配置文件允许key登录：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li></ol><p>找到PubkeyAuthentication这一行，改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication  yes</span><br></pre></td></tr></table></figure></p><ol start="2"><li>重启ssh服务：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# service sshd restart</span><br></pre></td></tr></table></figure></li></ol><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# systemctl  restart sshd</span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用ssh-keygen命令在本地机器上生成Rsa公钥对：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li></ol><p>执行上述命令后，会提示输入要保存的文件路径，默认为：~/.ssh/id_rsa.</p><p>输入文件名，点回车，会提示输入秘钥的密码（会提示输入两遍），即可生成秘钥文件：</p><p>查看秘钥文件</p><ol start="4"><li>将公钥文件上传到服务上：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# ssh-copy-id -i /home/zhao/.ssh/id_rsa_leilei.pub</span><br><span class="line">root@192.168.0.1</span><br></pre></td></tr></table></figure></li></ol><p><code>-i</code> 是用来指定公钥文件，执行命令之后，按提示输入远程密码即可。</p><ol start="5"><li>然后即可使用私钥文件登录服务器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# ssh -i /home/zhao/.ssh/id_rsa_leilei   root@192.168.0.1</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：如果在第3步时为秘钥设置了密码，则使用秘钥登录服务器时，需要输入秘钥密码。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>如果想实现免密登录，则只需要在第三步生成密钥对时不要设置秘钥密码。</li><li><p>如果使用秘钥文件使用默认文件名（id_rsa），则在使用ssh的过程中就不需要再使用-i开关来指定秘钥文件了。</p></li><li><p>拷贝文件到远程主机：<br>ssh中提供了scp命令用来拷贝文件到远程主机，使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# scp -i /home/zhao/.ssh/id_rsa_miyao  a.tar.gz root@192.168.0.1:/home/zhao/</span><br></pre></td></tr></table></figure></li></ol><p>就能将文件 <code>a.tar.gz</code> 拷贝到远程主机<code>/home/zhao/</code>下  </p><ol start="5"><li>在远程服务器上执行命令：<br>直接将需要执行的命令追加到ssh命令后面即可，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# ssh -i /home/zhao/.ssh/id_rsa_miyao root@192.168.0.1  &quot;ls -l&quot;</span><br></pre></td></tr></table></figure></li></ol><p>即可在远程服务器上执行“<code>ls -l</code>” 命令，结果将输出到本地控制台。<br>但是在执行一些命令时，远程主机会提示无法找到该命令，这说明需要设置远程主机的环境变量，可在发送给远程主机的命令中增加source指令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~# ssh -i /home/zhao/.ssh/id_rsa_miyao  root@192.168.0.1 &quot;source ~/.bash_profile &amp;&amp; ls -l&quot;</span><br></pre></td></tr></table></figure></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ol><li>本文的命令示例中，均使用了 <code>-i</code> 开关来指定秘钥文件，如果使用默认秘钥文件：<code>~/.ssh/id_rsa</code>登录，则均可省略-i开关。</li><li>其他用法后续再补充吧。<h2 id="更多参考内容"><a href="#更多参考内容" class="headerlink" title="更多参考内容"></a>更多参考内容</h2><a href="https://man.openbsd.org/ssh-add.1" target="_blank" rel="noopener">https://man.openbsd.org/ssh-add.1</a><br><a href="https://man.openbsd.org/?query=ssh-keygen&amp;sektion=1" target="_blank" rel="noopener">https://man.openbsd.org/?query=ssh-keygen&amp;sektion=1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS系统的shell工具blink</title>
      <link href="/2019/02/27/shell/iOS%E7%B3%BB%E7%BB%9F%E7%9A%84shell%E5%B7%A5%E5%85%B7blink/"/>
      <url>/2019/02/27/shell/iOS%E7%B3%BB%E7%BB%9F%E7%9A%84shell%E5%B7%A5%E5%85%B7blink/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用于iOS的Blink Shell(为更多Shell util进行了编辑)<br>Blink是第一个利用<code>Mosh</code>和<code>SSH</code>支持的专业桌面级iOS终端。因此，我们可以明确地保证稳定的连接、闪电般的速度和完整的配置。它可以而且应该是你一整天的工具。<br>我们没有创建另一个终端来修复您的网站的运行。Blink从一开始就被打造为专业级产品。<br>我们从分析什么是必须拥有的开始，我们最终基于以下三个概念:</p><h5 id="快速呈现"><a href="#快速呈现" class="headerlink" title="快速呈现"></a>快速呈现</h5><p>Unix服务器中的dmesg应该是即时的。我们等不及要渲染了。我们不需要重新发明轮子来实现这一点。我们只是简单地使用Chromium的HTerm来确保渲染是完美和快速的，即使是那些特殊的、复杂的编^码。</p><h5 id="始终在线"><a href="#始终在线" class="headerlink" title="始终在线"></a>始终在线</h5><p>Mosh超越了SSH的可变性。Mosh克服了我们都与移动连接相关的不稳定和间歇性连接。您可以检查Safari，而不必担心重新启动SSH连接。感谢Mosh，你可以完美地从家里跳到火车上，然后跳到办公室。Blink是坚如磐石的连接方式。Mosh很容易获得，并且可以很容易地安装在服务器上。访问<a href="https://mosh.org。" target="_blank" rel="noopener">https://mosh.org。</a></p><h5 id="完全可配置"><a href="#完全可配置" class="headerlink" title="完全可配置"></a>完全可配置</h5><p>Blink热情拥抱蓝牙连接键盘。一些人喜欢在Vim上设置Esc，另一些人喜欢在Emacs上设置Ctrl。瞬目是它们的冠军。但还有更多，因为我们想要更多。您还可以添加自己的自定义主题和字体来闪烁。在你的日常工作中，你处于自己的状态。<br>但是，眨眼更重要。请阅读:<br>你应该命令你的终端，而不是导航它。Blink会把你直接跳到一个友好的shell中，这样你就可以清楚地看到如何滚动了。<br>界面很简单。我们抛弃了所有的菜单，为您的终端打开了全屏。<br>使用滑动在打开的连接之间移动，滑下来关闭它们，甚至捏来缩放!<br>通过添加您自己的主机和RSA加密密钥来配置Blink连接。一切看起来都很熟悉，你很快就可以开始工作了!</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们已经合并了SplitView，用于那些必要的谷歌搜索和与同事聊天。<br>更多信息，请访问<a href>Blink Shell</a>。</p><h4 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h4><p>这个分支还包含一组shell实用程序，因此您可以添加/删除文件、列出它们等等。<br>目前可用的命令有:</p><ol><li>操作命令<br>cd, setenv, ls, touch, cp, rm, ln, mv, mkdir, rmdir, df, du, chksum, chmod, chflags, chgrp, stat, readlink, compress, uncompress, gzip, gunzip，</li><li>环境命令<br>pwd, env, printenv, date, uname, id, groups, whoami, uptime<br>cat,grep, wc</li><li>访问命令<br>curl(包括http、https、scp、sftp…)、scp、sftp</li><li>tar</li><li>第三方项目：使用外部项目:Python、Lua和TeX<br>您可以单独调用命令，或者使用python或lua使用script脚本。有重定向(“&gt;”、“&lt;”、“&amp; &gt;“…),但没有<code>pipe</code>工具。</li></ol><p>所有这些命令都在<code>ios_system.framework</code>(预编译，用于工具)中。如果您想编辑源代码(以添加更多命令)，请参见:<a href="https://github.com/holzschu/ios_system。" target="_blank" rel="noopener">https://github.com/holzschu/ios_system。</a></p><h4 id="编辑脚本文件"><a href="#编辑脚本文件" class="headerlink" title="编辑脚本文件"></a>编辑脚本文件</h4><p>我建议安装iVim (<a href="https://github.com/terrychou/iVim或https://itunes.apple.com/us/app/ivim/id1266544660?)mt=8)，使用ios11“edit-in-place”在Blink沙箱内编辑文件。" target="_blank" rel="noopener">https://github.com/terrychou/iVim或https://itunes.apple.com/us/app/ivim/id1266544660?)mt=8)，使用ios11“edit-in-place”在Blink沙箱内编辑文件。</a></p><h4 id="密钥访问方式"><a href="#密钥访问方式" class="headerlink" title="密钥访问方式"></a>密钥访问方式</h4><p>curl可以打开与iPad之间的文件传输(ftp、http、scp、sftp…)。</p><ol><li>它使用了BLINKSHELL的密钥管理(即“config”创建密钥)。</li><li><p>也可以指定键与路径:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl scp:<span class="comment">//host.name.edu/filename -o filename—key $SHARED/id_rsa—pass MyPassword</span></span><br></pre></td></tr></table></figure>    <p>你也可以使用scp和sftp命令:</p><pre><code>scp user@host.name.edu:文件名sftp localFilename user@host.name.edu: ~ /</code></pre></li></ol><p>scp和sftp是通过curl实现的，通过重写参数来遵循curl语法。<br>利:更轻的实现，更小的内存成本，更不可能有函数名冲突。<br>弊:有些开关可能没有完全相同的含义。</p><h4 id="第三方语言包"><a href="#第三方语言包" class="headerlink" title="第三方语言包"></a>第三方语言包</h4><p>语言包(Python、Lua和TeX)只提供等价的二进制文件。您可以使用包(/usr/local/texlive或/usr/lib/python2.7)传输目录，并将它们放到Blink应用程序的Library文件夹中。这是命令，如ls, rm, tar, mv…将是有用的。<br>注意:所有框架(除了curl)都是动态框架，以减少应用程序内存占用。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在iOS中，由于沙箱限制，不能在<strong>~</strong>目录下写，只能在<code>~/Documents/</code>、<code>~/Library/</code>和<code>~/tmp</code>中写。大多数Unix程序假定配置文件位于<code>$HOME</code>中。因此，要么将<code>$HOME</code>重新定义为<code>~/Documents/</code>，要么将配置变量(使用setenv)设置为其他位置。<br>我用Blink在<code>MCPSession.m</code>文件。定义了以下变量:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv PATH = <span class="variable">$PATH</span>:~/Library/bin:~/Documents/bin</span><br><span class="line">setenv PYTHONHOME = <span class="variable">$HOME</span>/Library/</span><br><span class="line">setenv SSH_HOME = <span class="variable">$HOME</span>/Documents/</span><br><span class="line">setenv CURL_HOME = <span class="variable">$HOME</span>/Documents/</span><br><span class="line">setenv HGRCPATH = <span class="variable">$HOME</span>/Documents/.hgrc/</span><br><span class="line">setenv SSL_CERT_FILE = <span class="variable">$HOME</span>/Documents/cacert.pem</span><br></pre></td></tr></table></figure></p><p>如果你想永久地改变它们，最好是编辑<code>MCPSession.m</code>文件。</p><h3 id="使用Blink"><a href="#使用Blink" class="headerlink" title="使用Blink"></a>使用Blink</h3><p>我们的UI非常直观，并优化了触摸设备的体验，这是非常重要的部分，terminal终端。您将直接跳到一个非常简单的shell中，因此您将知道如何操作。<br>这里还有一些技巧:<br>键入<code>help</code>在shell中查找信息。<br>新建shell命令：用两个手指轻敲创建一个新的shell。<br>移动shell命令：通过用手指移动两行shell命令。<br>新建连接/重连/退出：您可以退出会话并回到shell打开一个新连接。<br>关闭session：两个手指向下拖动来关闭会话。<br>缩放文本：使用缩放手势来增加或减少文本的大小。您也可以使用Cmd+或Cmd-如果使用键盘。<br>复制和粘贴：通过选择文本点击屏幕。<br>运行“config”来设置密钥。通过ssh-copy-id将它们安装到服务器。<br>在SmartKeys栏上的Ctrl和Alt修改器允许连续按下，就像在真正的键盘上一样。</p><h3 id="支持python命令"><a href="#支持python命令" class="headerlink" title="支持python命令"></a>支持python命令</h3><p><a href="https://github.com/holzschu/blink.git" target="_blank" rel="noopener">holzschu/blink</a><br><a href="https://github.com/holzschu/pyhon_iOS.git" target="_blank" rel="noopener">holzschu/pyhon_iOS</a></p><h3 id="配套使用的iVim工具"><a href="#配套使用的iVim工具" class="headerlink" title="配套使用的iVim工具"></a>配套使用的iVim工具</h3><p><a href="https://github.com/holzschu/iVim.git" target="_blank" rel="noopener">iVim</a><br>readme介绍了，如何在真机上运行以及集成python环境。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Guaka快速创建swift命令行CLI的工具</title>
      <link href="/2018/11/19/macOS/Guaka%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAswift%E5%91%BD%E4%BB%A4%E8%A1%8CCLI%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/11/19/macOS/Guaka%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAswift%E5%91%BD%E4%BB%A4%E8%A1%8CCLI%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-nsomar-Guaka-7d6135f" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-nsomar-Guaka-7d6135f", "nsomar", "Guaka", "7d6135f", false);</script><h3 id="Guaka介绍"><a href="#Guaka介绍" class="headerlink" title="Guaka介绍"></a>Guaka介绍</h3><p>通过 Guaka Framework 来实现 CLI(command-line interface)。<br>该框架可以快速实现如下的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -v &quot;url&quot;</span><br></pre></td></tr></table></figure></p><p><code>git</code> 就是一个 <strong>CLI</strong>，<code>checkout</code>是这个<strong>CLI</strong>的子命令，并接受一个<code>String</code> 作为他的参数。</p><p>对应上述的命令可以为分为：</p><ul><li><code>git</code> 主命令</li><li><code>checkout</code> 子命令</li><li><code>-v/–v</code> 命令所接收的 flag<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└── git</span><br><span class="line">    ├── checkout -v</span><br><span class="line">    └── push -f</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure></li></ul><p>在 Guaka 中代码表现基本就是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="type">Flag</span>(longName: <span class="string">"v"</span>, value: <span class="literal">false</span>, description: <span class="string">"Show verbose"</span>)</span><br><span class="line"><span class="keyword">let</span> command = <span class="type">Command</span>(usage: <span class="string">"git"</span>, flags: [flag]) &#123; flags, args <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> showVerbose = flags.getBool(name: <span class="string">"v"</span>)</span><br><span class="line">    <span class="comment">// args the positional arguments passed to the command</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是 git 的 -v 指令，是否打印过程.</p><h3 id="Guaka快速上手"><a href="#Guaka快速上手" class="headerlink" title="Guaka快速上手"></a>Guaka快速上手</h3><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; brew install oarrabi/tap/guaka</span><br></pre></td></tr></table></figure></li><li><p>新建工程<br>假设我们要建立一个 <strong>papa</strong> 的CLI指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 到需要建立工程的目录</span><br><span class="line">guaka create papa</span><br></pre></td></tr></table></figure></li></ol><p>会生成如下路径<br>├── Package.swift<br>└── Sources<br>    ├── main.swift<br>    ├── root.swift<br>    └── setup.swift </p><ol start="3"><li>增加指令<br>给 <strong>papa</strong> 增加个子命令叫做 check<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guaka add check</span><br></pre></td></tr></table></figure></li></ol><p>增加 flag<br>增加 flag 就要去 Source 下面对应的 Swift 文件中修改。</p><ol start="4"><li>编译执行 Swift build<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br></pre></td></tr></table></figure></li></ol><p>// 会编译生成可执行文件<br>// .build/debug/papa –help</p><ol start="5"><li>运行<strong>papa</strong>可执行文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.build/debug/papa check</span><br></pre></td></tr></table></figure></li></ol><p>增加逻辑就在对应的 Swift 文件中增加.</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用swift命令行抓取WWDC字幕</title>
      <link href="/2018/11/19/macOS/%E4%BD%BF%E7%94%A8swift%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%93%E5%8F%96WWDC%E5%AD%97%E5%B9%95/"/>
      <url>/2018/11/19/macOS/%E4%BD%BF%E7%94%A8swift%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%93%E5%8F%96WWDC%E5%AD%97%E5%B9%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-WWDC-Subtitles-84878dc" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-WWDC-Subtitles-84878dc", "huos3203", "WWDC-Subtitles", "84878dc", false);</script><p>平时没有那么大段的时间能去看这些 session 的视频，想先通过字幕能了解到 session 中的内容，所以搜罗了网上大牛抓取WWDC字幕的相关实现。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://github.com/insidegui/WWDC" target="_blank" rel="noopener">WWDC客户端</a>作者分享的一个开源项目<a href="https://github.com/rlwimi/jonyfive" target="_blank" rel="noopener">jonyfive</a>是把他WWDC项目中抓取字幕文件逻辑抽取出来，就是使用 swift 做的爬虫，可以结合项目做些有趣的东西。<br>这边我对该项目进行了一些修改，之前下载的直接就是 vtt 的文件，并没有对文本文件进行处理，我把vtt格式调整了正常阅读的模式，方便大家阅读。</p><blockquote><p>不支持2108下载</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/Danny1451/WWDC-Subtitles.git</span><br><span class="line">$ cd WWDC-Subtitles</span><br><span class="line">$ swift build</span><br></pre></td></tr></table></figure><h2 id="抓取字幕"><a href="#抓取字幕" class="headerlink" title="抓取字幕"></a>抓取字幕</h2><p>获取 2017 年 204 session 的字幕，保存到当前目录的 2017 文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wwwww subtitle -s 204 -v -y 2017</span><br></pre></td></tr></table></figure></p><p>获取 2016 年 204 session 的 meta 信息，以 json 格式并且保存在当前目录的 sessions.json 文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wwwww meta -s 204 -v -y 2016</span><br></pre></td></tr></table></figure></p><h2 id="如何下载中文"><a href="#如何下载中文" class="headerlink" title="如何下载中文"></a>如何下载中文</h2><h2 id="如何支持2018下载"><a href="#如何支持2018下载" class="headerlink" title="如何支持2018下载"></a>如何支持2018下载</h2><p><a href="http://danny-lau.com/2017/07/19/wwdc-2017-guaka/" target="_blank" rel="noopener">WWDC 2017 字幕抓取 &amp; Guaka 介绍</a></p><p><a href="https://www.jianshu.com/p/62a822835462" target="_blank" rel="noopener">WWDCHelper - 帮你更好下载 WWDC 中文字幕</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift的动态性</title>
      <link href="/2018/11/10/swift/Swift%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/"/>
      <url>/2018/11/10/swift/Swift%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p>Foundation 框架实现了基于运行时一个特性的两个API：</p><ol><li><code>键值编码 (key-value-coding, KVC)</code></li><li><code>键值观察 (key-value observing, KVO)</code><br>KVC 和 KVO 允许我们将 UI 和数据进行绑定，这也是 Rx 以及其他响应式框架实现的基础。<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3>KVC 的工作方式如下所示：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *number;</span><br><span class="line"></span><br><span class="line">[myClass valueForKey:<span class="string">@"number"</span>];</span><br><span class="line">[myClass setValue:@(<span class="number">4</span>) forKey:<span class="string">@"number"</span>];</span><br></pre></td></tr></table></figure></li></ol><p>例如，假设我们有这个 number 属性，您可以将属性名称作为键，来获取属性值或者设置属性值。这个功能可以用在此前我们所看到的获取变量列表、协议列表，以及危险的混淆功能当中。</p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>通常所说的 Objective-C 「动态性」，往往都是指 KVO。虽然还有其余的函数，但是这些是最常见、最常用的。这也就是人们所说的，Swift 缺失的部分。</p><ol><li>使用KVO对状态的变化进行注册<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[myClass addObserver:<span class="keyword">self</span></span><br><span class="line">forKeyPath:<span class="string">@"number"</span></span><br><span class="line">options:<span class="built_in">NSKeyValueObservingOptionInitial</span> | <span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change</span><br><span class="line">context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line"><span class="comment">// Respond to observation.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在观察的值发生变更之后，KVO 会调用此方法立即通知观察者。通过这个方法，我们便可以按需更新 UI。</p><ol start="2"><li>弊端：难以调试<br>KVO这些操作都存有隐患。比方说 KVO，特别是当我们对某个不是自己所创建的类进行观察时，往往会发现有出乎意料的变化发生。通常而言，这些问题是非常难以调试的，也很难去理解为什么出错。在实际产品当中，我并不建议使用它们，尽管它们非常好用。但是在实际产品当中，我会很谨慎地去使用这些功能。</li></ol><p>Apple 也是如此认为的，因此它们在视图控制器当中添加了这个私有方法，可以使用 class-dump 来查看。</p><ul><li>(void)                   attentionClassDumpUser:<br>yesItsUsAgain:<br>althoughSwizzlingAndOverridingPrivateMethodsIsFun:<br>itWasntMuchFunWhenYourAppStoppedWorking:<br>pleaseRefrainFromDoingSoInTheFutureOkayThanksBye:</li></ul><p>的确，很让人抓狂。</p><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>Swift 是一种强类型语言。即默认类型是安全的静态类型。如果需要的话，不安全类型也是存在的，但是 Swift 仍然是尽力推动我们使用安全的静态类型。Swift 中的动态性可以通过 Objective-C 运行时来获得。</p><p>本来这是很好的，但是 Swift 开源并迁移到 Linux 之后，由于 Linux 上的 Swift 并不提供 Objective-C 运行时，事情就大条了。社区的关键点在于，让 Swift 未来能够自己配备动态性，而不是依赖于 Apple。</p><h3 id="Swift中的两个动态修饰符"><a href="#Swift中的两个动态修饰符" class="headerlink" title="Swift中的两个动态修饰符"></a>Swift中的两个动态修饰符</h3><ol><li><code>@objc</code>: 将Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。</li><li><code>@dynamic</code>:动态功能修饰符，它隐含添加了 <code>@objc</code>功能。</li></ol><h3 id="Swift中运行时方法"><a href="#Swift中运行时方法" class="headerlink" title="Swift中运行时方法"></a>Swift中运行时方法</h3><p>回到我们的动态特性当中，让我们来看一看 Swift 当中这些动态特性是什么样的。假设我们需要使用内省机制、转发方法、替换和绑定方法。</p><h4 id="方法转发"><a href="#方法转发" class="headerlink" title="方法转发"></a>方法转发</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">override <span class="keyword">class</span> func resolveInstanceMethod(_ sel: Selector!)</span><br><span class="line">-&gt; Bool &#123;</span><br><span class="line"><span class="comment">// 添加实例方法并返回 true 的一次机会，它随后会再次尝试发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">override func forwardingTarget(<span class="keyword">for</span> aSelector: Selector!) -&gt;</span><br><span class="line">Any? &#123;</span><br><span class="line"><span class="comment">// 返回可以处理 Selector 的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 - Swift 不支持 NSInvocation</span></span><br></pre></td></tr></table></figure><p>resolveInstanceMethod 同样会被调用，forwardingTarget 看起来似乎更贴近于 Swift 3 风格的 API。但是 NSInvocation 并不能在 Swift 当中使用。我们同样可以实现方法转发，因此看起来也不算太坏。</p><h4 id="方法混淆"><a href="#方法混淆" class="headerlink" title="方法混淆"></a>方法混淆</h4><p><code>load</code> 在 Swift 不再会被调用，因此我们需要在 <code>initialize</code> 中进行混淆。在 Objective-C 当中使用的 <code>dispatch_once</code>，但是在 Swift 3 中被废弃。事情变得略为复杂。虽然对于特定类型的函数而言，我们仍然可以将其定义为动态函数，但是它会消除大部分混淆的功能。</p><h4 id="内省机制"><a href="#内省机制" class="headerlink" title="内省机制"></a>内省机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if self is MyClass &#123;</span><br><span class="line">// YAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myString = &quot;myString&quot;;</span><br><span class="line">let mirror = Mirror(reflecting: myString)</span><br><span class="line">print(mirror.subjectType) // “String&quot;</span><br><span class="line">let string = String(reflecting: type(of:</span><br><span class="line">myString)) // Swift.String</span><br><span class="line"></span><br><span class="line">// No native method introspection</span><br></pre></td></tr></table></figure><p><code>is</code> 替代了 <code>isMemberOfClass</code>，它同样也可以对 Swift 值类型:结构体、枚举以及其他 Swift 当中的新类型使用。此外还有一个新的映射 API，它主要针对于管道 (pipe) 和数据。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>目前，我们没有原生的办法来实现内省。这也预示着这个功能未来可能会出现，但是目前我们还无法实现。这很令人沮丧，特别是当您想到我们此前所实现的 XCTestCase。如果您打算为 Linux 编写单元测试的时候，就无法自动遍历所有的函数。您必须实现 static var allTests，然后手动列出所有的测试函数。这很糟糕。</p><h4 id="KVC-KVO功能的削弱"><a href="#KVC-KVO功能的削弱" class="headerlink" title="KVC/KVO功能的削弱"></a>KVC/KVO功能的削弱</h4><p>KVO 的魅力在于，您可以在不是自己所创建的类当中使用它，也可以只对您想要监听变化的类使用。KVO 和 KVC 在 Swift 被极大地削弱了。<br>两点要求：</p><ol><li>被观察的对象必须要继承自 NSObject，并且使用一个 Objective-C 类型。</li><li>被观察的变量必须要声明为 @dynamic。您必须要对想要观察的事务了如指掌。<br>问题是 Swift 并没有很好的替代方案。您可以使用 Rx 或者基于协议来观察对象。但是语言自身是没有原生的解决方案的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，Objective-C 的动态性无疑是非常强大的、极其有用，虽然也存在危险性。Swift 目前没有足够的替代方案来解决这些问题，但是可以预见在不久的将来 Swift 的动态性将会出现，这是值得我们期待的。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chisel-xcodeproj框架的使用</title>
      <link href="/2018/11/09/%E8%B0%83%E8%AF%95/Chisel-xcodeproj%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/09/%E8%B0%83%E8%AF%95/Chisel-xcodeproj%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-chisel-f331dc6" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-chisel-f331dc6", "huos3203", "chisel", "f331dc6", false);</script><p>这个pull请求添加<code>findinstances命令</code>，该命令完成<a href="https://github.com/facebook/chisel/pull/197" target="_blank" rel="noopener">Add findinstances, and new support framework in Chisel.xcodeproj </a>和<a href="https://github.com/facebook/chisel/pull/214" target="_blank" rel="noopener">Add Makefile for installing framework</a>的工作。<br>用户可以运行<code>help findinstances</code>获取<code>findinstances</code>的详细信息。简要总结一下，<code>findinstances</code>可以找到给定<code>class</code>类或<code>protocol</code>协议的所有实例，并使用谓词表达式过滤这些结果。<br>如果您有一个名为<code>XXSocialUser</code>的类，那么您可以通过运行<code>findinstances XXSocialUser == &#39;curry&#39;</code>来找到一个特定的用户。</p><p><code>Chisel.xcodeproj</code>为新建<code>findinstance</code>提供了凿子框架支持。<br>使用<code>Chisel.xcodeproj</code>支持新建<code>chisel Framework</code>通过本地代码实现<code>command</code>,<code>findinstances</code>等功能。也可以通过这种方式来实现更多<code>chisel命令</code>。</p><p><code>findinstance</code>命令通过扫描<strong>iOS/macOS</strong><code>malloc API</code>。对于每个<code>allocation</code>分配，都会使用<code>heuristics</code>来识别可能的<code>Objective-C实例</code>。<code>heuristics</code>不调用对象上的method，而是依赖<code>objc runtime</code>运行时函数,基于<code>class metadata</code>类元数据来匹配到<code>oc实例</code>。这避免了在<code>objc运行时</code>机制下分配和有状态副作用。<br>在第一次传递之后，候选对象将通过第二次传递，检查它们是否与可选的<code>NSPredicate</code>匹配。如果没有谓词，则输出对象的信息最少。如果有谓词，并且对象传递谓词，那么对象将输出更多细节，特别是谓词中查询的细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">findinstances UIView</span><br><span class="line">findinstances *UIView</span><br><span class="line">findinstances UIScrollViewDelegate</span><br><span class="line">findinstances UIView window == nil || hidden == true || alpha == 0 || layer.bounds.#size.width == 0 ||  layer.bounds.#size.height == 0 </span><br><span class="line">findinstances UIView subviews.@count == 0</span><br><span class="line">findinstances NSDictionary any @allKeys beginswith &apos;perf_&apos;</span><br><span class="line">findinstances NSArray @count &gt; 100</span><br></pre></td></tr></table></figure></p><h3 id="开发使用"><a href="#开发使用" class="headerlink" title="开发使用"></a>开发使用</h3><p>构建Xcode项目，并获得到<code>Chisel Framework</code>的路径。:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/&lt;me&gt;/Library/Developer/Xcode/DerivedData/Chisel-&lt;stuff&gt;/Build/Products/Debug-iphonesimulator/Chisel.framework/Chisel</span><br></pre></td></tr></table></figure></p><p>在lldb环境下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lldb</span><br><span class="line">&gt;&gt;&gt; expr -l objc -- (void*)dlopen(&quot;/path/to/Chisel.framework/Chisel&quot;, 2)</span><br><span class="line">script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;&lt;classname&gt;&quot;, &quot;&lt;predicate&gt;&quot;)&apos;, o)</span><br></pre></td></tr></table></figure></p><p><code>&lt;classname&gt;</code>:可以是<code>class</code>类名或<code>protocol</code>协议名<br><code>&lt;predicate&gt;</code>:是一个可由<code>NSPredicate</code>解析的字符串<br>可以使用<code>regex command 命令</code>:<br>(注意，<code>findinstance</code>后面必须换行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command regex findinstances</span><br><span class="line">s/(\S+) *(.*)/script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;%1&quot;, &quot;%2&quot;)&apos;, o)/</span><br></pre></td></tr></table></figure></p><p>或者，作为<code>python命令</code>，存储在<code>path/to/findinstances.py</code>中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import lldb</span><br><span class="line"></span><br><span class="line">def findinstances(debugger, command, exe_ctx, result, _):</span><br><span class="line">options = lldb.SBExpressionOptions()</span><br><span class="line">options.SetTrapExceptions(False)</span><br><span class="line">options.SetTryAllThreads(False)</span><br><span class="line">options.SetTimeoutInMicroSeconds(10*1000000)</span><br><span class="line">options.SetLanguage(lldb.eLanguageTypeObjC)</span><br><span class="line"></span><br><span class="line">frame = exe_ctx.frame</span><br><span class="line"></span><br><span class="line">if not exe_ctx.target.module[&apos;Chisel&apos;]:</span><br><span class="line">frame.EvaluateExpression(&apos;(void*)dlopen(&quot;/path/to/Chisel.framework/Chisel&quot;, 2)&apos;, options)</span><br><span class="line"></span><br><span class="line">args = command.split(&apos; &apos;, 1)</span><br><span class="line">typeName = args[0]</span><br><span class="line">predicate = args[1] if len(args) &gt; 1 else &apos;&apos;</span><br><span class="line">frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;)&apos;.format(typeName, predicate), options)</span><br><span class="line"></span><br><span class="line">def __lldb_init_module(debugger, _):</span><br><span class="line">debugger.HandleCommand(&apos;command script add -f findinstances.findinstances findinstances&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/facebook/chisel/pull/214" target="_blank" rel="noopener">Add Makefile for installing framework</a><br>This allows you to run make install with optional environment variables<br>in order to build and install Chisel.framework.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PREFIX ?= /usr/local/lib</span><br><span class="line"></span><br><span class="line">export INSTALL_NAME =</span><br><span class="line">ifneq ($(LD_DYLIB_INSTALL_NAME),)</span><br><span class="line">    INSTALL_NAME = &quot;LD_DYLIB_INSTALL_NAME=$(LD_DYLIB_INSTALL_NAME)&quot;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">    xcodebuild \</span><br><span class="line">        -scheme Chisel \</span><br><span class="line">        -configuration Release \</span><br><span class="line">        -sdk iphonesimulator \</span><br><span class="line">        install \</span><br><span class="line">        $(INSTALL_NAME) \</span><br><span class="line">        DSTROOT=/ \</span><br><span class="line">        INSTALL_PATH=&quot;$(PREFIX)&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>makefile自动化编译工具</title>
      <link href="/2018/11/09/shell/makefile%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/11/09/shell/makefile%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是：</p><p>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。<br>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。<br>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。<br>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p><p>makefile的规则</p><p>在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。<br><a href="https://seisman.github.io/how-to-write-makefile/introduction.html" target="_blank" rel="noopener">跟我一起写Makefile</a></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置Vim插件Python-mode开发python程序</title>
      <link href="/2018/11/08/python/%E9%85%8D%E7%BD%AEVim%E6%8F%92%E4%BB%B6Python-mode%E5%BC%80%E5%8F%91python%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/11/08/python/%E9%85%8D%E7%BD%AEVim%E6%8F%92%E4%BB%B6Python-mode%E5%BC%80%E5%8F%91python%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-python-mode-python-mode-95fdf8" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-python-mode-python-mode-95fdf8", "python-mode", "python-mode", "95fdf8", false);</script><h2 id="安装vim插件python-mode"><a href="#安装vim插件python-mode" class="headerlink" title="安装vim插件python-mode"></a><a href="https://github.com/python-mode/python-mode" target="_blank" rel="noopener">安装vim插件python-mode</a></h2><p>依赖于<a href="https://github.com/liuchengxu/space-vim" target="_blank" rel="noopener">space-Vim插件包工具</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function! UserInit()</span><br><span class="line">    &quot; Add plugin via Plug command.</span><br><span class="line">    Plug &apos;tpope/vim-pathogen&apos;</span><br><span class="line">    Plug &apos;python-mode/python-mode&apos;</span><br></pre></td></tr></table></figure></li><li><p>默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function! UserConfig()</span><br><span class="line">    let g:pymode_python = &apos;python3&apos;</span><br></pre></td></tr></table></figure></li></ol><p>结果出现加载问题失败<br><a href="https://github.com/liuchengxu/space-vim/issues/369#issuecomment-436874754" target="_blank" rel="noopener">安装vim插件python-mode</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vi test.py</span><br><span class="line">&gt;</span><br><span class="line">&quot;test.py&quot; [New File]</span><br><span class="line">Error detected while processing function pymode#init:</span><br><span class="line">line    2:</span><br><span class="line">E319: Sorry, the command is not available in this version: python3 import sys, vim</span><br><span class="line">line    3:</span><br><span class="line">E319: Sorry, the command is not available in this version: python3 sys.path.insert(0, vim.eval(&apos;a:plugin_root&apos;))</span><br></pre></td></tr></table></figure></p><p>最终采用<code>space-Vim</code>工具中的layer实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let g:spacevim_layers = [</span><br><span class="line">    \ &apos;python&apos;,</span><br><span class="line">\ ]</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/bb19438ea770" target="_blank" rel="noopener">Vim插件之python-mode 设置</a></p><p><a href="https://www.jianshu.com/p/37576a6de65b" target="_blank" rel="noopener">Python多版本管理</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Sphinx制作简洁而又美观的文档</title>
      <link href="/2018/11/07/hexo/%E4%BD%BF%E7%94%A8Sphinx%E5%88%B6%E4%BD%9C%E7%AE%80%E6%B4%81%E8%80%8C%E5%8F%88%E7%BE%8E%E8%A7%82%E7%9A%84%E6%96%87%E6%A1%A3/"/>
      <url>/2018/11/07/hexo/%E4%BD%BF%E7%94%A8Sphinx%E5%88%B6%E4%BD%9C%E7%AE%80%E6%B4%81%E8%80%8C%E5%8F%88%E7%BE%8E%E8%A7%82%E7%9A%84%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-sphinx-documentation/" target="_blank" rel="noopener">使用 sphinx 制作简洁而又美观的文档</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ easy_install sphinx</span><br><span class="line">Searching for sphinx</span><br><span class="line">Reading http://pypi.python.org/simple/sphinx/</span><br><span class="line">Reading http://sphinx.pocoo.org/</span><br><span class="line">Best match: Sphinx 1.0.5</span><br><span class="line">Downloading http://pypi.python.org/packages/[...]</span><br><span class="line">Processing Sphinx-1.0.5-py2.5.egg</span><br><span class="line">[...]</span><br><span class="line">Finished processing dependencies for sphinx</span><br></pre></td></tr></table></figure><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-quickstart </span><br><span class="line">Welcome to the Sphinx 1.0.5 quickstart utility.</span><br><span class="line"></span><br><span class="line">Please enter values for the following settings (just press Enter to</span><br><span class="line">accept a default value, if one is given in brackets).</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>工作目录的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── Makefile</span><br><span class="line">├── _build</span><br><span class="line">├── _static</span><br><span class="line">├── conf.py</span><br><span class="line">└── index.rst</span><br></pre></td></tr></table></figure></p><p>让我们详细研究一下每个文件。</p><ul><li><strong>Makefile</strong>：编译过代码的开发人员应该非常熟悉这个文件，如果不熟悉，那么可以将它看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。</li><li><strong>_build</strong>：这是触发特定输出后用来存放所生成的文件的目录。</li><li><strong>_static</strong>：所有不属于源代码（如图像）一部分的文件均存放于此处，稍后会在构建目录中将它们链接在一起。</li><li><strong>conf.py</strong>：这是一个 Python 文件，用于存放 Sphinx 的配置值，包括在终端执行 sphinx-quickstart 时选中的那些值。</li><li><strong>index.rst</strong>：文档项目的 root 目录。如果将文档划分为其他文件，该目录会连接这些文件。<h3 id="make生成文档"><a href="#make生成文档" class="headerlink" title="make生成文档"></a>make生成文档</h3>以<a href="https://github.com/sarumont/py-trello" target="_blank" rel="noopener">py-trello</a>为例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone py-trello</span><br><span class="line">$ cd py-trello/docs</span><br><span class="line">$ make html</span><br><span class="line">&gt;</span><br><span class="line">sphinx-build -b html -d _build/doctrees   . _build/html</span><br><span class="line">正在运行的是 Sphinx v1.8.1</span><br><span class="line">创建输出目录…</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>swift混编及Framework和静态库的支持</title>
      <link href="/2018/11/01/swift/swift%E6%B7%B7%E7%BC%96%E5%8F%8AFramework%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2018/11/01/swift/swift%E6%B7%B7%E7%BC%96%E5%8F%8AFramework%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="swift和OC混编"><a href="#swift和OC混编" class="headerlink" title="swift和OC混编"></a>swift和OC混编</h3><h2 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h2><h3 id="oc调用swift-framework-swift静态库"><a href="#oc调用swift-framework-swift静态库" class="headerlink" title="oc调用swift framework/swift静态库"></a>oc调用swift framework/swift静态库</h3><h3 id="oc静态库调用swift-oc的framework"><a href="#oc静态库调用swift-oc的framework" class="headerlink" title="oc静态库调用swift/oc的framework"></a>oc静态库调用swift/oc的framework</h3><h3 id="oc静态库调用swift-oc的静态库"><a href="#oc静态库调用swift-oc的静态库" class="headerlink" title="oc静态库调用swift/oc的静态库"></a>oc静态库调用swift/oc的静态库</h3><h2 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h2><h3 id="swift调用oc-swift静态库"><a href="#swift调用oc-swift静态库" class="headerlink" title="swift调用oc/swift静态库"></a>swift调用oc/swift静态库</h3><h3 id="swift-framework调用oc-swift静态库"><a href="#swift-framework调用oc-swift静态库" class="headerlink" title="swift framework调用oc/swift静态库"></a>swift framework调用oc/swift静态库</h3><h3 id="swift静态库调用oc-swift静态库"><a href="#swift静态库调用oc-swift静态库" class="headerlink" title="swift静态库调用oc/swift静态库"></a>swift静态库调用oc/swift静态库</h3><p>### </p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Fastlane持续集成开发</title>
      <link href="/2018/10/24/macOS/%E4%BD%BF%E7%94%A8Fastlane%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/"/>
      <url>/2018/10/24/macOS/%E4%BD%BF%E7%94%A8Fastlane%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>在框架开发中，一个优秀的持续集成环境是至关重要的。CI 可以保证潜在的贡献者在有保障的情况下对代码进行修改，减小了框架的维护压力。大部分 CI 环境对于开源项目都是免费的，得益于此，我们可以利用这个星球上最优秀的 CI 来确保我们的代码正常工作。</p><p>就 iOS 或者 OSX 开发来说，<code>Travis CI</code>, <code>CircleCI</code>, <code>Coveralls</code>，<code>Codecov</code> 等都是很好的选择。</p><p>开发总是有趣的，但是发布一般都很无聊。因为发布流程每次都一样，非常机械。无非就是跑测试，打 tag，上传代码，写 release log，更新 podspec 等等。虽然简单，但是费时费力，容易出错。对于这种情景，自动化流程显然是最好的选择。而相比于自己写发布脚本，在 Cocoa 社区我们有更好的工具，那就是 <a href="https://fastlane.tools" target="_blank" rel="noopener">fastlane</a>。</p><p>fastlane 是一系列 Cocoa 开发的工具的集合，包括跑测试，打包 app，自动截图，管理 iTunes Connect 等等。</p><p>不单单是 app 开发，在框架开发中，我们也可以利用到 fastlane 里很多很方便的命令。</p><p>使用 fastlane 做持续发布很简单，建立自己的合适的 Fastfile 文件，然后把你想做什么写进去就好了。比如这里是一个简单的 Fastfile 的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fastfile</span><br><span class="line">desc &quot;Release new version&quot;</span><br><span class="line">lane :release do |options|</span><br><span class="line">    target_version = options[:version]</span><br><span class="line">    raise &quot;The version is missed.&quot; if target_version.nil?</span><br><span class="line">    ensure_git_branch                                             # 确认 master 分支</span><br><span class="line">    ensure_git_status_clean                                       # 确认没有未提交的文件</span><br><span class="line">    scan                                                          # 运行测试</span><br><span class="line"></span><br><span class="line">    sync_build_number_to_git                                      # 将 build 号设为 git commit 数</span><br><span class="line">    increment_version_number(version_number: target_version)      # 设置版本号</span><br><span class="line"></span><br><span class="line">    version_bump_podspec(path: &quot;Kingfisher.podspec&quot;,</span><br><span class="line">               version_number: target_version)                    # 更新 podspec</span><br><span class="line">    git_commit_all(message: &quot;Bump version to #&#123;target_version&#125;&quot;)  # 提交版本号修改</span><br><span class="line">    add_git_tag tag: target_version                               # 设置 tag</span><br><span class="line">    push_to_git_remote                                            # 推送到 git 仓库</span><br><span class="line">    pod_push                                                      # 提交到 CocoaPods</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">$ fastlane release version:1.8.4</span><br></pre></td></tr></table></figure></p><p>AFNetworking 在 3.0 版本开始加入了 fastlane 做自动集成和发布，可以说把开源项目的 CI 做到了极致。在这里强烈推荐大家有空可以看一看这个项目，除了使用 fastlane 简化流程以外，这个项目里还介绍了一些发布框架时的最佳实践。</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cocoapods如何自动化管理项目依赖</title>
      <link href="/2018/10/24/macOS/cocoapods%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/"/>
      <url>/2018/10/24/macOS/cocoapods%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>通过介绍项目相关的属性配置，来了解cocoapods如何自动化管理项目依赖的。最后会通过自定义ruby脚本来演示。</p><h2 id="cocoapods偶现问题"><a href="#cocoapods偶现问题" class="headerlink" title="cocoapods偶现问题"></a>cocoapods偶现问题</h2><p><code>pod install</code>安装依赖，主要是对<code>build settings</code>中的新增依赖配置等，<br>当cocopad 集成失败时，可以通过以下几步排查 ，也可以尝试清除项目中pod相关的信息，重新<code>pod install</code>，了解以下步骤都是很重要的。</p><ol><li><p>添加宏Preprocessor Macros</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug：$(inherited) COCOAPODS=1</span><br><span class="line">Release：$(inherited) COCOAPODS=1</span><br></pre></td></tr></table></figure></li><li><p>设置Other C Flags</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug：$(inherited) -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small/Small.framework/Headers&quot; -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive/ZipArchive.framework/Headers&quot;</span><br><span class="line">Release：$(inherited) -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small/Small.framework/Headers&quot; -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive/ZipArchive.framework/Headers&quot;</span><br></pre></td></tr></table></figure></li><li><p>设置Framework Search Paths</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug：$(inherited) &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small&quot; &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive&quot;</span><br><span class="line">Release：$(inherited) &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small&quot; &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive&quot;</span><br></pre></td></tr></table></figure></li><li><p>Add User-Defined setting,新加三个参数</p><ol><li>PODS_CONFIGURATION_BUILD_DIR<br>Debug:   ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)<br>Release: ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)<br>PODS_PODFILE_DIR_PATH: ${SRCROOT}/../..</li><li>PODS_ROOT : ${SRCROOT}/../../Pods</li></ol></li></ol><h3 id="使用脚本自动设置"><a href="#使用脚本自动设置" class="headerlink" title="使用脚本自动设置"></a>使用脚本自动设置</h3><p><code>Small-subprojects.rb</code>编辑项目配置文件，动态设置插件库的<code>Framework search path</code>.<br>在项目中<strong>run shellScript</strong>添加<code>ruby Small-subprojects.rb</code>命令:</p><ol><li>当old_fsp为空时，会执行失败。</li><li>使用<code>./Small-subprojects.rb</code>，有时出现权限问题，替换为<code>ruby Small-subprojects.rb</code>。</li><li>编码问题：在头部添加<code># encoding: utf-8</code>：如<code>invalid byte sequence in US-ASCII (ArgumentError)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/local/bin ruby</span><br><span class="line"># encoding: utf-8</span><br><span class="line">require &apos;xcodeproj&apos;</span><br><span class="line">require &apos;xcodeproj/project/object/target_dependency&apos;</span><br><span class="line"></span><br><span class="line">project_path = &quot;#&#123;Dir.pwd&#125;/#&#123;Dir[&apos;*.xcodeproj&apos;][0]&#125;&quot;</span><br><span class="line">puts &quot;项目位置：#&#123;project_path&#125;&quot;</span><br><span class="line">project = Xcodeproj::Project.open(project_path)</span><br><span class="line">project.native_targets.each do |target|</span><br><span class="line">    puts &quot;项目target：#&#123;target&#125;&quot;</span><br><span class="line">    target.dependencies.each do |dep|</span><br><span class="line">        puts &quot;项目dep：#&#123;dep&#125;&quot;</span><br><span class="line">        if (dep.name != nil)</span><br><span class="line">            changed = false</span><br><span class="line">            sub_project = dep.target_proxy.proxied_object.project</span><br><span class="line">            puts &quot;sub_project：#&#123;sub_project&#125;&quot;</span><br><span class="line">            sub_project.native_targets.each do |sub_target|</span><br><span class="line">                sub_target.build_configurations.each do |config|</span><br><span class="line">                    old_fsp = &quot;ddd&quot;#config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;]</span><br><span class="line">                    puts &quot;旧old_fsp：#&#123;config.build_settings&#125;&quot;</span><br><span class="line">                    if (!(old_fsp.include? &quot;$(CONFIGURATION_BUILD_DIR)/**&quot;))</span><br><span class="line">                        changed = true</span><br><span class="line">                        puts &quot;更新-----&quot;</span><br><span class="line">                        #config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;] &lt;&lt; &quot;$(CONFIGURATION_BUILD_DIR)/**&quot;</span><br><span class="line">                        # puts &quot;Small: Add framework search paths for &apos;#&#123;dep.name&#125;&apos;&quot;</span><br><span class="line">                    end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            if (changed)</span><br><span class="line">                sub_project.save</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><p>打印信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Showing All Messages</span><br><span class="line">:-1: 项目位置：/Users/admin/hsg/hexo/XcodeTool/iSmallApp/iSmallApp.xcodeproj</span><br><span class="line"></span><br><span class="line">:-1: 项目target：iSmallApp</span><br><span class="line"></span><br><span class="line">:-1: 项目dep：IntelDecision</span><br><span class="line"></span><br><span class="line">:-1: sub_project：#&lt;Xcodeproj::Project&gt; path:`/Users/admin/hsg/hexo/XcodeTool/iSmallApp/bundles/IntelDecision/IntelDecision.xcodeproj` UUID:`84C839BA217F28A500541D4D`</span><br><span class="line"></span><br><span class="line">:-1: 旧old_fsp：&#123;&quot;CODE_SIGN_IDENTITY&quot;=&gt;&quot;&quot;, &quot;CODE_SIGN_STYLE&quot;=&gt;&quot;Automatic&quot;, &quot;DEFINES_MODULE&quot;=&gt;&quot;YES&quot;, &quot;DEVELOPMENT_TEAM&quot;=&gt;&quot;9CA5KUE8T7&quot;, &quot;DYLIB_COMPATIBILITY_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_CURRENT_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_INSTALL_NAME_BASE&quot;=&gt;&quot;@rpath&quot;, &quot;INFOPLIST_FILE&quot;=&gt;&quot;IntelDecision/Info.plist&quot;, &quot;INSTALL_PATH&quot;=&gt;&quot;$(LOCAL_LIBRARY_DIR)/Frameworks&quot;, &quot;LD_RUNPATH_SEARCH_PATHS&quot;=&gt;[&quot;$(inherited)&quot;, &quot;@executable_path/Frameworks&quot;, &quot;@loader_path/Frameworks&quot;], &quot;PRODUCT_BUNDLE_IDENTIFIER&quot;=&gt;&quot;com.clcw.IntelDecision&quot;, &quot;PRODUCT_NAME&quot;=&gt;&quot;$(TARGET_NAME:c99extidentifier)&quot;, &quot;SKIP_INSTALL&quot;=&gt;&quot;YES&quot;, &quot;SWIFT_VERSION&quot;=&gt;&quot;4.2&quot;, &quot;TARGETED_DEVICE_FAMILY&quot;=&gt;&quot;1,2&quot;&#125;</span><br><span class="line"></span><br><span class="line">:-1: 更新-----</span><br><span class="line"></span><br><span class="line">:-1: 旧old_fsp：&#123;&quot;CODE_SIGN_IDENTITY&quot;=&gt;&quot;&quot;, &quot;CODE_SIGN_STYLE&quot;=&gt;&quot;Automatic&quot;, &quot;DEFINES_MODULE&quot;=&gt;&quot;YES&quot;, &quot;DEVELOPMENT_TEAM&quot;=&gt;&quot;9CA5KUE8T7&quot;, &quot;DYLIB_COMPATIBILITY_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_CURRENT_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_INSTALL_NAME_BASE&quot;=&gt;&quot;@rpath&quot;, &quot;INFOPLIST_FILE&quot;=&gt;&quot;IntelDecision/Info.plist&quot;, &quot;INSTALL_PATH&quot;=&gt;&quot;$(LOCAL_LIBRARY_DIR)/Frameworks&quot;, &quot;LD_RUNPATH_SEARCH_PATHS&quot;=&gt;[&quot;$(inherited)&quot;, &quot;@executable_path/Frameworks&quot;, &quot;@loader_path/Frameworks&quot;], &quot;PRODUCT_BUNDLE_IDENTIFIER&quot;=&gt;&quot;com.clcw.IntelDecision&quot;, &quot;PRODUCT_NAME&quot;=&gt;&quot;$(TARGET_NAME:c99extidentifier)&quot;, &quot;SKIP_INSTALL&quot;=&gt;&quot;YES&quot;, &quot;SWIFT_VERSION&quot;=&gt;&quot;4.2&quot;, &quot;TARGETED_DEVICE_FAMILY&quot;=&gt;&quot;1,2&quot;&#125;</span><br><span class="line"></span><br><span class="line">:-1: 更新-----</span><br><span class="line"></span><br><span class="line">:-1: 项目target：iSmallAppTests</span><br><span class="line"></span><br><span class="line">:-1: 项目dep：TargetDependency</span><br><span class="line"></span><br><span class="line">:-1: 项目target：iSmallAppUITests</span><br><span class="line"></span><br><span class="line">:-1: 项目dep：TargetDependency</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将Playground作为项目的单元测试</title>
      <link href="/2018/10/23/swift/%E5%B0%86Playground%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/10/23/swift/%E5%B0%86Playground%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在<code>Perfect</code>项目中增加<code>playground</code>：</p><h3 id="新建Perfect-xcodeproj和PerfectPlayground"><a href="#新建Perfect-xcodeproj和PerfectPlayground" class="headerlink" title="新建Perfect.xcodeproj和PerfectPlayground"></a>新建<code>Perfect.xcodeproj</code>和<code>PerfectPlayground</code></h3><ol><li><p>新建一个Xcode工程<code>Perfect</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure></li><li><p>设置include路径<br>在Xcode工程的<code>build settings</code>中设置<code>SWIFT_INCLUDE_PATH</code> 路径为 <code>${PROJECT_DIR}</code>并设置<code>recursive</code>（递归）选项。</p></li><li>在同一工程目录下创建一个<code>PerfectPlayground</code>。</li></ol><h3 id="新建Perfect-workspace"><a href="#新建Perfect-workspace" class="headerlink" title="新建Perfect.workspace"></a>新建<code>Perfect.workspace</code></h3><ol><li>新建一个工作空间：<code>Perfect.workspace</code>,在工作空间中添加工程和操场：<code>Perfect.xcodeproj</code>和<code>PerfectPlayground</code>。</li><li>编译<code>Perfect.xcodeproj</code>，这样就激活了<code>PerfectPlayground</code>的<code>PerfectLib</code>函数库功能。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectLib</span><br><span class="line"><span class="keyword">let</span> json = <span class="string">"&#123;\"name\": \"tom\"&#125;"</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="keyword">try</span> json.jsonDecode()</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u = <span class="type">UUID</span>()</span><br><span class="line"><span class="built_in">print</span>(u.string)</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://github.com/PerfectExamples/Perfect-Playground/blob/master/README.zh_CN.md" target="_blank" rel="noopener">原文Perfect-Playground</a></p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新组件开发流程及打包证书配置</title>
      <link href="/2018/10/23/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%96%B0%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%89%93%E5%8C%85%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/10/23/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%96%B0%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%89%93%E5%8C%85%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎光顾，输入码阅读" />    <label for="pass">欢迎光顾，输入码阅读</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19Y0A+ATQ6//hQpJul9DDlwbi86LrHPOw4VEWXWzrNzylIVzGbYL34v4cy5v8YPs2PH1MPnpnZ+e/tCD84LpT5IacB4C5id4uZXSlKnQgIApTqFmmeZFJfeCVNEchnQtPTmDaK3hJDml26d2WSJypwr1ogTAfYM5ZOZT2UuWQlZNnPJYy2+l5XRZyMnDpyXXDTLUGOj/bCkZq+ybpzzoCd6TdwrFYGXdE1HkHqRS/gpYOKQOxdtW6SbyAMxursTY5kXKav4UmRTyjacNxoik6ty9+jiYLtZkrYMSBmVEhNLJzXo3UwB3ayyWjBCmGb7qX+n1kBW4ohFMZupjU82L1zquS3oaGl/O2nYHoPLBcgONnB2VLaiG+mCG1y519gQGgAJ4fstRQEmWJ1y94uiPzRwkEYpoHyvhBtKlOfDYvv1Ejc8h1Ze7gjm8BNna+DSs7g/kJs3aVEGWc7Sr6PiN3VO96G9i1DLSnYBU6kjmt9gepflVUbGzDHJJg/uUnlOjbjBcwEAzBjMykFhmQ0ifAOTpjJXzj8mIudWZdajOtvGNRyk2B6e9WlBOus2pEbjZF5uzXe+ROXWlcwPMWcrIFAPQjeEouqIjTvGtwaVdlMvK/zUefCVrn75he/gd/UU5RBrnZyEp6KHjlMyqSuzDNQPSd0gLxJuhm//oEcUFOPvQoDpMx1EiwudvwZG30h5cxT9RO+Z3SbS2Wft/1fCVXzW6Y7dM2tk4jr/TS961dgOftDaJUK1+LCnfZmeQDoFCZKkW7FoYvzaHmt0r9z99mnov7S/NrzeJLubYhw08MidT8mnCuO8IwUnCJxN6nwA4EDCaYgFs56gNFW/xhxgXGyt99x+6UfkLawk5DkChrYY5EAm7c+P+laow7D6m6dUxvEU2x8mpPG9mHFglLlRUzON2Kw4xgzHGSqM4vUrEoNKVaitJ2lR9e+Mjk3Qf9rKRNIl5sMW5D98ou+dXjOdZ9XAiv40GFxRGE7P/fZVyPAdCjot+bWobCJJdcT6XEJQ+gcgB0HqsrVA8lxmMWKpaLydvcLneBeSn5tP7zcELvJBfUr1QtX0asBgHspR1QZqN0l+3UiE+cRRnZ3ixi2rAPZeJe69W8szVlAidT5WzSS8yuXn33q5E3awnHEf3gGh5/aCfLI+u75xzRA83xhG3WrYF0d7X+DRP2EUevfozCctNDpngmsecK9uLoDYW4WFO85Q6Pbp1CMxV9BgdbXKte7Ihp6OMOiFVyB6H59abXkWH/vmaR5OUwkevfGHpIA7iQq74L0ez2cqn2qzlvZmCKunQbFxPzdasV8xNbN7YG6C6SM3B3PVU/J2nEVuQ/i7Sj3G7k5Tx9jMiRAkUD62QslmSbarMQfkHhB97UVT5tY2Ebemm+GCKxhR0o0XODwZkJW7ZopSMPg2lx8+u51oaOqfYxV4GFMLMzX6E+cm7NPMIl22yDOE1ZyuUF0ci2uxGyOiUjsUC7wY09z9ehf6MSx+3O5Q6WG8/1/HwV4V6ao+Ncv+m6gLTzVC/I+W4x59DyShPxCiLfqbjB/JRkvFO/JJrGzcyPUsL907c0U1qFq4jW6GDXjLsNbILVyBL/Ln0QnqODNMkfaOXq77vfkJ0BQvggx1scMUcmcJezqdBJc7xe5Hf9DlZCtD7zHNJ+v2eqNvFMz0z4ENM7/UcM0MZTQtQ/LLUvjTvEx7NfPeWhCmbv5QJdDW2Axu72E8CaAjrYOUSn0EWaVR4K5Sp/H0sTS2BtYHzwQgPeKhx7m4t5xopiakosHuj5ZCmMAGdKHRge7fhf/TxQ9esGdZYIDj3CcsMaNYRlQWV/Af6E6WvpP2ws7agh+zMMPSzZDjVq05RBdalVMEEE4TeL+EefWpSsQ3dTViAEI4Pjoj3D2VxNiATTI5iWjprCrjfiKqewUSYJWS/LfQj//UiuuZ1XsamlGz12L0NFu8YVIymaOakk1Ne2+wcV3Gui0IIyEY7JeWSOeD+XcHziV2cbbH39cvpP9qGhv8ylvaIl7Sq18DZQqrgF0OkqBbtV9kWCzkdJDKAqTYR92GVllmTsVak0vG3622l7jkMKkYuIJQyLJxjY14h6ZaxHuhARrNVGKU/Z/ilOOLLtWgXcj8hgtk2LgOggBSGYH6Xn9pNo1kReemCFm+4bWBeCSgl8gE7iUTLZ3QX5OR19NYAEzmlYGHhVncPpCye+jbNgD6Yi9wMAmt+jcuZD8OX3EKL8Y5FibwtY10IMQuvWWHOEIipHql4NCx75Emr0Yv2W+8M8MLwtRWU+1kIu6WMlCmA1DeOEGfj9VN5wWEz6GVYwFO4iS7TXKNn+ddauc/L8+nYhpI1oevlUNuPOb0Ok5f2Wn1t5zJgwM+Oswu+XOsUUGYrblpA0B1GGXKplxQo0DfSPYZJZ+ChVivoAgDprHX6t/vV1SFOyrckzEIPRW3yQojnrIWA1nZBogHDiBaK1CG/32XU7HoiQQRqX2c2xkEVUDKjxV9sF78XL2aBIDl2XaPbm0sjAczwSiJJeIVmyJAhkW7b+H9O6T3irFytVDau/fNYBkaGXbGEi7jwYrs01B7t66LRgqjV7mhvtknZvWVnRdo3C6oRF+ZJJnu7oSZOEqfseRGaaXWVuax617Qn3/6jXkD6MVc83FxrzohMSeeGBLpjh5JiRrqwGq/X6DMKlBefNfQOIaZyIuW6w43wnjM1IrrqIMuidDbXP8Xws72Wj0ydCragdtk3NEfMNWJeA//bB/u0yJGzdv69IbFikt4OD78QH4FAjBQUdy6qZVQ1ZMbkcA6q1Oxg9TS9/FY1StpW2+LtB1GYZ9Okek7gBrgRkSDshRIJSHJb2m0+5pw8fyQFo3uBsHh7MdZLLofiA9/5gzbNQVsCA98Bsksur4XtSYAlZDlE6fUead+tHNY8lYvEWKgr9iglSv0fjD/sf9kWytH8G/ZbUzIV9S44A4hdGiVCZPOHsZQSPhvgCYmnKosq09Tmn8j+1RV1jUNs8/H7vbEsx70gVX8SD5sh4LpgOZhBRaaK/jMoGNG2YUXt3bK9YDuvM8lBfMm40VuDXFV8O7TeB+IAHq/zEXcPLzzWaefvYYLqf8bzCWcMvTqKaOQ8nym/nl7PHWoDuR5UgsEhqHyPN35alydNQYpiAfEDNVlaz3HCi25lxjhcy4kXTTLTRBGE0b+NE9tYriHQ7l2Wu366nQlr20QYzxLrWxOwBPjbvRPcPnc50jDixc2xkomYoX/aJ3rO5/tOT2UXd7gO29n9QOlK2dHwQqOoRblYQY0siow0R9NoJCaJj+Rw88ceNgK7v/T3aPkDX4gGBjmZllRmpgT9/zJO/wJP+TkTha0nBIM0gDqvLDfnQBGSyXk11amenk6gqNOL3IIpC9mE+qBQpeSDgpuUUQcg2LrPqIvpXg1Tr/+qRqwaiqBmH+H3qsvRazfzeO6n1ku0bQszempGMGNZ4y50895SAsPLccH3G/tx40rZmsv2tfpyfVhqIIYr+HUQLVTaL9RDHhpMl3peeXC3liY+RDdMzum82AIzy/ooQH9ChXXF6Tw7VwVFuyElK36SqcmWZxRo1W7VIgYIreeS8C84u8JSRZYohWbeMh29XdKXxJg8exr49IgedUGylCKt41ucXSmGWlDqr7xhcXA0hbRgDAV6qQ5UeIGC2JzEXIvOjUfecwAFielUKUpZA2/zoyCEKlcBiIpSN/h5QHc3B9pYXG3/yuFJUFu/bouchvEC4bEX2TZal8eWh91orLVmnSvq7cttRt8VOuJWY26FEWX8OEfPzLkQ3qFoLTxcuNf966QNm01Wckbm9PW9OJ4PS/EZ+1qGgg77lYyoa9KGnu4LZ80Sjtm1ocDd5YnW4DZIsNoWO2KJEmU5BybcBLMhIXMF5Ys4He24s/unzQtNJEeDGWq93ypcPurTluzyi2TUyZoyl5+mQg9l/+8NiWN+51eK7YcPa7jZR2AxrdTpnrMLIvLMSWws47t/qSqWH0dJFkba0AU4ZKR4xdZ9MkiXdH1EbTVv5fqyBXBddLmLXvTDZTKkoTOBVUavNOqj7NserqpbIvWoxRvEFGspyFjCkFxeC0M646bFJLBvRq+/9YwOFszuUaIp8TM9PfGrGh5i9/pUGyS+DmqCsg211IegcWNAjudBg48uXskKuhHORGzWGk7zZZLJMdHJn3yPI7DwDhdiHy1kB5ZTJfxsHii70RuijzsaHRQ0gXZIVf3pglPousk32RuvamubihHAM8sz7TE3blo89P60yqKyowGV3OOE5PWaJOpVg5/EYZ2MWTml2/HafSJ0D9KZ/rc9pjRHTKoLQH9ZvpWFkObpmlzEHRAVaLw6dNdyxwlXhv4QDVpBeGejIoL3nwte6e8g3FqHjGx/Li9pWaOrjRd62gmBB0kSjVrWcQTpyvf708Yl+3BPWh08qqEa6oty98HO0TZsdtXJY/tJx9xMlOO5olx1UOcWs9zmJwOh3uiWygYL3sOw4ssw1ivFYKSTOP5vTTIm/rT91G5uAifCrs1N6vjNaPFh22piXqn8o8Vgz3Pdrbtfcev0MFFjQwoIH/KTR26x+k0cFOVTmSwLrvyZx2j0acLtZHW1B9SUKNDusENzCXkPvsKimwa/zgTNQV1bMZTdddcjBiJRY0rja9z1iaqiWAYiN9BU8OOnuX0sA4yZ6IQ9vjVFJ6a9z0vvmtZV9NC1zKL6/V7CJAagLdUEKv1izYtM/H9wRlafZVbf4422ZitibAsMST/hQ4OtkUTeFMEUmgMKoOm7InPXNHOWSn/eLK6k3quBjW65Bcbm0MfY67BqpnfIfxXoD9mc5PJB99h+Y2V+xKkkXGriYG6iv9NzRN3afiPWcChhC1tTmIM1U+7L8OVXFO17IdI3ZOAyzZwxV8dY8GW/fMRzbpI7JQWQxmpwe4oiYEjQs03UcfaGsM8tavTirj2LyymVKL1OWlPAt88dPFHcrzrrwPm6CjpyB/PGw0hSm6MZveAY+u/8YGZmmzt2KNzbY3PsP3EFraeMNK0xfetfsS5rBrqnfTTzAyL9fptH3qjIDH7T4Vl0y0HGoX9dt6KxMXlW7+Qv28nIdWUMVO5ZN4G/wJSXwXwnxbf74vpV6Ps+ZJxgnMUhvBTEvCCl9s9ct9VdVnlklMWdo3JQnrbpvAxUfrY+wwYIQvSfZEJFeAdEhBNSmbRwe3ABW9I8zPpi5+rXRwTCqtU5FUJuUB75h17S8oZtvEo8hX52MEdYoTgJ30CNXYnF8Y/hGswv5uezwBIshDpweeBR6MbiMkRaCEAFpDzdZWrkKDv4iwuYXDd1u4SiuiOlyxXuGhfOb8SzoNq+FOpu/2iMme6Cgj0mujqTVF+HCRCXrD7rTrXE8YS5J8UJDW9ApLRm6n4hL+ps+NrbHNW23oz6PsajjQEO0/ste7ON6i38rviO0uaIUbENT0kaB8oJ6ic64JIp1VS2IFgAX/D3MqrVfTIXFNihz5bCSttn/r6N7F0LcusHkVgUB+E/e7hL3cOuUpULJcvPu4DD1go37ttdtCvTgCnoFnx+PC6jq3SCxAYzzTyflwRedg12F0egS5WkmuKDkpqc+VvdtACtSgbzSCV75PDN3Jl1kEfxQ4Or9pN6gWN+N7ScnRmfDVXbL4bC9q68gqkhsAEaEdkgy8rlOwL+RknOHeQ7GqfE9VMTaoJfhj9K+v4KejwacREi3Qwp796ivoDzjvAccRTpfKNjgB6ZQflV9oFCOVycVqpBZ6RbZGxYxcfAxEvic5m1KiQKLppQvIVJV9K22LD0uzB2lx3vmsSEr76uCaSQoEzZfga42czz1UHVQ/o5lKC7GaIoT35ch+DjJBQJKZVvbqEG6p97acg69uHlvv5W/I/vntYdKrgWMFlI7CVx7owZda7DXO+v4Mh6YQobhe8/vyZZ3oDGQC8B4mtipUai4giouIbp4a6Zqy3XRI1x+bc0hY3mU4cvmMYno13lfl4Spgv33tNCUOieTCaLyooccEpUcmNV/s4FnmNejb9KuK/wk/H4NWfpqOpZe1eznPAmmroQH3uJhSwSHCOuGrVIDuad865UJqdFgeXYioWVbCC3ywnsY1JV2dK4bIpBmOfJB0kdbDlmdPffSj8oRuy9ydgqzhsYvmVH43QFZhzmmwOfYEpW1JvqWEBx9JMKknNuv+L26B1xJt/cA5p3hMrmayigihO/615QZ4xwxqhu1OqMAvd7TogxJx5x6kEFClGdpWnpONnhZCwVXmJC6kae7Q97Pqd0UO7LAYASTePz9391vrp0qkpLiBC2Ofh4j5QPnlDVShy4LMOwirybRlceqDrBctDCrr8iJm0hicWn0wfGaT+p3+JbVpC4rJkdp6H3fQqC3HGDRJg2UQt0a3E//zwQKOVs0MaObHjJD8ZxisdTFXPJJ+cBDNwq1GkOGHtpHJbnQkAsA8t1r0fdMiKK8l8xtbTpNKbBWOcq9ufvYTgva8MKi0Ro6e+/Ai53RHiFOjV7eTxoBgZnUOeSEmMz1haAgEe1tiuY25HKxDhg6rHBAh0PXC8QfuY/muJ1e+7R05wP7MiMbVlOLHL41zI3cGqdkiut2tmt4WJGqvLSULEd9NAiJEis1rVcMHbfBfZ1hlA9NEwGvdK13R/zARf8RdbUYireh4IUh+2XRDVTYswCa3MSDiUFjdUb8K4sARpyxR73/Wn3WN5kRrpKqAdxAkQTHcUfilBQuJDxjxPmaKR3cEAvfpS2Ci4x9STNOCFlvdnoyrGG9UhpNEeRsa7rzYBfxNXIqgda8y+wKCxxvATKwTEDZE85jTMzz7fISdV+HnKhuy+0dyOcZRbB8KxSxpDZ9Qzwpia0EEFkW+pac9ltwtBfgGnFzAbytns3waxFzD77B+c1yVb0QyHmzDw+DQPSM5U8pAMUVsBJRalo6YHm3hmQmNps7ftFIwXL6C3EW6/POQfcfUZiPBTN0AUw2blgABb2mybJ/4RnVze5ym5bIzCYSbCQpRVhpwHk7Yk2ne0xuOySWxWmvU+btgReR3JQKHtB/NK3EhFSR8fA8/ivi/R+WxXpjPu6T1GPpKNitXcfpRz+2VONUw+lphZqCIQy3UuAv61GVqNxnhmXrmZT90bqtvdUJEitEZ7/sUnA5RtBHu6n42qHqqgZ6W6Ufk56ctoiv4+QK5qVBHvUS+dYdHjXT1l6NKj/aZts3HuX4ZkM5HxtPmn2mayKJ0oSXlIcMhgwoz8V4IDu2Y82BJopK0xvOKj5vbaxglz3A/T5Z3fiKECVWAOOshR9cItO16vjTC3KF5YjDMgwOEBa7/ADKwRcReTBfBy8jJKYveJlG1ypf5Ezu7oWUksKehcEX5m86MaBTaBAahbgijtDzuoSNUfCDADbB0lu27jGQmLJo3KSuyCS3NQGcqPuOPq6VfVk3sIdoFKMmGRDnUJvVLnADDqoUOBcYtgzR/qkFaMBOjAPXjSj2t7njcylXdR+RoVs9eKDg7PgvjiCdgMiLSMZ6AQnMatqPbe2Ism85MVHxFaCHXMZReaAe0BRRLRMXwl/NS2oHq1lisRkdMI+GUYl8Xdtn7yvAmvTEh16WL540vGOXOHq9L802hXGMX9vvDVO2F16tW9d2lKKEghZFthdiOhVGQTVgU3j8D4paBitf649YgD4aHXAn/1ORqTL11DOFNOCe+8KE0uUsxFxT40NBGpcy4zyLcEJ9ZW5599adqeFyd1LzCP7JL7loV7SfYmOn8XfdFbh+M6NKMIQTfs+Yj+BfM4iheAblJq6pFVsYlBpOlq6GcKl0cSBHEBHvdAbzvRp7Lwk7ZhUhnqwXSnC8YBwdDZ07TUZF88w6qKFyfQNfPx/YuG6Q77DUUxeTgB1b5xfpnkuNRQJ9HbyeBU0oHd+qmgjQ2PTw47v/J3ZLAKHoXvfxkc5MVGICtThT4O+K72E4vnqK7r7zxgr5ZsVIUQJpZeUg3rI0knOKcbEmvnfFxtS1v0ZwM37+JSXVgNIrvyEE0sO2qKBMjLlnpl3vgDTHEsXduNhXH/LFGUcVA75dneWCVt+8MFuLKzc1k6AL1gGGaO0qKdzNRxrzEyboW5J5gJoke0YQBQZtohFZZDvN1tqWBFKMvSi+uYB8aEuLRu/bR6yPBGeSkVc2PErl1C1jnUrEn5jQOdA19Yyyi2Ih8VQ/mVzzr3yiDjpO41m2cd3FAIPGOraAkAqbtxkMx0xiCnuWjXUazzrQ4x9Px6vmEdyvaavTcYQwQTq+f8qTO1otycd5wsBmiqFnWwKi9mKdfFJJhqRQ0buKMP1EYyyKMNZ6uu3VJLE7++kkmIJJm+VXIvrmZVvrjiLTJz8+LN8/xQKH8FO2PvbQqfaCiIKKEOPZRvllKQCe9Enl9Q7rh2BEhY3wpid2h1rYRoTSROA8mEbduELenmC3HNcZhf3YO1NwRwAILS7JGegtRDSiFogW55RCF+OeIifeEqS2yyO3IB1hsoK0gaf+YHGXIL1Hw2w6MVFREcQ0QoNpO5rbNe2eA1UVSkZ6C3mKQusxyO3A3emr5pcTEehonv+N7tVzTW4FJPGdxD8C5RoFBSoJ9SASdEZNI2f7kBFHssNlAGv1FA5UAU1bJbG4XmiKdP1Tnr/ARVAD2mOSuPPC1SnmBC1yorQhJGAH5Z1tr0XuePEOSsL9H66LufpR0oGnh5AKHx0MFU1Fnc5Z4W0754Cgk2VH8RbYWUTusUAcLkSnf9IrObgrDoxZdECnL3QdtEmTu3WFByPQEN3/z6GswfPjN/w895Od4vibY4ybac4yjm4HlDwDfVJR8AI+uszVhgRPqpaz3qCVNitFIJtkJU41c+cENS7FdOIKZi7r0uBjZsNSIg/yYE3Y1+92VBf5yd9YFRcpptOf9JFJlYqI2oEaJrubm40KokwylpnoZnYwDVjQuJu2YwGzy8GwxZT3HBwZFA+aUD1cbAq1oE6xmWnU7GWg/64TSDdHod0Pi69PZSoe7BD/o9ZEG0G9nPFndfuR+ejF9GqSl82LaaWAMXJsik+iP1+4TxjydL52+lVyEdGjAJlb7rSHKeXlavMnC3BotN+kebY8aogeBwD/zAgyrEh9JXlOFY24MorAJzcI+1WAk4qzrgAOuwfjQhXHFTzuvaVL6xC6VGhVpgvC6EgtmBYmQKZlgg3rr1uEp1SsYH8Tc2NGd0+McEfozIMLZGDdU9rocBFf9In7Nsu16GaojSNCol0A4w//87rgwxpzhUToKaz3dzKuJ1pExcfLJMAahCmfgrH+HiqUtRczArRSNdTWZRkcl1DscR7Cdi+u2u5UAqqcOJ4eXh+9jPicNY+4a8HDDivkwK0xvaDlPHT8rcDB9mYgxj+PPwjc7IKpdR7/IA0u87JKJgrkSipOe/ZWwGAN6hDTUCjZCtz99xxQG/h7rmo/3ixIJ8v3YAWFfr6L3jz7q+/wVRj6YcL3UFLzm0+CSix2SNcDkX4qPyMeQmmDnZlbLXkBxh1XD8nETC+9//C1+5XtKOLEc+czy1vGoauYs/Qj6xWCMKslzzEJGh7Ae6o7q/a1B1+jRxA0MJw+OI9DAxOJBvFwhm1tTN3xv00evQ618uCtXeaJsPKkfHokXFNop5vIp2gIMT1fnHhUqNT9JNnVvapEtuL/gUMhcx7oDUWFBt3o6U9AK4GAV6D15XRoZoB4NDUro+cmbTWipxlECBBHOQ8s+7vtoKZ7qC5ze3mozEN1OK3LAe9Jf6bOOCAfCFSuUfJQUHuIyAAJyk5PF6zsWUvg6Qs7EBPNZv/Imi9RgHs+Uws/sDZmo2nNgXMKk0C0ZDeRzMvljbK/tzjIxb2yT6nV639884s9PTFPA03Eq9XgWgygVQx+3KfFwReAy2SMNrnMiKbydQGmDZZCEf7wu96V5s0dDZsf/k+iKSWmkaZn/PiYXH/Serra5LqJviHume8w9doOB4l42ci6w/VvDj8QW9hVTizzKaA8uXJsQ/gflUPpLgKJRgVot5IWvwJO7wLC9PTpdYK0ugDxzoENixN910st3p5fJ7H/zM57drCuXPaDxHbrAkt2+3BYSS0ayhKR/AYMoqGT8nsc1s6svJt+pJACJfIeHwc6kjovYIOUnBd6JHn1v/65kaZ7DiTiz4uSw9JyHQgemZDUgLZbGVIV6H1gnNs/t9GVqw5ynVeLDIRIEzzcYWKMdgi4HCowrJ6KldOR4m5ymGFk8oThcvkFtfRx8k9yk2P4JDEu9ziYrHGSlaY2+24JLV0wTldOrafLh1iHO2Mog6R+D+LTaWVqNlRQyADPR+yz4mZrNN7hcMVIN8NTl8J+2K2FIEGvu/BBdyyZcv6TVRXOU9bvktNsEB/hgvHm8XAjFhZXQ1yccPPSEv6ym3jZ09AOSTIowAaj52W5RkqVwsZSnNww4B2qvLgcrJ0pGWsINxrLJFbShnJ2/hE2bIv88GNxpn4PrhwB9DoX0jmE6WuIoQbnfh34CYtJ4KtpbE8v5WerUWRtQsuHWPopf1vsCzG3qLPIa6DzikirZxw6tgSxF0GZV/lBKCmzp/Lfx1Yj/JHHmA2jckDWN0F1DWykrlxob4qw0bDJxC7i3iDFv57ZDD+aXX7LkgYwvwIOwGUMvgFdah54Yh6iQox5okAaMLAQnZxmzt3WHHfWtXyytOftsETd6ewSJhVkoJjVxSvWEKubDBVe+JgqF06XiSHw+1cj4yW3WAnfORLp7YD6wFOX25NHfYd8EWtE82i+Sh4NIgHQGZ/Vcn61ov3bTRNgznvN/uBxp60a6g/l1hc0zWRpSWfothST8EQzHdWRrcepwvHo3goEaMqOK3vj8f+yIkyMco3LmU1kp+rHOGkSHfHxQKvejgG3dA+Ca9HhoBjQ1NzRFT/k841Q59iRmieKRSz4a+posYUFh/3QybKsEfZ3qgOIZoeN9Kd3T3m6V/NsQ+YMtiD4p9qi7DW9eMBKOvf91pV1rfxr6EkAH7CSEjs+rUhv/8QF5kapWqACWBJtzkT2ietfxhuK/gDduKwCMAeRRbRoJLHuhP6NIOpDT517QxmBtMUHgOjuYCNh6n71P2iL4taG0y5L2PFSP9crbOYZYfikOvL/z3S79cHcgRUrAM0883LQMp6F3AAi5lzzKP77ncpzVYR456PMyNi4WXU9yK+aWTTUHzOTgfnA8cvEfB8CzL/vTwoJBZpJis+pgKy+TmImnyYTG9XxHlt8tdfPnLIiVQOD/DcaQ6xIqfx7E6Uwu2K2KKqfx8dl9OW6Ob5RU7NcbdvB01ebK1ZvOCax3OkOw230M5yQZ2XkM2GTDGAWTwwCZ9T7UMMZ4PADbk532Jb9HBcNzhv8+hE/rwWSzDICzfvr8476POSSpLKkNNquVnCLwN+pe8IEoX0r8HnUgPWECeKi1qGVy5YjzmSJJPjioLsgejCtj6uqYOuAcwO+wcwvg0cAV8NEcPblpUmkQPqynqNcxuQVHFk8+LWiE+zFDdQAT/fbBvh6Yj86Km5z6b1AE/M1McmUbW3xRXb2mcr54m0PrQULODilCOcJfBNUZ4cOgdTlk32SCo/AyDUSip82d5fQ0g1/RNl/jk9cRiE1NirNj8OCN83Zin/HgPjLxuxYTmDvGu1HP01Oa7sZNJemJQqpfwCbAPDCI1L2cu2GxygrVIL65VPqgfhZlk7yTImCgHzaMts/X3+Giyk9uHxsZQniP3ApdPe1ArJx9AkVnN0T8HRqm4aDHbbC4CZPkkSvAoaF5TEc82hfD/U7DXWpeXWzuCltSmLG36oZK+lAWYpDM/3E3VRNzj3HCja1FD8Jx3LXCx06PwlYWeW2ZTgkm3l8EDwZbGjLG9P/QI0tH2TSfTgYFe8XwExJr8JgcRP1gbvFe/9JVVF2Rdgbn4EUe7BmRHQEC7k2YJMeMzRUNAdBK06PHXEbi708X37HXwWf7mzVL2Cm6T+Q/vxjsBJMplOcpLwpfn9NUgOzpnwoVyUZlDkCZP1ydzDeLKxVd4T0BT8ukrOg2tVatq0AJ0YdYeFsRNQvvzWsnjo/uEDMmK9pXSTQ+zqA1lfqMtXb2KX4IdLvGs9PgmCj8+Jla9ah1i/KmAajgGr4huApqNPA2cxkdslZuSFivzXK4SsUQps7gx+EtsPzajsgoKDXvts5Z0y8sDtA9jvF+SwypFyZo3C/vphTgMEtNaSTASlnmt0MiJCyqh+0lHAeD5q6UPwUm5WLbk9Bv6+4oS1f95wvoCHL1yoegFysDtnJrOtKxRNIjYzX/q7irGW8oD8nJf4pDou6tJ6a/apOdo284NBkCvWiXsDd3+IHyeFiJfZXJ7E6uRSuTLR4EHVT0/ZCVAXfal10VQU6MYp7CG4evMG6cWqrU0S59TlH4RlVGM9IEBnGeUakMndUC6ql1pobsoIfRx9Uja4oey+zknrVoDJZEvDL7Wx4oVN9IMTILUOqiJBF3cjCgzPR3XSA9b9RtCnzsvf2ubiqUtls+CKd+vE/EEm6sENXKohIkUSg9G2aj/vHerqDLSn9KXBzSYOgTNWP8sg6VBXXOMjQa12FKvySeRHkx5VWU441jqRLOodMYBSe4GP0UvaKQi32HHlOCTgM2k77bd7LU/FOCs1/Vylt1iWFz8zNAOK9C6c7v1kM9/fCXJVtOPWKtuQzJnkrDpeX8oCGaf/Od5J0qh5TMx6Vy1Q4+qL5NC3wqrYLqp8PHIP6X11pHATvWqJZhxa5f3VBEV82pB8hxsgohf9jyL36jbXXN36Hw6PRoOy9ezymll8ypflylmXP1JU1bHWUDCTSPcQIskTrDccvHFWZsIl7rA/L9lQAV9KHfLnwQaVqhWwkLs+Sok/WNsLiNypuKNbOvMcpdac6O1SRnXwszynBUN2M+bbWq3ij/s12ilJc+phQbGhdGtUKQ2ESkX5XdKseby+FcMNLSzmQyTHxoCXsAhKcReos2wenpgHqrAGv8H6sV1TGaNjylumMyuDxziXliIemcU2ldUDlxwCNEurHZZjnOCe6yA0cWlz8OpUOoOlweVk0DNjBKuiLxWVqhygGXDS57c7D8aaMvH5tbUMkRhsEReQr5Osby+BQ/Yi9Pw/wfFmEnhcDkrRE8KZiq6hGPd8U0pD5O5SVHU+LnPZSYg4grC7v9KTXFLL2bTfwijGJ1LmFg8UAjvlTjxSEScE3ZITbK/brK6LEB32JjNRK5TnkjtHwmt66lw10Ls8S1Tk7DIwa0knoK2cwXrsvJCDoD6CuXzpOdqgQsTMJX0e5aw8P7F0ocCwqhxPv6D3NnW8AOPvVp9zEytxvczl0tj2DqPgKerE1gXNmOi0OEXcXZreIsuTkBXQaesEt9D9bCBNHUyn2mMIw9WGfA9Fnk/7ZEI2Ue7gD1p2ZPp0c6bTspRkICoupbqbo1FNpCoCsuZEVXhfnbQNcfxAXoDXGIwL9SedCPGpUWLPHguXoks2z25wXRD9K+XgtCnyx8VpUAi3NzQmdsVxo+1KMoG2zKHsEmQqEuTqP2E8l0cpHWvKhuq3Qyn0TAiFdigw5An7gttP8ZUqJLNCl68xUMRT/bVWjpYZwTlJC385o/7ePvkfLFn0qlwyW4dCdnHAIboDF7yzU+0oaPvOO/RJ1Szd9I86+ADgSW01Pvi388qy0z+qzJiM0805x5RwnBqdHCQTtja6iSuHIcMX9tlE7JhAuTxfrAKPS1JYfrGFq+jEEnPavAwlKGX6Hg0iVaqAG6cf9p/nP3AYECXz7NEqEB7R2txHhX+SqbVjZXth3wySuzRAcWB3vq2bhcclhpgVFYHa4YvkGoek6u/TsKlGJO3s8+fXWkf3/QquXzqqsoNXjRAs3RNNmspajbyTWXxg1uiFKcmMDSJ/1USU22SZjdamT6YQ2W/WkrPM6DW9qbBieQf8YdBOginV6ugIwN40RGWL9nl9Wm+9nR059k4Wr7YqyHlipW8hcGFAEvGyT6RwjW8wgCIiqlTkSU2L+Plrqklxs33dmRUxWiE85vPRcSq7HDP9Ju4Cl7PvOKuPTUqMXMkUVbw2snb2Dodz6zPfZuHj3DsZEokimYslm0lcMWiY0vxlrmMB0J9ZbeGLAPwdALbVNvg0Pe8nzds3E3vmp0INPW2P3KWRHgB2lv/iU6H4j3dkNjdhAGQVAkU2+tAf9da6+/2z1aSG9dTuEwVmmpLcMDx7mdGZhaoKf0OxLNzqY2jHe5vyPyUwGNAdsASkoRhwexWgbbjHXziW0I9nOpl8DnScZz4mII4MNrIo17icl+vEQG0OxrXPr7c+BFu5oi97NuwcVGGtN+/c214leqf5ebJJCsLORaTmNw6iQHaThlOwdMQ3a28k6CCeOEaTO2i77scyb9q4BFRqfyr+R05nEZhI/NtFOoh1+eCopzCXnz+lHODZNSkA7cSoY29UKhKqp+431A4E9WgKB2aNgcoXcOPyzY/SMCUJEknSvUg0nBr62gmkWSvgWxTntDKo66iGLs8F7KktZF3MTJtnlHMFAc/yFhuURc+yQFWJgx8Wzr+2lziXsa8L8Wns50uL2gWfHufxieDHIC4WkXuuT4+/+0u3w5cn0il7g9DTIpF3UztBsNKrIWFVTEnM2l5A5O6dAA8CoX5MVAWiB1uhl3P7rt83oLMM0VYNguaVwMcIND0LU3pHMVhOB/yu3G2tbAjEB27oH62SL6uhEafZQfaxbhAbOuc1Xj4xMCg7091CMqa7KekhixUw3g/8Eu2N4P/xXYNrK4Q90i9THJ1Cwdl1WK5grk/Bt6vtB7Z8FPkc2Y7TYLTUDJEg5fly4V9yCG19IBth5Nuz4GeWbonRkpkbcXq7nkIVu2jCwTFQqkovdgYcdLlieEWOf/HmAp8lavrIgmBP3TB9MfzDsAX0MXZ+u9yrth14ZCcwgPWfqRw7Qij0sgCSnJ1RNX+fgFKk/3K3vYt80SecxdqyhbXgxYrDqB4KpWFqX2T2O9NeDQjFFULtDlfRY08LeHjlsaRiKGw10bnD26/i9pN61Z95es+8POsnR3IE+ZX/ATlvVb/tK76C5ucL0ZrwakQn0jdkwfL4hbUBooqLammGZYFFxmrmkKhyUxdldW4jIPH/PgI91ObCznj49SkVScb8ONlhSo3zrCjL+erX1vcYJG7/4rtsheDnueeN5ivO3Hd8Motpx3/bdokVb41g4ctgOvGggPG+c7TYorSc0zO7qDiVa1MODI0xyX7L7UI9yhOEyV+POphWfOMyaYpz13JX4L82j7UdpR7PAAHAHoeW6Ihlt5WoAYvZ0RShfYEYzq6C2Xj/E7ApGmAoGlnu3zgNZRWd0kpgRtYa5niHpyMJREWIJOHEPh5zkXUozSp0LJLqoJUITM2AxuoKSUFZ8xMBRk4LixKfHM/pqqzvdkz4GyqS4QptCqq+BWCHrUBYk7NVV+L1CGz8o1VkqbgqfAmowh+xarUzdVegXtqLeFt9Re7E8Fbyijr/9a3nL1/NzUeQevJ4jKMZf2kKk/jdHSnJwEfI7s5DsxOnscc3Vo2/j3HRkbnTmHSILQA8R5ejlhzV9lw+y48xVY98Dwk18n6KwxsVSXmzrR++MCWeIMbFGzGd/0mt10BsFm962mqzayRevW4irlovuD9Y1QmyhwOhm8527rHhg6aazovVVTy03r4PkxVSUO4Gp7xYwEdLvkn40jEInVkM08shSh3xOkEcBWPrXc8dQ2pO9dYhXFmBuRBtSXRAtLEUGdwPISgDIO2nSTjafiz++PbwR5CjUMU/54MRMqHSTVDp2j0bcfN5UqHz4ebOQqrBx9cm2RwCGWDzdVGVJtlARmFx6ZRAc3yzchRAiCJAZk1MonD2rPNMtRF0JDV24MChgetpKPVjHpo/jZpFiSukGutr8WOZSQQ1Kbc0gn6aXQOHotxFC++tSuFseQeddC3/oiRfqYiqDMotZez+RGpaIJSiYE/u0ryZOGPKHiM5mySZaIcq8IQttL0fLxiMIRHh4qpOMFG9mc3oaD75/JH7xE7lRz7bSt1juxRkJKildXsL3frMcdqp6s2lCn+RlVzyyA98WLoiIoA/7Hlvgk5gDVYqKChJrN/WjsmiveP9OFFHk8+LazpFkGqDQK3P44QXyZ7lRkZzD4DYaJ8KDKxzXhX4wOB2QJU+/MvK0/880IT2W7o1G+NtAkwiA3u9Mu5Eihubu0KEwqhqMbEBjH0HdaiutopnKDqG/tiijL1rPJyR5IMr3eFYlNTcDX10k5TF/TVsZLk4acx8PcDlcIExQe6VLAbKQoUk906IKBZBMXIIK642pR5Jcb2fe1+WR1+XjuYHZQzWcD2GmNHu16/2gyHeec4QQ3yKeSG9zqKU921helVW4YUY/sObPgTOJ5yxw2gg8gHYmL6GBLiOVDtlTbtZave3Gj/jBUjsklutE9msLSr+HbHKnADN0Tj4mPJHzczkwB/vLeEDbfi5QFxDob0RrMkmfF6eOAub+BRqD45SyzZ1DoXvaTTLXdbV6gnNmDZL1aU1RMUaRC1nlcGsIWdmODZnU11EpkYf3TPx3N6czMnWXvfAHDAieE+cwyQaC3CDwzVzneBGyQP3m78PBgx9pHIE8GlAk0nQIHvGXzga4KVNfMlFt/lizRuroD7Rm5eU1lKFfxyh4miEAmlRipULq+9IA4Pm7OYn//Q9yd/NXu3QQzsh42QdFcAERo0ONe1XHd+pddmtySNyb1rHOQ6BKJ020ukbMXA5Ba5tm6SXEj1XbCjzQXNYTtlDu1RRKqnfF9u+VhKBoxamwslh0EHe5yw4H6PnbOxygQZbdh+cmCjJHmCRkqHX+309OLULXA9CXGAWTSaCRjq17cfcp+AP7veyVPSqGj1pKRp6ALD1cmZiwjTF22KtQvrqRbsGtGts/AymVUOzAQd3j3/YUwFg/VqGjIZsdS6T/nSBWsdnvrXh3/AsTNbN3HPUH54w51hGlP37usF78C9nK9PtSuFVeiSIU0MPZw97Inlz5IpDH8qk+gOs7p/eZXCJvQqr72cG6ftXsTovL04YxcylEzYuPMaXOLCNv70H/bKTTvSBmCbUPKb694lnMixR0RI+5bor1LHyK5tXKbDKmW45rhdUGUB9C/+tGeQeHLaaf5YfiaFwB3CYes3HdVvv0N6TnCcJWVvAM+fUriHVl0bfXWVPICKzXLOrMVa2g+09xWP2J+ArQaBgtFMSupyTpX9WbNqwjgdIby2E6Elt+bgc+QchxkvM1Sj2IdYIwg9lNf+GgIrkN7+lHZHUbbWCKEAiZxEWxJOYvG1WvqQoc3zzz7kQY17wFj1U7nwFfG+4oTEbqhEqSXzEu1bj+BP5N1hUE9j4GeI1SU8wgUGp9kpYNXd+ySl8tUeMpvwiiA1HM4ywyotOjDzwcd6ZpHIEICz19Mkx2QNgh+PxKmaqJuSYOH8XUOAiI2fvWFwUftjS3eHGT382zvPgYwX8quOzoNMoGZRLafAnCataTD1sMuqSh6uKk8wcdit3Hm2rgyPJjn4e5cLoEdD4yPbiq/MuB5BiCpl00i6e5+9Zd7nZYxtYRkwJH3NX9iGXbO2AVMZHvfAWNYfYKfpeHWoQlGRWHCXCrLwDSPSLW9K37SDESENBpOTnY5GbV2UrK9g52ZRQum+vSj9FlU/4aP9cdh0dA4FZzpH3BelK9EvAlDiyEAbKMyHvhnutFj1/sZD1Br1zweClJsRYye76c8V/VzMj/B9rp24haJu3c2wIfm8ko/3xMJxvZxZhm5M9iOGo1TLzCRp3aPzlYeEg7pr9cgKno2onxB4vL4S4gfzgDdnhdGzcAXCe2AMM6AKXv5WKIGNduvZaxddn7LC/VB4BN5+wGyROFYBY/N3rS3vipHcbF0kBrD3TUBMKFCUSd6+tuyBrekip/2AnsK6v/DhB7c230tZFfde+vSZO2mJEsnFQMD+VXGMwd3Zoz2wpNNFiz9RgQlK75Xe5HazOZ8CT+XM6qrZOL5JhVXXe1m+O1VR1DYO18jE6+PmsPr1b7Bn22o=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift访问REST服务开发TrelloAPI</title>
      <link href="/2018/10/22/macOS/Swift%E8%AE%BF%E9%97%AEREST%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91TrelloAPI/"/>
      <url>/2018/10/22/macOS/Swift%E8%AE%BF%E9%97%AEREST%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91TrelloAPI/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><blockquote class="trello-card"><a href="https://trello.com/c/flp0VUyv/22-swift-ios-apps-with-rest-apis%E4%B8%80https-wwwjianshucom-p-01ca73387481" target="_blank" rel="noopener">(Swift) iOS Apps with REST APIs(一)https://www.jianshu.com/p/01ca73387481</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用screen在后台运行进程</title>
      <link href="/2018/10/22/shell/%E4%BD%BF%E7%94%A8screen%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/10/22/shell/%E4%BD%BF%E7%94%A8screen%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><ol><li>支持会话恢复<br> 当我们开启screen后，只要screen进程没有终止，其内部运行的会话都可以恢复。网络连接中断临时，用户也可以进入开启的screen中，对中断的会话的进行控制(恢复或删除)。<br>通常的用法是在暂时离开的时候，让在screen中运行的会话保持正常运行并将Screen切换到后台。</li><li>支持多窗口<br> 当使用screen时，可以开启多个窗口，让每个会话都独立运行到不同的窗口，并拥有各自的编号、名称等。用户可以通过这些编号及名称进入不同的窗口。</li><li>会话共享<br> Screen可以让一个或多个用户从不同终端登录一个会话，并共享会话。使用户登陆同一会话的用户看到同一会话内容。<br> 同时它可以提供窗口访问权限的设置，对窗口进行密码保护。<h4 id="screen参数"><a href="#screen参数" class="headerlink" title="screen参数"></a>screen参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-A 　          将所有的视窗都调整为目前终端机的大小</span><br><span class="line">-d  　         将指定的screen作业离线</span><br><span class="line">-h  　         指定视窗的缓冲区行数</span><br><span class="line">-m             即使目前已在作业中的screen作业，仍强制建立新的screen作业</span><br><span class="line">-r             恢复离线的screen作业</span><br><span class="line">-R 　          先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业</span><br><span class="line">-s 　          指定建立新视窗时，所要执行的shell</span><br><span class="line">-S             指定screen作业的名称</span><br><span class="line">-v 　          显示版本信息</span><br><span class="line">-x 　          恢复之前离线的screen作业</span><br><span class="line">-ls或-list 　  显示目前所有的screen作业</span><br><span class="line">-wipe 　       检查目前所有的screen作业，并删除已经无法使用的screen作业</span><br></pre></td></tr></table></figure></li></ol><h4 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h4><ol><li><p>自定义shell脚本启动一个进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen_name=<span class="string">"ngrok"</span> <span class="comment"># 创建了一个名为 my_screen 的窗</span></span><br><span class="line">screen -dmS <span class="variable">$screen_name</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="string">"ngrok tcp 22"</span>;</span><br><span class="line">screen -x -S <span class="variable">$screen_name</span> -p 0 -X stuff <span class="string">"<span class="variable">$cmd</span>"</span></span><br><span class="line">screen -x -S <span class="variable">$screen_name</span> -p 0 -X stuff <span class="string">'\n'</span></span><br></pre></td></tr></table></figure></li><li><p>退出进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name -X quit</span><br></pre></td></tr></table></figure></li></ol><p>其他<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C-a ?       显示所有键绑定信息</span><br><span class="line">C-a w       显示所有窗口列表</span><br><span class="line">C-a C-a     切换到之前显示的窗口</span><br><span class="line">C-a c       创建一个新的运行shell的窗口并切换到该窗口</span><br><span class="line">C-a n       切换到下一个窗口</span><br><span class="line">C-a p       切换到前一个窗口(与C-a n相对)</span><br><span class="line">C-a 0..9    切换到窗口0..9</span><br><span class="line">C-a a       发送 C-a到当前窗口</span><br><span class="line">C-a d       暂时断开screen会话</span><br><span class="line">C-a k       杀掉当前窗口</span><br><span class="line">C-a [       进入拷贝/回滚模式</span><br></pre></td></tr></table></figure></p><h4 id="退出screen"><a href="#退出screen" class="headerlink" title="退出screen"></a>退出screen</h4><p>退出screen的作业时，有两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Crtl + a +d     保存进程并退出作业(程序在screen中继续运行，screen -ls 可查看)</span><br><span class="line">Crtl + alt + a + d  进入后台运行进程</span><br><span class="line">exit            退出作业和进程(程序终止，screen -ls 不可查看)</span><br></pre></td></tr></table></figure></p><h2 id="什么是Mosh"><a href="#什么是Mosh" class="headerlink" title="什么是Mosh"></a>什么是Mosh</h2><p><strong>Mosh</strong>表示<code>移动Shell</code>(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。它能用于<code>SSH</code>连接，但是比<code>Secure Shell</code>功能更多。它是一个类似于<code>SSH</code>而带有更多功能的应用。程序最初由Keith Winstein 编写，用于类Unix的操作系统中，发布于GNU GPL V3协议下。<br><strong>Mosh</strong>最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的UDP方式。</p><ul><li>会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行。</li><li>会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。</li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Chisel自定义python调试命令</title>
      <link href="/2018/10/21/%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8EChisel%E8%87%AA%E5%AE%9A%E4%B9%89python%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/21/%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8EChisel%E8%87%AA%E5%AE%9A%E4%B9%89python%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-chisel-56d0e0d" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-chisel-56d0e0d", "huos3203", "chisel", "56d0e0d", false);</script><h2 id="管理-lldbinit"><a href="#管理-lldbinit" class="headerlink" title="管理.lldbinit"></a>管理.lldbinit</h2><p>.lldbinit每次启动Xcode 都会加载lldb环境，故当自定义命令写好之后，可以通过这里加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script fblldb.loadCommandsInDirectory(&apos;/magical/commands/&apos;)</span><br></pre></td></tr></table></figure></p><p>现在将lldbinit原文件放在自己便于管理的地方，便于导入python命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  installChisel.sh</span></span><br><span class="line"><span class="comment">#  HexoDeploy</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Created by admin on 2018/10/21.</span></span><br><span class="line"><span class="comment">#  Copyright © 2018年 boyer. All rights reserved.</span></span><br><span class="line">basepath=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`; <span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前cd的目录名："</span>`basename $(<span class="built_in">pwd</span>)`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sh脚本文件的绝对路径：<span class="variable">$basepath</span>"</span></span><br><span class="line">ln -fs <span class="variable">$basepath</span>/lldbinit ~/.lldbinit</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br></pre></td></tr></table></figure></p><h2 id="创建加载自定义命令"><a href="#创建加载自定义命令" class="headerlink" title="创建加载自定义命令"></a>创建加载自定义命令</h2><p>无论是本地使用还是提交到<code>Chisel</code>贡献，工作流程都是一样的。</p><ol><li><p>在便于管理的目录下，新建python文件 <code>vi example.py</code>，在chisel会通过该目录路径来加载新命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Example file with custom commands, located at /magical/commands/example.py</span><br><span class="line"></span><br><span class="line">import lldb</span><br><span class="line">import fblldbbase as fb</span><br><span class="line"></span><br><span class="line">def lldbcommands():</span><br><span class="line">    return [ PrintKeyWindowLevel() ]</span><br><span class="line"></span><br><span class="line">class PrintKeyWindowLevel(fb.FBCommand):</span><br><span class="line">    def name(self):</span><br><span class="line">        return &apos;pkeywinlevel&apos;</span><br><span class="line"></span><br><span class="line">def description(self):</span><br><span class="line">    return &apos;An incredibly contrived command that prints the window level of the key window.&apos;</span><br><span class="line"></span><br><span class="line">def run(self, arguments, options):</span><br><span class="line">    # It&apos;s a good habit to explicitly cast the type of all return</span><br><span class="line">    # values and arguments. LLDB can&apos;t always find them on its own.</span><br><span class="line">    lldb.debugger.HandleCommand(&apos;p (CGFloat)[(id)[(id)[UIApplication sharedApplication] keyWindow] windowLevel]&apos;)</span><br></pre></td></tr></table></figure></li><li><p>加载新建的命令<br>可以使用<code>Chisel</code>提供的函数<code>loadCommandsInDirectory</code>加载，在<code>fblldb.py</code>中声明的方法。<br>在<code>~/.lldbinit</code>新增如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ~/.lldbinit</span><br><span class="line">...</span><br><span class="line">command script import /path/to/fblldb.py</span><br><span class="line">script fblldb.loadCommandsInDirectory(&apos;/magical/commands/&apos;)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>更方便的方式：命令文件直接放在chisel源码中的<code>mcommands</code>目录中，这样会自动加载，就不用在lldbinit中配置了。<br>因为内置的支持，新命令也可以轻松使用<code>arguments</code>参数和<code>options</code>选项的相关功能。请参阅<code>border</code>和<code>pinvocation</code>命令的用法。</p></blockquote><h2 id="开发调试命令的流程"><a href="#开发调试命令的流程" class="headerlink" title="开发调试命令的流程"></a>开发调试命令的流程</h2><p>无论是本地使用还是提交到<code>Chisel</code>贡献，都是相同的工作流。</p><ol><li>启动<code>LLDB</code></li><li>拦截断点(或者通过Xcode的调试栏中的<code>pause</code>按钮暂停执行，或者直接<code>process interrupt</code>进程中断)</li><li>执行命令<code>source ~/.lldbinit</code>，在LLDB中提供命令源</li><li>运行您正在执行的命令</li><li>修改命令</li><li>重新加载脚本<code>script reload(modulename)</code></li><li>重复3-6步骤，直到自定义命令达到预期效果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fork印象笔记SDK支持pod安装</title>
      <link href="/2018/10/21/macOS/fork%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0SDK%E6%94%AF%E6%8C%81pod%E5%AE%89%E8%A3%85/"/>
      <url>/2018/10/21/macOS/fork%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0SDK%E6%94%AF%E6%8C%81pod%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-evernote-sdk-mac-fd5da70" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-evernote-sdk-mac-fd5da70", "huos3203", "evernote-sdk-mac", "fd5da70", false);</script><h2 id="制作pod支持"><a href="#制作pod支持" class="headerlink" title="制作pod支持"></a>制作pod支持</h2><ol><li><p>fork 并clone代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/evernote/evernote-sdk-mac.git</span><br></pre></td></tr></table></figure></li><li><p>创建pod spec索引文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd evernote-sdk-mac</span><br><span class="line">$ pod spec create EvernoteSDK https://github.com/huos3203/evernote-sdk-mac.git</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件<br>设置支持的平台，源码目录位置，指定忽略的文件等配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">spec.osx.deployment_target = &quot;10.7&quot;</span><br><span class="line">...</span><br><span class="line"># ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">spec.source_files  = &quot;EvernoteSDK&quot;, &quot;EvernoteSDK/**/*.&#123;h,m&#125;&quot;</span><br><span class="line">spec.exclude_files = &quot;EvernoteSDK/internal/ENOAuthViewController*&quot;</span><br><span class="line"></span><br><span class="line"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">#spec.requires_arc = true</span><br><span class="line">#spec.xcconfig = &#123;&quot;WARNING_CFLAGS&quot; =&gt; &apos;-Wno-nullability-completeness&apos;&#125;</span><br><span class="line"># spec.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>验证EvernoteSDK.podspec<br>需要用参数：–allow-warnings ，由于源码验证过程中的警告提示问题，导致验证失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint --allow-warnings</span><br></pre></td></tr></table></figure></li><li><p>发布到私库中<br>先在本地添加私库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo add PodRepo https://github.com/huos3203/PodRepo.git</span><br><span class="line">#输出：</span><br><span class="line">&gt; Cloning spec repo `PodRepo` from `https://github.com/huos3203/PodRepo.git`</span><br></pre></td></tr></table></figure></li></ol><p>开始发布过程中，也会验证，出现警告问题，需要添加<code>--allow-warnings</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push podRepo EvernoteSDK.podspec --allow-warnings</span><br></pre></td></tr></table></figure></p><ol start="6"><li>在项目中使用<br>编辑podfile文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#加载私库</span><br><span class="line">source &apos;https://github.com/huos3203/PodRepo.git&apos;</span><br><span class="line">#依赖库</span><br><span class="line">pod &apos;EvernoteSDK&apos;, &apos;~&gt; 1.2.0&apos;</span><br></pre></td></tr></table></figure></li></ol><p>在执行pod install 即可。</p><h2 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h2><h3 id="在objc中调用"><a href="#在objc中调用" class="headerlink" title="在objc中调用"></a>在objc中调用</h3><p>直接引入<code>#import &lt;EvernoteSDK/EvernoteSDK.h&gt;</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;EvernoteSDK/EvernoteSDK.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">hello</span></span></span><br><span class="line">-(<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *EVERNOTE_HOST = BootstrapServerBaseURLStringSandbox;</span><br><span class="line">    <span class="built_in">NSString</span> *CONSUMER_KEY = <span class="string">@"your key"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *CONSUMER_SECRET = <span class="string">@"your secret"</span>;</span><br><span class="line">    [EvernoteSession setSharedSessionHost:EVERNOTE_HOST consumerKey:CONSUMER_KEY consumerSecret:CONSUMER_SECRET];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="在swift中调用"><a href="#在swift中调用" class="headerlink" title="在swift中调用"></a>在swift中调用</h3><ol><li><p>创建<code>工程名-Bridging-Header.h</code><br>引入框架库</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;EvernoteSDK/EvernoteSDK.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>在main.swift 调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> <span class="type">EVERNOTE_HOST</span> = <span class="type">BootstrapServerBaseURLStringSandbox</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">CONSUMER_KEY</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">CONSUMER_SECRET</span> = <span class="string">""</span></span><br><span class="line"><span class="type">EvernoteSession</span>.setSharedSessionHost(<span class="type">EVERNOTE_HOST</span>, consumerKey: <span class="type">CONSUMER_KEY</span>, consumerSecret: <span class="type">CONSUMER_SECRET</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>config配置个人文档库专栏</title>
      <link href="/2018/10/20/hexo/config%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%BA%93%E4%B8%93%E6%A0%8F/"/>
      <url>/2018/10/20/hexo/config%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%BA%93%E4%B8%93%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-blogDocs-978ed39" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-blogDocs-978ed39", "huos3203", "blogDocs", "978ed39", false);</script><h3 id="忽略配置"><a href="#忽略配置" class="headerlink" title="忽略配置"></a>忽略配置</h3><p>文档库主要整理kindle读书笔记，jazzy文档相关html页面，放在hexo中不需要经过md转换html过程。故需要通过hexo的<code>skip_render</code>配置机制，来屏蔽一些目录/文件等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: [&quot;*.html&quot;,&quot;docs/*/*&quot;]</span><br></pre></td></tr></table></figure></p><p>这样，在hexo g过程，跳过这些文件，目录的编辑过程，直接拷贝到public中发布。<br><a href="https://github.com/hexojs/hexo/issues/1146#issuecomment-88380140" target="_blank" rel="noopener">skip_render参考</a></p><h3 id="docs配置"><a href="#docs配置" class="headerlink" title="docs配置"></a>docs配置</h3><ol><li>位置考虑<br><code>docs</code>放在在source目录下，目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── souce</span><br><span class="line">    ├── _post       //博客</span><br><span class="line">    ├── tags        //标签</span><br><span class="line">    ├── categories  //分类</span><br><span class="line">    ├── docs        //文档库</span><br><span class="line">        ├── index.md</span><br><span class="line">        └── kindle笔记</span><br></pre></td></tr></table></figure></li></ol><p>其他配置可以按照<code>tag</code>,<code>categories</code>相关配置，显示在网页中。</p><ol start="2"><li>版本控制<br>考虑<code>docs</code>文档库的容量递增，选择<code>git submodule</code>来管理<code>docs</code>文档库，集成到hexo主库中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装ruby及chruby版本管理</title>
      <link href="/2018/10/19/shell/%E5%AE%89%E8%A3%85ruby%E5%8F%8Achruby%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <url>/2018/10/19/shell/%E5%AE%89%E8%A3%85ruby%E5%8F%8Achruby%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-postmodern-ruby-install-ea2b8bb" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-postmodern-ruby-install-ea2b8bb", "postmodern", "ruby-install", "ea2b8bb", false);</script><h2 id="安装工具ruby-install"><a href="#安装工具ruby-install" class="headerlink" title="安装工具ruby-install"></a>安装工具ruby-install</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ruby-install</span><br></pre></td></tr></table></figure><h3 id="安装指定-Ruby-版本"><a href="#安装指定-Ruby-版本" class="headerlink" title="安装指定 Ruby 版本"></a>安装指定 Ruby 版本</h3><p>方式一：使用<code>Homebrew</code>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby-install ruby 2.4.1</span><br><span class="line">$ ruby-install --system ruby  #覆盖系统版本</span><br></pre></td></tr></table></figure></p><p>但Mac最新系统安装Xcode时已经没有Command Line工具，需要单独安装。安装命令行：<code>xcode-select --install</code></p><h3 id="安装chruby管理工具"><a href="#安装chruby管理工具" class="headerlink" title="安装chruby管理工具"></a>安装chruby管理工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install chruby</span><br></pre></td></tr></table></figure><h2 id="管理ruby版本"><a href="#管理ruby版本" class="headerlink" title="管理ruby版本"></a>管理ruby版本</h2><ol><li><p>预览安装的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chruby</span><br><span class="line">    ruby-1.9.3-p392</span><br><span class="line">    jruby-1.7.0</span><br><span class="line">    rubinius-2.0.0-rc1</span><br></pre></td></tr></table></figure></li><li><p>切换为使用版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ chruby 1.9.3 #切换操作</span><br><span class="line">$ chruby</span><br><span class="line">* ruby-1.9.3-p392  #当前使用的版本</span><br><span class="line">    jruby-1.7.0</span><br><span class="line">    rubinius-2.0.0-rc1</span><br></pre></td></tr></table></figure></li><li><p>智能切换支持<br>让chruby在<code>cd</code>不同项目目录时，自动切换Ruby的当前版本，<code>load auto.sh</code> in <code>~/.bashrc</code> or <code>~/.zshrc</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /usr/local/share/chruby/chruby.sh</span><br><span class="line">source /usr/local/share/chruby/auto.sh</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>OSX does not automatically execute <code>~/.bashrc</code>, instead try adding to <code>/etc/bashrc</code>.</p></blockquote><ol start="4"><li>设置默认的ruby<br>通过设置启动项来设置默认的ruby版本，在 <code>~/.bash_profile</code> or <code>~/.zprofile</code>设置:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chruby ruby-1.9</span><br></pre></td></tr></table></figure></li></ol><p>如果终端已经设置自启动项切换 <code>chruby.sh</code> and/or <code>auto.sh</code> , 只需要在<code>~/</code>目录新建<code>.ruby-version</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ruby-1.9&quot; &gt; ~/.ruby-version</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo做个人Wiki知识管理系统</title>
      <link href="/2018/10/19/hexo/%E7%94%A8Hexo%E5%81%9A%E4%B8%AA%E4%BA%BAWiki%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/19/hexo/%E7%94%A8Hexo%E5%81%9A%E4%B8%AA%E4%BA%BAWiki%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h2><p>知识是自己构建出来的，不是别人灌输的，也不是看了各种资料背住就完了。所谓构建，是指接受信息输入之后，通过信息整理加工，消化转变为自己理解的内容，并分类记录在脑部对应类别的不同层次区域。</p><p>就像一个帝国的建立和发展过程，不断的累积资本，转化为力量。通过知识加工这个二次学习的过程，能让我们更加牢固的记住关键知识和产生更加深入的理解。</p><p>一直希望寻找一种相对优雅、我比较喜欢的方式来做知识管理，帮助知识积累构建；经过尝试了<strong>手写笔记本</strong>、<strong>OneNote</strong> 、 <strong>Evernot</strong>e 、<strong>为知笔记</strong>等之后，最终选择用 <strong>个人 Wiki 系统</strong> 来做自己的知识管理。然而天下 Wiki 千千万，选择困难症患者到底该选哪一种呢？</p><p>我试了时下好几个流行的、推荐者比较多的 Wiki 系统，但是多少都有些小细节让我不是很满意。在我的 Wiki 首页 可以看到我对知识管理和这几个 Wiki 系统的一些简单的看法，以及为此自己开坑了个 Wiki 的轮子。</p><h2 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h2><p>先放上上我经过了这些使用之后，整理出自己对 个人 Wiki 系统的需求：</p><ul><li>界面简洁，排版整齐，有些留白，不要太满 （要求很宽泛）</li><li>部署简单，不需要后台与数据库 （最好静态页面）</li><li>支持多级分类 （满足知识的分类性）</li><li>分类目录可展开和收缩</li><li>展开分类时可直接看到该分类下所有条目</li><li>支持全文搜索</li><li>使用 Markdown 书写</li><li>适合单人的修改与更新内容</li><li>最好支持查看历史版本<br>嗯，所以以上这些也是我自己 Wiki 系统的特性了吧~~</li></ul><p>借用 Hexo 博客系统的框架，仿照 Wikitten 的样式，写了一个针对于个人 Wiki 的主题 <strong><a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">hexo-theme-Wikitten</a></strong>。<br>先放上两个链接：<br>我的个人 Wiki 地址：<a href="https://wiki.zthxxx.me/" target="_blank" rel="noopener">https://wiki.zthxxx.me/</a><br>Wikitten 主题地址：<a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">https://github.com/zthxxx/hexo-theme-Wikitten</a><br>再放一个预览的截图：<br>嘛，样式是跟 victorstanciu 的 Wikitten 一样的（人家有 MIT LICENSE 的，并且我提到时也都有注明出处），之所以选择 Wikitten ，是因为我觉得这个 Wiki 系统最接近我自己对个人 Wiki 的需求，并且样式也很简洁。不过相比起来，代码就完全不一样了；人家是 PHP ，我这是 Hexo 的主题，不需要后台，可以直接挂在 Github Pages 上，省去了服务器；原本只支持搜索标题的，我也给改到支持全文搜索了。<br><a href="https://www.v2ex.com/t/347176" target="_blank" rel="noopener">转</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>同步印象笔记到hexo博客</title>
      <link href="/2018/10/19/hexo/%E5%90%8C%E6%AD%A5%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%88%B0hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/10/19/hexo/%E5%90%8C%E6%AD%A5%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%88%B0hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-everblogjs-everblog-adaptor-hexo-3c081de" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-everblogjs-everblog-adaptor-hexo-3c081de", "everblogjs", "everblog-adaptor-hexo", "3c081de", false);</script><div id="badge-container-everblogjs-everblog-b1832a6" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-everblogjs-everblog-b1832a6", "everblogjs", "everblog", "b1832a6", false);</script><p><a href="https://www.v2ex.com/t/418632" target="_blank" rel="noopener">Everblog ——使用 Evernote 写博客</a><br><a href="https://itgoyo.github.io/8888/08/08/印象笔记-hexo搭建自己的个人博客/" target="_blank" rel="noopener">印象笔记+hexo搭建自己的个人博客</a><br><a href="https://dev.yinxiang.com/doc/articles/dev_tokens.php" target="_blank" rel="noopener">申请印象笔记token</a><br>邮件申请：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">欢迎使用印象笔记开发者Token功能，麻烦你回复这封邮件，在收到你的确认邮件后，我们会为你开启开发者Token权限，谢谢。</span><br><span class="line"></span><br><span class="line">注：回复邮件的邮箱需要和帐户的注册邮箱地址保持一致，如果当前地址不是帐户注册邮箱，建议使用帐户注册邮箱直接发送邮件到 online-help@yinxiang.com ，并说明需要开启Token即可。</span><br></pre></td></tr></table></figure></p><p>使用 Hexo 主题<br>图文步骤如下：<br>在印象笔记操作<br>创建 _config.yml<br>创建一些笔记<br>在hexo中执行<br>运行 DEBUG=* everblog start 构建并打开构建成功后的主页<br>使用 Hexo 主题完整步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-cli -g # 全局安装 hexo-cli</span><br><span class="line">$ hexo init myblog # 初始化一个 hexo 项目</span><br><span class="line">$ cd myblog &amp;&amp; npm i # 安装依赖</span><br><span class="line">$ npm i everblog -g # 全局安装 everblog</span><br><span class="line">$ npm i everblog-adaptor-hexo --save # 在当前 hexo 项目下安装 adaptor</span><br><span class="line">$ echo &quot;module.exports = require(&apos;everblog-adaptor-hexo&apos;)&quot; &gt; index.js # 在当前 hexo 项目下创建 index.js ，引入 adaptor</span><br><span class="line">$ DEBUG=* everblog build # 使用 everblog 构建 hexo 所需文件</span><br><span class="line">$ hexo server # 启动 hexo</span><br><span class="line">$ open http://localhost:4000/ # 浏览器打开博客主页</span><br></pre></td></tr></table></figure></p><p>需要安装node8+<br><a href="https://github.com/everblogjs/everblog/issues/11#issue-371806541" target="_blank" rel="noopener">详见issue-371806541</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何选择人生第一辆车型</title>
      <link href="/2018/10/18/%E6%97%85%E8%A1%8C/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E8%BE%86%E8%BD%A6%E5%9E%8B/"/>
      <url>/2018/10/18/%E6%97%85%E8%A1%8C/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E8%BE%86%E8%BD%A6%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><!--音乐欣赏-->         <div id="aplayer-CeDezPRV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CeDezPRV"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: ".png",              author: "autoplay",              url: "width:70%",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h1 id="掌握状况图解法"><a href="#掌握状况图解法" class="headerlink" title="掌握状况图解法"></a>掌握状况图解法</h1><h2 id="找出相似案例"><a href="#找出相似案例" class="headerlink" title="找出相似案例"></a>找出相似案例</h2><h2 id="找出差异"><a href="#找出差异" class="headerlink" title="找出差异"></a>找出差异</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="检讨对策图解法"><a href="#检讨对策图解法" class="headerlink" title="检讨对策图解法"></a>检讨对策图解法</h1><h2 id="分解要素"><a href="#分解要素" class="headerlink" title="分解要素"></a>分解要素</h2><h2 id="找出相关性"><a href="#找出相关性" class="headerlink" title="找出相关性"></a>找出相关性</h2><h2 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h2><h2 id="检讨对策"><a href="#检讨对策" class="headerlink" title="检讨对策"></a>检讨对策</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在我的插件中配置多种类型菜单的步骤</title>
      <link href="/2018/10/18/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E6%88%91%E7%9A%84%E6%8F%92%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%8F%9C%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
      <url>/2018/10/18/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E6%88%91%E7%9A%84%E6%8F%92%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%8F%9C%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎光顾，输入码阅读" />    <label for="pass">欢迎光顾，输入码阅读</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX184yIHiPDBH49XFAfX7xm3vu7wEsHJSOIeq/5cdxw4CBZeFgTYbsKTwFgL56bfHsOQLqTg0JBLh2PaBqLfRvv4WRJQ92ISTq31SWYDHyFTRdYpIeyf/hEJcom2NR8FQHT4OfF9fN0FF//MnMbcnWT0+U8Dzfj5vlfvfhl0jJRySIT5idYjDIF/ZxkrYkHpREPl+0AJPpbOUIU++JZRUms1fbMuSOr2F7XxZY3e52y+yRxYdpR2fIgF7YQR1T8I1R6BpETzp3LeZnEFQCVJET95UIqgpB7fQNrPs2uwPhy8mFKc6VU9qH3TgWI3+EsxCyQs5XgvXUz00M+pPEkJnkKF9z+y2UKuhENOKgZm6rDXOb7tsVXlJMm9It6FBCrEdGawU/hEAwS36vZfOqNrtqFt9d0uwsF1ChpEvTrTEPLNjUbQ6/XM5z49gy9x5Ka8uJOE9b+XEW+GmYB+1bBFRrXyRc0Y5nilR/5Yx0HMkiHmK66mKFhkD5esYbLVpptRVCC7guKwT23oCQWvuFk0Qk4RFCN7QSMuzADwqN0CENf+lY9XE5FBIPQme5HnZiiQAFjlcFdoDBWf3E05pVHTeX0x26FEImZ5NDb+X0n8lIRfLxCEv1MolQ6b7Dk0fYz/UEcTAKwS+LwpuoebQOVTpworzRxq3i4as4/VF23YOv7+7kOnbJAEuvS5BgsvpzcYfk9S1apszIqGvHkQCkUwPo7vBcxZZ5uuExYKgFR2LCbeft7g+1vdlXBu+sDUEsmQPABjNom1RP4vMpHOGwN/NOih/j2xfmKhdIZNbLUDMcAL1ovhVpxL6jY0SXnFWLVfTeNjKPsuA9sQpI1ntZ25fb51z39swq+/dmIKsQqT9u7aNil7Jzn29LKnUXv6dCkifKbQuWphJgVU4J401xzwkWCItqH7pZ6yaTF8EMZnJviFKo13O252cMMxRAXJU44odN4gT07nc3bavpupg4AnwoLAP53KMZSi4UDRA9/AjVJk+BHrl/fwoLv9VqVlZrd91hOCiIIhZwBpGleZ22xBFuHTLdVSC2FeVmqwlgVYl8k4YWM7LmKBEsFdFlGtMOIlWbrmqZFulqWHiLrZNYd3wWtPFf0M+4+IytOpiN1p3k2/EF6D+RQE5EayNGyRFUBSXeGdfKLjiIl05QgbVS7v0pp5AKTSt120bznmnMO7F60yR6Z2IuyGLyO/AecWYLyuyksBEeEcJKRP2QKQ02UtgRe/72OU8nFbhUrLC2438cDuYphGH8l4qF0VKl5IHpxT8lflRkdtOU8EYSdZcgbG2VNLsVIRqwql5ODigvVpmZAWfSzsrHmz+sBItwx2xhmZCZGW2K5N9rvriX9tbUOegJ4Q/dhyomIBmQV7wvBsE5yKB3IX4OkV9pJoncwIgG/KNvrXjtH6eYN4UwKC284mfddY+ZBpWikn15MpA5AzJj1+9/y1MoUMOlNKqAGiSIkw3hFQkSUO284KL3dirckljknmSNJ65mKl1jVAoKWevHsNLoBIR1wI/ql6uFAhkjtQ4klqbmZg9PIZd/lf2q0hEXsumLwahDQJcZYgyjPk99y4uYBZ/w+ixH0qm2Kw8nmRmlXmZU4VHUBDCLry8IcqQs9JkVAWTgbafEBYJSmJMtZvVRUFYLkzqPlGDVvkZot9sDEOe75slb+vWfMJ70yloqvRa6PyGHnP+W6Zm6q8nN3JxWpoXts3kKIvo8xI37F10LdktRPNwEM+Pt0gjTSAqR3FZFXr5p3bmEGy9cJLWpwUCjBHrCENCTR77bsGkPrMoGoFTxXbg/v2+JSkiGmU2wQsWx/AWkeXJVMVDlS5GROZ3e5yQ82BgL58SlAoDGhWEfT5K9A30E1iUItXU9y7lR7OBAXhzeNKl1ozc6GoRwGDA6Z0O6TUVOW3M5OocgmNhtsQw6kdKkqUZNGyG6TYR2aDxZAzzRQIZtVTVsPcCpQYPjvSB44M2Zm6irF/Mp8eexK5CFNvFdz63c/MhbEiXIsGfVobC7UovgaqJGTp4DBXg/YUhrnNm4On5+E7rHAoKMDXDSsTd0n4iMTpYfhzsy5WvuA7rJMLKiQCmsYgRxsQWNSeInf/hvsPuLSuUuVZwIvB/mkxI3OOXnVdhe6KN6BsHrC0UB0G3/Cywa31cLA/accbJRGmEyalguicpGf5jqJS4iNvLi980xx6PLkP5n8pmTJHwfMOVEtNJYGJbsE1AHfwjlPxqQnlxVI8GoIZzHwDAV5Q3E6kdV0BP9xKC7FNbUvlL9VVYN0jBy7xxyZa5I0GdEgjIsk7bU8nQYmMqwUFnOCmnO5uRpLgL4fZifrOLFz4WOzL54rQ1EcFAz2zwjuphwcUErgpGNzCuJbIyfw8h6eJZb+UORiNo3EWRgYQpHLY2bVcJLfaHjwLElBLdj90+FtU15ZfuAJZlH0mMq7cQfCjdny8x19rDAeEtTAJagdBNuG62CiC80evRErOz3iP5RzHm+TjQ84QEnm9LhAPdKuFHkAbfQAH8NXZ+JecrEysc6knvCATtnYHcCFu/o6S6O97JRrxsatkrhsKixYIgei9hNyscxJ5536St6MdWRBkFAB7b+IwtXMD9GItmQsrV+X5ctysw8I1NOIR7lVoDaZZ6v6nmrYTmKzdkl5uPTeWsXFlsihDw03dKC5VvxWPZ0NpICceisU/fwShHWeF6BjUvfAS4KoIKH9Hnw47CbUmmV9ucYDduS8tj/uPCaNbPEhNHiVxopuAGJUWfOgSNsf3Gb2FWnPmzooVLnLTypCcmChQgpbEhnbJYPuCGljF5rZfEYaKThnRFgDZw4hbNyw5RGF2LC8iH/RRGVvMqfVMRLE16V3Wc/01SLkwUW/jcHc07yFr+tbVAil0diAqAl6I+hNxyheqWMvgay1wrmhxpWGG7Cli4XRngtwPpkE7Xls9LIaaoS5USpEcefIiUBBNfqsCV/IvqG49DC4KrpXi6kpRUWjh3zrpluSapHuSlYnAFR8WJlCiVcMoYEpJiXtAhC0DxWolhoDYIEF8AMzIglnol8chJ+BCvnRxXyAbST1tevArMFaUr83BCKLi95F5k5x5DSMiLImWIGCEQkTzNnZ/5ZZKc4BRZkLsqSWBhuPCnMdyk4xRdwTcmjWRygDR+OZDHS2JLsOtN2LEvnTa95MNo4pR/d95AURL5pxuNHIj/NGUbyls3LRcXYCmbAbD+718C8a/yrjolNgHM/W9EfalavXRC5QPjEMGm0iBLmcl1+JmxKsqt/zHh9a+W6hoQ1UTNTOOniXSsVnrNVQ/LH44lEZYs58twWYQVnHFIymTtt+7M5wIzx7PGOQxbzx9DGu0JkFxvXzUrLI2fSa7N85QGYpyu52NPpskOo/D5g/FNl9aXOiuD2Vnv4FgozNZyMZG+qS0X8465lnqWBaZDgrzuWgvO6VVw2bswjAYdFeDZ0QIgULkrf6+cYDvj5abhcKNpmQ5iraAuxgTNPO4xjkuUZPsx/7JoERDsseSHEZ4kQ2JTxa9Xp7a4UBVy+THUjvbLC6kIhHgCV/Ei1Sqo8mbaJ+kel735xxrgPlSvO+upOGWI6HHx4HZtAwuTKE9tI6dY8UMvfnTcaMoPyHsZou7fWs5t4eWWt6C5/z5LaLcaunSooUkgDA8pgep13m8xC+jx7tNpBJsnRGZStQzCsUVA8vCSc/rcFGZEvvhDwjriPCVW/KyvsnjMA5R41kuRzRxom17N+WwAhs/B8ohw+H9fqGARpJQM1W3XiV2kRNm77+7yB8JpmCbiWOsg4NvfDGoXH11FEOjchi11Ga/0BI5A4ZEDGFcEJK03PDmNsi8AuzEnEptmwIDvXtAwv5i+nJnPUw6Dy2MTZ/oyjQinj6vq8wrdK1XXLSWwp9F3QSNy5At0Hglnsrx9tWsAlJTUBal6Yal/6W/bzH2Ezt1QiY3zX0mrJ6f3S6xFYdl5VywAPJAsI2Xg12kezY/kJOUT6MxUXbbwJvMpweOfX+T5IRdpIp9MwRxK+fvDC1aWVlasnU5j5qX27PsqS+5I6dwBx7tz4i/xY+Kf5g94vmyMDc1EtWxTLR0JldQSUlKSumMKtI2fdokkWEvzEs3XOGLlHxfzrlLouq+z7NW6mAPcKBVKGSKRyCpMJCixx1tauGIuGiNWl5OlgpbXVbYLdQxw1xPWP5MCv8IcBvZHx+kmFLtpVJAq+77HXEDMNIP1r4dXjzlQ0D5wZpdjFccKknv39fobFlcMWtHam12cXPoJfg6XaSaF4DaDkAchPjNI+WTDyHIzB/gw2+tblZ/BYDJENeFCtqnNJ1zy0s06VTtnrDLNwmmmT296rU6p7+Ed9c5I4lb+p6VirJzSJCNAooYTXKkzxDuBYb6JE5xEAIJ4RQfgSHwQJQQzuL+6i5zffoXmYgOooRH+l8pdVdK4is6MnYurC6B5T/4d8kiXbIhsU24e0jGZEI42qUEmoy85h9eNEx7eaS3Dv5kBUX/3awBTsL2X7v8O0Vxv4jERN2XVerxhw2PH94dPxO1dE5PmmBBOanvEPms1bCZjN4Wh8BGagGr63GZf8S/GemE3bKnAVBPwI6Qhq2vmGjTXa8/C5OoazI6Tc2o/k6gH7d6wpihNDRc/1Lwtey/8ZB0UlEbb0QlMfA5EGSPpuLGAnG8Oy3I3FeuwZU1cEvf/6KDK7+94h59Rej7rElJs/Nu9diqds0RKNZvlhSCb6hqLj1ae2BHSkea8btKRaT6cV5g0HXwDkUIwcKoEU7ZhJX6QcnOUx5EnGWv4lzpp4fpc4X/8Jp+MuYZKX94MAMfs0rWjjvlXMYiu2GrKSYwf78XjFr3SHI+audc5P+8z7kbLrUWwqoyfI4GrGeeqKTR+ogN5vCeXtstJi9bdIDXFapU4oDnCJscra4LIQzJaLX67cKEM1VtnciPxa+R18rxUfZpM6FK4h7WYbq3GZsM70beZPPF3wQCzm6oodtUEEoS2z3CovoLNNQE4hvJ2uLWAo2C60AfFMucZtIjPJdLGKAd0XdKV/D0JC8u5PIn8QBhIythzDjuCosQfWJMNgcS7SuClgmw76By0IxT8ZEDO0Ujmst8UP7hV0ymrDhzSZ3t3s3WfJ8LgVZkisSsX95+KfFUbrQmtOkzhmdyIoYXuKInPaCDVDk+ImkUpMcQS4uezDED8KGEC1AmM0Pu+/LGju6vQwdn1S/hy5G2Y/toPfJzgVO5jL0k21P40qgIar1g/1jlH483OPJrbNjRhIkL3bAEP6RgOSaPkfoENRRhqF6+cv0GL0wjDWsw9+6rTQZEJq0+2DhZ/lpyB+bn6WToIlQOvgvjpkK4L7MwrVH+VzEUDdZpXjBv1VikOPEKrg0CdgOYf1EokBWbJ5IeE87TNkV0LXD28vGrLBYynpkzIhr1t+9Ah8NiFpzhWSJV1FnpzbgWVrFhkU5PLFr7jaMLGe8XLt1PWPJUn8vGyd2Jv66fEKSrYFywxKyLIHb3+JTHCtj/Aee7lQTHj/uyrMTFcf9hlJ3aYJH5C7/+Tg+ISxwS+QEnvzAANloyk4vTwqHPdsawbA96piktu5DOU2JPsv8cpzdnvdMgSX9/ATxWP0yeyz/BXlVQT0YTq6m0QrEoiPwLQhRgyuIBpHe6cbtDPsWi2bB/JQXbh2uWx/Pjl9bn3GTcweML35ufy7lOlanFOYgURB18Y48h6SiOt5XzuNsmPOvgWV1YcOAmSepA/Sm+osoWtlKOiF2YyCFLn+c0oXJ5x3rBRuGpRETaQQgrMT8flQKOQv0IcqMGzwknLNaECsS2OoBu3Xracl4i0+etWCjU4cA+jUNMXc7er1zop1jXu8Bd2bGy8vo9N/e4/a7CIyE37C9jA+l/CPQ1RaPymVrqOPGZqSE245NkcetevAOvzKoOaXf6Q0tnn691ZzZcUfMBrAn9euIWK0SzPjRVeKSkmjN6t5uqCWhiPJpZE4AUsmfnoIxbV3MYaPLT8QupsJwiObX80aYvoxFyFcUHsWszTl2HYLR2luplh2/tgEtI3/4Xm9WmRpKdUpBjCzTe/+erhpUoc0noVa6db49mSIBgLihCGEp2EPD7XcT9MU3/bvN+ewJ+GTi9x5TEzY3v1vcasz+2A7ggJ0CtZEjzFEA2XV0jhKwbhQbzFwRuTrrymPLAtjoqrdvJG/DKy9jBn2UZNT2aLBWxgx1P6WPnpegx4lBYdYnbatuXVlC97IQD9ZChh1n6Rw99AMAvrKyfRWRfrAxGpxqgGQihHFSqFgLUG1alVKtwZ4XbSoR1EtTcQNYj4y0upIfB17pU+KhwUOAHYLXY6meE4YMjGvXOgEFoKtREVYIGtbJqZSwPDC8kY2AX8+PqeBzTCsTojJHgkUfyfGgUoGux2LndhcKsx9pM2drajxw1Y//+2Yyf3atas+gBWFwH87Rd47czSI0PIj1X6LGJpNLEeWOjTFs7sgMa7SlEcLGsWYl766dtqUcKWBe+6NGpM1tdFCNucrWlmtbjjYTZerIPCkTwZelPTrXEKADiyxByikFyGMu18D6FDMaO4hemolI+J8mP6v7zsnehbBszBU4OCNd/Gu77KRDs9rqdNS+uK9HNJ8QyUMDlZKSq/WiQ/ct/QwFxZvacs6sQeNaUO1ihIj8nenuYjle9a3+4z2ucdKOpVo76HA80RPOBuC5rMo5r0nQj5TeqrmjsMhTx4S7/2sUHjyORXmYBXbr2SIN4sYLYdHJdtpgRV3pbVBqwY9LDZ6m6VJQPV/Z1ZeHS+svefxWz+USSOMS5PGZxFAPKfqoPONnkcUA3N27619rzSwuJmKgxNG7RkXm+O/DEDE3H2fGiIHt9ZOg9bXptPCHmpK57DMQQFJzuErXVvmfu33ILSnCJS8dCe+JjlsEnfZxqMoygceDdTb9YzDa6RqE5G9voJN6kszo6SOoqjcOT70r+/hSmuxllRV8z0sK6wzsCnxlcAWC+V7xAjU4HjEs00xtQEhouGldpict/at3bz6G/326wbvCzppwhTIA8K8gaWJxfKssU9mgwCplbKhVBx8htp+uBhE5TFgVwuYa9vNnyjc0rLaW6IHvlYD50oQ9TH60HJYDanRQlsmCVDNIBLJearC5EOd9k+D/KW54JQ3BCQAC8uRryj4jcS2mj8k8JVaT6D0YUVRmhf6FZxxpIkb2EuuppEnWXbEBXd6oGzWxffCO7vqSFODNWMtE1DMFzQt95L1JCNxx+gOlFbbN/syL6qxlWQ6zi79A0yOhJgMyNfQXWy/hBxiHwgjVV6njEvxVl2wRuk9yDzDB612SACtd/zpbyrMnrOYw3nP/nfj+74tyEGsm6k05HSw3vu+WlJ0Fxxi9aoIoTZ0XyHiG/L0K8ARqL8XRJ96EgJ3dvevP1ovr6PQqaGGp3rVV/c90lnGgn+qRtwaDObP2kdxQH/uJ7KC1OPbJJyLUfO5/EMnyBRwxdWKrpzZxWagxqw7LtSsTNMSAJoC6+skAKyPySBXdR94yvSsTLaxoCjw7LrcXBoQ2qatIsNG2/MYfwZs1YJHA0xkh8BviffX9GbAX1GnPBzCqoEH57PdVpNF9Hvntm9wr2jzdGqr9vVJE8cY5F15aqXqPvT/vWVdZP3o38a1JmRIQ6kHdXMyzPqVEYqwMVBRM0AfdBFialEwqoIoU8dZXn8XLy0jIEvXHyRFKWZIstLmWubp35Ez0g4X8JNp0r6YF8lkuO/oAnfOMGz3NXySQ5ExtW7XP5g94We2VDP/ay77VuhMunnBjUXQ53zxqNhRgdGELpHisTf7Gmxz9eKRgcuE1i0R04ZUyumS9KsYLemaNXlxdKGk/y5smi78lKuJ4BG9APoOCX+AdHjQ8o5rAEClZGiT8G2oDVaHN0U5I4oC1U3+4zJss7jd9cq1ul3AE+w5MxgUrDPdH9CrfP1AORn+0kOKqLds5fiKqqR6FfZp3QW2mcxrzq/l5umQFy62FkzaIXlanZ9birCOZQdfre4EeekMHnmV/I+h9C0N/vRNMra4sst94yfiE4neqaIhoJMZRqHpaXncbrIkPb1nfA79yXgYfqwZYMlX5lZ6a4dDmnJmuBSxYPUXNgkgkpSYYvo6Ilv0+Zpa0Wa+v96riwQpUqznRHERe9JpR7QrsIWJ7H1L7Wv/JcBosFqOG+xWBFlqCxrWpmDPpzdQdGwPlNu2Ayzi2YtEBL9tqCGBvvBx3Mo55k6snI409gsl1irn4NvJllGB/zAxf95WtnqFnIGHSalpryBWmaeTTNsq5BirnR3eSGn4nlPUhTC8sCX5WavrTn6bBecWqogLX+gRcwohjLNY/8sgmy+0jWzEoQLQvotvuSJTZ2+eEWlASdW/2Bew/njHZ8/d7Kmr1J6ANDY7xnZ9HG38UgHX3UUznKcJyrdv6dviNCsGPyH140IPCEyKWpD2LMdbRXrytRSP2J1iO3d6kOLPceMSUuEFoQ6aCo1GmwYIz0E1yKLfeZwx6tM9ZqBRzptTGEtXOkPrBb5NRM5xJY8xb9Mo3Pje+ntM3wMIeP4Arph99ZhQ5sUPQuxWApN2ffBiis1hLabNqctdyLpfOxY2lp0mQkSfF2fWGWenO17nB+xxak6RIEeCNVroRQI4kzknumdhRXqCHpEXw4Qer70TA8zvpuXT8XuIie1IQV9+Bk+h8AuFVcGereyDBDAsSFJB9nHqcoJO44V1snz/cKnQDNfrruknHEypR1uPZvPK5QnZvkeQfp3wb8eCEiBHcU007Ms5rAzNFerg2cVF3jrV42xPAJj2a+8S+UmfvSTrLXR+5nQBKBeVx7tcH1YOWRqKfgYw+JRqwGZrFrvBr8VQLv9hbTB+hCRRkCnMfSQG0gaRLnHLcG5gU4ecfkvlbKwytAWjdg73xGGt0pFt3eZ5hRCDMStScyl6eqAyFDzuSYvTkc0UHvpsoaNRMmma9QMSKdoBoiMNQInK9U0h9WlhlmCRDLQlUYex9VSJHRI0TzzLXXb2ySskFBPG5MObC0u/auR/DNrulb5NleAgUYfzEdaJzhkly5XOqeIgJFkQDRvlCKLAcFR+iEgMnNR/fE39PO/mg0PAebN37nrcrI8zB9vD8Iww1IFNE2gTaWcfBpYyODtAZZ+jEgOvU3Iv+5vi7rv8LSPKzJwUXbl/YtwYI9PmW3uhqyQmHUImvdbjXZ0vQjCagUOeHIwB8KEPcVqQMEtEafFgtG4LefAaOB4ktKxkhfbh2kp6cuDA9W49UmybgQZPrI/yrmu5869ZZ1fIY3S1nk9l2L1uM4CKYx5YcxVTnRhSwUTYqejdemIRsZsTAc6FjYRK/7qgBh2uFlhKRgYtx15yhbm33qsSQC7ho5fDtOcDLaLinHodRRkJNsBW88ghIKnTwdRxTAN7NzyDu4eofjsblA4fyM64/PQVsnGp8soYKzfOCo7G5t3fHi5cGzTzkKz89QmHc47RU3MpkrwFHjkJjk59fJpBE0O2pWgfBw/x4hAn5mqskFFyDUCDhS7fRmjCAACvVoK6rxa03LU2zcdYl/pIS6RCwb3lnDPB5Ce0eRfG7r7b57zl9zJl0qSegKmDLc4zY92sgjSKQji//9YQgOfclPsbhQWaD9gOPEndE5AIBrUGki96Q7ZSy0Re/p2Dr6oxDgjxVa4kh+OA3QKbd7ewPog9VwiUpxom9Cnr9ZdvMihhFmsJ2ZluJssziH5DrCvWvsLLuaXITpavlrBIlNp2lMggUTv8dTXkLKEZWHk0W82ZAwMMDsH9DDefSTK9hJJhj0Ath1A0V2ndfpPvX9omrW2aqDIPBidpX5AshuNaHPzuSwumrQsSrbcR55eO1NHpYQ4PWJVlT6WMKVxcppH/BKuzwYgeKssSnDiqVAblvXDdB1nPic+Ee9kfmvVRKlKjXgcqoFkyTaMUCqHORgCG4PlRe5+ojF1chcz9RFFCBRxpFb2MYR/XXCrSMEHFh4gv0Rj1Y6NC7JjnLCIfT5p0JkeVb4dpiqwuS0EYKkzdsDGI1fGu1ri3mouUfqb8pyZkVAs3/lSUaLDx7N8yQpruk4m7apxHa1iEFdUr9N4QmWaLwGg0fqioVeq647xkDlNfutYQPa+80u1vQsyWSWNz2+yvW/bauoZsHUdQrIPYlfB9/QXvL3CAxcgRfu573iQmFP1ULO7S3fbTztQYGz4FPm+TPUtLIxXEtO66Sr/CvXRW02JDj9I4pfhYcB2mk53YH8mqu+ychZPYnl3P2mg+4pbo8z1ix1bL+U1KP9xCuWxv5/Hc6ay77KRMoxI4yA6CaBm1cxQdf+Ng+jg2mERpp15PamQjtMlm8fJngBuoQQ3AWyQFdmQ5oCYv/Jl9uELZVzMh/812Pld3XD/8RC/bX3NZO9P/7++jv8BcJTjCpBAPx6t5EQNxssVIepdWqOwA0CBDWV356BVP1QMS0SSUaWo0ofUihvmhRe+kn74AyyHtRalHujwN8mCZ4GmZkyMSllB7dg9aWwnvh6PXoNKjRvqL31NB/J6i52qK316RV+9E8lRiYqMjSXpWzctsnLw+uG+WU/xUNu9W1O8nMS6Iut5n4J/9/9p1C5njDE9ZiX4fiqCLkKjxCc0Gmmqjdx+zc7j88+PVM3Cv2shpCKJhEgUZjk2v7JdUg/7fBF9/S5Wgnwq+vT9GNSu01htNytidgXIm5XNlsHAgiHHFoOlJ9eadf1MsvDQMj8VhTacBHnutxw6oTP4OXSJALOExPQ0f2L3eRgjJDYKqKCSTmwEC2x6J0ca/rz/CY73PEMu5F/0LFM1LEqRysdrr5RR8ifm0XJdBCIsjTGQZnAmolfqyP6T7PARmLRDZeOmbk6IJGsphA1Z1pDGsNg0dtcix/4uzzyHzwjut/uoUMoTMvuyt1JJsO6EVDue7FKEWVSGi6aUuso28CHZg+SfRoIu/nudeGM4Gc65yCBNSvtnEtwNA2nEW9jXlcmgQM417tItlYbFoaqK1qR7r90u0KiTyHaAo652pc0NP5jgvy1imTe0kU2IRZDO13QqZ8+1P6C4K4OcRVzJ5YaPlY18a495QgzZ745QRVhBGxky4n8eW9kJds8EThd6gxPGkeUQqiEMIky5MTNhRArXj69F40sQ9/NqbIPnHdLPeHbx7eg1z48NxBHcJer6hOSWv/E6SOtWmOB3oYjwz3LdVA4NOtzA7FhKIgWLZKjgntknJ+5Qc64WzfCBwT3LvgpdxI4l3IKM9AnATZegq8L0rtbpwPkFpHGHFSuW/ZWxMrLGeNFM/UmYPuZxb6oe/HS+QEDNjFYl28c0ikQCyfeBGgGsT4aKslDhMw/yv+RH1OEtayZB1ldFviGLvH78KLfIxytYsyD9rDE/UkAa/KudatfD5wF+AHFDj5JRHhX3Mf41UjmrGnZhsMaVo0wxreehFus57i8bHOhhFtU7GdXIzk98xiXQctuAmnvYg5kEbpbiWRO71F1xLsk2CK+Qo9w5ZYmvm2xlChkhnxH1o/kUIh58IFkCdVsXK4+audFZn1B4sBhuA9EV9rHMvbT+JqIDXh/7nMvBQxcSf83mpE3w6idxRc6H44qIIZReGnqUxry0iCq4C6SUTpEKODOJejSO0DyNYXifjmJ0i701wGft+9u0PaWL1GOFo3upf36qg4jRbk186wJun8sLEzb0trqIerjmxKu6eLT/tbuuf4RMeIPjXsCUSsoTOprCWmkwjg/Il+z1Gy/e63LoGrOZIL/rq8hlf4xCGwXFY5md7tMKAKp9d/C9S37Jb3zCTiv58S7MebAeD3ozria6WHt8TS4hQJ8S2bKo4DU999mYbAicXaCQl/VImfp/ObT0k9gwH1yIV7GaUteKa2PyyShDTAkeMqXKO7KeMXZHzqlDAr+Syv8ANyGmLK+VqJlxmKuWa8mw/CWzrZYp90P8xzrvP6BctHV8HhgNEj965SzPAqyvyrOiPg3OH4VyCCFBEeYAgXZzuz92sFHFUKldPYnnPF4qsmv3Jpunvw9IxAPQEMj/e4/TRZlYaP8l9lsUwwQpnNcxZqILaTcuA0oADwmyB1gZray/OPpMsk6ocFxgTU5X3opllfupxEYYjEx9Qmv4B3kOMFYhawDhPPajUeL5v8fxU13zuA/6B1ubsvs1FAdy6cs0xrenE3EUekFUxKlM5ur74dN5o5dnBfxJBV0JUlvofqvMZApnFzTm+GRtlk0rMX+8Cf2daDjYoX0eN03WrQxStdZhtoVvoZzXKxfh5KEebSs4zrt1mfVhC9CbDgvY0xfzLsL6LTbTk5lzxKdGZ1VPekHEiZuXmkZ58bWX/6xyUyomHPxcBZdvN04FEALibVtkK2+pnldcBrP1nyv97bE/soN0DC9Cu84iuZ0flM0pk6I9s2Df6SzEeYh4VuNBQbU5ywKlhqhDtNVkCo0Au4DWcO4Q6LqgTyOy9VFHqfIvrBf2kcyp36fZjq1l2uwjMRmeG0uhMhlqNHEFe1Od26ZjGNpWYYGzvgM1tWZi3XblyoVXJTrx8FTVSRK+e5aiznRevbUdh+DRgPNMRaOpPvZvN2t7UN8QfeBbwEic2VFtLDKN9Sm1+DulIFkgDFyDa7n2sEivTVuvCGvk063+X2rPIV4+TQ2VgPLC3fA9X21RNJxxrTo9pi41ZCPMRuHZQwMRqJyt+RlnsGjDD79Gvi1nxQybXYSXX3GILmI1bzmJ/CAK+sqW5fIr9nGcQy9uPbPJIzoCfU0hgRaFAxUcR9ANb8gXvYVXX9REE1GDN1Ryz5CcTszDm4a7ZGT2MwuJlNXy6gC3DmVSHyoERtqkNV+1+A9FNABvBNw+/cTfHJKL973FcUYCmFuHhi4HQS/2UkyVg8rob95UAbWLtDZ9J5l5FsJ8kB3qYJcYbra57jq1X0RgDXCfVS+8gqJKwdYkmM5lDhCezxE4IoyVPOoEfLZa8uMztAvmBhP3g/ez0pt4FvbMHeneAZ04GDl3oCivuBdcD6WiPSPbuJT4Xjpq+bwexsHdoGQTYSl/9b8BTLXQLHuPxFI+N10q9h+4PWo/Bb8dHAWFl8rmNS/aLOFhMbRPHv/2bahXH77rpZ6mr9nfCd+AeIW2l8C3NbSBKQRMVDCAayqBjwFzC+jVNJgWf5NmU+6+0nSsgjiAc3z6gRgIC1CZpX4Y/TXt2IQ4joSR5d/jTIfrS1uajdspMQhR+2IZ6i+F3Be57fuwSaCPfYdAVHeYFLIv4ilh+4MfKIaZr+zkUAY5I2QI59e07z0q9v6as72RoR2OKctYVHEJLIIvixadaWPGcZ5wyh/CedwhPXwK6u55LJoGHys9QooROJ7m5xlEaBbrBwNCRwu2o8oif3CqiLZkOal2O7rqAQpkC/Ff8ttJ+qvk0K++zmhyPrMX1DgtEXJyP1k/SPmvHcDMHtbneKYp8t2pHp6wwrHe5jdttoES1os3H779P3KIc4NKzfZIHqydVHUBHYLEJsliURfbtHSHAr3Zmd0GfhUdIa4CeThFsII/bl1qvAE/ic8l6KjemMcuZ3+xI5riGtTC8z+35kfxrk76ELl6z8kSPQS6ulF020voqSFs5Z1vR0I4Ilvv9CRIg5sk/IyjT1tbFcnGenzy6d5DuoWEEbBbVdQlrMmzYk1OiODA5fwPfUXf+BZh5MhboRN0+6/UUUgcbGw0OHyc23zL8hCM35fdmKAc5diVU8t/6q4DRqL8GyAG4j+ZPOShl+gdEFu8YdATI/gkjbdQaFdZVJrzEGC0t8oBzbU9NLT9R32kZmkTl/uaqLdMlXoKHQB0LJOb6V56xvaBS20Fkal8JGBmav6xxOil9+xAaBRSh6NPSgy/7LiNIVtC/KjENTfszKG7i+zRZ8zNEXlg/XTiupFVPzNr9exW6Q2zrh9eVD1eBRULIwG6yM0VMw+Z+xcOeytTZw0rXdAVmI2rXxWhjr0qGQ24PnPuen18ccco4bzBjQSWyyMqh1wVYgJnWo1SYqStNlT/p/lBOKh2UJYdTc75RzEHBhjuEZ+G+yDEJhjWwPDM55hD/Bj+wTAbcMwMqxOQ9rznuku/14Lp50akjClQ4jMiNSCkDuUk1p7CptK0EZC1J8MseouARbjB3D64q6oth4+HzQsarWfB9tUZsAOwcZMXM5BeWbfuw60rZHsoZFggvglEuj4GLrhfUdRLIcifUGHKVZjCxEnlwqrr35L59yEpJDFHUwRTBvfC+xUVpYU5AuL+60jDphltzltUc58jmW0pDF9B4uLVPN6XOYFslm7xXaZrYnVnx3Xw+BceH63z770f5hNozoN2zt29U4PNCFHyAQUnleJ9njMButa+H2MMVsSjxns70UL46W5kvvZKRWSl0q6d/osxU2lst11qkO/sLwajn/nmO/nlA8q55635yYB38EhsRf0V/qCa4K3SwKqmyGpW37PmDbrXCVxs66qCQJ+8hvAVhJig7v8Uy06e/OPpKTNAO9gYl+qoTCdjda6/IrAdbnbo0NP6NKCLr0CdEDnySwh7GVkMK77pu4CDjVtczXdU9gH5j63xd+C1ZVOcTZFCduRADZaywmQe1ShPSqLe8i1zarr9iEFDPfZSvBuAUg5STxMZ1ncoHPpZhLHCurDwQSrtsziyIq4aphbXRjkdh+lIoga7eX60c3DMwjtxvIOmkH7j80BRFZU/62/0pmPM4isWukXUmDhnst6QSmlFDqTYOMuUY4lDkffU5XJyW3V+G4nhBq1HON1M/A0qH2mel5mZA8DVnJ4h3t81jCiO0HSXCqmeVFRaXyo47/Nu06phsGqhAH/CBT6Y+Yelfn1WP8FFdxi/gFmvkuH4EI2aDA0oZ+QHmFYcBx3HtJWUh/lWyJ2tTGf+VVq60EZd7R6TmV5YJgYO1km9J3gJ30SpYFhO7pNz/LDSBCX6YUeiGutj95bdlQynivC19QYY0MMkOloIf0WYDWmbf3wWEAViFCbJVsxzlWzfmWr+KLLKvCneCvLYmBp/kfv/4j2o5ceCtKHl5+zuHNc07FfymjExj2l+VDZlTa9xzolU3X4AOlH57e/T8PiyEcsQxUsQ9Am34fdjIuY6EXOTHmiwCFjHtcwrceJ8RZar/q8ylSLF6QI+s6/PiVFHXDwIZCIQcrj39FikGI5Q8tO+B0FxZuQTkYbrTI2N/VvH1iiuOabOXn8yT5f9XzwT5A4Zbntj7Abhf53NEB17PbSQ+Jtxq9gtM2j/wRfPOSKoC9WbxMwoWoMo7zDZMwzSl454shx4w7LS8HBST/o+BGaPlZWaDRdiBgLa/he2gpAOi30+Ns2QCycI+khJHFCb1kCBJCc1uIDcSYlRSQ5rYv3aKjrSouOJieOAqiL3cyqnmyUKAYe5s5cDmvsZVOYBJ3DXvgJ0c+rNrj6gSjaOe1rmh80XT3QtG1H9um5Y9QJtq8LOmy4un2ku7WGplOnAfI++oSlhIKhcCU/aclnv0PiDnS4lHwGCmf3XB87pvPLhPDCreCxWm7LBrc0dPlQ6A+B8hlSGU6FHQeCkcpn4/GO0DpKbRKhMNDG2XPSyQuhCGXxMzEyLTEGp3alWaIH8C31n+ausdSKtsjR4PnPmpqXetgTvzoo5OFU4BwIwjq24edhX6btJ+pBrIHHBltBV4ReNiRLHFGS1MuigFj1tfdBplaCtERYB5qMemkJqZGm65HsSpb8Eyw6YEOlrFWtVq1dWQ79dUwACLicz2ykJMYRuCjWdssB8yNEE13PLI6PyksPXp1F8wCD/dTZEKhUjBywAwwbvfAgv5vTABS01Sei8JQ9AnLRpoBQr6bCVeJt+XvD+NFw2Sq/hcH2rfP/33WG+aRSJt/W7ZI9EFCdbcWOJDsv9nQKt1IQbaC20IEoad78drbmoS38ROL432CvHJr1wL/yv4jJ0hT4MsGFzF+vKgGIKjNRdqtAPtm3371zLDWJzP3rmlBe7VcAnJaknE8ogefA+/cWRUo3twOrcjbzaZ6UnGUCfnlj6+fPmILd9QtNoYZPX6FyjI0ZTrjwMMLHyXSRgrurMPRoYh1NR9p3szvIhR/Qaq1cgL14jfmFGlkI1TXMCJ2JyRI9h/r/QpLHO0X6WiJC9Ws7MuTY2qKGJr+rDaixJQrme2oaP+RHcQ86SkmGBkRkUEkzxp6AZVLVpN1XBBSXbZIHEWM46hPW6wJCJpCbTC+P7Oaolcqsk0bNNDGjGXpS0V40UKPF5w1WEEL86LeOAuu1EbgMfAg7uBWJ2OIZppiSSVgd+ZosPxdS90WZCyYCyQEGjp0sHNri2Q5F0zMGXVPl8cscF4q15mY5/K6meP3CurzjNJ5E9yuwBH6jEeC6lNcH86Z+u311G4gmuEsLo7VTU+wJ/XvP3NiqTFMYRxm90MSdlJJt3py+p4r8l2UrRKAQP7Z3GurN+y/8eYbfVNtqWdGzczgnBfq8Sis4TMm3q1O+6RhYoIYvGi5kKMEW9vxF1eSNdZjRq7VfV6bh+kIWh4oj5p+BzqGKZMsXAS8zms6bTW6FHIz8f1LVgQItUbhJqicxFo+oM5RU8CD3y0GZSCaXai8GEVehBPWGCPNVz1agJt82tASvSDIIYUcRb3AypUb4Xz9H8RXXDbqGXPFjHCKLVWRhF6y3waoyZOruioZ3oKiYH4W/Ku5kH4JJrB431qQUsMuXzfETPC3zOCMvNpTr77r11Nho8azJtdq/t+zi3I4pmHvXXcNCwFM7A5gduBcGwHNs7k5MCvVtFcDi0nd/hWOtPyEWAZDT0PUlcggciNneeuMfSZM+FUqm2mj/0pNP5euMt9vIh8xQzkD/ZkdWGtJsdgDpwJ9bPpYfKkdTW5UwiLuDm7aDwPlfSpspGqA3ZFybCm7u63rwby3LcCIbwcqmxOJj5nXkBejWCF/VozfHyPwTezkb9SvWlyF1WmGAaR9uWbBmVXv8AS3rtM6iGs85a3GU2G1WL1LDIq2y4RDfrwaw/7qIXGCYUmkv0g8Rw2rDZylVqyIIQlVM2WQSCc0HQLiCCUH0yLwQk9YFpPe/fxWECb/YQa28wJcqhTa38mQ3RgYc6fhd6uonCGwRa12r7iCrWaWWb5PExeQ+AeBXdYc23Q9znMcRaFptvshh22axkXfAuQ6PrLqvezM4mNSsKG312wN+qV4Z3tT+Bgfd/aDcry2ASW/Vl3roVMGfSiZule7rUzr7rIDY5h73/9+XXVyewOIaYSgKpQ9ngFop6Kq7QdzsyNysfnfwdAAs70IAJzS9D32PEUspv4x9BzQ7cyi0KFon23hrYooFOtWPZDUOaAUDlvI2WoGU5RBLvdTVzuzoE/XCXjN2GpN9Po5alfazP8oe9ujjPV3PaUjXRtd9o7knYvhoxVjk2o+THcHuzl9ktN/KGd9E+6teq1M0NZz28iiTtbp+q/kmyQnDIbNHuFssE63b7u0t80Jt7al+wRfMQONkcQOb8gLOzEHP/fqEqgk1JvP2tyiRgPdu73V39g8rs2TiEvKLngN57nDrGhVhCnbSF0DBzCRBGy/6pui48jk305QLMJ4unw/wjukHx3Lkk880vZCxbb0vClRO6D2PXdBIK6nJU3KjvRc7NkI+6Nr4IBMzzj/tHwkXsAOpxq+eeUdXueH7tmljcGkL58EbDmsge/34BGRqX9j6ubyE/DLRoTkz7t9ACMNBMrAEDjgfEBaz3lDHN8mIXlBds+Mbr1Iz5QMnLncprUqWGwy6I4oAGHkM3/TEW5koKKd/hHwQAMBFDexLMEqNm1pOlAtnzERXgptGs9FKaekUcpEvweOOj4vYq+L/BSqx69meSlb2e68AHhgLFN+b2NxLkO6tF5+ubeCLOjnWXaWMtX28s6BkkgvtFcTmTkmHG/tM8eod4tfi7nV3lobVvUJyeSHvv7UDHzsrSLLIP2dK0/uwA+NBdjBB/FxiKzj3Spd1nCMYvYzoJn7A8R9iQsHIQE1SiA/DDXpBZ2N/GOf1r6zsBySjJuNNQui8tuqWbsdJhjy2I5kRLkg0efBBRXGtKeEaaPMUOeqfu56XJdwI4PKktntmdsD30y4Acl/3jaFBg7154EvZSnvFBsAnHzLb2bjgCULO8zKtqZVJbY+/rUuV9NQd7axUY0iE/vWrTjq9nNxDYduOuhEYCzsMp21WyJLCmTcYohW8l3upzU6twT+c313cOxKzaW1v/JNUYyGpHpDSeJlqryUOHu+G7omOZNK/gVurIF0dAvtxQ0c5ezvXvb7hhvKoa0ahTYC/rV3z4MP9GC5QIVIStKLKwFYoPKv6InIxxwdxqyZmeKOR6Y7rYXO5dPUGX2fEDgGP1bEjHRv/79+hJfJvq2oMuTGcqws48jPCl5F91ldMfMOagaRigoJ0nGpV8u3XA/96Rjc2Twu5U7bOiJqRLy6h9T13ZD0sjiapDt6YHnZoiI9TH4OTHz1bZbFhknLgmETLDliwVGabBx6/r7S613BotcdWa+1cAQq7hKHM1ztzcE5JbraAM7sMxhftVeazI3Ny11MVkp5GcVAMSzyxFmLZTW50bGvBxlcQDEldys38O+qZgo15/6U28UGDfgILnEN0xCeCRz+0yCx7664y24TVSKfAcjL5F6WxIRsnI+OP71nty2k8j8QrsAguTJFx+iQo/rR842mu2KsqfJCDDapcSk1oLc/z7oWdeoqIXoWjjuJUfLMAlTkSgktjjFoJ/A2CdKMsjinKoZeZp2X3cjWTq6r1i6KHe/lgYXy0G0YkS4+8WSCLNzZToHKzB5TQRb0BsmmCGpTexa12Uf+g35zoyPhQ2TtGjuAOBM7viJ6mDMCOkwaFMWduc+taKAPyMSAfHFiA5YZCEul/fkTXEoOpqZzk4PCCppvhhpcuejC395CPst+SagYvwVhUE6gzJxmWV6I3PG1pVp7wuF20BP+6eFGCkph1CHd32FgQHS4DCtAh3OSNNDDpbhsLwCEVLYt9glPu2R5zagnhyOW9nBpwWniyHoGkt/LoZUCgev3KkSEbo2MFJWfhW8S+5Cu6EfB7Ox1k7Y44cjTrBfqUa+tWzwzBeXuSe4mj2XnetdiKvC3hf13Axi/KXCxtZJ74YHdUXFXVZnAItOgT9HhVZ8+DzVSyoR2k5TvEIUn1IUQA254nZhium7w5+3ZAjUvRioZs37Rt5+Ra+i2xELb9+DDfv2l7qdvdJWXpGbessDYr3qa5YXDuVjRZzfvOcZrU4HwOaGiEitKc5Uq+x+fwSpZwjwvv8kUuor6QlNlcZQcmyBtIlQZL5BhO/hJ2boUBee1YPW9/87Zjs2zjAJok6RiP8E1OBsBVw0fypjjPhGcCusDUM1pN9Kv4yJp/cgrpYBtT7coDCsIgQYS1ZA13UIYOnui3iajS1E6TWs2fX/VYTEFaBwXmdcYHG/aosPnD271kVxN5Lnoz6Bawio6+x6DreLc+SDCx8jI85nduyn4SZDTOkzOcRK7e5SE7C2gia89tiHZ4OmAmEQq/zvYsglQ9xCVa6VgT4S/F0AH1Pu507lXOlGpKqPUvmEWAkOTC7mjbnOjAWs57HPfhqiBVYjAXbhXevKae4/KrLYd8WhVnD3zWLP82f/Ju6wqjh5i094HNOerfokge30sLPfW0sSQ8swyGn8ZbZvkT1y8d6Jf2cfnDv6aRuwiC/osFHF9YCEXYfJRXMvO5mqSOEZ5A5KB/p8kS3KMEBO0Zgy2GufKG38zJ6DwZDxZyJCyj8ae+vsDADwZdBdiSL4JVVJNy81JSoFZY3Wgx92qETN8S8Ftq8D45tUkQYULVklk/Yfzyi0ZjHnS/7u9ZoZ3mDtazwW+nqxwyJX+lGb80PpuTXxpXYFQgJQu6Ae7QBUK0ikchn5yBDbzaMhRS4dmq3LD9XA4GulMB8ylEKQ1E7Q4J8GeVSXPPOs5MdQO54X58cIPYtfbQXZOj2HHFgTGQbB/xAU5D26aWebUo1u9d9ggQF1DgvKoOfAxQqQmwF9TCc64BJAOdQ8EdEzhuFe+xQS6JVMXBWoq3DjEylU6QsdlQfRKJL5JULUlIeSwrKcDuYG1OxtIjJjUF06/3zVp+97hE7wsliut5Y4DO7LxfKv/4xKk3EoUHOO8bACmQ8UtFg421SXKtb1O4DzwtdXIDcn9HpqhFsnZskH5RI0aLX7oX+lDsl3Smg0mtUonuSbh9pZqiAAwCIMHzJF09YXQx6y1Ho++28el0aJ5AJAW70g2nZ0VWclXEUtj2k9clgVJmkGQmRvoYkeGH7XdPYjpl+cabu54X0nmPP5sc7Y9IjHll+AWASADaYMzlbc193u+wl5+cm51HRD1F8KdbYDZLcYL1jzY2pkuCZ1+1L9+rnaK6DaNxpJJA5qBRk+7LAxLX7IBxfalweCLsaMq2wb9enjd9ijWgEZin29AnUX/onjbph12nDmDdSMie68XUyIpsOBQfc9viUiN0kwFHeH66DY52UhVKMTl+0AgUQ9ZOHzFw1V+hN/FVpXKt1cpMjDFRa3uxRCoSrK+BcUImFWu7ElMmvuRZlcvxUzMXKQYX2uAntUSBUDZfGbXef5Rkm3pqkAVDGHmZU3mikJogu5CHf19vuph6zd/4jffO/3m1OXEIbAcpU6MMga2XWujg3sgnbSAskCYRyJUTuMmdr2YKRt9BlUQo42+zmUFzkiJFUxBlvnS9n435IG8sKbfEvPhFLFiPUmcGHGxeAI7k0lkYaVdg+fxiNcQVptutDK3fUOpesFzIuR4wytDJQ4f9C5NxKjxn4BpiN1EU8nu2P7Iizv8I3q2CnX+8Yz4W2/7yPNcKtcwBkNcwPtOQNycU9v9WhaAqRm24Cdo9owDygkjLmdngtvcHs8AaRchVpbIai9EKagi7zfIVZhEF8HaXTkckMoXQiOynYVmBhyDpbUkUdWuSGdAAEc+3ccqV6j4boCZJkkLvijXssn6JpjNeLqTEhCbno8RL4lF2aWbH8mKbG4rW1wJ9AITn21QYtXQ8ByYvBGwLx9fFdd8AB1Ca1NlUIRMp4UxHuFdEpOE82r8wV/cb6EnP8dNE+rAMTu66Fxz+ZkfnPegSF+qWr+q5bEhzQ6fnqQxPeIJWXQ8PmeHRS2nApOBLw/KiarsP3UhaaAXn41TrvGmpt3wspFUw69GCDNMrOWD3C3AJt6TxHirB25D9xB8LpYiktydoTEvkCjPV/CxHHiG8e7Niy/Bh0hoVyDIUNCpFtDW7LZnHVXAxBWF7igW0RFZKTy1KDujg13JlBeYad7jgg4OWRbaTd7Ptr2LOy8EgxJ0s+NjT4f3yxwCIFgDIel7dM+9NPDl6T1khXi23jQQ4g0IvV4UPfbwCPDR1x8AKjT1GABSqiz8CIVsJFNVy+9rttm9aYJ3lMt2HGN1ovKErmWuQQujRBDDBFGGIwjL6TnCSbXlC1INeY0p3aJL83TayCawi5TE+d68uxgGOrY6vwe++k0YHlPjoEItYySgoWHQGXj0ZLHoPbADlV9iI/5Y4ZJFd58EQ0KboNYIsCyeQIDPW8e/v2WL8XVxoBXXlFT2nQEazstzkTc+zPbJiNfiNrvIsctapmF7AbR5kJJ7ED45JBKCTlqTzF5MLdhsRsYXbLqY0qHWV0Hs/i9EwQzs1vn0Ckt7AAP2yI/+ZdfYGug8l1GudotvmaB727IYsyDT1U9EHpSlFHFPh/IqAauFf1m3eg7HoNz28q2KIcGK8X9k6ev9xsiZIrqu4IbZkuIscciPNp37xvGb+u50pe6XUe7UavO92LCrBwbhph8QOEwgREwnJtFnSD//SHU/H3MwIpEzqX+x3dXsJL3J4lOhX3YEU/WUPOSG6GgoG0I7kFgnYoSXQk0JSz+tdllJoAz9s95U2j8n7Ds0oI95+U9jASM+lsLJeGpxFWL+7Fec0W57bvjlcCjjiyLICiyCaeiYQ9i6I0qzkp3IC7FENGEPM+xvNtmHe9FH0nR4y5YQuS6vu0C/o3wms250W+xTq4QMUsnwc6P3M1vAJo1mDNZr8KAeDtZjee3DF406jRwQasmTudjpJB5soj8tk6k/A9FuyyGyxfiMGdz46Rld3YtkPZBKKUmY4PUJ0J91cRhKCtuDwNDJthlplERu5IaqVP657e0FTEbabbAJS9C9pNCUG1I5XgRruQU1l+oWa+i5BFqUNy6IAXXKSOPKoJ+GNqtrWQLS/PAKzKLylEnnvdwwqeXHfW00fGB9o49Lz8Zl8LupHOMhP3MlCwfMcVaZV2ENk1gQHchQ68d/P7zXWP+gySEpp+3RyqbRspEAPNYaKdzEKFG9sNqxR/0DErVgo+JSwck9T1AssuK30DfWQMBskAZ6QM1GTsjZqwehTBOWcbPvqgcUN3G1J+L9nOgAnbTny2WEuslPo3vUNrhNCMMLuLAjO0G7EV86KMLmBbelOPzrT3rGeiCFF4nQo68FEfCi3E8KoPQCnBPmWgDygVmTDSpYkrFFIMRqVJVwMI26iEJnfAyluF9wQi2+tXs0XKw9cOSE/toSrHXzKY+e6KUCPeYV8Z+9DRZPkVYrbvi6IDf1kEmUhXibpHXtb50JgjWrdH1o0E7M9nl9XHl8HZxwcQnnNb4IAtMrENll5QUl5Puyxi5c8nHlQkWAzg+H9/DzpNjJp2bIjJoH4gGJnNoMWXiJ3nO5kDjT3iGXCA0W1FJ2yiDDn8FQX+WagJb1qWc1drWQHnPXiCecrmNqEoCHIZGcxKpk2YoLN3bT1ObP4ltPxDGAS2cQRuJEuIb9HCITxWL3w21/XZuWVsvLkLsyI32/QezgbDqJhtpnLjfGrC9Udd+DdN66+z2bqAEeHD3NI9ANzvaGnNvJrCNBhO+8m6xUZEza9GRNqhs57v9mL0J6U8GExAjE1Qp0XF9x7Uv8ZP8uObNUO6QKX+NykAXe/SYkirS4D5N8AdhH39UbWWtO4dH0ExU8aqjBuDw6aaqzBMX1hWP5ldQDoZhM8hyKY2yk3dabmd8mJvpCs/ekaBeGprvqFJv+E1r5ekn9LgmbvC4AMm0kiUBHJHNGFkrUXeGSvgsgVKRGMxTcPja26bNLOurQRGUbs6tu/sFfpDGjfL0JpNhN5Epyi0WJL/NKxeEVyUBh2swKau81dLQyhNm59+DRfPxJ2xT3qxNsnN+2BlM+stnnthakFE/L26QmFtxlFlB5SBOudpkxWkSK8RUK7gdU5uHdyY+mm251dHnKPC9hPsqVIVf7uDPhFf9qkoId9vV8CLSymuHQL5Lu+ksRmv+koW0ceDq6WbeOKkeLKfh4zFlsy3Kw6X7c0JF9edljXkqdskGqT1s1YRAicOvtUTDtzYycyeV/ijMJdwBs+xMCP6NTByWcWUVo3WP0VgiufTv+LVceJ1hySfMzDK39LotqP7Ycea+gnDsTxPaoiNRkAvRPaG/UP6fx9HHfa9ShV67lrDEPUxz9kDrq1qN90VqgxFW39za07r3HRtK5QchhTgu1KxXRBVOwW16mnRhb457QCixdhxcDDDQH4pU7EDO4FfyLFD4yuSwDA4yDH6sDZ2xPe3wit/gqlv8kTXw+0p8zfaqplIDbJ97WtMMT+fPIQyKdnZV4NZp1hpfUHQ9/Ke5fhT872OFSMdfUKKOT5K+5a2oOlQJsztqurneAJyQwX49bL1oPFMyRinrxW3VKdgHoJeoc39ZUk/LinqC6n/4aJcj/GiHhQSOSq+jBlsVkF0GmQHMZ8jW59Uel5UMyERFx+DQrXzEuwW6c+oxXpIeNmbA8T9LlH3NEi5LH9rlH7nTnJL0YN7LaGyQrZVBZERoVF2n4YnDso/wxgIszpy39XL41/3Cgu/eQbWRo2p38GNuFvWpVJ2x2oqlZbnKw29TUzVvyrEce3ILXgruKkcIUkFeQA8IxumYa8eRVakkV+5R08yd6bldXiInmdWbfQJJOOOQPB0qwe07YCy0Vy1M6srkwyVazHzKYjR7mmXzBYsSq2SYU7gUIAN6RTM8tPu+vemOWSWXgRLdq9xfAy0IeRQ7umh9PpID+w1arTRZvjdbCnLoCkyVroK+McntfX9gckV7oUuVvK7KI69Iw5tChZ0VehoThAixQIKt9hA/8d+oeeSxIOTsTj69zfJiRdMbr+anP5HWUksUkVmx9pYn/khXfJLyzwso2QNH2Qme63dL13ncvdyPGj4Y/s2KMvvZHzg/MpZ/pAme+zfK6Tz2XSZORC7GEDWkfZb3daGVpu4s8yNldgzZvLB8xgMFYxXB8WfAY5uTBIjAn/tn/F+ZgpOWWel0w065tAtHRfPODQKK+NFHy9/CWugwoVfpJaq9JCBoYKJlKzoArSr8U7GNq4z6WpKqMG7/pDuJAMMsNAijk+/IMi7dtIs91BjN82OqTH2Gd1QHfmZc+VR7F3Shv2j3J2thwcjaRakpf11/lwZpwHci9+kc0NIoDvH1hEbWpxDof+rVOqdYZSpAelklIKYRqOQpB2CCX9HIsFLdrlhB/2+JBgLycyzcRmsoU2HGHifbmkHP/7mxvF39d8Nu+ET0DFtzMxtYQRKcXOTCfCBEK9wCz5NSBCQFAkG+v5MfAPQue04DU6YqcU/xgulMQ9G/VpEyNPfDuVP3leBgSENJ3pbK5uo2nqar+9g5h3fyER2jjK0nIKsvCW57YUedwCYaxDcmVBlpA6BbPm0RkaAMoHgkObPTa73ufLQgWThR6QQSPhBG5/ouePomPum2bxwSIzfdfPDw2z1dz6MlssAIEzD9/FxLd+KpT+h93HVisr5RXhuTvLJd6GijZ2u+HBtdJhodYH/44bKo2GqrGr45sQm/lW0H4zBMv1q5qggdM9mrLg+MxDVhpneS/8/loZd/WgfHrJOq69UgPM47yFHcqfqOSgmMqDMjTl6gKSEP1fVnkAjzomW/tMjIZQzpP/7jSZ5J0S7L9ir2pJnaocZ32qtfueohp/Yj0pAb6LbTVB7xsLMnAeOqiX1ORcQEC+3QEto/MbnGOeCo/f3SsS3U2PjwNwB0E6rLZT/cLHTraHYR0bNetDNLTByME6ywR2Mw+0wxO0aG/0NaEgAnYdosc/qaIhsOsqI6LHQpmEy8hHBhEYiZFhu15ldhO44+3EKc+NKe9K0+QMaNbsf3FAbrelaVebaYPdfw7YqkcIDUZCX/D6aB4gvd9vu0p1hFjsNvx72Vq9KDAzjYp5aJGyk1lXW1PKwylJGu+hZ945mLGJFf9aM4MurhKItPrg2blFuBee0yvDW8ZK0E8zsiNK056Baxd+V74bMQHkRulesRLPj6eSPxEVB0W1fot66t9D2U9edmKdpfxz1sjiUFRCN70AMm8aOtwgX3IYQZmgZCpxGdo997X6e0VirTfTn1MYx4zIXg04v9Iq0LVdzFJ9lS+WfnQFZ4QP/mJInWhB477Eoc8kYt748u8duURpXM0EHYAHJhUeaRJsgxufvT7I1ZInOU1W6/HImUOefMytRHYWK8S1R7f9tymO5fJ4FMx3SQnHL8E9khlS2AmL5aYkPi7a1jHKFDo48a33gf969ygRGpWSNrnM1wAisZhahRE5ztTtVqBp0Igx+GMVJOurPX3AX23JS57+d7SXvk8IYFYzE1/mp+I8osFr8hpPr2TcS+iQSu57tpUTES1SQAHVFRVfngM9lZF+pd9EOwIWjOmyjgIpIRGJD2SjvAdUE+4K4nF2MrRF9AJOv8xNZBfXs8bBGrEbLv4SAJQ6RG3FICwpxz9pgkBTi3VPuxhkQQC9c9rJV0YFSmtfIDp5qfi87Y+Ren+f+dcswOnBai9bSaxow4G/ZvJqtRA1lYBtx+Qme98oe+dkZ//kBvvmnSG52YrB7hqTANRae1SwZ7dkT/XOfof+7kR6feoGYIhY9Vxg9ppx+WIlqeiyCM0y5SZa1gjXpUeyzRAf+aPX5n2fB6na/1Kji0PNzVeO/XUKlPEPFTvlAwPsWSOgEmXlf1aGKtNJQqoYwsm/XXfcLFnEhMUwLRmgNL/7rsWEk9XCf1hfk6zi9WyV4gkn5jZnDIDe2E4NBzCPe2qFPcVKsSpODoTbQTXThoSXh+oW/XVt7ze/8hF1Szarz0wW9n+PUJZW2suIOWI0k/kyrWaar5lJl/111t1ddLrsh5mvCTeyE+EtsjXsec7ZMD+W4rNJy7gkT9nLZcrTYCDkVO8BKP7jJWR8gd4KLz5acMuxD4x78hqo8N5wqTYGqpNtYT7PwbZp8v/X2WLcop4IBh/trDbdXzGxSwyMOEDGLdf10sDs9DmLS7RN85g2xXYJO+qcR1GOLmiMsg5+by5HQ5r+7FAR+8hAEc+1nVsF1T+Wy6iNlsiebdLlGMkH2ZYmvzNhEK+45dVo1nYyTYZ63MjAUX943XaHvhGoDNA6ZhqdGw40SqF+baU4fF41+yZV9pO8Wpc+A0KL9rRV2FEtPQGGLTT5/wLdE8d4pi8Nmd1CgZAO6D9fQalD4vnnTHt7YwVWQeEOaGStNKAtxKceK4K+tfAO4rbxaIuPBB4AWVbjkbbwEymwR3f/CMfHLOJ9GprN7CHehZ9c87vQsCPFBP1Cxxr29Q9ce56phzF0OJCwsmNgPWgfdAnXDAfRXsdBdeMirBlFW7ynrGrazOmIsxyK2/8MkHz883SQrnw8OVUJNGrukxap5G+o6+tJdqFIXGgclXKgZXJUbvIHWjE4MG3o1FpIJowb6iJ5RqWnhCQUyJCxkYzIO0U+gssqbDGrzKN1KuNZEtTHOZtVwyUinoTdDye3EyBq2ffUqhCGGWGiUMEEorgSjOskHpc8WBM6d2lJXaboI44TeyMUz2GQgXFNHjzXp00soOidzX4G/74gtPmx1pkyQCuWNhMBDZ9SzEv6VWuJWct+dbStqMz/IxkOEhKQ8zdBQqgrFV6JpSD9dRVTJgkfwM5d9QH/kaljmPW0bjirL1ba1Av7MXNY0X0ZbzSw5br6i4q3d5vxKvarL99l0jvmgvXou4N791/7pvwxycIBPcW6cP4vwupXJbIYC/7WdiASepA0Mts9dZGaDqvg+CQNJ7lF/n+3Viq2xD5fDlSva49Lep2rNcGTgjJiYcdET6uxsbbKLffnZS8UOi3mEjA5eA1EdVhbt9FP0xL4Wx2dy2TAOewaEGrgZ48Fln+KOThh9ZR/y4JaVMIuWa0G99h+fwlDAdTS9jDJB8HqdJxHaTPfZS/7osY8Ep5iBQHSmEkcWiHSJxR+mU0eoAydrK4bV9nBNg3JtFXFtkObB25PGXi0+iNaxHqRirHhwhOCaSCfShT8M8Ow3tDUUAbrNdP+zZCuBcS1Ld42fEZ36x+UvqvWW5FWOTs6tyVJXUegXBVxGiFuuXhVcXz6hQ4oxd1lbzL6WUbP7XXXaxj0A45I3sZA5r5hE6Zm45uJ+4FGJWfAM18UJ0hUHVhzOqfvPz7DueGXwOHQ6YocXkGniHsaC7a/Cal3bSftoWyh6mommbNvQNGGJlonjVC8lOYwZDp5SeoVkLD3H1SMf3g8pXW9MHHYNyGp3QN1euWKwAFCO9vxASSgLULmZnsOeAKfn9bLJFutFlHYMmHo8G6rd2irzAqRvdICDAhs9o3f4kqFZHaL7C9IZMMJUF73iOr2cmF72Tf68hbj/Bwu9qtQX7H7/VDRnVXujvBRJgDHc1qOcFcFzg0TRciukHdbbXFD8nygv6eQt3YTZLkQAri9Ja0OORzYZ0CgkdPu9IEygBLHFQnbUaYpLbkOMOTBectoYq/0iHqz/sg3DTCfgz4pEM8X8uJF0Vimn6UPwPklf+tUgH9ubptOjxk32+k47TaYaZp/VI9mr9xIzjfBatQzjF9grGcU7YUToqcrn5TUxTxoMVJS852gVHNa+XqFACWzmrh8g6e6+ylxlbcfBIiYS6mosno8LM7095C9rv7iylXJOVbIiCK+FxUDZBZwv8SsEbTwm0pM6832ItMlkEBfHUMTd9TNJ5rjbN4JKEpM0m57KAwG6vGnHL9EZAFoi5limn9rnSTOMhfAU9gF5UZETneR8yGHuKTYh77PRWd3Fsq66jSAZ8bhOaW5YNc9UbMfJntvsEC1OWiP/XePJwE00hXgor42F7YBhm0iTERvd4QVpXiQ0xYjVCu1B+14t3zdSy8hUSl73497cldd66Vdqf1r7ummo/36QKUtcRL/5pXqkIA1RWmSDpHLL82NzrTABXfilov9kH138lMwKWicDUxSh0Bb7B3MavgVXtPmcKOXu+dNZzGVsCDdgEeE5BQYMejvMS2ON1mtGBjgMe3Gl8rZMm/k5G9yNpj2gROx/j6orHEO74RLCIR/ktrdFY/V3VlbpvzHHhFlijmSdH732E7t/o0FpXsgBgiJ0bQWZBcpiAGiERCSi+TxET3yVUdPYypmZXyDGSLhyianDRFHegatlr1wn013JGoM83xjd767hbMdhje22Vlcbg3mrWc++pKff1vjNtcofBPsdY8fh7JTVX/P9CncuTVRKDZ/U3/O9lBajx5rtr7ZUOTDGb8/606y0NUVAZ2bI13F8KsZ9vwzGjaaZ04JPRuVNwHLdxLiYCBaHxXpEglgSNJ9xDTvNxkRiPyXnMGkQxQHxzb5AhLI7OulYbtxcGH866vPswNx+KK1PMGuh9QE8wfB85pLhzQeL9Y3WFK1qNUpzdPpT0grm7Z0wJKPw0MoScQZ4gOmMvFf1Z2xn118mgP8JGrkD0oYnURlxTe54Vr8j5CZMdg9yZxWe66bRElDzeaM2+UH4LuSjonjNOjk1EMT7G1oBGI3CkDwVOcTzthWh4fqg5x9SSKuCNdlzCAFTgrzNubPAPIhaw9cCna+4uBKKVR/BVpW7+3tLQXwAkA8j+R755ODtrH/DWy4TIwH4H1MXiEh0m1cZhWB1XZzIWlm3WiCQEOk7UZvW+re9ZwFCd6MmPnaY/u1CLdQdqq6hmtb0rlxJIwAZp20D42OnkeH6eNx+tIYwmjrjXT/17HJaW2TRZHvt6QboZx9LW71DRwVVbigoitojGT3TRfoepiGcDAbP/1gR35eRWmVbuO6Up9PRCvaGqhBwgVNW8hm7cwRzPXyIRh/MbrvAzJlNsaVQ2sN8aPTiG0xTyCmRcTNwAyqQ//DVKoA9mw793BOH0ygBr1OfYEsUG+PkdppGsKRoq2Lb3EsbvzdqlSBbfxMln2bu5IXHIbfEE2JlTpS+rkr3GgvrrooL5gD7Mnw5iy8gRTFGvbY6LIOY+0DSWXbweTO+0XCvxsDHemp5vF080cWRXh6KAJ1JAttOECUasGnLpKomnuAgE0JOIHIRQ9WtDbACnEcrCk2gU2e1Nk158KGCHioBRIvxSxaQcqhbb9RohaG9jjoqOZ6IN9JVw5TJGMhB8srr1VaqhpaoYZR5CcNIJUpS74Si+O/ojm3978UYaWjnLeh+DEejXivenmJePTCE8sTO8vQMiEOipN8gpubT8c2mEeO9Jw13Pl2CSy/aIHe+NMzh2lFxRUs30PAlCMH/FPp6g4NpKIkePRT9fCSKMP2OTBEKf3zffHNEnG2BF8aYsbuDGdnliu0VibsUsokN/aKZLC/+3DgKcjhnIihd4LvWq1/7otzXftVPyBQdIfg2BnxRQCeFlilFzipU9TAoA+IJipewJBoywgbUom2296h9PuqKirHxesje5ltspdeWuX+Xa5i4KlKDRoPTHIjJCHefQcxVHfLmJh2P/AVOBUDmE4X4DzKeVXxPxJLBoACY6VceiZy0t7k2+HLggmXH86Zfp14xzcsrfJC9/4wGeBFEHG4KtkEikepgvhmFaiVUzgi87wNzLo2OMYCdB8/L9TUEMXMAReMCl07UxRB50qBAXvcfYgOpSh31dW2yzaZ+G6Sbhz78IfVvJF0+LLs5KNq1MNprAYW9dFaOgKi3UsPGZIfwXp+66T/hPIMiF6QF0qyxFjbdat63RYpFD35/eTvO7CIAakasTp89hLw0cYKIrdWx9ONhraUNUwqCkAFfkIKCeMgjyYAWP9IfQVRBBt50ia8PuSG4o8vKXN7UD5GzVlVUoOyQcAgGxqL2wNHEdGOQeAQ8SarlBTcoYPl0Is1I/AlExW7xCsYXOHaAF8DIYpXwDX1kV28A8k5On+C4uTN1GqRhmx3vg0y4lwEpSK32skJZWNDmb9tANxWVvOssxPrJ8xwtsFKZ3/F1nX1M+QG9+SUMi58RBHC/AoYG90c/qFv4ja4HWi8snXlyR2AZMIEk9f1Ch8zApHWgF4LAdFUJJ6RmTp9mHg2atRtfXrNu3S/I6ZdIxbqpOwwV7M8bEqlgjCzV5f1xtclVvpPCWg79+XvtQgYc62jWR/UdaIBRfgeIXLkxHwxLKoXwU+kkHRt1z4jzO9ba3lYMB5mpc5TBN0MyjVQeYaURJ5hO6CQIp44FjuK7aIhVrTpnQBfAEhCJLLPEv6YGWjguFKjotOwNF8MKsIpWSI1doOIOsseCFNDEuECtwGhobT1Prpshhwjjc5nPqms9e5afo+5FUpPAJDLPvpT5lFk/zSaO9iH3Ahynmr4AjOzbTKSPdeoIa4/E9tNtpOC4hnRUtc9XA+OSo7pFc/IqviM11XPXEWOPMZXcEl90DesVBGQ2aOZY7MV4VBZEea/Hjn4iuAml/eGkrsY6lXz+5bgYPLpgirIzNLGo29aTtk5vEGLRZYW9tKl+b6DEnEOrTZ/oeR62EpICv7bTz6ISoA/OlcZskymcal61b8alJDbSCxhTML1lBoSwhdLt720SuguoUmNVzn4N3kR0i2OFSIduMdAayE82/BV2vkCoVEeYvlP8/lCJ4o/L5oHQHxFtjWPbKRL1LVcQKArf8ShlZpF9TF2LDPykectJixkgw+CgChniIIC+zzSh8PbvXppnT0YlAGZUbpxQIEEZuWMG6d30NoEt+L/ysSWgNvtlsRMfF/M6m31FCKxmMuFpN+fkbHv0wB2Ok3wxyhad1oUztPvWYTJYFmNyXtfE/aCYpdxUv5Enzj2CgI2saL/B3kaDRLo34WwFXWrz5LxKJebb++blcICA7STkA1yj5YHZFKHtopL3eDYnrFQem0tPzZsggui1vWM7uZaZ0zy2h9fhA6DGOcsT837jnOqoIcRJKpgnAcvIpR5X8V9B+qbVl3qIinVOeAfBLKcA7KJSASV/Go/pi3r/IwqzrXxpMgH3r9/UPM+aqg09gVvH+l0TH/zuAHOg+ehGQgje4U/uF7nXDqPGMUn3wcT5IZpjgmAcxurmqo1ADRpn53UxywhehXuPko6xGa6y2W/cpBxHJyiG1S+2H5bgNFKlZRdQbW0OGBVgo4U+QRipQaBcww2ro6jhiXhpcOskxncfwWdsN8gGZS5WGVDoK0SjqupzK/cDcPc03h6+6hmNUgI9yH9Zwhi4/4OH3LG33OJB5LzEaepibEgywewvqlsp9RHgxN2yGBq2zSqwJXJPwtU6jtr77zupUNzxExlkUgWq+5R6+bYE5f/XKZmVUyqT8FejyMVijBcJJc62lxZkwYgCw9xmHQ5MfUW8rl/cph5Qx4LQ7GuunMiiU0J1yc5K7jtQohmwJYzJnO9kPguV9936D3sNF6nzuSil74RCI8bxNYubQpFIvSDuu2iDnOpVbNZVox3e1iBBkJSCt4zDlu9CTTkdJVIHKwjzGrwFa4ptpIZ3E/Amvg+XFd67sQ5R+EP5VRJCVnOK4upvfqVg7Cih5F37KTZGTx4CELOajXD6ivHF0+1nY0qIKOFOTdLU0q6bfmPkrNAD4PctrBVmFk8SRBtY2RxnHjGlHyCeTYYrripnremyK3pvPIqvQndX8/Vp2QBHVNOLvSb2MRHopFnUmFv621tpuOwvoUfstr1FS7YdIJ/1vi9uqNZB2S1AWDf6nW+byzxqbD9bAqR7iWr1/0uOQ/rztWue2dN7XArzOKbzEm1Or/L2hOo/5w+/e6FW+oh4K38wjTDFJsvTMmlZSH5lhTwU/EhZHjBkVl5c4qg5F+AlWp8DuDdn/zLH+67dCmOMsDKjxtyAGv0+B30HQKDQiPxhyrnf2A7r72I3/V39ZC8QKAxa8kPiKVpC1t9E0fEMFVaDYOW5kYM6D7Q8P5Txc8GatpKrhWkMrxPu1jwuypwg4M/PYPUFv9S6JrDqiq3I/cSTVwSC/mIt+wngm7kQjmYbO2eozzIo4K2QxFUo3k+2EsUBjRrV2JMK/W1BXILIAOdMWh2bU9esBpfbimR6/FRlEF36MaKMeWDGQInfxzYU/Hc29H8FZdzmiZ5AKxZCcEOP3TPhOogti6BncyZLAanN7HIzUJ55zqkZnj+/b45mFWm3tIkF1lKHZGSRHkMMjQ/K6oSBdE536/tud/9dlJUc6SMITgyqhhwH+ZM96Kbg32/DNQOpN9mcnZa6QrMUIyqkiMUuCAAy7myZsmTOtWAperpkWZ4mEyV7bw2uf3X8AA6OSbZSwghe1GYOMqVfBO42+c27JQGF1cVcKf3jb//493/srpy1frAtrytTu5Xc0yEX/YHPkRHBQpdXTaL4mSBx2lCHR1h/j+gJDGoMDOSExiaiELDioTlvvjHvLhEQong7HjlgB0gFv+jNz/x7fPUmDXbnuF2kAYfB9xdPN48QH+ca94WYMesGCwT5/vxI5qBpmn3KZ0d2IJuYLZ3PSGzQ2J/8zmynM2UhKvBNUP9EOPrxubSdwrXH4HWfUPWcI6S+7vuZpI5xchFUCfhn6aO5lyEqhUAzcrqU6dScrqS7am48jU7FM3pzpuc4v7xua+rnoKyHZyDNXSzQAwmyAFM4PE0ec6bZntt+wkWV0QajYHarl1M4hEILxs9d98DMWL143/5i+FfdQfuntxDkYxYl9aSGuZZakGerdZMXgEDH+Qv2aIJVO3MoajHIleeycsjiCayI9UXkVPmZ/EFPDd1qgwzvm02FayyeTgq/UUA+NoPffvPeX3LTV3gmCr0jThJuQQtUIRcLdigsdk0+y4lC1avNz+I061g2ydb9Q81ycHfycMzXCVaS8QldYQMAAy2OV8saOFvITAakrwxPi5TwH0jUMs1zc11i7nz8calddrZ1ilFY3Jlwv7+zxwFWIoddXyDi0uvut/kOeuRI6ofKNjAzBcYQaz0xea2R3GHN73Ou2CJ4WknnffMQFq8VSN8/Mj/w0oyswipu7eSA5bC5lYrn4B3boPy1ZNN7415weUWQqGDJhGnKSf5LM4W8Od+gap4MViUZ9TEQA0njABtERgCtUzIF5vwCtrj1NSfl6Z/2cE6GgYEr5o9nIudjs8OfZpBqD9GvVE+O3iFnfw2P2eycwsJ1a+iz+r4Q31Qhp7HXtLaCqD8l/D1/hu4zTB3jfERj/00fdDpr51QkjrPR9YgSX4QAh4DwNh7xFLV6ypsZIAuYXQm+039VseXBfsWpwk/8ZwQEiaCxoNqvyFrqb9ymdY588ywuj7CyxWw0hQ7G/rZYi/L4crrB0+++tv07zu1KoSl5wOap9/2ecglegiFnAMG34fmfXZpxcB41tGaYIckvAg6WS+aQsp/RyS0oxwiCLqWEFo221Axo3+e+x053v6/P5U1eD2jUrMcCAJJZZF9yTWChNVgIwdQVEvUI9iRFc++mOhVrr9/uDdYfU9okxrhTH4KXoCSeRUtMu+jcoJKb1pyzxkMmmcvoo8dE3rLuzqQv6/y/HRexl0wy89I0wKQK0yjEg2V5hTDEzmscoUaQ/bWDy7pUC1TeJit0ytP6rA1EEmpFQFLoV6F1hrmYJjs/GCsLaU47nP3p2B1ayubdsAz4Jr5j7tz8USdjgDKcFFltmEvEpAQ5FYttUTh4fI6N0Mg6VJ1lfP3IITcj+0KHGgG6b6OIKryHNXZiWktpzRmvE/ZbvE51t0abG+xheJkhlbXKSVaH0uHypEEvVnhyxDGu0nMcYcVxBVtwT4i4aGKk0iiEbzjFf+51cb3mM7f9WA8Ecllmvj0HG2KaKf8nLjA2bVEqwEu49ENrrxuOJi6lgrTDKNx0pwUHO7YmnyE8acPdwHYC/jnwEcVv2X67CvYu0KOcyzCVbo2BH7RnfAowdL1BRpTbtKWOtQAVjrOjuOLZ1lwKI8YhPzj4sb+lV8bAKqMCsrbrRanZFRprgN3Xbjzh5t3FX2jojCiBpknXPUkhfqOdzJ/xpOkwgZcUlPHAX0fejrQ65KYtik2hCEP0vdKIDGkaJgDFrNEEwPbHhCT4VbhRR3F5R/EwhJW7NCXnCbDiax/5DfFWxExm5am3HTcc0pszEE9uuU2U8Du8uEUtih2U0TgDb6H3uqGPuhQfgMuEDeoyuvnnkEb2P/K14uiONvnW2wSmu2F6oORZUuUdw8m1/jTPm6sluHlOIfNcu7G6kJDCnxESec5muZg9NUG5t7kS+JHxtZMN6jd76BweID001RDaY8CEXdFI1psHLrUokwqKLWYvS2Q1T8X+83yBWTqQ+p2MrIMSps3FzGXEqTcOmXjTHOScH/HEWvAKyK7knYqz0UFYsZ3CsO0if2E3RxcMHFEjo739DNF0m+Brrnru4JwGUlDy+12C6ueGLHC9+RXZjM+XrLBzHAIUIxytdc6XS7ZkTyM1s/sMXf0geV09aUugi0i31yUCyYxhSFGxhQbNI7uu9L/1j09/1YnIHG6tmvX+rSLrRgTnxOn1iALuBE6LA9mcF1ya8Hm0/Fy6bhzWNJW7Ik+79pccCo86lFsJqjWkvBdS9Bph4pZT34/JK2coCInwoqQ9uDvvP7EexSrWAxK9TiGZhDuBpKVrV9ML9FVKcDUDAr/Pghu9Ve994Jd1Cj2KrqOo3IcPqb+MHj8+OlSYdY47lO3n616/tiYx55k4zsld+iv2pZINbfxMg6x1WsNwxjXYUWd+QVb7cld5g0FSiwcAQPyy+YTw9MCByumgUju6Cx41j7PxxYxB46J8249cbLe/DPFDbpYMmf+Bfvfmp+nQSI+GKYmnKnTzaxaS+Wm7wGYvnd2G3OAFrhwgn2moTo6JL3RVHUEu0ErJiEoUuCMbzBH5qa/G8C2FCSvBkVyJts5dXwTPbTc6Hcbm76TX8avW9yAJtvcWY+hak5c0kPrbZQ9G+DJnR1BcWoqvKdqZkEIr236LhSzT59aoeCG/DryY5/VlGg8yD9ag+Fa8k+/Cy/nRFt85pP71ZRi1Ku+CAe/Nz0Grvi0I7PiupHhsP0xrew07V6cDXtkxHCqVwqpIJ3Y1yAVzsdOqmNnM517DItIAtu18m621aSKp+1taHYFpD9dsXgIUTVSs/sL2uJRsMm+JPVohENL4dd6lCXqEnybfPw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xcode调试中引用python脚本</title>
      <link href="/2018/10/18/%E8%B0%83%E8%AF%95/xcode%E8%B0%83%E8%AF%95%E4%B8%AD%E5%BC%95%E7%94%A8python%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/10/18/%E8%B0%83%E8%AF%95/xcode%E8%B0%83%E8%AF%95%E4%B8%AD%E5%BC%95%E7%94%A8python%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Xcode集成了LLDB，进一步简化了程序调试流程。虽然LLDB很强大，但是它的命令很有限。所幸的是，lldb包含了对python的支持，使得lldb的拓展成为可能。本人在开发过程中很喜欢使用image lookup 命令，但是苦于每次只能执行一条，相当耗时，因此一直想要找到一种批量执行的方法</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>批量执行image lookup -a<br><code>optparse</code>和<code>shlex</code>是用于解析参数的两个重要的库。通过<code>optparse</code>来生成解析器</p><ol><li>编写python脚本(layne_command.py)，代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8  </span></span><br><span class="line"><span class="comment">#自定义lldb命令 </span></span><br><span class="line"><span class="keyword">import</span> lldb</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量执行`image lookup`命令的函数，也是自定义的新的lldb命令的名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layne_imagelookup</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></span><br><span class="line">    target = debugger.GetSelectedTarget()</span><br><span class="line">    process = target.GetProcess()</span><br><span class="line">    thread = process.GetSelectedThread()</span><br><span class="line"></span><br><span class="line">    command_args = shlex.split(command)</span><br><span class="line">    parser = create_custom_parser()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (options, args) = parser.parse_args(command_args)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        result.SetError (<span class="string">"option parsing failed"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> args:</span><br><span class="line">        <span class="keyword">for</span> address <span class="keyword">in</span> args:</span><br><span class="line">            print(<span class="string">"*************************************"</span>)</span><br><span class="line">            debugger.HandleCommand(<span class="string">'image lookup -a %s'</span>%(address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_custom_parser</span><span class="params">()</span>:</span></span><br><span class="line">    usage = <span class="string">"usage: %prog [options]"</span></span><br><span class="line">    description = <span class="string">'''Parse Symbols to Human-readable Format.'''</span></span><br><span class="line">    <span class="comment">#生成解析器</span></span><br><span class="line">    parser = optparse.OptionParser(description=description, prog=<span class="string">'print_frame'</span>,usage=usage)</span><br><span class="line">    <span class="comment"># parser.add_option('-p','--parse',type='string',dest = 'parse',help='parse symbols.');</span></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本入口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lldb_init_module</span><span class="params">(debugger, internal_dict)</span>:</span>  </span><br><span class="line">    debugger.HandleCommand(<span class="string">'command script add -f layne_command.layne_imagelookup layne_imagelookup'</span>)  </span><br><span class="line">    print(<span class="string">'The "layne_imagelookup" python command has been installed and is ready for use.'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>然后保存为文件<code>layne_command.py</code>,放到如下目录(自己指定)：<code>~/Python/lldb/layne_command.py</code><br>说明:<br>①#coding=utf-8指定python脚本编码，否则运行时注释中的中文将会报错。<br>②运行脚本时入口为<code>__lldb_init_module(debugger,internal_dict)</code> 。<code>debugger.HandleCommand</code>是<code>python</code>中执行<code>lldb</code>命令的主要方式。<br>③<code>layne_imagelookup</code>是批量执行<code>image lookup</code>命令的函数，也是自定义的新的lldb命令的名称。<br>④<code>optparse</code>和<code>shlex</code>是用于解析参数的两个重要的库。通过<code>optparse</code>来生成解析器。</p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommandLineTool使用pod依赖库开发</title>
      <link href="/2018/10/17/macOS/CommandLineTool%E4%BD%BF%E7%94%A8pod%E4%BE%9D%E8%B5%96%E5%BA%93%E5%BC%80%E5%8F%91/"/>
      <url>/2018/10/17/macOS/CommandLineTool%E4%BD%BF%E7%94%A8pod%E4%BE%9D%E8%B5%96%E5%BA%93%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="ttps://github.com/CocoaPods/CocoaPods/issues/3707" target="_blank" rel="noopener">#3707</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/FilesProvider.framework/Versions/A/FilesProvider</span><br></pre></td></tr></table></figure></p><p>结论：cocoa pods不支持<code>Command Line Tool</code>项目</p><p><a href="https://stackoverflow.com/questions/41258187/cocoapods-command-line-tool-dyld-library-not-loaded-rpath-realm-framework" target="_blank" rel="noopener">Cocoapods + Command Line Tool - dyld: Library not loaded: @rpath/Realm.framework/Versions/A/Realm</a><br>cocoa pods不支持<code>Command Line Tool</code>项目<br><a href="https://github.com/CocoaPods/CocoaPods/issues/3707" target="_blank" rel="noopener">Command Line Tool + CocoaPods frameworks breaks</a></p><h2 id="采用SPM来管理依赖库"><a href="#采用SPM来管理依赖库" class="headerlink" title="采用SPM来管理依赖库"></a>采用SPM来管理依赖库</h2><ol><li><p>使用SPM创建可执行模版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir SPMCmdLineTool</span><br><span class="line">$ swift package init --type=executable</span><br></pre></td></tr></table></figure></li><li><p>配置<code>Package.swift</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"SPMCmdLineTool"</span>,</span><br><span class="line">    dependencies: [</span><br><span class="line">        <span class="comment">// Dependencies declare other packages that this package depends on.</span></span><br><span class="line">        <span class="comment">// .package(url: /* package url */, from: "1.0.0"),</span></span><br><span class="line">        .package(path: <span class="string">"/Users/admin/hsg/FileProvider"</span>)</span><br><span class="line">    ],</span><br><span class="line">    .target(</span><br><span class="line">        name: <span class="string">"SPMCmdLineTool"</span>,</span><br><span class="line">        dependencies: [<span class="string">"FilesProvider"</span>]),</span><br><span class="line">        </span><br><span class="line">    .testTarget(</span><br><span class="line">        name: <span class="string">"SPMCmdLineToolTests"</span>,</span><br><span class="line">        dependencies: [<span class="string">"SPMCmdLineTool"</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>使用workspace管理<br>先生成一个Xcode工程文件：<code>SPMCmdLineTool.xcodeproj</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swift package generate-xcodeproj</span><br></pre></td></tr></table></figure></li></ol><p>再把<code>SPMCmdLineTool.xcodeproj</code>拖入现有的workspace中来管理。</p><blockquote><p>每次执行swift build ，须重新生成xcodeproj工程文件，再重新打开workspace即可。</p></blockquote><h2 id="命令行的单元测试赏析"><a href="#命令行的单元测试赏析" class="headerlink" title="命令行的单元测试赏析"></a>命令行的单元测试赏析</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SPMCmdLineToolTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">        <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct</span></span><br><span class="line">        <span class="comment">// results.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some of the APIs that we use below are available in macOS 10.13 and above.</span></span><br><span class="line">        <span class="keyword">guard</span> #available(macOS <span class="number">10.13</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行可执行文件</span></span><br><span class="line">        <span class="keyword">let</span> fooBinary = productsDirectory.appendingPathComponent(<span class="string">"SPMCmdLineTool"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> process = <span class="type">Process</span>()</span><br><span class="line">        <span class="comment">// 指定可执行文件</span></span><br><span class="line">        process.executableURL = fooBinary</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pipe = <span class="type">Pipe</span>()</span><br><span class="line">        process.standardOutput = pipe</span><br><span class="line">        <span class="comment">//开始运行</span></span><br><span class="line">        <span class="keyword">try</span> process.run()</span><br><span class="line">        process.waitUntilExit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = pipe.fileHandleForReading.readDataToEndOfFile()</span><br><span class="line">        <span class="keyword">let</span> output = <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line"></span><br><span class="line">        <span class="type">XCTAssertEqual</span>(output, <span class="string">"Hello, world!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns path to the built products directory.</span></span><br><span class="line">    <span class="keyword">var</span> productsDirectory: <span class="type">URL</span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> os(macOS)</span><br><span class="line">            <span class="keyword">for</span> bundle <span class="keyword">in</span> <span class="type">Bundle</span>.allBundles <span class="keyword">where</span> bundle.bundlePath.hasSuffix(<span class="string">".xctest"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bundle.bundleURL.deletingLastPathComponent()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"couldn't find the products directory"</span>)</span><br><span class="line">        #<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Bundle</span>.main.bundleURL</span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allTests = [</span><br><span class="line">        (<span class="string">"testExample"</span>, testExample),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>swift调用pngquant批量压缩图片</title>
      <link href="/2018/10/16/macOS/swift%E8%B0%83%E7%94%A8pngquant%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
      <url>/2018/10/16/macOS/swift%E8%B0%83%E7%94%A8pngquant%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-amosavian-FileProvider-b597244" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-amosavian-FileProvider-b597244", "amosavian", "FileProvider", "b597244", false);</script><h2 id="安装FilesProvider"><a href="#安装FilesProvider" class="headerlink" title="安装FilesProvider"></a>安装FilesProvider</h2><p>使用<code>FilesProvider</code>来做文件处理，通过SPM管理库依赖</p><ol><li><p>配置<code>Package.swift</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies: [</span><br><span class="line">    // Dependencies declare other packages that this package depends on.</span><br><span class="line">    // .package(url: /* package url */, from: "1.0.0"), 指定版本。giturl</span><br><span class="line">    .package(path: "/Users/admin/hsg/FileProvider")   //源码clone本地，指定路径</span><br><span class="line">],</span><br><span class="line">    .target(</span><br><span class="line">        name: "SPMCmdLineTool",</span><br><span class="line">        dependencies: ["FilesProvider"]),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><code>swift build</code></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2></li><li><code>FilesProvider</code>异步处理：需要<code>XCTestExpectation</code>辅助测试</li><li><code>FilesProvider</code>在处理文件（拷贝/重命名/删除）时，不能使用绝对路径，应采用文件相对于<code>documentsProvider.baseURL</code>的相对路径。否则，在当给定的路径包含root目录时，例如<code>/Users/nam/file.png</code>会提示失败。</li><li>在swift调用shell时，目前只能使用<code>Process.launchedProcess</code>类方法执行shell脚本命令。<br> 有可能在单元测试环境，导致其他两种调用shell的失败。</li></ol><h2 id="测通可运行的代码片段"><a href="#测通可运行的代码片段" class="headerlink" title="测通可运行的代码片段"></a>测通可运行的代码片段</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FilesProvider</span><br><span class="line"><span class="keyword">var</span> documentsProvider:<span class="type">LocalFileProvider!</span></span><br><span class="line"><span class="keyword">var</span> pngexpectation: <span class="type">XCTestExpectation!</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">    documentsProvider = <span class="type">LocalFileProvider</span>(<span class="keyword">for</span>: .userDirectory, <span class="keyword">in</span>: .allDomainsMask)</span><br><span class="line">    pngexpectation = <span class="keyword">self</span>.expectation(description: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">    <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">    <span class="comment">//创建文件夹</span></span><br><span class="line">    documentsProvider.create(folder: <span class="string">"testPng"</span>, at: <span class="string">"admin/hsg/"</span>) &#123; (err) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"新建目录成功"</span>)</span><br><span class="line">        <span class="comment">//拷贝图片到目录</span></span><br><span class="line">        <span class="keyword">self</span>.documentsProvider.contentsOfDirectory(path: <span class="string">"admin/Desktop"</span>,           </span><br><span class="line">            completionHandler: &#123; (contents, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> contents</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> png = file.path.hasSuffix(<span class="string">"png"</span>)</span><br><span class="line">                <span class="keyword">if</span> png&#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"文件路径:\(file.path)"</span>)</span><br><span class="line">                    <span class="keyword">let</span> thePath:<span class="type">NSString</span> = file.path <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">                    <span class="keyword">let</span> toFile = <span class="string">"admin/hsg/testPng/\(thePath.lastPathComponent)"</span></span><br><span class="line">                    <span class="keyword">self</span>.documentsProvider.copyItem(path: file.path, to: toFile, overwrite: <span class="literal">true</span>, completionHandler: &#123; (err) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">//调用shell工具压缩图片</span></span><br><span class="line">                        <span class="keyword">self</span>.testProcessRunShellScript(filePath: toFile)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"Name: \(file.name)"</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"Size: \(file.size)"</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"路径: \(file.path)"</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    waitForExpectations(timeout: <span class="number">40</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testProcessRunShellScript</span><span class="params">(filePath:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sub = <span class="string">"_temp.png"</span></span><br><span class="line">    <span class="keyword">let</span> pngquantFile = <span class="string">"/Users/"</span>+filePath</span><br><span class="line">    <span class="keyword">let</span> tmpFilePath = filePath.replacingOccurrences(of: <span class="string">".png"</span>, with: sub)</span><br><span class="line">    <span class="keyword">let</span> exePath = <span class="string">"/Users/admin/hsg/hexo/GitSubmodules/hsgTool/pngquant/pngquant"</span></span><br><span class="line">    <span class="type">Process</span>.launchedProcess(launchPath: exePath, arguments: [<span class="string">"--ext"</span>,sub,<span class="string">"--speed=3"</span>,pngquantFile])</span><br><span class="line">    <span class="comment">// 删除旧文件</span></span><br><span class="line"><span class="comment">//        documentsProvider.removeItem(path: filePath) &#123; (error) in</span></span><br><span class="line"><span class="comment">//            //重命名压缩过的tmp文件</span></span><br><span class="line"><span class="comment">//            print("ddddddderr:\(error?.localizedDescription)")</span></span><br><span class="line"><span class="comment">//            self.documentsProvider.moveItem(path: tmpFilePath, to: filePath, overwrite: true,  completionHandler: &#123; (error) in</span></span><br><span class="line"><span class="comment">//                self.pngexpectation.fulfill()</span></span><br><span class="line"><span class="comment">//            &#125;)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用swift开发自己的命令行工具</title>
      <link href="/2018/10/16/swift/%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/10/16/swift/%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-Panagram_Final-8023350" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-Panagram_Final-8023350", "huos3203", "Panagram_Final", "8023350", false);</script><p><a href="https://www.raywenderlich.com/511-command-line-programs-on-macos-tutorial" target="_blank" rel="noopener">Command Line Programs on macOS Tutorial</a><br><a href="https://my.oschina.net/uniquejava/blog/685537?p=1" target="_blank" rel="noopener">swift编写命令行工具</a></p><pre><code>更新7/21/17:macOS教程上的命令行程序已经更新为Xcode 9和Swift 4。</code></pre><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>典型的Mac用户使用图形用户界面(GUI)与计算机交互。gui，顾名思义，是基于用户通过输入设备(如鼠标)与计算机进行视觉交互，通过选择或操作屏幕元素(如菜单、按钮等)。<br>不久前，在GUI出现之前，命令行接口(CLI)还是与计算机交互的主要方法。CLIs是基于文本的接口，用户可以在其中输入要执行的程序名，后面跟着参数。<br>尽管gui很流行，命令行程序仍然在当今的计算世界中扮演着重要的角色。命令行程序(如<code>ImageMagick</code>或<code>ffmpeg</code>)在服务器世界中非常重要。事实上，大多数形成Internet的服务器只运行命令行程序。<br>甚至Xcode也使用命令行程序!当Xcode构建项目时，它调用xcodebuild，它执行实际的构建。如果构建过程被嵌入到Xcode产品中，持续集成解决方案将很难实现，如果不是不可能的话!</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>对于创建命令行程序来说，Swift似乎是一个奇怪的选择，因为C、Perl、Ruby或Java等语言是更传统的选择。但是，有一些很好的理由可以根据您的命令行需求选择Swift:</p><ul><li>Swift既可以用作解释脚本语言，也可以用作编译语言。这给了您脚本语言的优势，例如零编译时间和易于维护，以及选择编译应用程序以提高执行时间或将其捆绑销售。</li><li>你不需要学习其他语言。许多人说程序员应该每年学一门新语言。这不是一个坏主意，但是如果你已经习惯了Swift和它的标准库，你可以通过坚持使用Swift来减少时间投资。</li></ul><h2 id="样例介绍"><a href="#样例介绍" class="headerlink" title="样例介绍"></a>样例介绍</h2><p>在macOS教程中的命令行程序中，您将编写一个名为Panagram的命令行实用程序。根据传入的选项，它将检测给定输入是回文还是字谜。它可以从预定义的参数开始，或者在交互模式下运行，提示用户输入所需的值。<br>通常，命令行程序是从嵌入在工具应用程序(比如macOS中的Terminal)中的shell中启动的。为了简单易学，在本教程中，大部分时间您将使用Xcode来启动Panagram。在本教程的最后，您将学习如何从终端启动Panagram。<br>Open Xcode and go to<code>File/New/Project</code>. Find the <code>macOS</code> group, select <code>Application/Command Line Tool</code> and click Next:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/New-Project-444x320.png" alt><br>For <code>Product Name</code>, enter <code>Panagram</code>. Make sure that Language is set to <code>Swift</code>, then click <code>Next</code>.<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Name-the-New-Project.png" alt><br>In the Project Navigator area you will now see the <code>main.swift</code> file that was created by the <code>Xcode Command Line Tool</code> template.<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/main-swift.png" alt><br>Many C-like languages have a <code>main</code> function that serves as the entry point — i.e. the code that the operating system will call when the program is executed. This means the program execution starts with the first line of this function. Swift doesn’t have a <code>main</code> function; instead, it has a <code>main file</code>.<br>When you run your project, the first line inside the main file that isn’t a method or class declaration is the first one to be executed. It’s a good idea to keep your <code>main.swift</code> file as clean as possible and put all your classes and structs in their own files. This keeps things streamlined and helps you to understand the main execution path.</p><h3 id="The-Output-Stream"><a href="#The-Output-Stream" class="headerlink" title="The Output Stream"></a>The Output Stream</h3><h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command-Line Arguments"></a>Command-Line Arguments</h3><h3 id="Anagrams-and-Palindromes"><a href="#Anagrams-and-Palindromes" class="headerlink" title="Anagrams and Palindromes"></a>Anagrams and Palindromes</h3><h3 id="Handle-Input-Interactively"><a href="#Handle-Input-Interactively" class="headerlink" title="Handle Input Interactively"></a>Handle Input Interactively</h3><h3 id="Xcode中测试"><a href="#Xcode中测试" class="headerlink" title="Xcode中测试"></a>Xcode中测试</h3><p>Launching Outside Xcode<br>Normally, a command-line program is launched from a shell utility like Terminal (vs. launching it from an IDE like Xcode). The following section walks you through launching your app in Terminal.<br>There are different ways to launch your program via Terminal. You could find the compiled binary using the Finder and start it directly via Terminal. Or, you could be lazy and tell Xcode to do this for you. First, you’ll learn the lazy way.</p><ol><li>Launch your app in Terminal from Xcode<br>Create a new scheme that will open Terminal and launch Panagram in the Terminal window. Click on the scheme named Panagram in the toolbar and select New Scheme:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/SelectNewScheme.png" alt></li></ol><p>Name the new scheme <code>Panagram on Terminal</code>:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/NameNewScheme.png" alt></p><p>Ensure the Panagram on Terminal scheme is selected as the active scheme. Click the scheme and select Edit Scheme… in the popover.<br>Ensure that the Info tab is selected and then click on the Executable drop down and select Other. Now, find the Terminal.app in your Applications/Utilities folder and click Choose. Now that Terminal is your executable, uncheck Debug executable.<br>Your Panagram on Terminal scheme’s Info tab should look like this:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/TerminalScheme-650x368.png" alt></p><blockquote><p>Note: The downside is that you can’t debug your app in Xcode this way because now the executable that Xcode launches during a run is Terminal and not Panagram.</p></blockquote><p>Next, select the Arguments tab, then add one new argument:<br><code>${BUILT_PRODUCTS_DIR}/${FULL_PRODUCT_NAME}</code><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/passed_arguments2-480x118.png" alt><br>Finally, click Close.<br>Now, make sure you have the scheme <code>Panagram on Terminal</code> selected, then build and run your project. Xcode will open Terminal and pass through the path to your program. Terminal will then launch your program as you’d expect.<br><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/Finished_Program-e1458913657510-700x267.png" alt></p><h2 id="终端启动命令行APP"><a href="#终端启动命令行APP" class="headerlink" title="终端启动命令行APP"></a>终端启动命令行APP</h2><p>Open Terminal from your Applications/Utilities folder.<br>In the Project Navigator select your product under the Products group. Copy your debug folder’s Full Path from Xcode’s Utility area as shown below (do not include “Panagram”):<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/BuildFullPath.png" alt><br>Open a Finder window and select the Go/Go to Folder… menu item and paste the full path you copied in the previous step into the dialog’s text field:<br>Click Go and Finder navigates to the folder containing the Panagram executable:<br>Drag the Panagram executable from Finder to the Terminal window and drop it there. Switch to the Terminal window and hit Return on the keyboard. Terminal launches Panagram in interactive mode since no arguments were specified:<br><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/Finished_Program-e1458913657510-700x267.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift直接调用Python函数库</title>
      <link href="/2018/10/16/swift/Swift%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Python%E5%87%BD%E6%95%B0%E5%BA%93/"/>
      <url>/2018/10/16/swift/Swift%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Python%E5%87%BD%E6%95%B0%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-PerfectlySoft-Perfect-Python-63589be" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-PerfectlySoft-Perfect-Python-63589be", "PerfectlySoft", "Perfect-Python", "63589be", false);</script><h1 id="Perfect-Python"><a href="#Perfect-Python" class="headerlink" title="Perfect - Python"></a>Perfect - Python</h1><p>本项目提供了在Swift服务器应用上直接引用Python 2.7函数库的简便方法。</p><p>本项目采用Swift Package Manager 软件包管理器编译，是<a href="https://github.com/PerfectlySoft/Perfect" target="_blank" rel="noopener">Perfect</a> 项目的一部分，但是也可以独立运行</p><p>在使用之前请准备好最新的Swift 4.1.2 工具链</p><h2 id="Linux-编译事项"><a href="#Linux-编译事项" class="headerlink" title="Linux 编译事项"></a>Linux 编译事项</h2><p>首先请确保 libpython2.7-dev 已经在 Ubuntu 16.04 上正确安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="MacOS-编译事项"><a href="#MacOS-编译事项" class="headerlink" title="MacOS 编译事项"></a>MacOS 编译事项</h2><p>请确定 Xcode 9.0 以上版本已经正确安装</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>首先在Package.swift中增加依存关系：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.package(url: <span class="string">"https://github.com/PerfectlySoft/Perfect-Python.git"</span>, </span><br><span class="line">from: <span class="string">"3.2.0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意在编译目标段落需要追加：</span></span><br><span class="line">.target(</span><br><span class="line"><span class="comment">// name: "your project name",</span></span><br><span class="line">dependencies: [<span class="string">"PerfectPython"</span>, <span class="string">"PythonAPI"</span>]),</span><br></pre></td></tr></table></figure><p>然后将下列头文件导入Swift源代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PythonAPI</span><br><span class="line"><span class="keyword">import</span> PerfectPython</span><br></pre></td></tr></table></figure><p>请注意在任何程序调用之前，必须调用<code>Py_Initialize()</code>函数初始化python嵌入环境：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Py_Initialize</span>()</span><br></pre></td></tr></table></figure><h3 id="导入Python函数库模块"><a href="#导入Python函数库模块" class="headerlink" title="导入Python函数库模块"></a>导入Python函数库模块</h3><p>使用 <code>PyObj</code> 类对象用于导入python模块。下列参考范例中，一个名为<code>/tmp/clstest.py</code>的脚本被动态导入到当前Swift运行环境：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pymod = <span class="keyword">try</span> <span class="type">PyObj</span>(path: <span class="string">"/tmp"</span>, <span class="keyword">import</span>: "clstest")</span><br></pre></td></tr></table></figure><h3 id="访问Python变量"><a href="#访问Python变量" class="headerlink" title="访问Python变量"></a>访问Python变量</h3><p>导入模块后，您可以使用<code>PyObj.load()</code>函数加载任何一个变量；也可以反过来用 <code>PyObj.save()</code>命令保存当前变量为一个新的值。</p><p>比如，以下python脚本中有个叫做 <code>stringVar</code> 的字符串变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringVar = <span class="string">'Hello, world'</span></span><br></pre></td></tr></table></figure><p>那么要取得这个字符串的值只需要这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = pymod.load(<span class="string">"stringVar"</span>)?.value <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="comment">// 会打印变量的字符串值 "Hello, world!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时您还可以为该变量直接写入新的字符串值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> pymod.save(<span class="string">"stringVar"</span>, newValue: <span class="string">"Hola, 🇨🇳🇨🇦！"</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 目前，Perfect-Python仅支持如下Swift / Python数据类型自动转换：</p><table><thead><tr><th>Python 类型</th><th>Swift 类型</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>Int</td><td></td></tr><tr><td>float</td><td>Double</td><td></td></tr><tr><td>str</td><td>String</td><td></td></tr><tr><td>list</td><td>[Any]</td><td>递归转换</td></tr><tr><td>dict</td><td>[String:Any]</td><td>递归转换</td></tr></tbody></table><p>比如，您可以把一个字符串 <code>String</code> 转换为 <code>PyObj</code>，通过 <code>let pystr = &quot;Hello&quot;.python()</code> 或者 <code>let pystr = try PyObj(value:&quot;Hello&quot;)</code> 完成转换。</p><p>反过来，如果要把 <code>PyObj</code> 类转换为Swift数据类型，比如字符串，则仍然有两种方法：<code>let str = pystr.value as? String</code> 和 <code>let str = String(python: pystr)</code>。</p><h3 id="执行Python函数"><a href="#执行Python函数" class="headerlink" title="执行Python函数"></a>执行Python函数</h3><p>方法 <code>PyObj.call()</code> 用于带参数执行某个python函数。以如下python脚本为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymul</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line"><span class="keyword">return</span> num1 * num2</span><br></pre></td></tr></table></figure><p>Perfect-Python 可以用下列方法封装并调用以上函数，您所需要注意的仅仅是其函数名称以及参数。其中函数名称用字符串代替，而参数用一个数组表达：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> res = pymod.call(<span class="string">"mymul"</span>, args: [<span class="number">2</span>,<span class="number">3</span>])?.value <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment">// 结果为 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python类对象"><a href="#Python类对象" class="headerlink" title="Python类对象"></a>Python类对象</h3><p>请同样使用 <code>PyObj.load()</code> 函数用于家在Python类对象，但是注意后面一定要紧跟一个<code>PyObj.construct()</code> 用于初始化类对象实例。该方法同样支持用一个任意类型的数组作为参数进行对象构造。</p><p>假设如下脚本的典型python类对象 <code>Person</code>，该类有两个属性姓名<code>name</code> 和年龄<code>age</code>，还有一个名为“自我介绍”的类对象方法<code>intro()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intro</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Name: '</span> + self.name + <span class="string">', Age: '</span> + str(self.age)</span><br></pre></td></tr></table></figure><p>在Swift中初始化上述类对象的方法需要进行以下两步走：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> personClass = pymod.load(<span class="string">"Person"</span>),</span><br><span class="line"><span class="keyword">let</span> person = personClass.construct([<span class="string">"rocky"</span>, <span class="number">24</span>]) &#123;</span><br><span class="line"><span class="comment">// person is now the object instance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以访问类实例的属性变量和方法了，如同上文所提到的普通变量和函数调用的方法一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = person.load(<span class="string">"name"</span>)?.value <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line"><span class="keyword">let</span> age = person.load(<span class="string">"age"</span>)?.value <span class="keyword">as</span>? <span class="type">Int</span>,</span><br><span class="line"><span class="keyword">let</span> intro = person.call(<span class="string">"intro"</span>, args: [])?.value <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(name, age, intro)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>参考以下python代码，此时如果执行 <code>x = caller(&#39;Hello&#39;, callback)</code> 则可以将函数作为参数进行回调:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(msg)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'callback: '</span> + msg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caller</span><span class="params">(info, func)</span>:</span></span><br><span class="line"><span class="keyword">return</span> func(info)</span><br></pre></td></tr></table></figure><p>在Swift中等效的代码平淡无奇，只不过将待调函数作为参数而已：:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fun = pymod.load(<span class="string">"callback"</span>),</span><br><span class="line"><span class="keyword">let</span> result = pymod.call(<span class="string">"caller"</span>, args: [<span class="string">"Hello"</span>, fun]),</span><br><span class="line"><span class="keyword">let</span> v = result.value <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="comment">// 结果是 "callback: Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000010917250" target="_blank" rel="noopener">你没看错：Swift可以直接调用Python函数库</a></p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift调用AppleScript脚本和Shell脚本</title>
      <link href="/2018/10/16/swift/Swift%E8%B0%83%E7%94%A8AppleScript%E8%84%9A%E6%9C%AC%E5%92%8CShell%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/10/16/swift/Swift%E8%B0%83%E7%94%A8AppleScript%E8%84%9A%E6%9C%AC%E5%92%8CShell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是AppleScript作为互通的桥梁。</p><h2 id="NSTask调用AppleScript"><a href="#NSTask调用AppleScript" class="headerlink" title="NSTask调用AppleScript"></a>NSTask调用AppleScript</h2><h3 id="用Process-原NStask-进行调用main-scpt脚本"><a href="#用Process-原NStask-进行调用main-scpt脚本" class="headerlink" title="用Process(原NStask)进行调用main.scpt脚本"></a>用<code>Process</code>(原<code>NStask</code>)进行调用<code>main.scpt</code>脚本</h3><ol start="2"><li>swift两种方式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">let</span> process = <span class="type">Process</span>()</span><br><span class="line">process.launchPath = <span class="string">"/usr/bin/osascript"</span></span><br><span class="line">process.arguments = [<span class="string">"~/Desktop/main.scpt"</span>]</span><br><span class="line">process.launch()</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">NSBundle</span>.mainBundle()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scriptPath = bundle.pathForResource(<span class="string">"main"</span>, ofType: <span class="string">"scpt"</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> paths = [scriptPath]</span><br><span class="line">    <span class="type">Process</span>.launchedProcess(launchPath: <span class="string">"/usr/bin/osascript"</span>, arguments: paths)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="NSAppleScript调用AppleScript"><a href="#NSAppleScript调用AppleScript" class="headerlink" title="NSAppleScript调用AppleScript"></a>NSAppleScript调用AppleScript</h3><p><code>NSAppleScript</code>语法：<code>do shell script &quot;shell语句&quot;</code>，必须在<code>on run {变量名称，逗号隔开}</code> 以<code>end run</code>结束的闭包里运行。<br>调用APPleScript脚本片段样例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bundle = <span class="type">NSBundle</span>.mainBundle()</span><br><span class="line"><span class="keyword">let</span> videoPath = bundle.pathForResource(<span class="string">"BigBuck"</span>, ofType: <span class="string">"m4v"</span>)</span><br><span class="line"><span class="comment">//https://developer.apple.com/library/mac/technotes/tn2084/_index.html</span></span><br><span class="line"><span class="comment">//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器</span></span><br><span class="line"><span class="keyword">let</span> myAppleScript = <span class="string">"on run\ndo shell script \"open -na /Applications/mpv.app \(videoPath!)\"\ntell application \"mpv\" to activate\n end run"</span></span><br><span class="line"><span class="built_in">print</span>(myAppleScript)</span><br><span class="line"><span class="keyword">var</span> error: <span class="type">NSDictionary?</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scriptObject = <span class="type">NSAppleScript</span>(source: myAppleScript) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> output: <span class="type">NSAppleEventDescriptor</span> = scriptObject.executeAndReturnError(&amp;error) &#123;</span><br><span class="line">        <span class="built_in">print</span>(output.stringValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"error: \(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://stackoverflow.com/questions/25163433/can-you-execute-an-applescript-script-from-a-swift-application" target="_blank" rel="noopener">oc调用AppleScript</a><br><a href="https://stackoverflow.com/questions/25163433/can-you-execute-an-applescript-script-from-a-swift-application" target="_blank" rel="noopener">Can you execute an Applescript script from a Swift Application</a></p><h2 id="AppleScript调用shell"><a href="#AppleScript调用shell" class="headerlink" title="AppleScript调用shell"></a>AppleScript调用shell</h2><p>在<code>NSAppleScript</code>语法中调用shell语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do shell script &quot;shell语句&quot;`</span><br></pre></td></tr></table></figure></p><p>例：运行shell命令<code>open -na /Applications/mpv.app (videoPath!)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on run</span><br><span class="line">    <span class="keyword">do</span> shell script </span><br><span class="line">    <span class="string">"open -na /Applications/mpv.app (videoPath!)"</span></span><br><span class="line">    tell application <span class="string">"mpv"</span> to activate</span><br><span class="line">end run</span><br></pre></td></tr></table></figure></p><h2 id="终端osascript调用AppleScript"><a href="#终端osascript调用AppleScript" class="headerlink" title="终端osascript调用AppleScript"></a>终端<code>osascript</code>调用<code>AppleScript</code></h2><p><a href="http://www.hackmac.org/tutorials/run-applescript-from-the-command-line/" target="_blank" rel="noopener">参考</a></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e 'applescript command' #单引号</span><br></pre></td></tr></table></figure><h3 id="打开Finder窗口"><a href="#打开Finder窗口" class="headerlink" title="打开Finder窗口"></a>打开Finder窗口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e 'tell app "Finder" to make new Finder window'</span><br></pre></td></tr></table></figure><h3 id="打开某个程序同时弹出”Hello-World”提示框"><a href="#打开某个程序同时弹出”Hello-World”提示框" class="headerlink" title="打开某个程序同时弹出”Hello World”提示框"></a>打开某个程序同时弹出”Hello World”提示框</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e <span class="string">'tell app "applicationname" to display dialog "Hello World"'</span></span><br></pre></td></tr></table></figure><h3 id="设置音量，音量大小范围（0-7）"><a href="#设置音量，音量大小范围（0-7）" class="headerlink" title="设置音量，音量大小范围（0-7）"></a>设置音量，音量大小范围（0-7）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e <span class="string">"set volume number"</span></span><br></pre></td></tr></table></figure><h2 id="c语言调用shell"><a href="#c语言调用shell" class="headerlink" title="c语言调用shell"></a>c语言调用shell</h2><p>可以用c语言的<code>#include  system</code><br>函数库：<code>include&lt;stdlib.h&gt;</code><br>函数说明:<br><code>system()</code>会调用<code>fork()</code>产生子进程，由子进程来调用<code>/bin/sh-c string</code>来执行参数<code>string</code>字符串所代表的命令，此命&gt;令执行完后随即返回原调用的进程。在调用<code>system()</code>期间<code>SIGCHLD</code> 信号会被暂时搁置，<code>SIGINT</code>和<code>SIGQUIT</code> 信号则会被忽略。<br>返回值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=-1:出现错误  </span><br><span class="line">=0:调用成功但是没有出现子进程  </span><br><span class="line">&gt;0:成功退出的子进程的id</span><br></pre></td></tr></table></figure></p><p> 如果<code>system()</code>在调用<code>/bin/sh</code>时失败则返回<code>127</code>，其他失败原因返回<code>-1</code>。若参数string为空指针(<code>NULL</code>)，则返回非零值&gt;。如果<code>system()</code>调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 <code>system()</code>调用<code>/bin/sh</code>失败所返回的<code>127</code>，因此最好能再检查<code>errno</code>来确认执行成功。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自动生成icon@2x@1x</title>
      <link href="/2018/10/15/%E5%85%B6%E4%BB%96/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90icon@2x@1x/"/>
      <url>/2018/10/15/%E5%85%B6%E4%BB%96/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90icon@2x@1x/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-rickytan-RTImageAssets-cf0a641" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-rickytan-RTImageAssets-cf0a641", "rickytan", "RTImageAssets", "cf0a641", false);</script><h2 id="自动生成所有所需的应用程序图标"><a href="#自动生成所有所需的应用程序图标" class="headerlink" title="自动生成所有所需的应用程序图标"></a>自动生成所有所需的应用程序图标</h2><p><a href="https://github.com/rickytan/RTImageAssets" target="_blank" rel="noopener">https://github.com/rickytan/RTImageAssets</a><br><a href="http://blog.yuzhuohui.info/2015/04/25/iOS-image-auto-scale-folder-action/index.html" target="_blank" rel="noopener">iOS开发工具：自动生成@2x,@3x图片</a></p><h2 id="IconMaker程序生成icon"><a href="#IconMaker程序生成icon" class="headerlink" title="IconMaker程序生成icon"></a>IconMaker程序生成icon</h2><script src="//gist.github.com/816b7ef296219d14edac.js"></script> <p> 通过原始1024X1024图片来生成各种iphone ios icon，包含Content.json</p><p> <code>IconMaker</code>使用说明：</p><ol><li><p>默认生成到当前目录:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ IconMaker 1024.png   #默认放在当前目录</span><br><span class="line">$ IconMaker 1024.png ~/Desktop/icon/  #生成在指定目录icon中</span><br></pre></td></tr></table></figure></li><li><p>生成结果自动结构如下：<br>|—Images.xcassets/<br>|——AppIcon.appiconset/<br>|———Content.json<br><a href="mailto:|------------con-60@3x.png" target="_blank" rel="noopener">|------------con-60@3x.png</a></p></li><li>拖入xcode即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批量压缩png图片工具</title>
      <link href="/2018/10/15/%E5%85%B6%E4%BB%96/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9png%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/10/15/%E5%85%B6%E4%BB%96/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9png%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><h2 id="pngquant"><a href="#pngquant" class="headerlink" title="pngquant"></a>pngquant</h2><p>使用pngquant批量压缩png</p><ol><li>编写批量处理脚本<br><code>vi compresspng.py</code><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># vim:fenc=utf-8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright © 2018 admin &lt;admin@bogon&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Distributed under terms of the MIT license.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定路径下所有指定后缀的文件</span></span><br><span class="line"><span class="comment"># dir 指定路径</span></span><br><span class="line"><span class="comment"># ext 指定后缀，链表&amp;不需要带点 或者不指定。例子：['xml', 'java']</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFileFromThisRootDir</span><span class="params">(dir, ext = None)</span>:</span></span><br><span class="line">    allfiles = []</span><br><span class="line">    needExtFilter = (ext != <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(dir):</span><br><span class="line">        <span class="keyword">for</span> filespath <span class="keyword">in</span> files:</span><br><span class="line">        filepath = os.path.join(root, filespath)</span><br><span class="line">        extension = os.path.splitext(filepath)[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> needExtFilter <span class="keyword">and</span> extension == ext <span class="keyword">in</span> ext:</span><br><span class="line">            allfiles.append(filepath)</span><br><span class="line"><span class="keyword">return</span> allfiles</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    PngquantExe=<span class="string">"/Users/admin/Downloads/pngquant/pngquant"</span></span><br><span class="line">    srcDir=<span class="string">".../resource/images"</span>     </span><br><span class="line">    imgFiles=GetFileFromThisRootDir(srcDir, <span class="string">'png'</span>)</span><br><span class="line">    suffix=<span class="string">"_temp.png"</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> imgFiles:</span><br><span class="line">    cmd = <span class="string">"\""</span> + PngquantExe + <span class="string">"\""</span> + <span class="string">" --ext "</span> + suffix + <span class="string">" --force --speed=3 "</span>+ f  <span class="comment"># 更多命令https://pngquant.org</span></span><br><span class="line">        os.system(cmd)   <span class="comment"># 执行压缩命令</span></span><br><span class="line">        os.remove(f)     <span class="comment"># 删除旧文件</span></span><br><span class="line">        newfile=f.replace(<span class="string">".png"</span>, suffix) </span><br><span class="line">        os.rename(newfile, f)  <span class="comment"># 重命名压缩过的tmp文件</span></span><br></pre></td></tr></table></figure></li></ol><p><code>PngquantExe</code>：指定pangquant程序路径<br><code>srcDir</code>：指定图集路径</p><ol start="2"><li>运行：<code>python compresspng.py</code></li></ol><p>参考<a href="https://www.jianshu.com/p/260ed2ab5f57" target="_blank" rel="noopener">使用pngquant批量压缩png</a></p><h2 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a>tinypng</h2><p><a href="https://tinypng.com/developers" target="_blank" rel="noopener">https://tinypng.com/developers</a><br><a href="https://www.jianshu.com/p/b15ebd623650" target="_blank" rel="noopener">python 脚本批量处理</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zsh插件之github使用</title>
      <link href="/2018/10/15/git/Zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgithub%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/15/git/Zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgithub%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="github插件"><a href="#github插件" class="headerlink" title="github插件"></a>github插件</h2><p>This plugin supports working with GitHub from the command line. It provides a few things:</p><ul><li>Sets up the <code>hub</code> wrapper and completions for the <code>git</code> command if you have <code>hub</code> installed.</li><li>Completion for the <code>github</code> Ruby gem.</li><li>Convenience functions for working with repos and URLs.</li></ul><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><ul><li><code>empty_gh</code> - Creates a new empty repo (with a <code>README.md</code>) and pushes it to GitHub</li><li><code>new_gh</code> - Initializes an existing directory as a repo and pushes it to GitHub</li><li><code>exist_gh</code> - Takes an existing repo and pushes it to GitHub</li><li><code>git.io</code> - Shortens a URL using <a href="https://git.io" target="_blank" rel="noopener">git.io</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android安装BusyBox</title>
      <link href="/2018/10/15/%E5%85%B6%E4%BB%96/Android%E5%AE%89%E8%A3%85BusyBox/"/>
      <url>/2018/10/15/%E5%85%B6%E4%BB%96/Android%E5%AE%89%E8%A3%85BusyBox/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>大家是否有过这样的经历，在命令行里输入adb shell，然后使用命令操作你的手机或模拟器，但是那些命令都是常见Linux命令的阉割缩水版，用起来很不爽。是否想过在Android上使用较完整的shell呢？用BusyBox吧。不论使用adb连接设备使用命令行还是在手机上直接用terminal emulator都可以。</p><h2 id="什么是BusyBox-？"><a href="#什么是BusyBox-？" class="headerlink" title="什么是BusyBox ？"></a>什么是BusyBox ？</h2><p>BusyBox 是标准 Linux 工具的一个单个可执行实现。BusyBox 包含了一些简单的工具，例如 cat 和 echo，还包含了一些更大、更复杂的工具，例如 grep、find、mount 以及 telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。（摘自百度百科）</p><h2 id="在Android上安装BusyBox"><a href="#在Android上安装BusyBox" class="headerlink" title="在Android上安装BusyBox"></a>在Android上安装BusyBox</h2><p>准备：</p><ol start="0"><li><p>先要把手机给Root了，具体教程这里就不提供了，网上有很多。</p></li><li><p>下载BusyBox的binary，打开这个地址 <a href="http://www.busybox.net/downloads/binaries" target="_blank" rel="noopener">http://www.busybox.net/downloads/binaries</a> ，选择最新版本，然后下载对应你的设备架构的版本，这里我下载了busybox-armv6l，下面将以这个文件名为示例。<br><a href="http://www.cnblogs.com/xiaowenji/archive/2011/03/12/1982309.html" target="_blank" rel="noopener">[Android] 为Android安装BusyBox —— 完整的bash shell</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了解手机处理器ARM</title>
      <link href="/2018/10/15/%E5%85%B6%E4%BB%96/%E4%BA%86%E8%A7%A3%E6%89%8B%E6%9C%BA%E5%A4%84%E7%90%86%E5%99%A8ARM/"/>
      <url>/2018/10/15/%E5%85%B6%E4%BB%96/%E4%BA%86%E8%A7%A3%E6%89%8B%E6%9C%BA%E5%A4%84%E7%90%86%E5%99%A8ARM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。</p><p>Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。</p><p><a href="https://www.jianshu.com/p/567d3b730608" target="_blank" rel="noopener">iOS armv7, armv7s, arm64区别与应用32位、64位配置</a><br><a href="https://blog.csdn.net/hello_haozi/article/details/8073107" target="_blank" rel="noopener">为什么手机多用arm？</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装在android系统</title>
      <link href="/2018/10/15/%E5%85%B6%E4%BB%96/Docker%E5%AE%89%E8%A3%85%E5%9C%A8android%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/15/%E5%85%B6%E4%BB%96/Docker%E5%AE%89%E8%A3%85%E5%9C%A8android%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://stackoverflow.com/questions/25817461/using-docker-on-android" target="_blank" rel="noopener">Using Docker on Android - Stack Overflow</a><br><a href="https://git.io/fx0Oh" target="_blank" rel="noopener">Installing, running, using docker on armhf (ARMv7)devices</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>package_json文件配置说明</title>
      <link href="/2018/10/15/shell/package_json%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/10/15/shell/package_json%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://blog.csdn.net/u011240877/article/details/76582670" target="_blank" rel="noopener">npm 与 package.json 快速入门教程</a><br>每个项目的根目录下一般都有一个package.json文件，定义项目所需要的各种模块，以及项目的配置信息。npm install则是根据这个配置文件，自动下载所需要的模块，也就是配置项目所需的运行和开发环境。<br>package.json文件可以手工编写，也可以用npm init命令自动生成，除了项目名称和项目版本是必填的，其他都是选填的。</p><h2 id="最简单的package-json"><a href="#最简单的package-json" class="headerlink" title="最简单的package.json"></a>最简单的package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;aaa&quot;,       //项目名称</span><br><span class="line">&quot;version&quot;:&quot;0.0.0&quot;   //项目版本(大版本.次要版本.小版本)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package是一个JSON对象，对象的每个成员就是当前项目的一项设置。</p><h3 id="script字段"><a href="#script字段" class="headerlink" title="script字段"></a>script字段</h3><p>script指定运行脚本命令的npm命令行缩写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">    &quot;start&quot;:&quot;node index.js&quot;,</span><br><span class="line">    &quot;test&quot;:&quot;tap test/*.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">//运行npm run start时，执行node index.js命令</span><br><span class="line">//运行npm run test时，执行tap test/*.js命令</span><br></pre></td></tr></table></figure></p><h3 id="dependencies，devDependencies"><a href="#dependencies，devDependencies" class="headerlink" title="dependencies，devDependencies"></a>dependencies，devDependencies</h3><p>dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围</p><p>–save参数表示将该模块写入dependencies属性，<br>–save-dev表示将该模块写入devDependencies属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;devDependencies&quot;:&#123;</span><br><span class="line">        &quot;browserify&quot;:&quot;~13.0.0&quot;,</span><br><span class="line">        &quot;babel-core&quot;:&quot;^6.5.0&quot;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//模块名：对应的版本</span><br></pre></td></tr></table></figure></p><h3 id="对应的版本"><a href="#对应的版本" class="headerlink" title="对应的版本"></a>对应的版本</h3><p>指定版本: 比如1.2.2，安装时只安装指定版本1.2.2</p><p>波浪号(tilde) + 指定版本：比如~1.2.2，表示安装不低于1.2.2的1.2.x最新版本，但是不会安装1.3.x，等于只会影响小版本的版本号。</p><p>插入号(caret) + 指定版本 : 比如^1.2.2，表示安装不低于1.2.2的1.x.x最新版本，但是不会安装2.x.x，等于不会影响大版本号。如果大版本号为0，则插入号和波浪号效果一样，不会改变次要版本号。</p><p>latest:安装最新的版本</p><p>如果一个模块不在package.json文件汇总，则可以单独安装这个模块，并使用相应的参数将其写入package.json中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br><span class="line">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p><p>例如安装上面的express模块，–save表示将模块写入dependencies属性，–save-dev表示将模块写入devDependencies属性。</p><h2 id="注释问题"><a href="#注释问题" class="headerlink" title="注释问题"></a>注释问题</h2><p>package.json就是一个json文件，json本身只是一种数据格式，而不是程序语言，一般程序语言都会支持注释，但作为数据格式，它本身并不支持注释，所以只能通过其他方式绕过了。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>opkg在小米路由器的使用</title>
      <link href="/2018/10/15/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/opkg%E5%9C%A8%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/15/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/opkg%E5%9C%A8%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-openwrt-openwrt-759f111" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-openwrt-openwrt-759f111", "openwrt", "openwrt", "759f111", false);</script><p><a href="https://openwrt.io" target="_blank" rel="noopener">openwrt.io</a><br><a href="https://openwrt.io/docs/miwifi/" target="_blank" rel="noopener">小米路由器固件信息</a></p><p>## </p><p>路由器read-only file system怎么改权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure></p><h1 id="新建配置"><a href="#新建配置" class="headerlink" title="新建配置"></a>新建配置</h1><ol><li><p>备份初始conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/opkg.conf /etc/opkg.conf.bak</span><br></pre></td></tr></table></figure></li><li><p>开始配置<br><code>vim /etc/opkg.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src/gz attitude_adjustment_base http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base</span><br><span class="line">src/gz attitude_adjustment_packages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/packages/</span><br><span class="line">src/gz attitude_adjustment_luci http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/luci/</span><br><span class="line">src/gz attitude_adjustment_management http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/management/</span><br><span class="line">src/gz attitude_adjustment_oldpackages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/oldpackages/</span><br><span class="line">src/gz attitude_adjustment_routing http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/routing/</span><br><span class="line">src/gz openwrt_dist http://openwrt-dist.sourceforge.net/releases/ramips/packages</span><br><span class="line">src/gz openwrt_dist_luci http://openwrt-dist.sourceforge.net/releases/luci/packages</span><br><span class="line">dest root /data</span><br><span class="line">dest ram /tmp</span><br><span class="line">lists_dir ext /data/var/opkg-lists</span><br><span class="line">option overlay_root /data</span><br><span class="line">arch all 100</span><br><span class="line">arch ramips 200</span><br><span class="line">arch ramips_24kec 300</span><br></pre></td></tr></table></figure></li><li><p>更新库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ opkg update</span><br><span class="line">Downloading http://downloads.openwrt.org/..../generic/packages/packages/Packages.gz.</span><br><span class="line">Updated list of available packages in /data/var/opkg-lists/attitude_adjustment.</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：如果下载失败，请确认是否是http而非https。另外如果链接失效可能是更新了包，可以到<a href="https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/搜索libc_找到最新下载地址。" target="_blank" rel="noopener">https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/搜索libc_找到最新下载地址。</a></p></blockquote><p>经过用上操作，opkg就可以正常使用了</p><h3 id="opkg安装命令"><a href="#opkg安装命令" class="headerlink" title="opkg安装命令"></a>opkg安装命令</h3><p><code>opkg install 软件包名</code>:一律安装在/data/usr/bin目录中<br><code>opkg upgrade 软件包名</code>: 升级软件包<br><code>opkg list-installed</code>:查看已经安装的包<br><code>opkg list-upgradable</code>:查看可以升级的包<br><code>opkg update</code> 更新可以获取的软件包列表<br><code>opkg remove 软件包名</code> 卸载已经安装的指定的软件包<br><code>opkg list</code> 获取软件列表</p><ol><li><p>安装基础包libc<em><br>安装其他库的时候，经常会提示错误，缺少`libc</em>`。这里他没办法直接安装，只能手工操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  opkg install http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/libc_0.9.33.2-1_ramips_24kec.ipk</span><br></pre></td></tr></table></figure></li><li><p>接下来就可以安装一些自己需求的软件包:<br>例如：安装git命令工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ opkg install git</span><br></pre></td></tr></table></figure></li><li><p>配置系统环境<br>由于没有配置 /etc/profile,导致：运行命令时，提示no fond<br>例如：#python    no fond</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/data/usr/bin:$PATH</span><br><span class="line">$ source /etc/profile //命令生效</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://www.liwangmeng.com/openwrt基本知识归纳/" target="_blank" rel="noopener">OpenWRT基本知识整理</a></p>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>brew升级git版本</title>
      <link href="/2018/10/13/git/brew%E5%8D%87%E7%BA%A7git%E7%89%88%E6%9C%AC/"/>
      <url>/2018/10/13/git/brew%E5%8D%87%E7%BA%A7git%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew doctor</span><br><span class="line">$ brew install git </span><br><span class="line">$ brew link --overwrite git</span><br><span class="line">Linking /usr/local/Cellar/git/2.19.1... 216 symlinks created</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为Pod的库创建演示文件SwiftPlayground</title>
      <link href="/2018/10/13/macOS/%E4%B8%BAPod%E7%9A%84%E5%BA%93%E5%88%9B%E5%BB%BA%E6%BC%94%E7%A4%BA%E6%96%87%E4%BB%B6SwiftPlayground/"/>
      <url>/2018/10/13/macOS/%E4%B8%BAPod%E7%9A%84%E5%BA%93%E5%88%9B%E5%BB%BA%E6%BC%94%E7%A4%BA%E6%96%87%E4%BB%B6SwiftPlayground/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-asmallteapot-cocoapods-playgrounds-c54b492" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-asmallteapot-cocoapods-playgrounds-c54b492", "asmallteapot", "cocoapods-playgrounds", "c54b492", false);</script><p><a href="https://github.com/asmallteapot/cocoapods-playgrounds/issues/62#issuecomment-427543129" target="_blank" rel="noopener">issues 62</a></p><p><a href="https://www.jianshu.com/p/8e7599c27542" target="_blank" rel="noopener">在playground中优雅的使用Pod</a></p><h1 id="This-Could-Be-Us-But-You-Playing"><a href="#This-Could-Be-Us-But-You-Playing" class="headerlink" title="This Could Be Us But You Playing"></a>This Could Be Us But You Playing</h1><p><a href="https://travis-ci.org/segiddins/ThisCouldBeUsButYouPlaying" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/segiddins/ThisCouldBeUsButYouPlaying/master.svg?style=flat" alt="Build Status"></a></p><p><img src="README_images/alamofire.png" alt></p><p>Generates a Swift Playground for any Pod.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>$ gem install cocoapods-playgrounds</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>To generate a Playground for a specific Pod:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod playgrounds Alamofire</span><br></pre></td></tr></table></figure></p><p>To generate a Playground for a local development Pod:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod playgrounds ../../../Sources/Alamofire/Alamofire.podspec</span><br></pre></td></tr></table></figure></p><p>To generate a Playground with multiple Pods:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod playgrounds RxSwift,RxCocoa</span><br></pre></td></tr></table></figure></p><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><p>To generate a Playground for a Carthage-enabled library:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ carthage-play Alamofire/Alamofire</span><br></pre></td></tr></table></figure></p><p>Note: This currently assumes that libraries are hosted on GitHub.</p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>To generate an empty Playground from the commandline:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ playground --platform=ios YOLO</span><br><span class="line">$ open YOLO.playground</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在playground中执行异步方法</title>
      <link href="/2018/10/13/swift/%E5%9C%A8playground%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/13/swift/%E5%9C%A8playground%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://swifter.tips/playground-delay/" target="_blank" rel="noopener">PLAYGROUND 延时运行</a>引入 Playground 的<code>XCPlayground</code>扩展包框架,其中就包括使 Playground 能延时执行的黑魔法，<code>needsIndefiniteExecution</code>(需要无限期执行)使 Playground 具有延时运行的功能.<br>在实际使用和开发中，我们最经常面临的异步需求可能就是网络请求了，如果我们想要在 Playground 里验证某个 API 是否正确工作的话，使用 XCPlayground 的这个方法开启延时执行也是必要的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://httpbin.org/get"</span>)!</span><br><span class="line"><span class="keyword">let</span> getTask = <span class="type">URLSession</span>.shared.dataTask(with: url <span class="keyword">as</span> <span class="type">URL</span>) &#123;</span><br><span class="line">    (data, response, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> dictionary = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.jsonObject(with: data!, options: [])</span><br><span class="line">    <span class="built_in">print</span>(dictionary)</span><br><span class="line">&#125;</span><br><span class="line">getTask.resume()</span><br></pre></td></tr></table></figure></p><p>之前有30s限制，目前可以无限执行。<br>~~可以通过 Alt + Cmd + 回车 来打开辅助编辑器。在这里你会看到控制台输出和时间轴，将右下角的 30 改成你想要的数字，就可以对延时运行的最长时间进行设定了。 ~~</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装Material主题</title>
      <link href="/2018/10/13/hexo/%E5%AE%89%E8%A3%85Material%E4%B8%BB%E9%A2%98/"/>
      <url>/2018/10/13/hexo/%E5%AE%89%E8%A3%85Material%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://zdran.com/20180326.html" target="_blank" rel="noopener">Hexo + Material + Github 搭建博客与配置</a><br><!--github库卡片--><br><div id="badge-container-viosey-hexo-theme-material-d93c5a8" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-viosey-hexo-theme-material-d93c5a8", "viosey", "hexo-theme-material", "d93c5a8", false);</script></p><p>注意！ 在主题的开发迭代过程中，主题的配置文件模板 可能会改动。为了避免使用 git pull 更新主题的用户出现冲突，我们将 主题配置文件模板 命名为 <code>_config.template.yml</code>。配置主题时，你应该拷贝一份 <code>_config.template.yml</code> 并将其重命名为 <code>_config.yml</code>。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><a href="https://github.com/viosey/hexo-theme-material/issues/688" target="_blank" rel="noopener">issues/688</a><br>在主题文件夹下新建一个_config.yml文件，并将_config.template.yml里的配置复制到_config.yml文件。<br>修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% &#125; else if(theme.comment.use.startsWith(&quot;disqus&quot;)) &#123; %&gt;</span><br><span class="line">// to</span><br><span class="line">&lt;% &#125; else if(theme.comment.use &amp;&amp; theme.comment.use.startsWith(&quot;disqus&quot;)) &#123; %&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ERROR /Users/kai/Code/hexoBlog/themes/material/layout/layout.ejs:3</span><br><span class="line">1| </span><br><span class="line">2| &lt;html style=&quot;display: none;&quot; &lt;% if(config.language !== null) &#123; %&gt;lang=&quot;&lt;%- config.language.substring(0,2) %&gt;&quot;&lt;% &#125; %&gt;&gt;</span><br><span class="line"></span><br><span class="line">3| &lt;%- partial(&apos;_partial/head&apos;) %&gt;</span><br><span class="line">4|</span><br><span class="line">5| &lt;% if(page.layout === &apos;gallery&apos;) &#123; %&gt;</span><br><span class="line">6|</span><br><span class="line">/Users/kai/Code/hexoBlog/themes/material/layout/_partial/head.ejs:22</span><br><span class="line">20|</span><br><span class="line">21|</span><br><span class="line"></span><br><span class="line">22| &lt;%- partial(&apos;_widget/dnsprefetch&apos;) %&gt;</span><br><span class="line">23|</span><br><span class="line">24| </span><br><span class="line">25|</span><br><span class="line">/Users/kai/Code/hexoBlog/themes/material/layout/_widget/dnsprefetch.ejs:2</span><br><span class="line">1|</span><br><span class="line"></span><br><span class="line">2| &lt;% if(theme.vendors.materialcdn) &#123; %&gt;</span><br><span class="line">3| </span><br><span class="line">4| &lt;% &#125; %&gt;</span><br><span class="line">5| &lt;% if( (theme.leancloud.enable === true) || (theme.comment.use == &quot;valine&quot;) ) &#123; %&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo作图插件</title>
      <link href="/2018/10/13/hexo/hexo%E4%BD%9C%E5%9B%BE%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/10/13/hexo/hexo%E4%BD%9C%E5%9B%BE%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;hexo-filter-flowchart&quot;: &quot;^1.0.4&quot;,</span><br><span class="line">&quot;hexo-filter-sequence&quot;: &quot;^1.0.3&quot;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#作图插件</span><br><span class="line">sequence:</span><br><span class="line">#  webfont: https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js</span><br><span class="line">#  snap: https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js</span><br><span class="line">#  underscore: https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js</span><br><span class="line">#  sequence: https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js</span><br><span class="line">#  css: # optional, the url for css, such as hand drawn theme</span><br><span class="line">options:</span><br><span class="line">theme: simple</span><br><span class="line">css_class:</span><br><span class="line">flowchart:</span><br><span class="line"># raphael:   # optional, the source url of raphael.js</span><br><span class="line"># flowchart: # optional, the source url of flowchart.js</span><br><span class="line">options: # options used for `drawSVG`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客生成restful风格的json数据源</title>
      <link href="/2018/10/12/hexo/%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90restful%E9%A3%8E%E6%A0%BC%E7%9A%84json%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/2018/10/12/hexo/%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90restful%E9%A3%8E%E6%A0%BC%E7%9A%84json%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://npm.taobao.org/package/hexo-generator-restful" target="_blank" rel="noopener">hexo-generator-restful</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">## API接口：以下为默认配置，属性值为 false 表示不生成。</span><br><span class="line">restful:  #http://npm.taobao.org/package/hexo-generator-restful</span><br><span class="line"># site 可配置为数组选择性生成某些属性</span><br><span class="line"># site: [&apos;title&apos;, &apos;subtitle&apos;, &apos;description&apos;, &apos;author&apos;, &apos;since&apos;, email&apos;, &apos;favicon&apos;, &apos;avatar&apos;]</span><br><span class="line">site: false        # hexo.config mix theme.config</span><br><span class="line">posts_size: 10    # 文章列表分页，0 表示不分页</span><br><span class="line">posts_props:      # 文章列表项的需要生成的属性</span><br><span class="line">title: false</span><br><span class="line">slug: false</span><br><span class="line">date: false</span><br><span class="line">updated: false</span><br><span class="line">comments: false</span><br><span class="line">path: false</span><br><span class="line">excerpt: false</span><br><span class="line">cover: false      # 封面图，取文章第一张图片</span><br><span class="line">content: false</span><br><span class="line">keywords: false</span><br><span class="line">categories: false</span><br><span class="line">tags: false</span><br><span class="line">categories: false  # 分类数据</span><br><span class="line">tags: false        # 标签数据</span><br><span class="line">post: false        # 文章数据</span><br><span class="line">pages: false      # 额外的 Hexo 页面数据, 如 About</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git-lfs命令工具使用</title>
      <link href="/2018/10/12/git/git-lfs%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/12/git/git-lfs%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-git-lfs-git-lfs-45c4568" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-git-lfs-git-lfs-45c4568", "git-lfs", "git-lfs", "45c4568", false);</script><p><a href="https://git-lfs.github.com" target="_blank" rel="noopener">git-lfs官网</a><br>LFS其实是git的一个扩展，并没有改变git的工作方式，有点像耍了个小花招，把指定需要lfs管理的文件替换成了一个指针文件交给git进行版本管理；<br>在pull/push等这些操作中，lfs又通过lfs服务器把这些文件的真身给下载或上传回来；<br>通过这样的手段，使得本地仓库的体积大大减小，而不会出现随着这些文件的版本增多而体积剧烈膨胀的情况；<br>个人觉得这种把存储负担转移给了服务器的做法，是不是有违git去中心化的理念，毕竟lfs这样做其实算是强依赖于这个lfs服务器了，本地仓库并不是一个完整的仓库</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="http://macappstore.org/git-lfs/" target="_blank" rel="noopener">安装</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure><h3 id="配置git库支持git-lfs"><a href="#配置git库支持git-lfs" class="headerlink" title="配置git库支持git-lfs"></a>配置git库支持git-lfs</h3><ol><li>Git命令行扩展工具<code>git-lfs</code>,您只需设置一次<code>Git LFS</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置库支持</span><br><span class="line">git lfs install</span><br><span class="line">#删除库支持</span><br><span class="line">git lfs uninstall</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>当使用gitee时，push远程库：WARNING: Authentication error: Authentication required: not a enterprise project </p><ol start="2"><li>配置<code>.gitattribute</code>文件，添加需要<code>Git LFS</code>管理的文件类型。也可<code>track</code>命令添加其他类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line">git lfs track &quot;*.psd&quot;</span><br><span class="line"># 查看规则</span><br><span class="line">git lfs track</span><br><span class="line"># 查看跟踪的文件清单</span><br><span class="line">git lfs ls-files</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="3"><li><p>确保跟踪<code>.gitattributes</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure></li><li><p>像往常一样提交并推送到GitHub。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file.psd</span><br><span class="line">git commit -m &quot;Add design file&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gist命令工具使用</title>
      <link href="/2018/10/12/git/gist%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/12/git/gist%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-defunkt-gist-8d86604" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-defunkt-gist-8d86604", "defunkt", "gist", "8d86604", false);</script><p><a href="http://macappstore.org/gist/" target="_blank" rel="noopener">按照gist</a></p><h3 id="安装gist"><a href="#安装gist" class="headerlink" title="安装gist"></a>安装gist</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gist</span><br></pre></td></tr></table></figure><h3 id="创建gist"><a href="#创建gist" class="headerlink" title="创建gist"></a>创建gist</h3><p>上传<code>a.rb</code>中的代码段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist a.rb</span><br></pre></td></tr></table></figure></p><p>上传多个文件<code>a.rb</code>,<code>b.rb</code>,<code>c.rb</code>的代码段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gist a b c</span><br><span class="line">gist *.rb</span><br></pre></td></tr></table></figure></p><p>作为文件上传：获取<code>STDIN</code>数据，并使用<code>-f</code>指定文件名<code>test.rb</code>上传：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -f test.rb &lt;a.rb</span><br></pre></td></tr></table></figure></p><p>直接从剪切板上传文本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -P</span><br></pre></td></tr></table></figure></p><p>设置隐私片段 <code>-p</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -p a.rb</span><br></pre></td></tr></table></figure></p><p>添加片段描述信息<code>-d</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -d &quot;Random rbx bug&quot; a.rb</span><br></pre></td></tr></table></figure></p><p>更新现有的片段 <code>-u</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gist -u GIST_ID FILE_NAME</span><br><span class="line">例子：</span><br><span class="line">gist -u 42f2c239d2eb57299408 test.txt</span><br></pre></td></tr></table></figure></p><p>‌If you’d like to copy the resulting URL to your clipboard, use <code>-c</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -c &lt;a.rb</span><br></pre></td></tr></table></figure></p><p>‌If you’d like to copy the resulting embeddable URL to your clipboard, use <code>-e</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -e &lt;a.rb</span><br></pre></td></tr></table></figure></p><p>打开浏览器访问片段 <code>-o</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist -o &lt;a.rb</span><br></pre></td></tr></table></figure></p><p>‌To list (public gists or all gists for authed user) gists for user<br><code>gist -l</code> : all gists for authed user<br><code>gist -l defunkt</code> : list defunkt’s public gists<br>To read a gist and print it to STDOUT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gist -r GIST_ID</span><br><span class="line">例子：</span><br><span class="line">gist -r 374130</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>‌See <code>gist --help</code> for more detail.</p><h4 id="使用gist命令"><a href="#使用gist命令" class="headerlink" title="使用gist命令"></a>使用gist命令</h4><h4 id="使用gistit快捷工具"><a href="#使用gistit快捷工具" class="headerlink" title="使用gistit快捷工具"></a>使用gistit快捷工具</h4><div id="badge-container-jrbasso-gistit-99fc659" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-jrbasso-gistit-99fc659", "jrbasso", "gistit", "99fc659", false);</script><ol><li><p><a href="http://macappstore.org/gistit/" target="_blank" rel="noopener">安装</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gistit</span><br></pre></td></tr></table></figure></li><li><p><a href="http://gistit.herokuapp.com" target="_blank" rel="noopener">使用说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Creating a public gist from other app response</span><br><span class="line">ls | gistit</span><br><span class="line"></span><br><span class="line"># Creating a private gist from other app response</span><br><span class="line">ls | gistit -priv</span><br><span class="line"></span><br><span class="line"># Specifying the gist filename</span><br><span class="line">ls | gistit -i list.txt</span><br><span class="line"></span><br><span class="line"># Sending files</span><br><span class="line">gistit file.txt</span><br><span class="line"></span><br><span class="line"># Sending multiple files in a private gist</span><br><span class="line">gistit -priv file1.txt file2.c</span><br><span class="line"></span><br><span class="line"># Setting gist description</span><br><span class="line">gistit -d &quot;This is just a sample&quot; sample.txt</span><br><span class="line"></span><br><span class="line"># Setting gist description, private and with multiple files</span><br><span class="line">gistit -d &quot;Sample&quot; -priv file1.txt file2.txt file3.txt</span><br><span class="line"></span><br><span class="line"># Help</span><br><span class="line">gistit -h</span><br><span class="line"></span><br><span class="line"># Version</span><br><span class="line">gistit -v</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>subtree拆分大的git库到多个独立git库</title>
      <link href="/2018/10/09/git/subtree%E6%8B%86%E5%88%86%E5%A4%A7%E7%9A%84git%E5%BA%93%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8Bgit%E5%BA%93/"/>
      <url>/2018/10/09/git/subtree%E6%8B%86%E5%88%86%E5%A4%A7%E7%9A%84git%E5%BA%93%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8Bgit%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://segmentfault.com/a/1190000002548731" target="_blank" rel="noopener">Git 仓库拆拆拆</a></p><h2 id="拆分一个子目录为独立仓库"><a href="#拆分一个子目录为独立仓库" class="headerlink" title="拆分一个子目录为独立仓库"></a>拆分一个子目录为独立仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这就是那个大仓库 big-project</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:tom/big-project.git</span><br><span class="line">$ <span class="built_in">cd</span> big-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有 `codes-eiyo` 目录下的相关提交整理为一个新的分支 eiyo</span></span><br><span class="line">$ git subtree split -P codes-eiyo -b eiyo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另建一个新目录并初始化为 git 仓库</span></span><br><span class="line">$ mkdir ../eiyo</span><br><span class="line">$ <span class="built_in">cd</span> ../eiyo</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取旧仓库的 eiyo 分支到当前的 master 分支</span></span><br><span class="line">$ git pull ../big-project eiyo</span><br></pre></td></tr></table></figure><h2 id="清除一个子目录下所有内容和记录"><a href="#清除一个子目录下所有内容和记录" class="headerlink" title="清除一个子目录下所有内容和记录"></a>清除一个子目录下所有内容和记录</h2><p>这个还是要用万能的 <code>filter-branch</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还是那个大仓库 big-project</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:tom/big-project.git</span><br><span class="line">$ <span class="built_in">cd</span> big-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 `master` 分支上所有跟 `codes-eiyo` 目录有关的痕迹</span></span><br><span class="line">$ git filter-branch --index-filter <span class="string">"git rm -rf --cached --ignore-unmatch codes-eiyo"</span> --prune-empty master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另建一个新目录并初始化为 git 仓库</span></span><br><span class="line">$ mkdir ../big-project-fresh</span><br><span class="line">$ <span class="built_in">cd</span> ../big-project-fresh</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取 `big-project` 的 `master` 分支（到新仓库的 master 分支）</span></span><br><span class="line">$ git pull ../big-project master</span><br></pre></td></tr></table></figure></p><h2 id="推送给新的远端仓库"><a href="#推送给新的远端仓库" class="headerlink" title="推送给新的远端仓库"></a>推送给新的远端仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git://github.com:tom/fresh-project.git</span><br><span class="line">$ git push origin -u master</span><br></pre></td></tr></table></figure><h3 id="git-subtree-合并"><a href="#git-subtree-合并" class="headerlink" title="git subtree 合并"></a>git subtree 合并</h3><p>git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。</p><h4 id="创建合并subtree-add命令"><a href="#创建合并subtree-add命令" class="headerlink" title="创建合并subtree add命令"></a>创建合并subtree add命令</h4><p>命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class="line">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure></p><h5 id="两步走"><a href="#两步走" class="headerlink" title="两步走"></a>两步走</h5><p>先fetch库再subtree add合并</p><ol><li><p>先将依赖库fetch到本地仓库中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建lib的远程版本库: </span><br><span class="line">git init --bare lib-rep</span><br><span class="line"><span class="comment">#-f：远端库添加后立即执行fetch操作</span></span><br><span class="line">git remote add -f librepo ../lib-rep</span><br></pre></td></tr></table></figure></li><li><p>通过git subtree命令将依赖库合并到主项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree add -P lib librepo master</span><br></pre></td></tr></table></figure></li></ol><h5 id="squash合并法"><a href="#squash合并法" class="headerlink" title="squash合并法"></a>squash合并法</h5><p><code>--squash</code>: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p><h4 id="subtree其他命令"><a href="#subtree其他命令" class="headerlink" title="subtree其他命令"></a>subtree其他命令</h4><p>git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'git subtree'</span> pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class="line"><span class="string">'git subtree'</span> push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class="line"><span class="string">'git subtree'</span> merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class="line"><span class="string">'git subtree'</span> split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p><p>从子树库中拉取最新代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p><p>将自己的代码发布到子树库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p><p>相关参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-q | --quiet</span><br><span class="line">-d | --debug</span><br><span class="line">-P &lt;prefix&gt; | --prefix=&lt;prefix&gt;      引用库对应的本地目录</span><br><span class="line">-m &lt;message&gt; | --message=&lt;message&gt;   适用于add/pull/merge子命令。设置产生的合并提交的说明文本</span><br><span class="line">--squash                             适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。</span><br><span class="line">使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246</span><br></pre></td></tr></table></figure></p><p>split子命令选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--annotate=&lt;annotation&gt;              创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。</span><br><span class="line">-b &lt;branch&gt; | --branch=&lt;branch&gt;      创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。</span><br><span class="line">--onto=&lt;onto&gt;</span><br><span class="line">--rejoin</span><br><span class="line">--ignore-joins</span><br></pre></td></tr></table></figure></p><h4 id="使用sourcetree管理"><a href="#使用sourcetree管理" class="headerlink" title="使用sourcetree管理"></a>使用sourcetree管理</h4><ol><li>配置 subtree<br>菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)<br>在左边栏的SUBTREES(子树)中显示：</li><li>拉取依赖库的最新代码<br>在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：<br>第二步的功能代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zsh插件之gi使用说明</title>
      <link href="/2018/10/09/git/zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgi%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/10/09/git/zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgi%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-joeblau-gitignore.io-a09921d" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-joeblau-gitignore.io-a09921d", "joeblau", "gitignore.io", "a09921d", false);</script><h2 id="配置zsh支持插件gi命令"><a href="#配置zsh支持插件gi命令" class="headerlink" title="配置zsh支持插件gi命令"></a>配置zsh支持插件<code>gi</code>命令</h2><ol><li>先浏览<code>oh-my-zsh/plugins</code>目录下支持所有插件,找到<code>gi</code>命令的插件名称：<code>gitignore</code>,即目录名称。</li><li>把<code>gitignore</code>添加到<code>zshrc.zsh-template</code>的插件激活的清单中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 插件设置，如果添加太多启动速度会比较慢</span><br><span class="line">plugins=(git gitignore ruby autojump osx mvn)</span><br></pre></td></tr></table></figure></li></ol><h2 id="gi清单命令使用"><a href="#gi清单命令使用" class="headerlink" title="gi清单命令使用"></a><code>gi</code>清单命令使用</h2><p>再次打开zsh窗口会激活<code>gi</code>命令</p><ul><li><p>list命令<br>打印出<a href="https://www.gitignore.io/" target="_blank" rel="noopener">gitignore.io</a>官网支持语种的所有模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gi list</span><br></pre></td></tr></table></figure></li><li><p>系统全局清单<br>在<code>.gitignore_global</code>文件中添加，忽略当前操作系统中某个<code>IDE</code>工具的忽略清单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gi linux,eclipse &gt;&gt; ~/.gitignore_global</span><br></pre></td></tr></table></figure></li><li><p>Project项目忽略清单<br>在<code>.gitignore</code>文件中添加，配置项目中使用的<code>源码语言</code>的相关忽略清单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gi java,python &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置Podfile支持playground导入库</title>
      <link href="/2018/10/06/macOS/%E9%85%8D%E7%BD%AEPodfile%E6%94%AF%E6%8C%81playground%E5%AF%BC%E5%85%A5%E5%BA%93/"/>
      <url>/2018/10/06/macOS/%E9%85%8D%E7%BD%AEPodfile%E6%94%AF%E6%8C%81playground%E5%AF%BC%E5%85%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="pod支持问题"><a href="#pod支持问题" class="headerlink" title="pod支持问题"></a>pod支持问题</h2><p><a href="http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#" target="_blank" rel="noopener">xcode-playground-with-cocoapods</a><br>You could use <a href="https://github.com/neonichu/ThisCouldBeUsButYouPlaying" target="_blank" rel="noopener">ThisCouldBeUsButYouPlaying</a> or add this to your Podfile<br>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库</p><h2 id="RxSwift资源案例"><a href="#RxSwift资源案例" class="headerlink" title="RxSwift资源案例"></a>RxSwift资源案例</h2><p>在项目中使用<code>RxSwift.Resources.total</code>，提供所有Rx资源分配的计数，这对于在开发期间检测泄漏非常有用。<br>在写入磁盘之前，修改一些工程的配置<a href="https://guides.cocoapods.org/syntax/podfile.html#tab_group_hooks" target="_blank" rel="noopener">post_install hook</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">target &apos;AppTarget&apos; do</span><br><span class="line">    pod &apos;RxSwift&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">post_install do |installer|</span><br><span class="line">    installer.pods_project.targets.each do |target|</span><br><span class="line">        if target.name == &apos;RxSwift&apos;</span><br><span class="line">                target.build_configurations.each do |config|</span><br><span class="line">                    if config.name == &apos;Debug&apos;</span><br><span class="line">                    config.build_settings[&apos;OTHER_SWIFT_FLAGS&apos;] ||= [&apos;-D&apos;, &apos;TRACE_RESOURCES&apos;]</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>Run pod update.<br>Build project (Product → Build).</p><h2 id="post-install-用法"><a href="#post-install-用法" class="headerlink" title="post_install 用法"></a>post_install 用法</h2><p><a href="https://guides.cocoapods.org/syntax/podfile.html#tab_group_hooks" target="_blank" rel="noopener">podfile hook语法</a><br><a href="https://www.jianshu.com/p/9dfd59c7c411" target="_blank" rel="noopener">post_install语法</a><br><a href="https://www.jianshu.com/p/d8eb397b835e" target="_blank" rel="noopener">把玩CocoaPods post_install 和 pre_install</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用gem升级pod方法</title>
      <link href="/2018/10/06/shell/%E4%BD%BF%E7%94%A8gem%E5%8D%87%E7%BA%A7pod%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/06/shell/%E4%BD%BF%E7%94%A8gem%E5%8D%87%E7%BA%A7pod%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="升级cocopods"><a href="#升级cocopods" class="headerlink" title="升级cocopods"></a>升级cocopods</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo gem update --system</span><br><span class="line">gem source -l</span><br><span class="line">pod setup</span><br><span class="line">pod repo update --verbose</span><br><span class="line">sudo gem install cocoapods --pre</span><br><span class="line">sudo gem cleanup</span><br></pre></td></tr></table></figure><p>gem source<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">https://gems.ruby-china.com</span><br><span class="line"># 确保只有 gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><p>腾讯云：<code>https://gems.ruby-china.com/</code><br>淘宝：<code>https://ruby.taobao.org/</code></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设置环境变量的profile与bash_profile区别</title>
      <link href="/2018/10/05/shell/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84profile%E4%B8%8Ebash_profile%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/10/05/shell/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84profile%E4%B8%8Ebash_profile%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="profile文件"><a href="#profile文件" class="headerlink" title="profile文件"></a>profile文件</h2><p>1.1 profile文件的作用<br><strong>profile</strong>(<code>/etc/profile</code>)，用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。当用户登录(login)时，文件会被执行。<br>1.2 在profile中添加环境变量<br>一般不建议在<code>/etc/profile</code>文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。<br>当必须添加时，我们可以按以下方式添加：<br>如，添加一个HOST值为linuxprobe.com的环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HOST=linuxprobe.com</span><br></pre></td></tr></table></figure></p><p>添加时，可以在行尾使用<code>;</code>号，也可以不使用。<br>一个变量名可以对应多个变量值，多个变量值需要使用<code>:</code>进行分隔。<br>添加环境变量后，需要重新登录才能生效，也可以使用<code>source</code>命令强制立即生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>查看是否生效可以使用echo命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $HOST</span><br><span class="line">linuxprobe.com</span><br></pre></td></tr></table></figure></p><h2 id="bashrc文件"><a href="#bashrc文件" class="headerlink" title="bashrc文件"></a>bashrc文件</h2><p><code>bashrc</code>文件用于配置函数或别名。<br><code>bashrc</code>文件有两种级别：系统级的位于<code>/etc/bashrc</code>、用户级的位于<code>~/.bashrc</code>，两者分别会对所有用户和当前用户生效。<br><code>bashrc</code>文件只会对指定的<code>shell</code>类型起作用，<code>bashrc</code>只会被<code>bash shell</code>调用。<br>Mac OS X上的终端bash不读取<code>~/.bashrc</code>，因为Mac OS X上的bash是通过login的方式运行的，而<code>man bash</code>中写着，通过<code>login</code>方式登录的bash不会读取<code>~/.bashrc</code>。<br>解决方法：把下面的代码 添加到 <code>~/.bash_profile</code>中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- lang: shell --&gt;</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p><h2 id="bash-profile文件"><a href="#bash-profile文件" class="headerlink" title="bash_profile文件"></a>bash_profile文件</h2><p><code>bash_profile</code>只对单一用户有效，文件存储位于<code>~/.bash_profile</code>，该文件是一个用户级的设置，可以理解为某一个用户目录下的<code>profile</code>。这个文件同样也可以用于配置环境变量和启动程序，但只针对单个用户有效。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim一般模式下查找和替换命令</title>
      <link href="/2018/10/05/shell/vim%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/05/shell/vim%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="/,?查找命令"></a><code>/</code>,<code>?</code>查找命令</h3><ul><li><code>/word</code> 向下查找word字符串</li><li><code>?word</code>向上查找word字符串<br>组合查找<br><code>n</code>:  代表重复前一个查找的操作<br><code>N</code>:反向进行前一个查找操作  <h3 id="s-old-new-g替换命令"><a href="#s-old-new-g替换命令" class="headerlink" title="s/old/new/g替换命令"></a><code>s/old/new/g</code>替换命令</h3></li></ul><ol><li>行间查找<br>在第n1和n2行查找<code>word1</code>比替换为<code>word2</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1,n2s/word1/word2/g</span><br></pre></td></tr></table></figure></li></ol><p>举例：  <code>：100,200s/vbird/VBIRD/g</code></p><ol start="2"><li>全文查找并替换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$s/word1/word2/g</span><br></pre></td></tr></table></figure></li></ol><p>从第一行到最后一行查找字符串word1字符串，并将字符串word1替换为word2</p><ol start="3"><li>用户确认替换提示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$s/word1/word2/gc</span><br></pre></td></tr></table></figure></li></ol><p>从第一行到最后一行查找字符串word1，并将字符串word1替换为word2,在替换之前提示用户确认是否替换</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本路径和执行的路径区别</title>
      <link href="/2018/10/04/shell/shell%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/10/04/shell/shell%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="获取shell脚本文件的绝对路径"><a href="#获取shell脚本文件的绝对路径" class="headerlink" title="获取shell脚本文件的绝对路径"></a>获取shell脚本文件的绝对路径</h2><p>basepath=$(cd <code>dirname $0</code>; pwd)<br>echo “sh脚本文件的绝对路径：$basepath”</p><h2 id="当前执行脚本的路径"><a href="#当前执行脚本的路径" class="headerlink" title="当前执行脚本的路径"></a>当前执行脚本的路径</h2><p>echo “当前执行脚本的路径也是cd路径打印方法:”<code>pwd</code><br>echo “当前cd的目录名：”<code>basename $(pwd)</code></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift应用登录验证</title>
      <link href="/2018/10/04/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%BA%94%E7%94%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/"/>
      <url>/2018/10/04/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%BA%94%E7%94%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-SimpleValidation-fb7a58b" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-SimpleValidation-fb7a58b", "huos3203", "SimpleValidation", "fb7a58b", false);</script><!--音乐欣赏-->     <div id="aplayer-zwovlHfl" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="0036mZ7Q1pk7st" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><h2 id="使用RxSwift的优点"><a href="#使用RxSwift的优点" class="headerlink" title="使用RxSwift的优点"></a>使用RxSwift的优点</h2><p>RxSwift的目的是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用swift进行响应式编程</p><p>这是一个模拟用户登录的程序。</p><h2 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h2><ol><li>当用户输入用户名时，如果用户名不足 5 个字就给出红色提示语，并且无法输入密码，当用户名符合要求时才可以输入密码。</li><li>同样的当用户输入的密码不到 5 个字时也给出红色提示语。</li><li>当用户名和密码有一个不符合要求时底部的绿色按钮不可点击，只有当用户名和密码同时有效时按钮才可点击。</li><li>当点击绿色按钮后弹出一个提示框，这个提示框只是用来做演示而已。<h3 id="share-replay-1-是用来做什么的？"><a href="#share-replay-1-是用来做什么的？" class="headerlink" title="share(replay: 1)是用来做什么的？"></a><code>share(replay: 1)</code>是用来做什么的？</h3>我们用 <code>usernameValid</code> 来控制用户名提示语是否隐藏以及密码输入框是否可用。<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/operator/shareReplay.md" target="_blank" rel="noopener">shareReplay</a> 就是让他们共享这一个源，而不是为他们单独创建新的源。这样可以减少不必要的开支。</li></ol><p>第一个观察者<code>passwordOutlet.rx_enabled</code>订阅<code>usernameValid</code>时，调用<code>map</code>里的<code>print</code>函数，第二个观察者在订阅时(没有添加<code>.shareReplay(1)</code>)时，又再次调用<code>map</code>里的<code>print</code>函数，以此类推，如果有很多观察者的话就要调用很多次，而从第二个观察者开始需要的只是<code>map</code>返回的一个序列，而不是让其徒劳地调用<code>map</code>里的函数，那么怎样解决在多个观察者订阅时多次重复调用执行的问题？<br>使用<code>shareReplay(bufferSize: Int)</code>就ok了。<br><code>shareReplay</code>会返回一个新的事件序列，它监听底层序列(这里指的是map返回的序列)的事件，并且通知自己的订阅者们。不过和传统的订阅不同的是，它是通过『重播』的方式通知自己的订阅者，因此在这里通过<code>shareReplay</code>订阅的<code>map</code>并不会调用多次。<br>// 参数bufferSize指的是重播的最大元素个数，因为usernameValid是一个只有一个元素的序列observable，因此shareReplay参数为1；假如对于一个有5个元素的序列，你只需要重复播报最后3个，那么就写成.shareReplay(3)，就酱紫。</p><h3 id="disposed-by-disposeBag-是用来做什么的？"><a href="#disposed-by-disposeBag-是用来做什么的？" class="headerlink" title="disposed(by: disposeBag) 是用来做什么的？"></a><code>disposed(by: disposeBag)</code> 是用来做什么的？</h3><p>和我们所熟悉的对象一样，每一个绑定也是有生命周期的。并且这个绑定是可以被清除的。<code>disposed(by: disposeBag)</code>就是将绑定的生命周期交给 <code>disposeBag</code> 来管理。当 <code>disposeBag</code> 被释放的时候，那么里面尚未清除的绑定也就被清除了。这就相当于是在用 <code>ARC</code> 来管理绑定的生命周期。 这个内容会在 <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/disposable.html" target="_blank" rel="noopener">Disposable</a> 章节详细介绍。</p><h3 id="bindTO-简单使用"><a href="#bindTO-简单使用" class="headerlink" title="bindTO 简单使用"></a>bindTO 简单使用</h3><p>我的理解就是将已经信号源去用一个<code>UIBindingObserver</code>去接受,当接收到的属性是<code>true</code>进行相应的操作<br>为登录按钮写一个rx_click的拓展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">///首先写一个UIBindingObserver</span><br><span class="line">var rx_click:AnyObserver&lt;Bool&gt; &#123;</span><br><span class="line">return UIBindingObserver.init(UIElement: self, binding: &#123; (lab, result) in</span><br><span class="line">lab.backgroundColor = result ? UIColor.blue:UIColor.gray</span><br><span class="line">&#125;).asObserver()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//*bindto 信号合并处理  bindto发送信号</span><br><span class="line">//              combineLatest(合并信号)                       bind(订阅)</span><br><span class="line">//   observer -----------------------&gt;处理信号时间-------------&gt;处理信号</span><br><span class="line">///然后手机号11位 验证码 6位就可以用这一行代码解决</span><br><span class="line">let _ = Observable.combineLatest(phoneobser, passobserver, resultSelector: &#123;</span><br><span class="line">$0 &amp;&amp; $1</span><br><span class="line">&#125;).bind(to: canclik.rx_click)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自动初始化Gitalk和Gitment评论</title>
      <link href="/2018/10/04/hexo/%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk%E5%92%8CGitment%E8%AF%84%E8%AE%BA/"/>
      <url>/2018/10/04/hexo/%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk%E5%92%8CGitment%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.jianshu.com/p/9be29ed2f4b7" target="_blank" rel="noopener">Hexo添加Gitalk评论插件</a><br><a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">自动初始化 Gitalk 和 Gitment 评论</a><br><a href="https://madordie.github.io/post/blog-gitment-auto-setup/" target="_blank" rel="noopener">Gitment/Gitalk自动初始化</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Heroku部署web服务器</title>
      <link href="/2018/10/03/hexo/Heroku%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/10/03/hexo/Heroku%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://devcenter.heroku.com/articles/heroku-cli#download-and-install" target="_blank" rel="noopener">安装Heroku CLI工具</a><br>Mac端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install heroku/brew/heroku</span><br></pre></td></tr></table></figure></p><p><a href="https://devcenter.heroku.com/articles/heroku-cli-commands" target="_blank" rel="noopener">Heroku CLI 命令</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heroku -h</span><br><span class="line">heroku login</span><br></pre></td></tr></table></figure></p><ol><li><p><a href="https://devcenter.heroku.com/articles/creating-apps" target="_blank" rel="noopener">Creating Apps from the CLI</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir example</span><br><span class="line">$ cd example</span><br><span class="line">$ git init</span><br><span class="line">$ heroku apps:create example</span><br><span class="line">Creating ⬢ example... done</span><br><span class="line">https://example.herokuapp.com/ | https://git.heroku.com/example.git</span><br><span class="line">Git remote heroku added</span><br></pre></td></tr></table></figure></li><li><p><a href="https://devcenter.heroku.com/articles/heroku-cli-commands#heroku-apps-info" target="_blank" rel="noopener">查看现有APP信息</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heroku apps      //所有应用列表</span><br><span class="line">heroku apps:info //查看所有应用的详细信息</span><br></pre></td></tr></table></figure></li><li><p><a href="https://devcenter.heroku.com/articles/heroku-cli-commands#heroku-apps-open-path" target="_blank" rel="noopener">在浏览器中访问APP页面</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USAGE</span><br><span class="line">$ heroku apps:open [PATH]</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">-a, --app=app        (required) app to run command against</span><br><span class="line">-r, --remote=remote  git remote of app to use</span><br><span class="line"></span><br><span class="line">EXAMPLES</span><br><span class="line">$ heroku open -a myapp</span><br><span class="line"># opens https://myapp.herokuapp.com</span><br><span class="line"></span><br><span class="line">$ heroku open -a myapp /foo</span><br><span class="line"># opens https://myapp.herokuapp.com/foo</span><br></pre></td></tr></table></figure></li></ol><h2 id="用例：在heroku上部署gh-oauth-server服务"><a href="#用例：在heroku上部署gh-oauth-server服务" class="headerlink" title="用例：在heroku上部署gh-oauth-server服务"></a>用例：在heroku上部署<code>gh-oauth-server</code>服务</h2><p><a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">issues:object ProgressEvent</a><br>下载服务器源代码<a href="https://github.com/imsun/gh-oauth-server" target="_blank" rel="noopener">gh-oauth-server</a> ,由于是<code>nodejs</code>写的所以需要安装<code>nodejs</code>环境 如何安装自己Google; 然后<code>git clone</code> 该项目并进入目录, 执行<code>npm install</code> 安装依赖, 依赖安装成功后执行<code>npm start</code>, 如果输出<code>start on port 300</code>表示开启成功,;为了支持<code>ssl</code> 可以安装<code>nginx代理</code>, 这个可以自己百度, 有很多教程的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/imsun/gh-oauth-server</span><br><span class="line">cd gh-oauth-server</span><br><span class="line">heroku create gitment-hexo   //创建herokua应用</span><br><span class="line">git push heroku master       //会自动安装package.json依赖库。</span><br><span class="line">heroku open -a gitment-hexo  //浏览器打开</span><br></pre></td></tr></table></figure></p><h2 id="进入heroku服务器命令行"><a href="#进入heroku服务器命令行" class="headerlink" title="进入heroku服务器命令行"></a>进入heroku服务器命令行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$heroku run bash</span><br><span class="line">Running `bash` attached to terminal... up, run.3052</span><br><span class="line">~ $ ls</span><br><span class="line">Procfile  README.md  composer.json  composer.lock  vendor  views  web</span><br><span class="line">~ $ exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs#prepare-the-app" target="_blank" rel="noopener">Getting Started on Heroku with Node.js</a><br><a href="https://devcenter.heroku.com/articles/preparing-a-codebase-for-heroku-deployment" target="_blank" rel="noopener">把已经存在的应用部署到heroku上</a>learn how to prepare it for Heroku deployment.</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo集成gitment评论系统</title>
      <link href="/2018/10/03/hexo/hexo%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/03/hexo/hexo%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="安装gitment"><a href="#安装gitment" class="headerlink" title="安装gitment"></a>安装<code>gitment</code></h3><p>在<code>package.json</code>文件添加gitment依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;gitment&quot;: &quot;^0.0.3&quot;</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><h3 id="申请应用"><a href="#申请应用" class="headerlink" title="申请应用"></a>申请应用</h3><p>首先去<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">New OAuth App</a>为你的博客应用一个密钥:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name:随便写</span><br><span class="line">Homepage URL:这个也可以随意写,就写你的博客地址就行</span><br><span class="line">Application description:描述,也可以随意写</span><br><span class="line">Authorization callback URL:这个必须写你的博客地址</span><br></pre></td></tr></table></figure></p><p>申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>下面就是配置<code>Gitment</code>,主要编辑在<code>themes/next/_config.yml</code>:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">    count: true # Show comments count in post meta area</span><br><span class="line">    lazy: false # Comments lazy loading with a button</span><br><span class="line">    cleanly: false # Hide 'Powered by ...' on footer, and more</span><br><span class="line">    language: # Force language, or auto switch by theme</span><br><span class="line">    github_user: &#123;you github user id&#125;</span><br><span class="line">    github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue</span><br><span class="line">    client_id: &#123;刚才申请的ClientID&#125;</span><br><span class="line">    client_secret: &#123;刚才申请的Client Secret&#125;</span><br><span class="line">    proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">    redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure></p><h3 id="开通评论"><a href="#开通评论" class="headerlink" title="开通评论"></a>开通评论</h3><p>注意到这里基本上已经OK了,再看你的博客应该可以显示评论了.不过每篇博客都需要你手动初始化评论功能(如果你的历史博客很多那就一篇一篇去点吧，不过貌似有人写了批量处理脚本,没试过哈).</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">object ProgressEvent</a><br>由于引入的 gitment.js 中有这样的一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_utils.http.post(<span class="string">'https://gh-oauth.imsun.net'</span>, &#123;</span><br><span class="line">        code: code,</span><br><span class="line">        client_id: client_id,</span><br><span class="line">        client_secret: client_secret</span><br><span class="line">    &#125;, <span class="string">''</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        _this.accessToken = data.access_token;</span><br><span class="line">        _this.update();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        _this.state.user.isLoggingIn = <span class="literal">false</span>;</span><br><span class="line">        alert(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>请求了一个服务接口，由于这个跨域服务接口是作者自己搭建的，已经停止了。<br>有博主 fork 源作者的 repo ，在这个基础上改的，修改了一些地方接入自己通用的服务<a href="https://github.com/jjeejj/CORS-Proxy-Server" target="_blank" rel="noopener">CORS-Proxy-Server</a>.<br>现在直接把这个文件 <code>https://imsun.github.io/gitment/dist/gitment.browser.js</code> 替换为 <code>https://www.wenjunjiang.win/js/gitment.js</code> 就可以了.<br>原理：<br>hexo 这个评论接了一个自己写的一个通用的跨域服务 <code>https://cors.wenjunjiang.win/</code> github地址为：<code>https://github.com/jjeejj/CORS-Proxy-Server</code>，代替作者的 <code>https://gh-oauth.imsun.net</code> 这个接口地址，去请求 github的接口。 可以自己搭建，可以转发所有的前端跨域服务。要注意的是： 在向 github 请求 <code>access_token</code>时 需要带上<code>Accept: application/json</code> 或者<code>Accept: application/xml</code>请求头， 否则回报 406 的错误.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.wenjunjiang.win/2017/07/02/gitment%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%85%A5hexo/" target="_blank" rel="noopener">gitment评论模块接入hexo</a><br><a href="https://xiaotiandi.github.io/publicBlog/2018-09-19-d196c9ad.html" target="_blank" rel="noopener">hexo博客配置-添加评论系统-gitment和valine-需注册</a><br><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">Gitment：使用 GitHub Issues 搭建评论系统</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Instrument使用Signposts工具</title>
      <link href="/2018/10/03/%E8%B0%83%E8%AF%95/Instrument%E4%BD%BF%E7%94%A8Signposts%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/10/03/%E8%B0%83%E8%AF%95/Instrument%E4%BD%BF%E7%94%A8Signposts%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。</p><p>我们知道开发更好的工具，并让开发者使用这些工具，是我们帮助您成为更高效的开发人员的方法之一。所以今天我们要谈谈其中的一个工具——<code>Signposts</code>（路标）。</p><h2 id="介绍Signposts及历史"><a href="#介绍Signposts及历史" class="headerlink" title="介绍Signposts及历史"></a>介绍Signposts及历史</h2><p><code>Signposts</code>是<code>OSLog</code>家族的新成员，我们正准备让它支持<code>iOS</code>和<code>macOs</code>。您可以在swift和C中使用它们，但最酷的是我们把它和<code>Instruments</code>集成在了一起。这就意味着<code>Instruments</code>可以获取<code>Signposts</code>所产生的数据，并且让深入你理解你的程序正在做什么。</p><p>首先要介绍一点历史，几年前我们介绍了<code>OSLog</code>。这是我们现代化的呈现日志记录的工具。这是我们从系统中获取调试信息的方法。它是在我们“效率”、“隐私”的目标下完成的。具体了解，请查看<a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank" rel="noopener">WWDC 2016 Unified Logging and Activity Tracing</a>。</p><p>这里你可以看到一个<code>OSLog</code>的例子，创建一个简单的日志句柄，并且像它发送了一个Hello world。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let logHandle = OSLog(subsystem: &quot;com.example.widget&quot;, category: &quot;Setup&quot;)</span><br><span class="line">os_log(.info, log: logHandle, &quot;Hello, %&#123;public&#125;s!&quot;, world)</span><br></pre></td></tr></table></figure></p><p><code>Signposts</code>扩展了<code>OSLogAPI</code>，但它们是为性能用例而做的。这意味着它们正在传达与性能相关的信息，并且它们与我们的开发工具集成在一起，您可以使用<code>Signposts</code>对代码进行标注，然后启动<code>Instruments</code>查看类似的内容。因此，<code>Instruments</code>向您展示了您的程序正在做的事情的可视化时间轴，以及<code>Signposts</code>展示在上面。然后底部有个表，统计汇总和分析<code>Signposts</code>数据，数据分成一块一块的，可以让您看到程序到底做了些什么。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/1.jpg" alt><br>在文章中，我将谈谈如何在您的代码中使用<code>Signposts</code>，以及展示一下他们的作用。然后展示<code>Instruments</code>中<code>Signposts</code>的可视化界面，让您了解<code>Instruments</code>和<code>Signpost</code>是如何协同工作的。</p><h2 id="使用Signposts"><a href="#使用Signposts" class="headerlink" title="使用Signposts"></a>使用Signposts</h2><ol><li><code>Siginposts</code>的两个函数:<code>os_signpost(.begin, ...)</code>和<code>os_signpost(.end, ...)</code>.</li><li>日志句柄:<code>日志句柄</code>需要两个参数一个是<code>子系统</code>，一个是<code>类别</code>.<br>让我们从一个非常基础的例子开始。想象一下这是你的应用。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/2.jpg" alt><br>你要研究的就是一个接口特定部分刷新所需要的时间。你知道你需要加载一些图片并在屏幕上展示。所以，在这个简单、抽象的视图中，可能你需要做的就是获取图片资源。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/3.jpg" alt><br>所有操作完成后，界面会刷新。<code>Signposts</code>允许我们在一系列工作的<code>开始</code>和<code>结尾</code>进行标记，然后将这两个时间点关联起来，同时这两个日志事件也会互相关联。这就需要调用<code>Siginposts</code>的两个函数。<code>os_signpost(.begin, ...)</code>和<code>os_signpost(.end, ...)</code>。图中<code>b</code>箭头代表开始，<code>e</code>箭头代表结束。然后我们将这两个时间点互相关联，让您了解这一段经过的时间。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/4.jpg" alt><br>在代码中，有一个简单的算法实现，对于我们接口中的每个元素，我们将获取该资源，这正是我们想要去测量的。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</span><br><span class="line">    fetchAsset(<span class="keyword">for</span>: element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因此，为了将<code>Signposts</code>代码加入到基本的代码中，我们需要导入<code>import os</code>模块，然后由于<code>Siginposts</code>是<code>OSLog</code>的一部分，所以我们需要创建一个<code>日志句柄</code>。这个<code>日志句柄</code>需要两个参数一个是<code>子系统</code>，一个是<code>类别</code>。</p><ul><li>子系统: 在整个项目中可能都是相同的，它看起来很像您的app的包名。它代表了组件或者软件，或者是您正在使用的框架。</li><li>类别: 用于关联，将相关的操作或者<code>Signposts</code>绑定在一起。之后我们会讲到这么做的好处。</li></ul><p>当我们拥有了日志句柄，我们只需要调用<code>Siginposts</code>的<code>.begin</code>和<code>.end</code>两个函数即可。参数中，我们将日志句柄传递过去，然后再传递一个<code>Signpost</code>的名字。名字是一个字符串，用来标识我们感兴趣的操作的时间间隔。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.signpost</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</span><br><span class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">    fetchAsset(<span class="keyword">for</span>: element)</span><br><span class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/5.jpg" alt><br>所以返回之前的时间轴，它就变成了这个样子。在每次开始、结束获取资源时，我们都添加了一个<code>路标</code>。因为在开始和结束的路标的标识一样，所以我们可以将他们两者匹配在一起。但是，如果我们还想要测试整个操作的全部时间，整个刷新过程是怎样的，该如何去做呢？我们在代码中，只需要再添加一对新路标即可（新的名字）。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.signpost</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</span><br><span class="line"></span><br><span class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</span><br><span class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">    fetchAsset(<span class="keyword">for</span>: element)</span><br><span class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">&#125;</span><br><span class="line">os_signpost(.end, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</span><br></pre></td></tr></table></figure></p><p>这时，我们的时间轴又发生了变化。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/6.jpg" alt></p><h3 id="异步用例：测量异步任务的时间"><a href="#异步用例：测量异步任务的时间" class="headerlink" title="异步用例：测量异步任务的时间"></a>异步用例：测量异步任务的时间</h3><ol><li><code>Signpost IDs</code>路标ID:区分重叠时间间隔的方法，将告诉系统哪些是相同类型的操作，但每个操作彼此不同。</li><li>上面是一个很简单的例子。如果你的应用顺序执行第一步、第二步、第三步等等，那么这样测量是非常有效的。但是我们会经常用到一些异步的工作，他们可能同时发生，他们之间也可能会有重叠或者交叉。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/7.jpg" alt><br>在这种情况下，我们需要向系统提供一些额外的信息，以便系统可以将这些路标彼此区分开来。到现在为止，我们在调用方法的时候只用到了名字，通过名字将相同路标的绑定在一起。名字已经确定了时间间隔，但是没有给我们一种区分重叠时间间隔的方法，所以在这里引入了<code>Signpost IDs</code>。路标ID将告诉系统哪些是相同类型的操作，但每个操作彼此不同。在路标开始和结尾传递相同的id，则系统知道这两个是关联的。你可以通过日志句柄来得到一个路标ID。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spid = <span class="type">OSSignpostID</span>(log: refreshLog)</span><br><span class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID: spid)</span><br><span class="line"><span class="comment">//  some code or even async...</span></span><br><span class="line">os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID: spid)</span><br></pre></td></tr></table></figure></li></ol><p>同样你也可以通过一个对象来得到<code>日志句柄</code>。如果你有一些对象代表您正在尝试的工作，只要您使用该对象实例就会生成相同的路标ID。这就意味着您不用去存放路标ID，只需要通过对象去管理ID就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let spid = OSSignpostID(log: refreshLog, object: element)</span><br></pre></td></tr></table></figure></p><p>在视觉上，您可以将路标ID视为允许我们向每一个路标调用传递一些额外的上下文，这可以将特定操作的开始和结束标记互相关联。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/8.jpg" alt><br>这很重要，因为这些操作不仅仅可以重叠，而且通常他们需要的时间也不同。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/9.jpg" alt><br>我们现在把示例中的<code>fetchAsset</code>从同步调用改为异步调用。并且由于是异步的，这些时间间隔可能会相互重叠，所以我们还要在创建路标时加上路标ID。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> spidForRefresh = <span class="type">OSSignpostID</span>(log: refreshLog)</span><br><span class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Refresh Panel"</span>, signpostID: spidForRefresh)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</span><br><span class="line">    <span class="comment">//通过对象去创建路标ID</span></span><br><span class="line">    <span class="keyword">let</span> spid = <span class="type">OSSignpostID</span>(log: refreshLog, object: element)</span><br><span class="line">    <span class="comment">//通过ID去记录一个路标</span></span><br><span class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID:spid)    </span><br><span class="line">    fetchAssetAsync(<span class="keyword">for</span>: element) &#123;</span><br><span class="line">        <span class="comment">//每一个完成之后的回调</span></span><br><span class="line">        os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID: spid)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  全部完成完成的回调</span></span><br><span class="line">notifyWhenDone &#123;</span><br><span class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Refresh Panel"</span>, signpostID: spidForRefresh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了，您可以将<code>Signposts</code>视为一种分类或等级制度。所有的操作都通过日志句柄相关联，这意味着日志分类。然后对我们感兴趣的每个操作，我们给它一个路标名字，如果可能有重叠，我们在给他们<code>路标ID</code>，告诉系统虽然名字相同了，但是我希望通过ID区分。</p><p>这个接口设计的特别灵活，所以你可以控制起始点和结束点的所有参数，日志句柄，路标名字及ID。只要传递的参数是一致的，起始点与结束点就可以对应上，即便他们写在了不同的方法或者文件中。我们之所以这样做是因为希望您能够将它应用到实际开发中。</p><h3 id="在Signposts中添加元数据"><a href="#在Signposts中添加元数据" class="headerlink" title="在Signposts中添加元数据"></a>在Signposts中添加元数据</h3><p>您可能希望在路标中传达一些额外的信息，额外的性能相关的信息。很巧，我们有一个方法来为路标添加元数据。下面是一个基本的路标。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_signpost(.begin, log: log, name: <span class="string">"Compute Physics"</span>)</span><br></pre></td></tr></table></figure></p><p>我们可以添加一个额外的<code>字符串</code>（OSLog格式化的）参数。这允许您向开始点与结束点添加一些上下文。我们可以通过<code>%d</code>来传递<code>整数</code>。当然也可以传递<code>其他的格式化类型</code>的参数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os_signpost(.begin, log: log, name: <span class="string">"Compute Physics"</span>, <span class="string">"%d %d %d %d"</span>,x1, y1, x2, y2)</span><br><span class="line">os_signpost(.begin, log: log, name: <span class="string">"Compute Physics"</span>,<span class="string">"%&#123;public&#125;s %.1f %.1f %.2f %.1f %.1f"</span>, description, x1, y1, m, x2, y2)</span><br></pre></td></tr></table></figure></p><p>至于字符串的长度，不用担心，您可以自由、随意的使用。该字符串也会全部渲染到Instruments的界面中，或者仍然可以在程序中访问附加的数据。</p><h3 id="添加独立事件"><a href="#添加独立事件" class="headerlink" title="添加独立事件"></a>添加独立事件</h3><p>除了元数据之外，您可能还希望及时添加单独的时间点。这就表示，除了开始的路标以及结尾的路标外，你可能还有一个路标，该路标没有连接到特定的时间间隔，而是一些固定的时刻。为此，我们提供了一个带有事件类型的路标。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/10.jpg" alt><br>用法与设置开始、结束的路标类似，只不过它标识一个单一的时间点。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os_signpost(.event, log: log, name: <span class="string">"Fetch Asset"</span>, <span class="string">"Fetched first chunk, size %u"</span>, size)</span><br><span class="line">os_signpost(.event, log: log, name: <span class="string">"Swipe"</span>, <span class="string">"For action 0x%x"</span>, actionCode)</span><br></pre></td></tr></table></figure></p><p>您可以在间隔的上下文中使用该方法，或者一些您想追踪的与用户交互无关等时间间隔无关的内容。如果您真的在调查一个性能上的问题，您可能会大量使用它。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/11.jpg" alt></p><h2 id="有条件启动Signposts"><a href="#有条件启动Signposts" class="headerlink" title="有条件启动Signposts"></a>有条件启动Signposts</h2><ol><li>路标通常默认是开启<br>如果你启用了一些路标，那么他们通常默认是开启的，但我想谈谈有条件的打开和关闭它们。首先我要强调一下，路标是轻量级的。这说明我们已经做了很多优化。我们通过编译器优化来完成这些工作，这些优化在编译时就做了，而不是在运行时完成的。我们还推迟了很多工作，以便他们在Instruments后端完成。这意味着路标应该占用很少的系统资源。我们之所有这样做是因为我们希望尽量减少对您代码的影响。我们也做到了这一点，因为我们确保即使您的时间跨度非常小，也可以发出许多路标来获取一些细粒度的测量结果。</li><li>关闭路标<br>但您可能希望能够关闭路标。要做到一这点，我们将利用<code>OSLog</code>的功能，即禁用的<code>日志句柄</code>。禁用的<code>日志句柄</code>也是一个简单的句柄。它的作用是针对该句柄进行的每个<code>OSLog</code>和<code>os_signpost</code>调用都会几乎会变为无操作。事实上，如果你在C中采用这个，我们甚至会对你进行检查，然后我们甚至不会评估其余的参数。所以你可以在运行时更改这个句柄。</li></ol><p>举个例子，让我们回到第一个示例的代码上。我以一个环境变量作为条件，来初始化。如果包含该变量，那么使用普通的<code>os日志构造函数</code>；如果不包含，那么将使用禁用的<code>日志句柄</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> refreshLog: <span class="type">OSLog</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">ProcessInfo</span>.processInfo.environment.keys.<span class="built_in">contains</span>(<span class="string">"SIGNPOSTS_FOR_REFRESH"</span>) &#123;</span><br><span class="line">    refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    refreshLog = .disabled</span><br><span class="line">&#125;</span><br><span class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</span><br><span class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">    fetchAsset(<span class="keyword">for</span>: element)</span><br><span class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</span><br><span class="line">&#125;</span><br><span class="line">os_signpost(.end, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</span><br></pre></td></tr></table></figure></p><p><code>环境变量</code>是您在调试程序时可以在<code>Xcode scheme</code>中设置的内容。现在我说你不必在调用中进行更改，但这种方式相当昂贵并且只适用于调试时。因此如果您有一些基于<code>Instruments</code>的特定的功能，你可以检查特定的<code>日志句柄</code>，查看它是否打开了<code>siginposts enabled</code>属性。然后试用该属性来控制添加该附加操作。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> refreshLog.signpostsEnabled &#123;</span><br><span class="line">    <span class="keyword">let</span> information = copyDescription() os_signpost(..., information)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C语言中的Signposts"><a href="#C语言中的Signposts" class="headerlink" title="C语言中的Signposts"></a>C语言中的Signposts</h2><p>上面我们所有示例都是swift的，但是C语言中也提供了路标。到目前为止，上述功能都是可用的：长句柄、使用不用的路标、以及管理路标标识符。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/12.jpg" alt><br>那些对C语言中使用路标感兴趣的人，推荐你们阅读头文件中的文档。文档中包含了所有信息，都是从C语言开发人员的角度考虑的。</p><h2 id="Instruments中使用路标"><a href="#Instruments中使用路标" class="headerlink" title="Instruments中使用路标"></a>Instruments中使用路标</h2><p>现在介绍完如何在代码中应用<code>路标</code>，接下来很开心为大家介绍<code>路标</code>和<code>Instruments</code>是如何在一起工作的。向大家展示<code>Instruments 10</code>中三个重要的新功能，来帮助您使用路标数据。</p><ul><li>路标工具:该工具允许您记录、查看和分析应用程序中所有的路标活动。</li><li>兴趣点:谈谈什么是兴趣点，以及何时您要设置一个兴趣点</li><li>自定义工具: 介绍新的自定义工具，以及如何将它与路标一起使用，以获得更精致的路标展示。<h3 id="路标"><a href="#路标" class="headerlink" title="路标"></a>路标</h3>接下来就看下例子吧。示例的app名叫开拓者，主要是展示一些风景。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/13.jpg" alt><br>当我们滚动时，最初展示一个白色的背景，当图片下载完之后，会填充到白色背景区域。这是一种常见的设计，尽管这样设计可以提升一些用户体验，但很难分析它的性能，因为在这个过程中进行了很多异步的活动。如果用户快速滚动，那么有可能出现某个单元格还没有下载完毕之前，就已经要被重用了，那么就必须取消下载。如果不取消的话，可能会有几个并行下载，而展示出来的图也不一定是我们想要的（图和标题不对应）。接下来看看如何通过路标来分析这个应用吧。<br>首先，在每个单元格中，有一个<code>startImageDownload</code>方法。当我们需要下载图片时会调用它，并传递要下载图片的名字。方法内部，有一个图片下载类，我们通过图片名字和设置自己为委托来初始化该类。在这种情况下，由于<code>downloader</code>对象代表正在进行的并发活动，因为下载是异步的，所以可以通过<code>downloader</code>来创建一个<code>路标ID</code>。接着在下载开始之前，调用<code>os_signpost(.begin，...)</code>方法，设置<code>日志句柄</code>、<code>名称</code>、<code>ID</code>、以及一些元数据。然后开始下载图片，并且将<code>downloader</code>设置为当前单元格正在运行的下载器。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/14.jpg" alt><br>图片下载完毕的回调中将图片展示到屏幕上，然后调用<code>os_siginpost(.end, ...</code>方法，设置<code>日志句柄</code>、<code>名称</code>、<code>ID</code>、以及一些元数据。您会注意到，我们用<code>xcode:size-in-bytes</code>注释了这个参数。它的作用是告诉<code>Xcode</code>和<code>Instruments</code>这个参数应该被视为展示和分析字节大小。这种被称作为<code>工程类型</code>。可以<code>Instruments</code>开发人员帮助文档中找到他们的详细介绍。最后，我们下载完毕了，将下载器设置为空。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/15.jpg" alt><br>当然下载除了成功以外，还有失败的情况，在单元格准备重用时，进行相关的路标设置。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/16.jpg" alt><br>设置完之后，就可以来进行分析了。打开Instruments后，可以选择一个空白的文档。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/17.jpg" alt><br>然后从右侧添加中选择os_signpost工具，并推动到轨迹中。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/18.jpg" alt><br>接下来就可以在app中操作了，一阵操作猛如虎之后，我们回到<code>Instruments</code>来看一下。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/20.jpg" alt><br>通过选择某一段时间，可以查看这段时间内的情况。我们可以看到左侧的路标名称<code>Background Image</code>，以及右侧的一些使用元数据来注释的时间段。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/19.jpg" alt><br>现在再缩小然后看看其他未知的追踪，我们注意到我们最多只有五个并行下载图片的任务，这是一件好事，证明我们取消了。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/21.jpg" alt><br>查看底部间隔的摘要，我们看到是按照类别、路标的名字、开始的消息和结束的消息来区分的。我们来看一共触发了93次的图片下载请求。其中location1触发了12次，7次取消，5次下载成功，下载成功时间共计3.04秒，3.31MB。并且可以查看每次请求时间的最小值、最大值和平均值。如果对某类数据感兴趣，可以点击进入查看详细内容。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/22.jpg" alt><br>如果要查看元数据相关的内容，可以进行筛选，然后查看数据。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/23.jpg" alt><br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/24.jpg" alt><br>这是一种很好的方式来查看您通过元数据传达的值的统计分析.<h3 id="兴趣点"><a href="#兴趣点" class="headerlink" title="兴趣点"></a>兴趣点</h3>接下里，我们看看<code>兴趣点</code>。回到应用，我们我们在主页点击一个单元格，就会进入详情页面。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/26.jpg" alt><br>如果现在我们每次都能追踪这些详情页面出现的时间就太好了，因为这样我们就可以知道用户正在做什么，并且我们知道用户在app中的哪个页面。当然可以通过路标完成这件事，但是你需要在<code>Instruments</code>中把它拖到轨迹中，并且记录所有的活动。这样有点淡化了导航事件的重要性。所以我们提供了兴趣点。</li></ul><p>点在我们在详情页面的代码中查看<code>viewDidAppear</code>方法，我们通过<code>os_signpost(.event, ...</code>来创建一个<code>路标事件</code>。这个事件要发送到我们创建的称之为<code>兴趣点</code>的<code>日志句柄</code>中。<code>类别</code>设置为<code>兴趣点</code>，这正是<code>Instruments</code>寻找的一个特殊类别。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/27.jpg" alt><br>我们回到再次打开<code>Instruments</code>选择时间分析，会发现自动有了兴趣点这一项。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/28.jpg" alt><br>然后开始录制，从首页进入详情页，选择不同的单元格反复执行，然后返回Instruments，就可以看到这些兴趣点了。<br><img src="https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/29.jpg" alt><br>因此您可以在看到用户在哪个页面，并且将其与其他性能数据相关联。</p><h2 id="自定义Instruments"><a href="#自定义Instruments" class="headerlink" title="自定义Instruments"></a>自定义Instruments</h2><p>视频中，具体没有讲如何创建，如果想了解如何创建的话，可以参考一下<a href="https://developer.apple.com/wwdc18/410" target="_blank" rel="noopener">WWDC 2018 Creating Custom Instruments</a>。<br><a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank" rel="noopener">WWDC 2018 session 405</a><br>转自<a href="https://blog.csdn.net/tugele/article/details/81252603" target="_blank" rel="noopener">使用日志记录来衡量性能</a></p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode10新特性</title>
      <link href="/2018/10/02/xcode/Xcode10%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/10/02/xcode/Xcode10%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Xcode 10<br>Xcode 10在macOS Mojave的黑暗模式下看起来非常棒，也让你很容易在macOS应用程序中采用新的外观。Xcode 10测试版包括Swift 4.2和beta sdk，适用于iOS 12、watchOS 5、tvOS 12和macOS Mojave。</p><h2 id="Dark模式界面和Mac程序支持"><a href="#Dark模式界面和Mac程序支持" class="headerlink" title="Dark模式界面和Mac程序支持"></a>Dark模式界面和Mac程序支持</h2><ul><li><p>全新的<code>dark</code>外观贯穿<code>Xcode</code>和<code>Instruments</code><br>在终端中输入命令，Xcode10开启dark mode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode NSWindowDarkChocolate -bool true</span><br></pre></td></tr></table></figure><p>  使用低版本的macOS,使用此命令可能会造成Xcode interface损坏(测试系统 macOS High Sierra<br>  10.13.4),只能使用macOS Mojave 10.14+才能使用暗黑模式</p></li><li><p><code>Asset catalogs</code>为自定义<code>colors assets</code> 和 <code>image assets</code> 添加了深色和浅色变体，支持不同的图像与颜色assets的亮暗与高对比度表现。<br>支持CarPlay assets.<br>支持ARKit 3D ARReferenceObject assets.<br>Asset目录与视图调试器(view debugger)的背景可以被明确设定成亮或暗，这样前景的元素就会明显看出来。</p></li><li><code>Interface Builder</code>支持<code>dark</code>和<code>light</code>预览之间切换<br>调试您的Mac应用程序在黑暗或光明的变种，而不改变OS设置<h2 id="Source-Control"><a href="#Source-Control" class="headerlink" title="Source Control"></a>Source Control</h2></li></ul><ol><li>在共享服务器上的本地存储库或上游的更改直接在编辑器中突出显示。乍一看，你会发现:<br>修改代码。<ul><li>更改尚未推入共享存储库。</li><li>其他人已经做出了上游的改变。源编辑器(source editor)会显示出某个开发者做出的改变并展示其他开发者做出的还未添加到项目中的改变。</li><li>在承诺之前，你应该解决冲突。<br>支持Atlassian Bitbucket提供的云托管和自托管Git服务器，以及与现有GitHub支持一起使用的GitLab。<br>Xcode提供了在从存储库中提取最新版本的代码时重新设置更改的基础。<br>如果需要，将生成SSH密钥，并将其上载到服务提供者。<h2 id="编辑器的改进"><a href="#编辑器的改进" class="headerlink" title="编辑器的改进"></a>编辑器的改进</h2></li></ul></li></ol><ul><li>在代码编辑器中放置多个游标，以便同时进行许多更改。<br>Xcode 10 Source Editor现在支持多光标编辑，允许你快速同时编辑多范围的代码。你可以通过多种方式放置额外的光标，包括鼠标点击方式<code>⌃+⇧+Click</code>，或通过选择列<code>⌥+Click+Drag</code>，或通过键盘的<code>⌃+⇧+Up</code>选择上一列，或<code>⌃+⇧+Down</code>选择下一列。</li><li>代码折叠带现在可以隐藏任何被大括号包围的代码块。</li><li>Over-scroll功能可以方便地将屏幕中间的最后几行代码居中。</li><li>库(Library)内容从Inspector区的底部移动到了一个重叠窗口中，这个窗口可以移动或调整大小，就像Spotlight search一样。在拖动物品时它会解除，但在拖动前按住Option键，它就会为一个额外的拖动保持开启。<h2 id="Playgrounds支持机器学习"><a href="#Playgrounds支持机器学习" class="headerlink" title="Playgrounds支持机器学习"></a>Playgrounds支持机器学习</h2></li><li><code>REPL-like</code> model 立即重新运行您现有的playground代码。</li><li>代码运行到指定的行，或键入<code>shift-return</code>来运行刚刚添加的代码。</li><li>import<a href="https://developer.apple.com/machine-learning/build-a-model/" target="_blank" rel="noopener">Create ML  Framework</a>以交互式地培训新模型，然后在playground上编写代码的测试模型。完成后，将模型拖放到应用程序中。<h2 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h2></li><li><code>Debugging symbols</code>从新设备下载的速度比以前快了五倍。</li><li>Xcode将生成一组完全相同的模拟器，以充分利用多核Mac的优势，并通过风扇测试并行运行，以更快的速度完成测试套件。</li><li>以随机或线性顺序运行测试。</li><li>Instruments工具会自动显示添加到代码中的OSLog路标。</li><li>构建并共享您自己的定制<code>instruments package</code>，为您自己的代码提供独特的数据可视化和分析。</li><li><code>Memory</code>内存调试器使用紧凑的布局，以便更容易地研究内存图。</li><li><code>Metal shader</code>调试器允许您轻松地检查顶点、片段、计算和平铺着色器代码的执行。</li><li><code>Metal dependency viewer</code>可以预览在你的<code>Metal-based</code>应用程序中如何使用资源的详细图表。</li><li>Xcode的视图调试器添加了一个选项，可以选择亮暗canvas背景色。<br>你可以改变你macOS应用运行时的外观，通过使用<code>Debug &gt; View Debugging &gt; Appearance menu</code>，或调试栏中的<code>Override Appearance</code>菜单，或接触栏(touch bar)<br>检查器(inspector)中展示的已命名颜色在调试时会显示它们的名字以及它们是否为系统颜色。<h2 id="构建性能"><a href="#构建性能" class="headerlink" title="构建性能"></a>构建性能</h2></li><li><p>默认情况下启用<code>New build system</code>，改进了整个系统的性能。<br>Xcode 10使用了一个新的创建系统。新创建系统提供了更好的可靠性与创建性能，它可以获取项目配置问题，而legacy创建系统则不能。<br>Legacy创建系统在Xcode 10中依旧可用。要想使用的话，在File &gt; Project/Workspace Settings页选择它。为legacy创建系统配置过的项目会在Activity View显示一个橘黄锤子标签</p></li><li><p>Swift编译器构建每个单独的文件要快得多。</p></li><li>使用<code>incremental build setting</code>增量构建设置时，用于调试的大型Swift项目的构建速度要快得多。<br><a href="https://www.ithome.com.tw/news/123646" target="_blank" rel="noopener">《WWDC》Xcode 10也有暗黑模式，現在整合GitLab程式碼託管服務</a><br><a href="https://blog.csdn.net/u010960265/article/details/80630118" target="_blank" rel="noopener">Xcode10新功能新内容（Beta版下载链接）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SPM搭建Perfect模版服务器</title>
      <link href="/2018/10/02/macOS/SPM%E6%90%AD%E5%BB%BAPerfect%E6%A8%A1%E7%89%88%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/10/02/macOS/SPM%E6%90%AD%E5%BB%BAPerfect%E6%A8%A1%E7%89%88%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Perfect简介"><a href="#Perfect简介" class="headerlink" title="Perfect简介"></a>Perfect简介</h2><div id="badge-container-PerfectlySoft-Perfect-60e44e4" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-PerfectlySoft-Perfect-60e44e4", "PerfectlySoft", "Perfect", "60e44e4", false);</script><p>目前比较流行服务端框架主要有<code>Vapor</code>、<code>Perfect</code>、<code>Kitura</code>和<code>Zewo</code>，他们各有长短，本人这次主要是使用<code>Perfect</code>来写的，因为<code>Perfect</code>的功能比较完善，在GitHub上具有1W+的星，而且有一个非常重要的原因提供了<a href="https://github.com/PerfectlySoft/PerfectDocs/blob/master/README.zh_CN.md" target="_blank" rel="noopener">Perfect 中文文档</a>。</p><p><strong>Perfect</strong> 包括了您所期待的所有基本功能，包括<code>路由</code>、<code>websockets</code> 基于 HTTP 的网络套接字、<code>TLS</code>（SSL）通信加密、<code>Mustache</code> 模板和 <code>Markdown</code> 模板、<code>JSON</code> 结构化数据等等，以及全部其他所有 Swift 后台框架加在一起才有的 XML 结构化数据、苹果推送消息 <code>APNS</code>、<code>MqTT</code> 消息队列和 <code>SMTP</code> 邮件发送，甚至大数据也支持。Perfect 的数据库支持非常广泛，其<strong>原生SQL驱动</strong>包括 <code>MySQL</code>、<code>SQLite</code>、<code>PostgreSQL</code> 和 <code>MariaDB</code>，还支持 <code>MongoDB</code>、<code>Redis</code>、<code>CouchDB</code> 甚至还包括 <code>FileMaker</code>（苹果自己的数据库 Swift 都不支持，Perfect 反过来支持——译者注）。<strong>Perfect</strong> 据说还部分支持微软的 <code>ODBC</code>，即多种数据库的底层兼容界面——有点像 <code>ORM</code>，但是以 C 函数库为基础。提到 <code>ORM</code> 数据库对象关系自动化管理，<strong>Perfect</strong>有 <code>StORM</code> 并完整实现了 <code>PostgreSQL</code>、<code>MySQL</code>、<code>CouchDB</code> 和 <code>SQLite</code>。</p><p><a href="https://github.com/PerfectlySoft/PerfectDocGenerator" target="_blank" rel="noopener">Perfect文档生成器</a></p><h2 id="搭建HTTP服务器"><a href="#搭建HTTP服务器" class="headerlink" title="搭建HTTP服务器"></a>搭建HTTP服务器</h2><div id="badge-container-huos3203-PerfectTemplate-20294e56" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-PerfectTemplate-20294e56", "huos3203", "PerfectTemplate", "20294e56", false);</script><p>本章将引导您使用Swift和Perfect软件框架逐步设置一个简单的HTTP服务器。</p><h3 id="创建Web应用"><a href="#创建Web应用" class="headerlink" title="创建Web应用"></a>创建Web应用</h3><p><a href="https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide/gettingStartedFromScratch.md" target="_blank" rel="noopener">原文</a></p><ol><li><p>新建一个文件夹保存项目文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir iPerfect</span><br><span class="line">$ cd iPerfect</span><br></pre></td></tr></table></figure></li><li><p>初始化项目，用<code>SPM</code>软件包管理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ swift package init --type=executable</span><br><span class="line">Creating executable package: iPerfect</span><br><span class="line">Creating Package.swift</span><br><span class="line">Creating README.md</span><br><span class="line">Creating .gitignore</span><br><span class="line">Creating Sources/</span><br><span class="line">Creating Sources/iPerfect/main.swift</span><br><span class="line">Creating Tests/</span><br></pre></td></tr></table></figure></li><li><p>配置依赖<br>打开<code>Package.swift</code>文件进行编辑：<br>该文件在要求Swift编译的最低版本为<code>3.0.0</code>，设置<code>target</code>编译依存库<code>PerfectHTTPServer</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version:4.0</span></span><br><span class="line"><span class="comment">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">name: <span class="string">"iPerfect"</span>,</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: <span class="string">"https://github.com/PerfectlySoft/Perfect-HTTPServer.git"</span>, from: <span class="string">"3.0.0"</span>)</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">    .target(</span><br><span class="line">        name: <span class="string">"iPerfect"</span>,</span><br><span class="line">        dependencies: [<span class="string">"PerfectHTTPServer"</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Sources</span><br><span class="line">echo &apos;print(&quot;您好！&quot;)&apos; &gt;&gt; Sources/iPerfect/main.swift</span><br></pre></td></tr></table></figure></li><li><p>编译和运行<br>现在项目就已经准备好，可以通过以下两个命令编译和运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br><span class="line">.build/debug/iPerfect</span><br></pre></td></tr></table></figure></li></ol><p>成功之后，会打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好！！！</span><br></pre></td></tr></table></figure></p><h2 id="设置Perfect-HTTPServer服务器"><a href="#设置Perfect-HTTPServer服务器" class="headerlink" title="设置Perfect HTTPServer服务器"></a>设置<strong>Perfect HTTPServer</strong>服务器</h2><h3 id="注册路由和请求／响应句柄"><a href="#注册路由和请求／响应句柄" class="headerlink" title="注册路由和请求／响应句柄"></a>注册路由和请求／响应句柄</h3><p>打开<code>Sources/iPerfect/main.swift</code>文件，把内容替换为以下程序：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectHTTP</span><br><span class="line"><span class="keyword">import</span> PerfectHTTPServer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册路由和请求／响应句柄</span></span><br><span class="line"><span class="keyword">var</span> routes = <span class="type">Routes</span>()</span><br><span class="line">routes.add(method: .<span class="keyword">get</span>, uri: <span class="string">"/"</span>) &#123;</span><br><span class="line">    request, response <span class="keyword">in</span></span><br><span class="line">    response.setHeader(.contentType, value: <span class="string">"text/html"</span>)</span><br><span class="line">    response.appendBody(string: <span class="string">"&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line">    .completed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 启动HTTP服务器</span></span><br><span class="line">    <span class="keyword">try</span> <span class="type">HTTPServer</span>.launch(.server(name: <span class="string">"www.example.ca"</span>, port: <span class="number">8181</span>, routes: routes))</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"\(error)"</span>) <span class="comment">// fatal error launching one of the servers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>编译运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">$ .build/debug/iPerfect</span><br><span class="line">&gt;&gt;</span><br><span class="line">[INFO] Starting HTTP server www.example.ca on :::8181</span><br></pre></td></tr></table></figure></li></ol><p>在浏览器上打开<code>http://127.0.0.1:8181/</code><br>终止服务器：在终端控制台上用组合键<code>control-c</code>可以随时停止服务器。</p><h2 id="使用Xcode调试服务器"><a href="#使用Xcode调试服务器" class="headerlink" title="使用Xcode调试服务器"></a>使用Xcode调试服务器</h2><p>生成<strong>iPerfect.xcodeproj</strong><br>Swift软件包管理器（SPM）能够为您的项目<code>iPerfect</code>生成Xcode工程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure></p><h3 id="递归编译设置"><a href="#递归编译设置" class="headerlink" title="递归编译设置"></a>递归编译设置</h3><ol><li>设置递归编译项目目录中的所有<code>target</code><br>打开<code>iPerfect.xcodeproj</code>，在检索项目软件库<code>Library Search Paths</code>字典中新增路径：<code>$(PROJECT_DIR)</code> ，路径属性修改为<code>recursive</code>。<br><code>recursive</code>：遍历该目录，<code>non-recursive</code>：默认路径设置；不遍历该目录。<br>如果路径的属性为<code>recursive</code>，那么编译的时候在找库的路径的时候，会遍历该目录下的所有子目录的库文件。<blockquote><p>PS：在搭建项目的时候，可以创建一个专门放库文件的文件夹并且设置其属性为<code>recursive</code>:即为<code>$(PROJECT_DIR)/**</code>，相当于遍历项目文件同级下的所有路径(不推荐使用，项目大的话，影响编译的速度)。</p></blockquote></li><li>scheme运行在<strong>My Mac</strong><br>在Xcode打开项目之后，选择可执行目标为 <code>My Mac</code>，并选择正确的Swift工具链。</li><li>设置服务器的资源目录<br>为了使服务器能够访问您工程文件夹下的目录，比如html静态网页。<br>进入菜单命令 <code>Product &gt; Scheme &gt; Edit Scheme…</code>，设置工作目录 <code>Use Custom Working Directory</code> 为项目文件夹。 </li></ol><p>现在您就可以在Xcode中运行调试您的服务器了.</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SPM管理依赖库</title>
      <link href="/2018/10/02/swift/%E4%BD%BF%E7%94%A8SPM%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2018/10/02/swift/%E4%BD%BF%E7%94%A8SPM%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="概念概述"><a href="#概念概述" class="headerlink" title="概念概述"></a>概念概述</h2><p><a href="https://swift.org/package-manager/#conceptual-overview" target="_blank" rel="noopener">Package Manager</a><br><div id="badge-container-huos3203-PerfectTemplate-20294e56" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-PerfectTemplate-20294e56", "huos3203", "PerfectTemplate", "20294e56", false);</script></p><h3 id="Modules模块"><a href="#Modules模块" class="headerlink" title="Modules模块"></a>Modules模块</h3><p>在 Swift 中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外哪些部分的代码是可以被访问控制的。</p><p>一个程序可以将它所有代码聚合在一个模块中，也可以将它作为依赖关系导入到其他模块。除了少量系统提供的模块，像 OS X 中的 Darwin 或者 Linux 中的 Glibc 等的大多数依赖需要代码被下载或者内置才能被使用。</p><p>当你将编写的解决特定问题的代码独立成一个模块时，这段代码可以在其他情况下被重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的 app 或者 一个天气的 app 里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p><h3 id="Packages包"><a href="#Packages包" class="headerlink" title="Packages包"></a>Packages包</h3><p>一个包由 Swift 源文件和一个清单文件组成。这个清单文件称为 <code>Package.swift</code>，定义包名或者它的内容使用<code>PackageDescription</code> 模块。<br>一个包有一个或者多个目标，每个目标指定一个产品并且可能声明一个或者多个依赖。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import PackageDescription</span><br><span class="line"><span class="built_in">let</span> package = Package(</span><br><span class="line">    name: <span class="string">"DeckOfPlayingCards"</span>,</span><br><span class="line">    products: [</span><br><span class="line">        .library(name: <span class="string">"DeckOfPlayingCards"</span>, targets: [<span class="string">"DeckOfPlayingCards"</span>]),</span><br><span class="line">        .executable(name: <span class="string">"Dealer"</span>, targets: [<span class="string">"Dealer"</span>]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: <span class="string">"https://github.com/apple/example-package-fisheryates.git"</span>, from: <span class="string">"2.0.0"</span>),</span><br><span class="line">        .package(url: <span class="string">"https://github.com/apple/example-package-playingcard.git"</span>, from: <span class="string">"3.0.0"</span>),</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"DeckOfPlayingCards"</span>,</span><br><span class="line">            dependencies: [<span class="string">"FisherYates"</span>, <span class="string">"PlayingCard"</span>]),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: <span class="string">"DeckOfPlayingCardsTests"</span>,</span><br><span class="line">            dependencies: [<span class="string">"DeckOfPlayingCards"</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="Products产品"><a href="#Products产品" class="headerlink" title="Products产品"></a>Products产品</h3><p>一个<code>target</code>可能构建一个<code>.library()库</code>或者一个<code>.executable()可执行文件</code>作为其产品。<br><code>.library(name: &quot;&quot;, targets: [])</code>库:是包含用于其他Swift 代码导入该模块<br><code>.executable(name: &quot;&quot;, targets: [])</code>可执行文件:是一段可以被操作系统运行的程序。</p><h3 id="Dependencies依赖"><a href="#Dependencies依赖" class="headerlink" title="Dependencies依赖"></a>Dependencies依赖</h3><p><code>Dependencies</code>依赖是指<code>Package</code>中代码必须添加的<code>Modules</code>块。<code>Dependencies</code>由<code>.package</code>资源的<code>绝对路径</code>或<code>相对 URL</code> 和<code>包的版本</code>组成。<br>包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成了一个依赖相关图。</p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h3 id="创建依赖库lib-Package"><a href="#创建依赖库lib-Package" class="headerlink" title="创建依赖库lib Package"></a>创建依赖库lib Package</h3><ol><li><p>建一个<code>target</code>表示标准的52张扑克牌的<code>PlayingCard</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir PlayingCard</span><br><span class="line">cd PlayingCard</span><br><span class="line">swift package init</span><br></pre></td></tr></table></figure></li><li><p>创建公共实现类<br><code>PlayingCard</code>定义<code>PlayingCard</code>类型，它由<code>Suit</code>枚举值(梅花、方块、红心、黑桃)和<code>Rank</code>枚举值(Ace、2、3、…、Jack、Queen、King)组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum Rank : Int &#123;</span><br><span class="line">    case Ace = 1</span><br><span class="line">    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</span><br><span class="line">    case Jack, Queen, King</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Suit: String &#123;</span><br><span class="line">    case Spades, Hearts, Diamonds, Clubs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct PlayingCard &#123;</span><br><span class="line">    let rank: Rank</span><br><span class="line">    let suit: Suit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>按照约定，一个<code>target</code>所有的源文件都存在相应的<code>Sources/&lt;target-name&gt;</code>目录下，默认情况下，<code>库模块</code>使用<code>public</code>来声明类型和方法，这些类型和方法位于<code>Sources/&lt;target-name&gt;</code>中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example-package-playingcard</span><br><span class="line">├── Sources</span><br><span class="line">│   └── PlayingCard</span><br><span class="line">│       ├── PlayingCard.swift</span><br><span class="line">│       ├── Rank.swift</span><br><span class="line">│       └── Suit.swift</span><br><span class="line">└── Package.swift</span><br></pre></td></tr></table></figure></p><p><code>PlayingCard</code>因为不生成<code>executable</code>可执行文件，这种类型的<code>target</code>成为<code>库</code>，当构建一个模块可以被依赖导入使用。</p><ol start="3"><li>运行<code>swift build</code>命令，将编译生成<code>PlayingCard</code>模块。</li></ol><h3 id="使用-if-else-endif构建配置语句"><a href="#使用-if-else-endif构建配置语句" class="headerlink" title="使用 #if #else #endif构建配置语句"></a>使用 <code>#if #else #endif</code>构建配置语句</h3><ol><li>创建<code>fisher</code>模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir fisher</span><br><span class="line">cd fisher</span><br><span class="line">swift package init</span><br></pre></td></tr></table></figure></li></ol><p><code>fisher</code>与<code>PlayingCard</code>不同，此模块不定义任何新类型。相反，它扩展了现有的类型(特别是<code>CollectionType</code>和<code>MutableCollectionType</code>协议)，以添加<code>shuffle()</code>方法和它的变体副本<code>shuffleInPlace()</code>。</p><ol start="2"><li>使用构建配置语句 <code>#if #else #endif</code><br><code>shuffleInPlace()</code>的实现使用<code>Fisher-Yates</code>算法随机排列集合中的元素。因为Swift标准库不提供随机数生成器，所以该方法必须调用从系统模块导入的函数。为了使该函数与<code>macOS</code>和<code>Linux</code>兼容，代码使用构建配置语句。<br>在<code>macOS</code>中，系统模块是<code>Darwin</code>，它提供了<code>arc4random_uniform(_:)</code>函数。<br>在<code>Linux</code>中，系统模块为<code>Glibc</code>，它提供了<code>random()</code>函数:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#if os(Linux)</span><br><span class="line">import Glibc</span><br><span class="line">#else</span><br><span class="line">import Darwin.C</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">public extension MutableCollectionType where Index == Int &#123;</span><br><span class="line">    mutating func shuffleInPlace() &#123;</span><br><span class="line">        if count &lt;= 1 &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        for i in 0..&lt;count - 1 &#123;</span><br><span class="line">            #if os(Linux)</span><br><span class="line">                let j = Int(random() % (count - i)))) + i</span><br><span class="line">            #else</span><br><span class="line">                let j = Int(arc4random_uniform(UInt32(count - i))) + i</span><br><span class="line">            #endif</span><br><span class="line">                if i == j &#123; continue &#125;</span><br><span class="line">                swap(&amp;self[i], &amp;self[j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="依赖库导入及使用"><a href="#依赖库导入及使用" class="headerlink" title="依赖库导入及使用"></a>依赖库导入及使用</h3><p><code>DeckOfPlayingCards</code>包将前两个包组合在一起:它定义了一种桥牌类型，该类型在一个<code>PlayingCard</code>值数组上使用<code>fisher()</code>方法。<br>要使用<code>fisher</code>和<code>PlayingCards</code>模块，必须在<code>DeckOfPlayingCards</code>模块的清单文件<code>Package.swift</code>中声明为它们<code>package</code>依赖项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// swift-tools-version:4.0</span><br><span class="line">import PackageDescription</span><br><span class="line"></span><br><span class="line">let package = Package(</span><br><span class="line">    name: &quot;DeckOfPlayingCards&quot;,</span><br><span class="line">    products: [</span><br><span class="line">        .library(name: &quot;DeckOfPlayingCards&quot;, targets: [&quot;DeckOfPlayingCards&quot;]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: &quot;https://github.com/apple/example-package-fisheryates.git&quot;, from: &quot;2.0.0&quot;),</span><br><span class="line">        .package(url: &quot;https://github.com/apple/example-package-playingcard.git&quot;, from: &quot;3.0.0&quot;),</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: &quot;DeckOfPlayingCards&quot;,</span><br><span class="line">            dependencies: [&quot;FisherYates&quot;, &quot;PlayingCard&quot;]),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: &quot;DeckOfPlayingCardsTests&quot;,</span><br><span class="line">            dependencies: [&quot;DeckOfPlayingCards&quot;]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>每个依赖项指定源<code>URL</code>和<code>from:</code>版本号。<br><code>源URL</code>是解析到Git存储库的当前用户可以访问的URL。版本需求遵循语义版本控制(SemVer)约定，用于确定签出哪个Git标签并使用它来构建依赖关系。对于依赖项<code>FisherYates</code> ，将使用最新版本主版本为2(例如，2.0.4)。类似地，<code>PlayingCard</code>依赖项将使用最新版本主版本为3。<br>当运行<code>swift build</code>命令时，包管理器下载所有依赖项，编译、并链接到包模块。这样<code>DeckOfPlayingCards</code>使用<code>import</code>语句来访问依赖模块中<code>public</code>类型的属性和方法。<br>您可以在项目根目录下的<code>.build/checkouts</code>目录中看到下载的源代码，在项目根目录下的<code>.build</code>目录中看到中间的构建产品。</p><h2 id="解决依赖传递关系"><a href="#解决依赖传递关系" class="headerlink" title="解决依赖传递关系"></a>解决依赖传递关系</h2><p>构建<code>Dealer</code>模块,它依赖于<code>DeckOfPlayingCards</code>包，而<code>DeckOfPlayingCards</code>包又依赖于<code>PlayingCard</code>和<code>fisher</code>包。然而，由于Swift包管理器自动解析传递依赖项，您只需将<code>DeckOfPlayingCards</code>包声明为依赖项即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// swift-tools-version:4.0</span><br><span class="line"></span><br><span class="line">import PackageDescription</span><br><span class="line"></span><br><span class="line">let package = Package(</span><br><span class="line">    name: &quot;dealer&quot;,</span><br><span class="line">    products: [</span><br><span class="line">        .executable(name: &quot;Dealer&quot;, targets: [&quot;Dealer&quot;]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;, from: &quot;3.0.0&quot;),</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">        name: &quot;Dealer&quot;,</span><br><span class="line">        dependencies: [&quot;DeckOfPlayingCards&quot;]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>依赖传递关系也体现在Swift源文件代码<code>import</code>导入一个模块，就可以使用该某块下所有依赖库的类型。例如<code>Dealer</code>模块的<code>main.swift</code>文件。在<code>DeckOfPlayingCards</code>中的<code>Deck</code>类型和<code>PlayingCard</code>中的<code>PlayingCard</code>类型。尽管<code>Deck</code>类型的<code>shuffle()</code>方法在内部使用了<code>fisher</code>模块，但该模块不需要在<code>main.swift</code>中导入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import PlayingCard</span><br><span class="line">import DeckOfPlayingCards</span><br><span class="line"></span><br><span class="line">let numberOfCards = 10</span><br><span class="line"></span><br><span class="line">var deck = Deck.standard52CardDeck()</span><br><span class="line">deck.shuffle()</span><br><span class="line"></span><br><span class="line">for _ in 1...numberOfCards &#123;</span><br><span class="line">    guard let card = deck.deal() else &#123;</span><br><span class="line">        print(&quot;No More Cards!&quot;)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    print(card)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构建并运行可执行文件"><a href="#构建并运行可执行文件" class="headerlink" title="构建并运行可执行文件"></a>构建并运行可执行文件</h3><p>根据约定，一个<code>target</code>的根目录中包含一个名为<code>main.swift</code>文件，可以构建成一个可执行文件。<br>运行<code>swift build</code>命令，然后运行<code>.build/debug</code>目录下的<code>Dealer</code>可执行文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">$ ./.build/debug/Dealer</span><br><span class="line">♠︎6</span><br><span class="line">♢K</span><br><span class="line">♢2</span><br><span class="line">♡8</span><br><span class="line">♠︎7</span><br><span class="line">♣︎10</span><br><span class="line">♣︎5</span><br><span class="line">♢A</span><br><span class="line">♡Q</span><br><span class="line">♡7</span><br></pre></td></tr></table></figure></p><h3 id="两个坑"><a href="#两个坑" class="headerlink" title="两个坑"></a>两个坑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure><ol><li>每次更新或添加库或框架，xcodeproj就需要重新创建一次，不然无法引用到新库或新框架；</li><li>在source文件夹如果发生任何改动，库或框架的更新就会失败。<br>这就是为什么我要专门建一个工程来管理这些框架或者库（这是我踩的最恶心的坑）。为了解决这个大坑，就再创建一个项目工程，然后使用workspace来管理<br><a href="https://blog.csdn.net/loveqcx123/article/details/70160379" target="_blank" rel="noopener">今天开始用swift写服务器(一)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift单文件相关命令行工具</title>
      <link href="/2018/10/02/swift/Swift%E5%8D%95%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/10/02/swift/Swift%E5%8D%95%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="直接用-swift-命令执行"><a href="#直接用-swift-命令执行" class="headerlink" title="直接用 swift 命令执行"></a>直接用 swift 命令执行</h2><p><code>xcrun swift</code>可以直接将一个 <code>.swift</code>文件作为命令行工具的输入，这样里面的代码也会被自动地编译和执行。我们甚至还可以在 <code>.swift</code> 文件最上面加上命令行工具的路径，然后将文件权限改为可执行，之后就可以直接执行这个 .swift 文件了：</p><ol><li><p>hello.swift</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env xcrun swift </span></span><br><span class="line">println(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></li><li><p>终端设置为可执行权限，并运行打印：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; chmod 755 hello.swift </span><br><span class="line">&gt; ./hello.swift </span><br><span class="line">// 输出： </span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这些特性与其他的解释性语言表现得完全一样</p></blockquote><h2 id="swiftc"><a href="#swiftc" class="headerlink" title="swiftc"></a>swiftc</h2><p>相对于直接用 swift 命令执行，Swift 命令行工具的另一个常用的地方是直接脱离 Xcode 环境进行编译和生成可执行的二进制文件。我们可以使用 swiftc 来进行编译，比如下面的例子：</p><ol><li><p>MyClass.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"XiaoMing"</span> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123; </span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Hello \(name)"</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>() </span><br><span class="line">object.hello()</span><br></pre></td></tr></table></figure></li><li><p>终端编译运行，将生成一个名叫 <code>main</code> 的可执行文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; xcrun swiftc MyClass.swift main.swift</span><br><span class="line">&gt; ./main  //运行main文件</span><br></pre></td></tr></table></figure></li></ol><p>利用这个方法，我们就可以用 Swift 写出一些命令行的程序了。</p><p>最后想说明的一个 Swift 命令行工具的使用案例是生成汇编级别的代码。有时候我们想要确认经过优化后的汇编代码实际上做了些什么。swiftc 提供了参数来生成 asm 级别的汇编代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -O hello.swift &gt; hello.asm</span><br></pre></td></tr></table></figure></p><p>Swift 的命令行工具还有不少强大的功能，对此感兴趣的读者不妨使用 <code>xcrun swift --help</code> 以及 <code>xcrun swiftc --help</code> 来查看具体还有哪些参数可以使用。</p><h2 id="swiftc-g支持lldb调试"><a href="#swiftc-g支持lldb调试" class="headerlink" title="swiftc -g支持lldb调试"></a><code>swiftc -g</code>支持lldb调试</h2>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>swift在终端使用LLDB调试</title>
      <link href="/2018/10/02/swift/swift%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95/"/>
      <url>/2018/10/02/swift/swift%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://swift.org/getting-started/#using-the-lldb-debugger" target="_blank" rel="noopener">Using the LLDB Debugger</a><br>使用LLDB调试器一步一步地运行Swift程序，通过设置<code>断点</code>调试运行状态。</p><ol><li><p>创建一个名<code>Factorial.swift</code>，定义了一个<code>factorial(n:)</code>函数，并打印调用该函数的结果:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func factorial(n: Int) -&gt; Int &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= 1 &#123; <span class="built_in">return</span> n &#125;</span><br><span class="line">    <span class="built_in">return</span> n * factorial(n: n - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> number = 4</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(number)! is equal to \(factorial(n: number))"</span>)</span><br></pre></td></tr></table></figure></li><li><p>swiftc命令<br>运行swiftc命令<code>-g</code>选项生成<code>swift</code>调试信息,在目录中生存可执行的Factorial文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ swiftc -g Factorial.swift</span><br><span class="line">$ ls</span><br><span class="line">Factorial.dSYM</span><br><span class="line">Factorial.swift</span><br><span class="line">Factorial*</span><br></pre></td></tr></table></figure></li><li><p>使用lldb启动Factorial文件<br>通过LLDB调试器命令<code>lldb</code>运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lldb Factorial</span><br><span class="line">(lldb) target create <span class="string">"Factorial"</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">'Factorial'</span> (x86_64).</span><br></pre></td></tr></table></figure></li><li><p>设置断点<br>使用<code>breakpoint set</code> (<code>b</code>) 命令在<code>factorial(n:)</code>函数的第2行中设置一个断点，每次执行函数时中断进程:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b 2</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = Factorial`Factorial.factorial (Swift.Int) -&gt; Swift.Int + 12</span><br></pre></td></tr></table></figure></li><li><p>运行调试<br>使用<code>run</code> (<code>r</code>)命令运行进程。进程在<code>factorial(n:)</code>函数的调用位置停止。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) r</span><br><span class="line">Process 40246 resuming</span><br><span class="line">Process 40246 stopped</span><br><span class="line">* thread <span class="comment">#1: tid = 0x14dfdf, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line">frame <span class="comment">#0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2</span></span><br><span class="line">   1    func factorial(n: Int) -&gt; Int &#123;</span><br><span class="line">-&gt; 2        <span class="keyword">if</span> n &lt;= 1 &#123; <span class="built_in">return</span> n &#125;</span><br><span class="line">   3        <span class="built_in">return</span> n * factorial(n: n - 1)</span><br><span class="line">   4    &#125;</span><br><span class="line">   5</span><br><span class="line">   6    <span class="built_in">let</span> number = 4</span><br><span class="line">   7    <span class="built_in">print</span>(<span class="string">"\(number)! is equal to \(factorial(n: number))"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>Use the print (p) command to inspect the value of the n parameter.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p n</span><br><span class="line">(Int) <span class="variable">$R0</span> = 4</span><br></pre></td></tr></table></figure></p><p>The print command can evaluate Swift expressions as well.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p n * n</span><br><span class="line">(Int) <span class="variable">$R1</span> = 16</span><br></pre></td></tr></table></figure></p><p>Use the <code>backtrace</code> (<code>bt</code>) command to show the frames leading to <code>factorial(n:)</code> being called.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread <span class="comment">#1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line">    * frame <span class="comment">#0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2</span></span><br><span class="line">    frame <span class="comment">#1: 0x0000000100000daf Factorial`main + 287 at Factorial.swift:7</span></span><br><span class="line">    frame <span class="comment">#2: 0x00007fff890be5ad libdyld.dylib`start + 1</span></span><br><span class="line">    frame <span class="comment">#3: 0x00007fff890be5ad libdyld.dylib`start + 1</span></span><br></pre></td></tr></table></figure></p><p>Use the <code>continue</code> (<code>c</code>) command to resume the process until the breakpoint is hit again.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 40246 resuming</span><br><span class="line">Process 40246 stopped</span><br><span class="line">* thread <span class="comment">#1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line">frame <span class="comment">#0: 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -&gt; Swift.Int + 12 at Factorial.swift:2</span></span><br><span class="line">   1    func factorial(n: Int) -&gt; Int &#123;</span><br><span class="line">-&gt; 2        <span class="keyword">if</span> n &lt;= 1 &#123; <span class="built_in">return</span> n &#125;</span><br><span class="line">   3        <span class="built_in">return</span> n * factorial(n: n - 1)</span><br><span class="line">   4    &#125;</span><br><span class="line">   5</span><br><span class="line">   6    <span class="built_in">let</span> number = 4</span><br><span class="line">   7    <span class="built_in">print</span>(<span class="string">"\(number)! is equal to \(factorial(n: number))"</span>)</span><br></pre></td></tr></table></figure></p><p>Use the <code>print</code> (<code>p</code>) command again to inspect the value of the n parameter for the second call to<code>factorial(n:)</code>.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p n</span><br><span class="line">(Int) <span class="variable">$R2</span> = 3</span><br></pre></td></tr></table></figure></p><ol start="6"><li>取消断点<br>Use the <code>breakpoint disable</code> (<code>br di</code>) command to disable all breakpoints and the <code>continue</code> (<code>c</code>) command to have the process run until it exits.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br di</span><br><span class="line">All breakpoints disabled. (1 breakpoints)</span><br><span class="line">(lldb) c</span><br><span class="line">Process 40246 resuming</span><br><span class="line">4! is equal to 24</span><br><span class="line">Process 40246 exited with status = 0 (0x00000000)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPM相关命令工具</title>
      <link href="/2018/10/01/swift/SPM%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/10/01/swift/SPM%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="概念概述"><a href="#概念概述" class="headerlink" title="概念概述"></a>概念概述</h2><p><a href="https://swift.org/getting-started" target="_blank" rel="noopener">getting-started</a><br><div id="badge-container-huos3203-PerfectTemplate-20294e56" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-PerfectTemplate-20294e56", "huos3203", "PerfectTemplate", "20294e56", false);</script></p><h2 id="使用Swift编译系统"><a href="#使用Swift编译系统" class="headerlink" title="使用Swift编译系统"></a>使用Swift编译系统</h2><p>Swift 编译系统为编译库、可执行文件和在不同工程之间共享代码提供了基本的约定。</p><h3 id="swift-工具"><a href="#swift-工具" class="headerlink" title="swift 工具"></a>swift 工具</h3><ul><li>swift package</li><li>swift package generate-xcodeproj</li><li>swift run</li><li>swift build</li><li>swift test</li></ul><h3 id="swift-package创建一个HelloSPM"><a href="#swift-package创建一个HelloSPM" class="headerlink" title="swift package创建一个HelloSPM"></a><code>swift package</code>创建一个<code>Hello</code>SPM</h3><ol><li><p>创建<code>Hello</code>目录，目录名会作为SPM名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Hello</span><br><span class="line">$ cd Hello</span><br></pre></td></tr></table></figure></li><li><p><code>swift package</code>初始化为SPM工程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ swift package init</span><br><span class="line">├── Package.swift   // 依赖清单文件</span><br><span class="line">├── README.md</span><br><span class="line">├── Sources         // 源码目录</span><br><span class="line">│   └── Hello</span><br><span class="line">│       └── Hello.swift</span><br><span class="line">└── Tests</span><br><span class="line">├── HelloTests</span><br><span class="line">│   └── HelloTests.swift</span><br><span class="line">└── LinuxMain.swift</span><br></pre></td></tr></table></figure></li></ol><p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件。如果清单文件为空，那包管理器将会使用常规默认的方式来编译包。</p><ol start="3"><li><p><code>swift build</code>编译SPM<br>编译会先解析<code>Package.swift</code>项目配置和下载依赖库等环境，然后编译源码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ swift build  <span class="comment">#编译可执行文件</span></span><br><span class="line">Compile Swift Module <span class="string">'Hello'</span> (1 sources)</span><br></pre></td></tr></table></figure></li><li><p>swift test运行SPM的单元测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ swift <span class="built_in">test</span></span><br><span class="line">Compile Swift Module <span class="string">'HelloTests'</span> (1 sources)</span><br><span class="line">Linking ./.build/x86_64-apple-macosx10.10/debug/HelloPackageTests.xctest/Contents/MacOS/HelloPackageTests</span><br><span class="line">Test Suite <span class="string">'All tests'</span> started at 2016-08-29 08:00:31.453</span><br><span class="line">Test Suite <span class="string">'HelloPackageTests.xctest'</span> started at 2016-08-29 08:00:31.454</span><br><span class="line">Test Suite <span class="string">'HelloTests'</span> started at 2016-08-29 08:00:31.454</span><br><span class="line">Test Case <span class="string">'-[HelloTests.HelloTests testExample]'</span> started.</span><br><span class="line">Test Case <span class="string">'-[HelloTests.HelloTests testExample]'</span> passed (0.001 seconds).</span><br><span class="line">Test Suite <span class="string">'HelloTests'</span> passed at 2016-08-29 08:00:31.455.</span><br><span class="line">Executed 1 <span class="built_in">test</span>, with 0 failures (0 unexpected) <span class="keyword">in</span> 0.001 (0.001) seconds</span><br><span class="line">Test Suite <span class="string">'HelloPackageTests.xctest'</span> passed at 2016-08-29 08:00:31.455.</span><br><span class="line">Executed 1 <span class="built_in">test</span>, with 0 failures (0 unexpected) <span class="keyword">in</span> 0.001 (0.001) seconds</span><br><span class="line">Test Suite <span class="string">'All tests'</span> passed at 2016-08-29 08:00:31.455.</span><br><span class="line">Executed 1 <span class="built_in">test</span>, with 0 failures (0 unexpected) <span class="keyword">in</span> 0.001 (0.002) seconds</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建一个可执行的SPM"><a href="#创建一个可执行的SPM" class="headerlink" title="创建一个可执行的SPM"></a>创建一个可执行的SPM</h3><p>可运行的SPM必须包含<code>main.swift</code>文件。SPM会把<code>main.swift</code>编译成可执行文件的二进制文件。<br>在本例中，SPM将生成一个名为<code>Hello</code>的可执行文件，输出“Hello, world!”</p><ol><li><p>创建</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Hello</span><br><span class="line">$ <span class="built_in">cd</span> Hello</span><br><span class="line">$ swift package init --<span class="built_in">type</span> executable</span><br></pre></td></tr></table></figure></li><li><p>两种运行方式<br>2.1 先编译在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">Compile Swift Module &apos;Hello&apos; (1 sources)</span><br><span class="line">Linking ./.build/x86_64-apple-macosx10.10/debug/Hello</span><br><span class="line"></span><br><span class="line">$ .build/x86_64-apple-macosx10.10/debug/Hello</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></li></ol><p>2.2 <code>swift run</code>直接运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ swift run Hello</span><br><span class="line">Compile Swift Module <span class="string">'Hello'</span> (1 sources)</span><br><span class="line">Linking ./.build/x86_64-apple-macosx10.10/debug/Hello</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p><ol start="3"><li>多个源文件协作<br>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code> 然后直接用 <code>print(_:)</code> 替换执行调用的内容。<br>在 <code>Sources/</code> 目录下创建一个新文件命名为 <code>Greeter.swift</code> 然后输入如下代码：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>sayHello(_:)</code> 方法带一个单一的字符串参数，然后在前面打印一个 “Hello”，后面跟着函数参数单词 “World”。</p><p>现在打开 <code>main.swift</code>， 然后替换原来的内容为下面代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">Process</span>.arguments.<span class="built_in">count</span> != <span class="number">2</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Usage: hello NAME"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="type">Process</span>.arguments[<span class="number">1</span>]</span><br><span class="line">    sayHello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟之前的硬编码不同，<code>main.swift</code> 现在从命令行参数中读取。替代之前直接调用 <code>print(_:)</code>， <code>main.swift</code> 现在调用 <code>sayHello(_:)</code> 方法。因为这个方法是 <code>Hello 模块</code>的一部分，所以不需要使用到 <code>import</code> 语句。</p><p>运行 swift build 并尝试 Hello 的新版本：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">$ .build/debug/<span class="type">Hello</span> 'whoami'</span><br></pre></td></tr></table></figure></p><p>目前为止，你已经能够运用开源 Swift 来运行一些你想要的程序了 。<br>要了解Swift包管理器，包括如何构建模块、导入依赖项和映射系统库，请参阅网站的<a href="https://swift.org/package-manager" target="_blank" rel="noopener">Swift包管理器</a>部分。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用JavaScript构建OSX原生应用</title>
      <link href="/2018/09/30/macOS/%E5%88%A9%E7%94%A8JavaScript%E6%9E%84%E5%BB%BAOSX%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/"/>
      <url>/2018/09/30/macOS/%E5%88%A9%E7%94%A8JavaScript%E6%9E%84%E5%BB%BAOSX%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://segmentfault.com/a/1190000002504649" target="_blank" rel="noopener">利用JavaScript构建OSX应用</a><br><a href="https://github.com/tylergaw/js-osx-app-examples" target="_blank" rel="noopener">Example OS X applications written in JavaScript.</a><br><a href="https://github.com/JXA-Cookbook/JXA-Cookbook" target="_blank" rel="noopener">JavaScript for Automation Cookbook</a><br><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">廖雪峰的JavaScript教程</a><br><a href="https://www.w3cschool.cn/javascript/" target="_blank" rel="noopener">W3Cschool javascript教程</a><br><a href="https://www.jianshu.com/p/4b236af8745c" target="_blank" rel="noopener">JavaScript快速入门</a></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><a href="https://www.jianshu.com/p/37c3fac40be2" target="_blank" rel="noopener">UIAutomation的简单使用方法</a><br><a href="http://www.cnblogs.com/vowei/archive/2012/08/10/2631949.html" target="_blank" rel="noopener">如何使用UIAutomation进行iOS 自动化测试（Part I）</a><br><a href="https://developer.telerik.com/featured/javascript-os-x-automation-example/" target="_blank" rel="noopener">JavaScript for OS X Automation by Example</a><br><a href="https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html" target="_blank" rel="noopener">JavaScript For Automation</a><br><a href="http://www.cocoachina.com/ios/20180402/22865.html" target="_blank" rel="noopener">iOS 程序员效率提升利器之 AppleScript</a><br><a href="https://www.jianshu.com/p/816667ee92ce" target="_blank" rel="noopener">Numbers入门 — 附录：脚本 AppleScript 与 Numbers</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修改Mac用户名导致丢失管理员权限问题修复</title>
      <link href="/2018/09/26/macOS/%E4%BF%AE%E6%94%B9Mac%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%A4%B1%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
      <url>/2018/09/26/macOS/%E4%BF%AE%E6%94%B9Mac%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%A4%B1%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="出现的问题主要有两点"><a href="#出现的问题主要有两点" class="headerlink" title="出现的问题主要有两点"></a>出现的问题主要有两点</h2><ol><li>数据恢复问题<br>1）修改用户名后，mac系统认为是创建了一个新的用户，这时候，之前管理员账号的数据在当前用户的finder里是看不到的。这时候可以去到桌面，点击又上角的“前往” 。</li><li>管理员权限问题<br>虽然数据问题恢复了，但是另外一个更严重的问题又出现了。新的用户名账号只是一个普通用户账号，没有管理员权限没有管理员权限了。在需要管理员权限的操作中输入具有管理员权限的前用户名和密码也不认了。<br>解决办法：</li><li>创建一个新的具有管理员权限的用户<br>第一步：重启电脑，并长按组合键：<code>command+s</code>进入Single User Model模式，出现像DOS一样的提示符 。<br>第二步：在命令行顺序输入命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fsck -y</span><br><span class="line">mount -uaw /</span><br><span class="line">rm /var/db/.AppleSetupDone</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol><p>苹果电脑会重启，并且在开机后出现新装机时的欢迎界面。重新建立一个新的管理员账号。 </p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义Xcode支持Vim快捷键</title>
      <link href="/2018/09/21/xcode/%E8%87%AA%E5%AE%9A%E4%B9%89Xcode%E6%94%AF%E6%8C%81Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/09/21/xcode/%E8%87%AA%E5%AE%9A%E4%B9%89Xcode%E6%94%AF%E6%8C%81Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用了Vim之后，被其强大的文本编辑能力吸引, 于是每天都在寻找 Vim 插件, 试图用 Vim 代替 Xcode 进行日常开发. 直到有一天突然发现, 我想要的就是一个<strong>拥有强大文本编辑能力的 Xcode.</strong><br>分享一个<a href="https://github.com/Scyano/XcodeKeyBindingSet.git" target="_blank" rel="noopener">自定义快捷键完整版</a></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>Xcode虽然没有 Vim 的模式切换, 但是也可以使用大部分文本操作, 这里主要用到的是:</p><ol><li>删除: 完全删除单行, 删除单行到行首, 删除词组, 删除单词, 删除段落</li><li>替换: 替换单行, 替换词组</li><li>复制: 复制行尾词组, 复制词组, 复制单行.<br>另外还有向前删除单行, 向后删除单行, 全局替换, 剪切单行, 格式化粘贴单行等.</li></ol><h2 id="系统自带快捷操作"><a href="#系统自带快捷操作" class="headerlink" title="系统自带快捷操作"></a>系统自带快捷操作</h2><p>首先 Xcode 原生自带的快捷键就非常实用了, <code>CMD+</code>, 打开<code>Preferences</code>-&gt;<code>Code Binding</code>-&gt;<code>Text</code>可以看到常用的选择, 删除, 搜索等快捷操作, 如 <code>Move Word Right</code> =&gt; <code>⌥+→</code> : 光标向右按单词移动.</p><h2 id="自定义快捷操作"><a href="#自定义快捷操作" class="headerlink" title="自定义快捷操作"></a>自定义快捷操作</h2><p>实际使用时发现系统提供的删除只可以删除单词或词组某一方向的字符:<br>系统快捷键演示：<br><img src="https://upload-images.jianshu.io/upload_images/1253941-d451d9eadbbb6fa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt></p><h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><p>所以, 决定自行添加快捷操作, 而 Xcode 本身就是一个OSX 应用程序, 所以我们可以找到相关文件去配置快捷操作。</p><ol><li>了解并编辑<code>IDETextKeyBindingSet.plist</code><br><code>Application</code>-&gt;<code>Xcode.app</code>-&gt;<code>Contents</code>-&gt;<code>Frameworks</code>-&gt;<code>IDEKit.framework</code>-&gt;<code>Resources</code>-&gt;<code>IDETextKeyBindingSet.plist</code><br>使用编辑器打开IDETextKeyBindingSet.plist, 自行添加快捷操作:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;Delete Current Word&lt;/key&gt;</span><br><span class="line">&lt;string&gt;moveLeft:, moveWordRight:, deleteWordBackward:&lt;/string&gt;</span><br></pre></td></tr></table></figure></li></ol><p>自定义快捷键演示<br><img src="https://upload-images.jianshu.io/upload_images/1253941-a04470b8b26e6fe8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt><br>其中<code>Cut Current Line</code> 是显示在 Xcode 偏好设置内的快捷操作.<code>moveToEndOfLine</code> 是编辑器的文本操作相关的 <code>编辑器API</code>, 可以组合类似的 <code>API</code> 自定义操作.</p><ol start="2"><li>更新到xcode设置快捷键<br>编辑完成后, 重新打开 <code>Xcode-&gt;Preferences-&gt;Key Bindings-&gt;Customized</code>, 为自定义的快捷操作添加快捷键.<br><img src="https://upload-images.jianshu.io/upload_images/1253941-717652603f41af8d?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt><br>分享一个<a href="https://github.com/Scyano/XcodeKeyBindingSet.git" target="_blank" rel="noopener">自定义快捷键完整版</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>巡查自查整合类图</title>
      <link href="/2018/09/14/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%B7%A1%E6%9F%A5%E8%87%AA%E6%9F%A5%E6%95%B4%E5%90%88%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/09/14/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%B7%A1%E6%9F%A5%E8%87%AA%E6%9F%A5%E6%95%B4%E5%90%88%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://www.plantuml.com/plantuml/svg/bLVjKnD76Fz-VyKEp9W4BsHilmLbHj9QSP0w1kpOJfivaYMvySpXvLBhe1sm88JtgIWQ1On0Gwr471nU4Y7_pErUyib_eS_UNYvt2Zhk3EHsztdPvxVFytlkT5bNC29x1RgwGUQdoFgOkV20Fdf75YPhrIsZiYR4SLh76afXAO4rWKlIN97kFFfOldHKAnL8QSMSsoRFZWISJjXAWg-D3sI-hP2rRVfaZcuMoF8IijTzWe_jh4o7uugKoOZIG4RNfBWkoipte1J7efHEgxgaosfQnEdiJT2ebQhrfH9PNGtxWm6pE4gVvqH_Qy2eBjEfTT7_Pu3CZ3UMJmV8-6juyWc2vG7rISc85TYm40mYBaRUhj2H8anzPF91FRzellud61JRsyLpvyHOp2TqT_sO1RHqrDyTZMkgeboJyMtKfZC8cmiT9yd5LV2NrjsIlT7BMLqQKF1vJPFksAPwf06iP5nchaWwg4InfCLJNPA6skG1P-Bnnlt80zzhcgfn3rVnhGko0d56TLN3bzK4Lb3ReBLYJJg4M8nCBfFYD9bvZ6WbJwOswOk9-iidzF41t74i9eH2o95mHoG4aVztLKu4CbZl7tAjWmBTgv2f5pGtmc3TMg1pHJAvIvvkaZS7fBp87NZr-vpGFwVlrOcaP2N1N4O0MkOUSksUC2J5RqX9Z6hL2LfP9tiRP7mFdJrxGLKW5pixX-qCk7GHSg17pkZC0Ci2YDnSh3IIe8bhRxH7kgDcTN32iX9Iac7SnwwDgVQfFNXGjq-HrJk-f1XDGKtqgVnMN6h184SSN0UT6BD3JRcmlpTgvqaW8UcIzTpH45PKAV4ThBA8mlw4d1cIz7WgbjJKx51C3rY_Zd0cfTvkXDu1a7cmG6rG0fSkkjAcxyuGZc154Vgx8mpbE2j3IzGVE44KEIWViydGfdF0DsiEshtHgAx9wIJK00ZrIZSnguv6MKX9UFhyGNcHzCat-KczthsRmu9bwRWjooJ0YCz3BkbNvFWDh3MJgn7KYGB3O1Xe2YC5KWAfWoTB2dHfjxxqhZwIezF_GcAR-J6oFLfR6sUqYPWDRaYJaodBqWbnabBUECXnOt5Oe2_soFlvfX5kHLU7t3QybyfD6FjvEZBAMVWZ8qXWWFdeaoDplHogvnTgI_CWAC8VJrb-Y-PM3f7ndVfYYMmjqSKtT6QKitcJn3bp2xuW3CGR0VCulcFkLCnobQnFq9rDaSo_CIeRvF0X6SsRYvl6qJHTXcIvR-pFaSbjBbshha066VjR24pvU9GjlFVmkk_lXlO4GP6f0c0BNbgGb46S-IBiM1mUNwirhCPaURSRKxDHFV-FR1yPXrKuITXoOnpEceUbCEBohOtXyzwyqs1GguOJ0hH8O_yLBJoWAxjm7cE_OXm-_F0-3psAJh-c2y_DTozXDyGFJvSBHcMNJ2xL2fiXXvJDhIFNnVfEMOETrAoCGVzjdjn-uWAde5MIyIspE6kBMPSRxWNs5wz2AKlff895pexY1GqgJumeQZOXCZOPa3BOvp2gpcll63A5dIuGjPhfbzgeNS4i_r0ygy6KFNQWK8Z7o7FmazxOf3oGvD3GHzjqjaJB2z34K1BhW7OeO_qupIle_zXEapl1Jdqapn1t-RMxnaIPvLzkbZk26slwQdOOibes2oEWvq84UVfBbvJkaQr6Eoma4WdGzMugCYSaldTFQ9fslMTvyBQHHcVlMambWn67bTZ4wcGDLWLXHgS2P61ArI5Ui_pIl7_0AzdTSVH6DuCpU3nSPpQlHP1pC6lXc0om1QrGM2mDnRQ64HQevS4RkyjDGm9vZ_13bidQRlZas22F3mSnL5ql1HElwDe8-x-wSJAkr-MV8od9YOnDliAbrzPFs6tCddsDDIilV9tMG0vTmXis41odGGzpTTh3AdkBAgVkmvr35ORzTpi3PgL8SrNHtnPWN32vW4I_6gYDvc4c0dtl6fN7hU8VuZtnjFWRl4Aj02rRgi5WWD5hkOe-l9_njxS7Qa_pCBFAsIQwbZCjSDq9zNRw5yPvlmPHoxUdlscnqGZpKc8r0mNJwMRBD5Baz0tKcjGmJWkruXePjSaFA9zp8vbQhVrrQ3xRPp7bnu3T_vxXxDwanC-Uv4oBvzqX_2dHmfduiBzu1bKmgWaCSS2QjnR-YSC_RlZ-_m00"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Codeanywhere上使用zsh终端及高亮样式</title>
      <link href="/2018/09/13/shell/%E5%9C%A8Codeanywhere%E4%B8%8A%E4%BD%BF%E7%94%A8zsh%E7%BB%88%E7%AB%AF%E5%8F%8A%E9%AB%98%E4%BA%AE%E6%A0%B7%E5%BC%8F/"/>
      <url>/2018/09/13/shell/%E5%9C%A8Codeanywhere%E4%B8%8A%E4%BD%BF%E7%94%A8zsh%E7%BB%88%E7%AB%AF%E5%8F%8A%E9%AB%98%E4%BA%AE%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="检查是否安装："><a href="#检查是否安装：" class="headerlink" title="检查是否安装："></a>检查是否安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh</span><br></pre></td></tr></table></figure><p>打印：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Debian / Ubuntu 安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install zsh</span><br></pre></td></tr></table></figure></p><p>zsh直接启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p><h3 id="安装oh-my-zsh样式工具"><a href="#安装oh-my-zsh样式工具" class="headerlink" title="安装oh-my-zsh样式工具"></a>安装oh-my-zsh样式工具</h3><p>在hexoDeploy项目根目录执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Util/oh-my-zsh/installTemplate.sh</span><br></pre></td></tr></table></figure></p><p>会提示<code>sed</code>文件修改失败的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed: can&apos;t read s#export ZSH=.*#export ZSH=&apos;/home/cabox/workspace/huos3203.github.io/Util/oh-my-zsh&apos;#g: No such file or directory</span><br></pre></td></tr></table></figure></p><p>暂时通过手动来修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ../oh-my-zsh/templates/zshrc.zsh-template</span><br></pre></td></tr></table></figure></p><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ZSH=&apos;/home/cabox/workspace/huos3203.github.io/Util/oh-my-zsh&apos;</span><br></pre></td></tr></table></figure></p><h3 id="安装space-vim工具"><a href="#安装space-vim工具" class="headerlink" title="安装space-vim工具"></a>安装space-vim工具</h3><ol><li>执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Util/space-vim/Manualinstall.sh</span><br></pre></td></tr></table></figure></li></ol><p>创建替身失败的提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/cabox/workspace/huos3203.github.io</span><br><span class="line">已经存在</span><br><span class="line">Util/space-vim/Manualinstall.sh: 18: Util/space-vim/Manualinstall.sh: Syntax error: &quot;(&quot; unexpected</span><br></pre></td></tr></table></figure></p><p>手动解决创建替身的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ln -fs /home/cabox/workspace/huos3203.github.io/Util/space-vim/init.vim ~/.vimrc</span><br><span class="line">$ ln -fs /home/cabox/workspace/huos3203.github.io/Util/space-vim/init.spacevim ~/.spacevim</span><br></pre></td></tr></table></figure></p><h3 id="安装vim插件"><a href="#安装vim插件" class="headerlink" title="安装vim插件"></a>安装vim插件</h3><p>启动vim工具，终端自动安装相关插件。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo开发文档及使用教程</title>
      <link href="/2018/09/07/hexo/Hexo%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2018/09/07/hexo/Hexo%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-hexojs-hexo-0b26940" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-hexojs-hexo-0b26940", "hexojs", "hexo", "0b26940", false);</script><p><a href="https://hexo.io/zh-cn/docs/contributing" target="_blank" rel="noopener"></a></p><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>请遵守以下准则：</p><ul><li>遵守 Google JavaScript 代码风格。</li><li>使用 2 个空格缩排。</li><li>不要把逗号放在最前面。<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3></li></ul><ol><li>Fork <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexojs/hexo</a></li><li><p>把库（repository）复制到电脑上，并安装所依赖的插件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/&lt;username&gt;/hexo.git</span><br><span class="line">$ cd hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ git submodule update --init</span><br></pre></td></tr></table></figure></li><li><p>新增一个功能分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b new_feature</span><br></pre></td></tr></table></figure></li><li><p>开始开发。</p></li><li><p>推送（push）分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin new_feature</span><br></pre></td></tr></table></figure></li><li><p>建立一个新的合并申请（pull request）并描述变动.</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>不要修改 <code>package.json</code> 的版本号。<br>只有在测试通过的情况下您的合并申请才会被批准，在提交前别忘了进行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm test</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插件开发</title>
      <link href="/2018/09/07/hexo/Hexo%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2018/09/07/hexo/Hexo%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-hexojs-site-e1839be" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-hexojs-site-e1839be", "hexojs", "site", "e1839be", false);</script><p>Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：</p><h2 id="脚本（Scripts）"><a href="#脚本（Scripts）" class="headerlink" title="脚本（Scripts）"></a>脚本（Scripts）</h2><p>如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 <code>scripts</code> 文件夹，在启动时就会自动载入。</p><h2 id="插件（Packages）"><a href="#插件（Packages）" class="headerlink" title="插件（Packages）"></a>插件（Packages）</h2><p>如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 <code>node_modules</code> 文件夹中建立文件夹，文件夹名称开头必须为 <code>hexo-</code>，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。</p><p>文件夹内至少要包含 2 个文件：一个是主程序，另一个是 <code>package.json</code>，描述插件的用途和所依赖的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── index.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></p><p><code>package.json</code> 中至少要包含 <code>name</code>, <code>version</code>, <code>main</code> 属性，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;hexo-my-plugin&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;main&quot;: &quot;index&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>您可以使用 Hexo 提供的官方工具插件来加速开发：<br><a href="https://github.com/hexojs/hexo-fs" target="_blank" rel="noopener">hexo-fs</a>：文件 IO<br><a href="https://github.com/hexojs/hexo-util" target="_blank" rel="noopener">hexo-util</a>：工具程式<br><a href="https://github.com/hexojs/hexo-i18n" target="_blank" rel="noopener">hexo-i18n</a>：本地化（i18n）<br><a href="https://github.com/hexojs/hexo-pagination" target="_blank" rel="noopener">hexo-pagination</a>：生成分页资料</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>当您完成插件后，可以考虑将它发布到 <a href="https://hexo.io/plugins" target="_blank" rel="noopener">插件列表</a>，让更多人能够使用您的插件。发布插件的步骤和 <a href="https://hexo.io/zh-cn/docs/contributing.html#更新文件" target="_blank" rel="noopener">更新文件</a> 非常类似。</p><ol><li>Fork <a href="https://github.com/hexojs/site" target="_blank" rel="noopener">hexojs/site</a></li><li><p>把库（repository）复制到电脑上，并安装所依赖的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/&lt;username&gt;/site.git</span><br><span class="line">$ cd site</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></li><li><p>编辑 source/_data/plugins.yml，在档案中新增您的插件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- name: hexo-server</span><br><span class="line">description: Server module for Hexo.</span><br><span class="line">link: https://github.com/hexojs/hexo-server</span><br><span class="line">tags:</span><br><span class="line">- official</span><br><span class="line">- server</span><br><span class="line">- console</span><br></pre></td></tr></table></figure></li><li><p>推送（push）分支.</p></li><li>建立一个新的合并申请（pull request）并描述改动。</li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一周膳食计划</title>
      <link href="/2018/09/06/%E5%81%A5%E5%BA%B7/%E4%B8%80%E5%91%A8%E8%86%B3%E9%A3%9F%E8%AE%A1%E5%88%92/"/>
      <url>/2018/09/06/%E5%81%A5%E5%BA%B7/%E4%B8%80%E5%91%A8%E8%86%B3%E9%A3%9F%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><blockquote class="trello-card"><a href="https://trello.com/c/hdKk3KEp/1-%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%92" target="_blank" rel="noopener">一周计划</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zeroTier内网穿透</title>
      <link href="/2018/09/06/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/zeroTier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2018/09/06/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/zeroTier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><blockquote class="trello-card"><a href="https://trello.com/c/uWKfqFDb/24-zerotier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" target="_blank" rel="noopener">zeroTier内网穿透</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git-log的使用</title>
      <link href="/2018/09/05/git/git-log%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/05/git/git-log%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="trello-卡片"><a href="#trello-卡片" class="headerlink" title="trello 卡片"></a>trello 卡片</h2><p><blockquote class="trello-card"><a href="https://trello.com/c/RWMUfhlD/4-git-log%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">git log使用</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><p><a href="http://iissnan.com/progit/html/zh/ch2_3.html" target="_blank" rel="noopener">查看提交历史</a><br>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=<span class="string">"%h - %s"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">--before=<span class="string">"2008-11-01"</span> --no-merges -- t/</span><br><span class="line">5610e3b - Fix testcase failure when extended attribute</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;()</span><br><span class="line">f563754 - demonstrate breakage of detached checkout wi</span><br><span class="line">d1a43f2 - reset --hard/<span class="built_in">read</span>-tree --reset -u: remove un</span><br><span class="line">51a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detac</span><br><span class="line">b0ad11e - pull: allow <span class="string">"git pull origin <span class="variable">$something</span>:<span class="variable">$cur</span></span></span><br></pre></td></tr></table></figure></p><p>Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。</p><h2 id="gitk图形工具"><a href="#gitk图形工具" class="headerlink" title="gitk图形工具"></a>gitk图形工具</h2><p><img src="http://iissnan.com/progit/book_src/figures/18333fig0202-tn.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jazzy生成Swift文档工具</title>
      <link href="/2018/09/05/macOS/Jazzy%E7%94%9F%E6%88%90Swift%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/09/05/macOS/Jazzy%E7%94%9F%E6%88%90Swift%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-realm-jazzy-6932e5e" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-realm-jazzy-6932e5e", "realm", "jazzy", "6932e5e", false);</script><p>demo<br><div id="badge-container-appcoda-SwiftDocSample-24c1649" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-appcoda-SwiftDocSample-24c1649", "appcoda", "SwiftDocSample", "24c1649", false);</script></p><h2 id="使用-Jazzy-产生代码文档"><a href="#使用-Jazzy-产生代码文档" class="headerlink" title="使用 Jazzy 产生代码文档"></a>使用 Jazzy 产生代码文档</h2><p>Jazzy 是一款可以为 Swift 和 Objective-C 代码产生具有 Apple 风格的代码文档工具。事实上，Jazzy 会为你创建一个链接所有代码文档的独立网页。它是一款命令行工具，但还是很容易使用的。<br><a href="https://www.jianshu.com/p/7847a5dc52e2" target="_blank" rel="noopener">在 Xcode 中使用 Markdown 生成 Swift 代码文档</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install jazzy</span><br></pre></td></tr></table></figure><p>gem source不稳定常会导致无法找到jazzy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">https://gems.ruby-china.com</span><br><span class="line"># 确保只有 gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><p>腾讯云：<code>https://gems.ruby-china.com/</code><br>淘宝：<code>https://ruby.taobao.org/</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用 cd 命令将目录切换到工程对应的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path_to_project_folder</span><br><span class="line">Jazzy</span><br></pre></td></tr></table></figure></p><p>输入 <code>Jazzy</code> 之后敲回车,会将标注为 <code>public</code> 的结构写入代码文档。<br>如果你想要包含所有的实体，就输入一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jazzy --min-acl internal</span><br></pre></td></tr></table></figure></p><p>默认输出的文件夹位于工程的根目录（你也可以更改输出路径），叫 <code>docs</code>。<br>当jazzy不支持swift版本时，会导致错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could not parse compiler arguments from `xcodebuild` output.</span><br><span class="line">Please confirm that `xcodebuild` is building a Swift module.</span><br></pre></td></tr></table></figure></p><p>这是就需要在<code>build settings</code>中设置<code>swift Language Version</code>版本号。</p><h3 id="生成指定的swift版本"><a href="#生成指定的swift版本" class="headerlink" title="生成指定的swift版本"></a>生成指定的swift版本</h3><p>如果不是 Swift 的最新版本，发现使用 Jazzy 后没有效果的话，需要先指定 Xcode 支持的 Swift 版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jazzy --swift-version 2.1.1 --min-acl internal</span><br></pre></td></tr></table></figure></p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p><code>jazzy -help</code>查看使用 Jazzy 时可能使用到的参数。当然，你完全可以根据自己的喜好来得到最终的结果。</p><h3 id="集成Xcode"><a href="#集成Xcode" class="headerlink" title="集成Xcode"></a>集成Xcode</h3><p>在项目中添加运行脚本，或创建 其他–&gt;<code>Aggregate</code>在<code>build phases</code>下添加<code>New run script phase</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">author=&quot;iTBoyer&quot;;</span><br><span class="line">author_url=&quot;http://huos3203.github.io&quot;;</span><br><span class="line">github_url=&quot;https://github.com/huos3203&quot;;</span><br><span class="line">sdk=&quot;iphone&quot;;</span><br><span class="line">output=&quot;docs/swift_output&quot;;   #生成的文档地址</span><br><span class="line">docSetDir=&quot;/Users/admin/Library/Developer/Shared/Documentation/DocSets/&quot;</span><br><span class="line"></span><br><span class="line">jazzy \</span><br><span class="line">--objc \</span><br><span class="line">--clean \</span><br><span class="line">--author &quot;$&#123;author&#125;&quot;\</span><br><span class="line">--author_url &quot;$&#123;author_url&#125;&quot; \</span><br><span class="line">--github_url &quot;$&#123;github_url&#125;&quot; \</span><br><span class="line">--module-version 0.96.2 \</span><br><span class="line">--xcodebuild-arguments -scheme,&quot;$&#123;PROJECT_NAME&#125;&quot; \</span><br><span class="line">--module &quot;$&#123;PROJECT_NAME&#125;&quot; \</span><br><span class="line">--sdk  &quot;$&#123;sdk&#125;&quot; \</span><br><span class="line">--output &quot;$&#123;output&#125;&quot; \</span><br><span class="line">#拷贝到xcode文档目录中</span><br><span class="line">echo &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot;</span><br><span class="line">pwd</span><br><span class="line">cp -r &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot; &quot;$&#123;docSetDir&#125;&quot;</span><br></pre></td></tr></table></figure><p>安装到Xcode，在编写代码时，可以快速查看帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#拷贝到xcode文档目录中</span><br><span class="line">echo &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot;</span><br><span class="line">pwd</span><br><span class="line">cp -r &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot; &quot;$&#123;docSetDir&#125;&quot;</span><br></pre></td></tr></table></figure></p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><ul><li><a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">appledoc</a>工具install 方法和更新方法相同</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/tomaz</span><span class="regexp">/appledoc.git</span></span><br><span class="line"><span class="regexp">cd ./appledoc</span></span><br><span class="line">sudo sh install-appledoc.sh</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/omz/Dash-Plugin-for-Xcode#readme" target="_blank" rel="noopener">dash插件</a>的使用</li><li><a href="https://kapeli.com/dash" target="_blank" rel="noopener">下载</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>swift支持的正则（textKit）</title>
      <link href="/2018/09/05/swift/swift%E6%94%AF%E6%8C%81%E7%9A%84%E6%AD%A3%E5%88%99%EF%BC%88textKit%EF%BC%89/"/>
      <url>/2018/09/05/swift/swift%E6%94%AF%E6%8C%81%E7%9A%84%E6%AD%A3%E5%88%99%EF%BC%88textKit%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><blockquote class="trello-card"><a href="https://trello.com/c/kSIkFQXO/5-swift%E6%94%AF%E6%8C%81%E7%9A%84%E6%AD%A3%E5%88%99%EF%BC%88textkit%EF%BC%89" target="_blank" rel="noopener">swift支持的正则（textKit）</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><p><a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80" target="_blank" rel="noopener">正则表达式语法</a>.aspx)<br><a href="http://www.cocoachina.com/ios/20150415/11568.html" target="_blank" rel="noopener">iOS开发之详解正则表达式</a>原文：NSRegularExpression Tutorial: Getting Started<br><a href="http://nshipster.cn/nspredicate/" target="_blank" rel="noopener">nshipster文章NSPredicate</a><br><a href="http://www.cocoachina.com/ios/20160111/14926.html" target="_blank" rel="noopener">iOS中的谓词（NSPredicate）使用</a></p><h2 id="谓词和正则表达式的区别及适用场景"><a href="#谓词和正则表达式的区别及适用场景" class="headerlink" title="谓词和正则表达式的区别及适用场景"></a>谓词和正则表达式的区别及适用场景</h2><ol><li>谓词的对象可以是字符串，集合，同时支持sql语法和正则表达式</li><li>正则表达式，对字符串</li></ol><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。<br>正则表达式的通用用例：</p><ol><li>执行搜索：高亮显示搜索和替换<ol><li>UITextView的NSAttributedString属性来高亮显示搜索的结果</li><li>用text kit来实现高亮的功能</li></ol></li><li>验证用户输入</li></ol>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaunchPad打击垫学习</title>
      <link href="/2018/09/05/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPad%E6%89%93%E5%87%BB%E5%9E%AB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/09/05/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPad%E6%89%93%E5%87%BB%E5%9E%AB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="trello卡片"><a href="#trello卡片" class="headerlink" title="trello卡片"></a>trello卡片</h2><p><blockquote class="trello-card"><a href="https://trello.com/c/FTCK9PPX/29-launchpad%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener">LaunchPad学习</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><p><a href="http://www.bilibili.com/video/av12189950" target="_blank" rel="noopener">第二期：Chain的选择与设置/页数的映射</a></p><ol><li><p>分轨和音频采样</p></li><li><p>音频轨道<br>拖拽音频文件或视频文件到<code>Simple</code>采样轨道中，视频格式会生成<code>asd</code>格式的新文件文件，加载到轨道中。</p></li><li><p>MIDI轨道可以为<code>Lights</code><br>1.1 灯光轨道<br>1.2 鼓点设置</p><h3 id="鼓点音色映射设置，来输出不同的音乐片段"><a href="#鼓点音色映射设置，来输出不同的音乐片段" class="headerlink" title="鼓点音色映射设置，来输出不同的音乐片段"></a>鼓点音色映射设置，来输出不同的音乐片段</h3></li><li>拖动IB控件到MIDI模块</li></ol><h3 id="鼓点灯光映射设置"><a href="#鼓点灯光映射设置" class="headerlink" title="鼓点灯光映射设置"></a>鼓点灯光映射设置</h3><ol><li>拖进MIDI Effects rack控件<br>1.1 点击黄色选项：展开Key:vel:chain:Hide页面<br>1.2 右击蓝色条，选择map selecter<br>1.3 选中右上角的<code>MIDI</code>切换到设置MIDI映射键模式。<br>1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置<br>1.5 新建八个chain，错位蓝色条，完成页数映射的设置<br>1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件</li></ol><p><a href="http://www.bilibili.com/video/av12319673" target="_blank" rel="noopener">第三期：关于分轨和音频采样</a><br><a href="https://www.reddit.com/r/SongStems/" target="_blank" rel="noopener">reddit.com</a><br><a href="https://www.beatport.com/stems" target="_blank" rel="noopener">beatport.com</a><br><a href="https://splice.com/explore/contests" target="_blank" rel="noopener">splice.com</a><br>选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。</p><p><a href="http://www.bilibili.com/video/av12431271" target="_blank" rel="noopener">第四期：基础灯光效果制作</a></p><h3 id="Arpeggiator-（A效果器）"><a href="#Arpeggiator-（A效果器）" class="headerlink" title="Arpeggiator （A效果器）"></a>Arpeggiator （A效果器）</h3><p>设置纵横方向的属性变化<br>效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围</p><ol><li>rate速度：1/1一拍移动一下最慢，1/128最快。</li><li>Gate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光</li><li>style：纵向变化的方向：up/down/upDown/DownUp…</li><li>Hold激活不用长按，即可厂量</li><li><p>repeats：设置走马灯的循环次数</p></li><li><p>A效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。</p></li></ol><h3 id="Chord-（和弦）"><a href="#Chord-（和弦）" class="headerlink" title="Chord （和弦）"></a>Chord （和弦）</h3><ol><li>拖拽到Key列表中的一个垫子的灯光效果包上。</li><li>chord提供六个属性shift1，shift2….shift6，来设置和弦灯光错位，融合等效果<br>第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮<br>第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。<br>以此类推<br>一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮</li></ol><h3 id="MIDI-Effect-Rack"><a href="#MIDI-Effect-Rack" class="headerlink" title="MIDI Effect Rack"></a>MIDI Effect Rack</h3><p>在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。<br>设置灯光效果包</p><ol><li>选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果</li><li>选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置</li><li>新建Velocity（力度感应）</li><li>新建chord（和弦）</li><li>新建Arpeggiator（A效果器）</li></ol><p>Note Length<br>Pitch<br>Random<br>Scale</p><h3 id="Velocity：力度感应"><a href="#Velocity：力度感应" class="headerlink" title="Velocity：力度感应"></a>Velocity：力度感应</h3><ol><li>拖到刚才的chain上，即在该键上添加力度感应属性设置。</li><li>设置灯光颜色：<code>Out Hi</code>的表盘参数，参考MIni支持的灯光色值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>敏捷开发歌诀</title>
      <link href="/2018/09/05/%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%AD%8C%E8%AF%80/"/>
      <url>/2018/09/05/%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%AD%8C%E8%AF%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="trello卡片"><a href="#trello卡片" class="headerlink" title="trello卡片"></a>trello卡片</h2><p><blockquote class="trello-card"><a href="https://trello.com/c/4NID7312/26-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%AD%8C%E8%AF%80%E5%8F%8A%E5%AE%A3%E8%A8%80" target="_blank" rel="noopener">敏捷开发歌诀及宣言</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><h2 id="敏捷开发歌诀"><a href="#敏捷开发歌诀" class="headerlink" title="敏捷开发歌诀"></a>敏捷开发歌诀</h2><p>迭代开发，价值优先<br>分解任务，真实进度<br>站立会议，交流畅通<br>用户参与，调整方向<br>结对编程，代码质量<br>测试驱动，安全可靠<br>持续集成，尽早反馈<br>自动部署，一键安装<br>定期回顾，持续改进<br>不断学习，提高能力</p><h2 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h2><ul><li>个体和交互，胜过过程和工具</li><li>可工作的软件，胜过面面俱到的文档</li><li>客户协作，胜过合同谈判</li><li>响应变化，胜过遵循计划</li></ul><p>虽然右项也有价值，左项具有更大的价值。</p><h2 id="迭代和增量式的学习"><a href="#迭代和增量式的学习" class="headerlink" title="迭代和增量式的学习"></a>迭代和增量式的学习</h2><p>每天计划用一段时间来学习新技术，它不需要很长时间，但需要经常进行。记下那些你想学习的东西–当你听到一些不熟悉的术语或者短语时，简要地把它记录下来。然后在计划的时间中深入研究它。了解最新行情。互联网上有大量关于学习新技术的资源。阅读社区讨论和邮件列表，可以了解其他人遇到的问题，以及他们发现的很酷的解决方案。选择一些公认的优秀技术博客，经常去读一读，以了解那些顶尖的博客作者们正在关注什么（最新的博客列表请参考pragmaticprogrammer.com）。参加本地的用户组活动。Java、Ruby、Delphi、.NET、过程改进、面向对象设计、Linux、Mac，以及其他的各种技术在很多地区都会有用户组。听讲座，然后积极加入到问答环节中。</p><blockquote><p>跟踪技术变化。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。</p></blockquote><h2 id="切身感受"><a href="#切身感受" class="headerlink" title="切身感受"></a>切身感受</h2><p>你能嗅到将要流行的新技术，知道它们已经发布或投入使用。如果必须要把工作切换到一种新的技术领域，你能做到。</p><h3 id="平衡的艺术"><a href="#平衡的艺术" class="headerlink" title="平衡的艺术"></a>平衡的艺术</h3><ul><li>许多新想法从未变得羽翼丰满，成为有用的技术。即使是大型、热门和资金充裕的项目也会有同样的下场。你要正确把握自己投入的精力。</li><li>你不可能精通每一项技术，没有必要去做这样的尝试。只要你在某些方面成为专家，就能使用同样的方法，很容易地成为新领域的专家。</li><li>你要明白为什么需要这项新技术——它试图解决什么样的问题？它可以被用在什么地方？</li><li>避免在一时冲动的情况下，只是因为想学习而将应用切换到新的技术、框架或开发语言。在做决策之前，你必须评估新技术的优势。开发一个小的原型系统，是对付技术狂热者的一剂良药。</li></ul><p>当开发项目的时候，你需要使用一些术语或者隐喻来清晰地传达设计的概念和意图。如果团队中的大部分成员不熟悉这些，就很难进行高效地工作。再比如你参加了一个课程或者研讨班之后，所学的知识如果不用，往往就会忘记。所以，你需要和其他团队成员分享所学的知识，把这些知识引入团队中。</p><p>找出你或团队中的高手擅长的领域，帮助其他的团队成员在这些方面迎头赶上（这样做还有一个好处是，可以讨论如何将这些东西应用于自己的项目中）。</p><p>“午餐会议”是在团队中分享知识非常好的方式。在一周之中挑选一天，例如星期三（一般来说任何一天都可以，但最好不要是星期一和星期五）。事先计划午餐时聚集在一起，这样就不会担心和其他会议冲突，也不需要特别的申请。为了降低成本，就让大家自带午餐。</p><p>每周，要求团队中的一个人主持讲座。他会给大家介绍一些概念，演示工具，或者做团队感兴趣的任何一件事情。你可以挑一本书，给大家说说其中一些特别内容、项目或者实践。①无论什么主题都可以。</p><p>从每周主持讲座的人开始，先让他讲15分钟，然后，进行开放式讨论，这样每个人都可以发表自己的意见，讨论这个主题对于项目的意义。讨论应该包括所能带来的益处，提供来自自己应用程序的示例，并准备好听取进一步的信息。</p><p>这些午餐会议非常有用。它促进了整个团队对这个行业的了解，你自己也可以从其他人身上学到很多东西。优秀的管理者会重用那些能提高其他团队成员价值的人，因此这些活动也直接有助于你的职业生涯。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>heroku的SSH终端命令</title>
      <link href="/2018/09/05/hexo/heroku%E7%9A%84SSH%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/05/hexo/heroku%E7%9A%84SSH%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="启动heroku-终端"><a href="#启动heroku-终端" class="headerlink" title="启动heroku 终端"></a>启动heroku 终端</h2><p><a href="(https://devcenter.heroku.com/articles/exec">Heroku Exec (SSH Tunneling)</a>)<br>每个<code>Heroku exec</code>连接最多持续一个小时。一小时后，您可能需要重新连接。<code>Heroku exec</code>在对Shield Private Spaces是不限制的。</p><p>先在该目录初始化环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku create myhexo</span><br></pre></td></tr></table></figure></p><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku ps:exec</span><br></pre></td></tr></table></figure></li><li><p>bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heroku run bash</span><br><span class="line">//</span><br><span class="line">Heroku ps:stop run #停止所有的dynos</span><br><span class="line">再执行heroku run bash</span><br></pre></td></tr></table></figure></li><li><p>查看正在运行的bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heroku run:detached ls</span><br></pre></td></tr></table></figure></li><li><p>退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heroku dyno:kill dyno</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heroku dyno:restart [dyno]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用LLDB独立调试APP</title>
      <link href="/2018/09/05/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8LLDB%E7%8B%AC%E7%AB%8B%E8%B0%83%E8%AF%95APP/"/>
      <url>/2018/09/05/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8LLDB%E7%8B%AC%E7%AB%8B%E8%B0%83%E8%AF%95APP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://lldb.llvm.org" target="_blank" rel="noopener">lldb官方文档</a><br><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html#//apple_ref/doc/uid/TP40012917-CH4-SW2" target="_blank" rel="noopener">苹果文档</a><br><a href="https://southpeak.github.io/2015/01/25/tool-lldb/" target="_blank" rel="noopener">LLDB调试器使用简介 南峰子译</a><br><a href="http://www.cocoachina.com/ios/20150330/11435.html" target="_blank" rel="noopener">调试：案例学习</a><br><a href="http://www.jianshu.com/p/09a4c1f7c732" target="_blank" rel="noopener">系统翻译文章</a><br><a href="http://codedigging.com/blog/2016-04-27-debugging-ios-binaries-with-lldb/" target="_blank" rel="noopener">Debugging iOS binaries with LLDB</a><br><a href="https://www.jianshu.com/p/2d4083d27653" target="_blank" rel="noopener">高级LLDB调试</a><br><a href="https://www.jianshu.com/p/381d2d232ec1" target="_blank" rel="noopener">LLDB中使用python概览</a></p><h2 id="善用LLDB"><a href="#善用LLDB" class="headerlink" title="善用LLDB"></a>善用LLDB</h2><p>如果想断点到某种场景，不是先随意打个断点然后一直单步到出问题的那行代码，最佳的做法是充分利用LLDB的特性以一次性定位到你所感兴趣的代码。</p><ol><li>自定义数据类型<br>因为LLDB默认是只输出系统类型的，而并不认识自定义的数据类型，所以需要告诉LLDB你所关注的自定义数据类型及其数据，实现对数据的查看。</li><li>合理开销<br>为了避免重新构建所带来的时间开销，你需要学会编写调试代码，以改变应用的执行路径，并修改数据，比如初始化还未初始代的数据。你所输入并执行的表达式会改变应用原本的执行路径，所以对此所带来的副作用你需要有清晰的把控。</li></ol><h3 id="正确的调试过程"><a href="#正确的调试过程" class="headerlink" title="正确的调试过程"></a>正确的调试过程</h3><ol><li>想通过LLDB获取什么信息？</li><li>断点到可疑的代码块</li><li>在正在执行的代码中一步步执行</li><li>观察数据并验证猜想</li></ol><h3 id="LLDB的使用时机和作用"><a href="#LLDB的使用时机和作用" class="headerlink" title="LLDB的使用时机和作用"></a>LLDB的使用时机和作用</h3><p>什么时候用LLDB,LLDB能在调试的时候怎样帮助你</p><ol><li>debug-Only assertion<br>它能帮助你知道应用中的运行异常，以及各组件之间传递的参数是否与约定的一致。但是不要在assertion中做对应用逻辑有影响的操作，因为一旦构建发布版本，这些assertion都会被屏幕，你在其中执行的操作也就不会进行了。<br>所以，当发现bug时，LLDB并不是你的第一选择，而应该是debug-Only assertion。</li><li>log  apple system log(ASL)<br>而对于在运行中各处都看起来很正常，最终却呈现了错误的结果的情况，log会是一个非常有用的工具。而此处的log指的并不是NSLog，而是apple system log(ASL)，其可以通过console观察到。</li></ol><ul><li>level<br>ASL可以通过log的level来区分log的严重程序，比如<code>ASL_LEVEL_EMERG</code>和<code>ASL_LEVEL_DEBUG</code>。</li><li>tag<br>同时还可以附带使用hash tag以方便log的查找，比如为特定的业务添加特定的业务字符串等。而鉴于log可能被滥用，所以ASL可以通过开关提供某些log是否应该进行。<br>正常的开关方式可以是可以使用NSUserDefaults等，或者也可以在shell中设置一个变量，程序在运行的时候读取此值以决定是否进行log。</li></ul><ol start="3"><li>Xcode 静态代码分析器<br>Xcode可以为程序做的，<code>-Weverything</code>和静态代码分析器可以在代码运行前的编译阶段即发现可能存在的问题。可以在之前的session： What’s New In LLVM和What’s New In the LLVM Compiler中找到相关内容。而在运行期间可以通过Guard Malloc发现堆上缓存overrun的问题，通过zombie objects获取对释放了的对象进行方法调用的问题。具体可以参见Advanced Memory Analysis with Instruments</li></ol><h3 id="LLDB的正确打开方式"><a href="#LLDB的正确打开方式" class="headerlink" title="LLDB的正确打开方式"></a>LLDB的正确打开方式</h3><ol><li>两种启模式：一种是通过Xcode上的按钮，另一种是通过console中的lldb调试语言。</li><li>三种命令表达式：discoverable,abbreviated及alias形式，<br><code>discoverable</code>格式: expression –object-description – foo<br><code>abbreviated</code>格式:  e -0 – foo<br><code>alias</code>格式: po foo<br>同一个命令三种方式，书写繁琐程度递减，而且可以定义自己的alias 形式的命令。</li><li>设置断点<br>行号断点：<code>b MyCode.m:4（breakpoint set --file MyCode.m --line 4）</code><br>方法断点：<code>b &quot;-[MyClass method:]&quot;（breakpoint set --name &quot;-MyClass method:]&quot;）</code><br>selector断点: <code>b method:（breakpoint set --selector method:）</code></li></ol><h3 id="省时的命令"><a href="#省时的命令" class="headerlink" title="省时的命令"></a>省时的命令</h3><p>鉴于在app及Xcode之间因为多次中断而进行的多次切换，可以在断点发生之后执行特定的命令，比如希望查看的数据之后再立即恢复执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b &quot;-[MyClass method:]&quot;</span><br><span class="line">br co a/breakpoint command add</span><br><span class="line">&gt;p rect/expression rect</span><br><span class="line">&gt;bt/thread backtrace</span><br><span class="line">&gt;c/process continue</span><br><span class="line">&gt;DONE</span><br></pre></td></tr></table></figure></p><p>这些命令也可以在Xcode面板中通过点击及输入完成同样的功能。</p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>如果不希望断点频繁触发，可以通过条件断点来达到此目的，比如想在某个特定对象析构的消息处断点，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p id $myModel = self/expression id $myModel = self</span><br><span class="line">b &quot;-[MyClass dealloc]&quot;/breakpoint set  &quot;-[MyClass dealloc]&quot;</span><br><span class="line">br m -c &quot;self == $myModel&quot;/breakpoint modify --condition &quot;self == $myModel&quot;</span><br></pre></td></tr></table></figure></p><h3 id="通过watchpoint监控特定内存空间"><a href="#通过watchpoint监控特定内存空间" class="headerlink" title="通过watchpoint监控特定内存空间"></a>通过watchpoint监控特定内存空间</h3><p><code>watchpoint</code>的应用场景在于有人会修改某个变量值，你对此很关心但只知道变量的地址，其行为方式是如果变量被访问则watchpoint会暂停app的运行，设置watchpoint的方式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w s v self-&gt;_needsSynchronization/watchpoint set variable self-&gt;_needsSynchronization</span><br></pre></td></tr></table></figure></p><p>受限于CPU的支持程度，在intel平台上，提供了4个slot供watchpoint使用，所以同时只可设置最多4个watchpoint，arm上是2个<br>watchpoint也可以在Xcode的控制面板中进行操作，只需要在变量区域中右击某变量选择菜单中的watchpoint选项即可</p><h3 id="避免不断单步的高招"><a href="#避免不断单步的高招" class="headerlink" title="避免不断单步的高招"></a>避免不断单步的高招</h3><p>LLDB可以在两种场景下暂停程序的执行：</p><ol><li>执行到程序的具体某行代码的时候<br>这种场景的实用命令是<code>thread until linenum</code>，避免一步步单步执行到希望的行，在xcode中这个功能对应的操作是右击代码行选择<code>continue to this line</code>。</li><li>函数返回之后</li></ol><h3 id="LLDB中手动执行代码"><a href="#LLDB中手动执行代码" class="headerlink" title="LLDB中手动执行代码"></a>LLDB中手动执行代码</h3><p>很多时候你可能会发现，要想让你希望执行的代码执行一遍会很困难，比如单元测试的时候某个用例就是无法进行测试，这种情况下你需要用Clang([‘kl^n])直接调用这份代码，调用方式是直接在命令行表达式中输入你希望执行的代码并执行，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &quot;-[ModelDerived removeDuplicates]&quot;</span><br><span class="line">e -i false -- [self removeDuplicates]/expression --ignore-breakpoints false -- [self removeDuplicates]</span><br></pre></td></tr></table></figure></p><p>先在方法上打断点，然后在LLDB中执行此函数，选择不要忽略断点，你会发现执行此<code>expression</code>之后会断点到<code>removeDuplicates</code>，接着即可对其进行执行。<br>然而有一点需要特别注意的是，通过LLDB执行的表达式代码是在你的进程中执行的，所以需要对此所带来的后果有自己的认知。</p><h2 id="检查数据以找寻事情的缘由"><a href="#检查数据以找寻事情的缘由" class="headerlink" title="检查数据以找寻事情的缘由"></a>检查数据以找寻事情的缘由</h2><p>在上述的操作之后，我们已经可以断点到我们希望断点的位置了，接着就是检查数据寻找事情发生的原因了，这部分有3方面内容：</p><h3 id="在LLDB命令行中检查数据"><a href="#在LLDB命令行中检查数据" class="headerlink" title="在LLDB命令行中检查数据"></a>在LLDB命令行中检查数据</h3><p>查看局部变量：<code>frame variable</code><br>执行任意代码： <code>expression (x+35)</code> 其会通过app使用的编译器进行编译并在你的app中执行<br><code>p @&quot;hello&quot;</code> 兼容expression的语法，执行表达式并输出结果<br><code>po @&quot;hello&quot;</code> 执行任意代码并输出结果的description</p><h3 id="LLDB实用数据格式"><a href="#LLDB实用数据格式" class="headerlink" title="LLDB实用数据格式"></a>LLDB实用数据格式</h3><p>需要先搞清楚<code>raw data</code>和<code>data</code>的区别，<br><code>raw data</code>:是内存中所存储的数据，但它并不易读，对你来说可能太复杂，或者并不是你理解的数据类型，又或者它的数据量很大。<br>解析：如果想对raw data有个直观的印象，只需要在Xcode的变量区域选择show raw values就可以在观察任意一个栈帧的时候看到raw data了，而此时切换到show types就可以看到规整而有意义的数据呈现形式了，这就是 LLDB 数据格式所要达到的目的。<br>对于内置的系统库STL,CoreFoundation,Foundation，其中的数据都已经添加了<code>Data formatter</code>，在调试的时候显示都很规整<br>对于程序员自定义的数据类型的data formatter，苹果构建了可扩展的data formatter子系统，这意味着程序员也可以为自定义的类型添加data formatter。</p><h4 id="自定义data-formatter"><a href="#自定义data-formatter" class="headerlink" title="自定义data formatter"></a>自定义data formatter</h4><p>数据类型的data formatter包括两部分：综述summary，用于呈现数据的关键描述；所组成的子数据即synthetic children<br>以使用python定义summary为例，summary会将一种数据类型与一个python函数映射起来，基础的映射是通过类型名，更多其它规则可以<a href="http://lldb.llvm.org/varformats.html" target="_blank" rel="noopener">参见</a><br>这个python函数会在此类型的数据在展示的时候被调用，LLDB会将一个<code>SBValue</code>传递给它，SBValue是LLDB对象模型的一部分，可以将其简单地想象成为一个变量，这个python函数最终会返回一个字符串，这个字符串即会被当做summary</p><h4 id="SBValue"><a href="#SBValue" class="headerlink" title="SBValue"></a>SBValue</h4><p>之前提到SBValue可以当做一个变量来对待，可以询问其name,data type,summary(如果有的话),是否有children,有多少children,是否可以详述每个child的信息,每个child的信息其实也是一个SBvalue，所以整个是一个递归的过程。如果值是一个比如数字这样的标量，整数，浮点数等，也可以询问其value。<br>对自定义类进行summary<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def MyClass_Summary(value,unused)://其中value是一个SBValue</span><br><span class="line">//由于是自己定义的数据，可先获取其中的成员变量，成员变量也是SBValue</span><br><span class="line">member1 = value.GetChildMemberWithName(&quot;_member1&quot;)</span><br><span class="line">member2 = value.GetChildMemeberWithName(&quot;_member2&quot;)</span><br><span class="line">member1Summary = member1.GetSummary()</span><br><span class="line">member2Summary = member2.GetSummary()</span><br><span class="line">#当然也可以做任何你想做的事情，这里仅仅只是简单地组合两个成员的summary</span><br><span class="line">return member1Summary + &quot; &quot; + member2Summary</span><br></pre></td></tr></table></figure></p><p>完成了这个python函数之后，变量区域中仍然不能正确显示MyClass的自定义数据类型，因为你还需要在LLDB中执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ty su a MyClass -F MyClass_Summary/type summary add MyClass --python-function MyClass_Summary</span><br></pre></td></tr></table></figure></p><h4 id="审视不透明的数据"><a href="#审视不透明的数据" class="headerlink" title="审视不透明的数据"></a>审视不透明的数据</h4><p>先介绍下用于数据分析的expression，可以通过如下形式定义一个持久有效的结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression struct $NotOpaque&#123;int item1;float item2;char* item3;&#125;</span><br></pre></td></tr></table></figure></p><p>对于第3方库提供的对象，你可能连其数据类型都不知道，更不会知道其中成员变量的定义，可能通过google之后，可以发现其具体的定义，这时候，就需要使用上述expression再结合summary，即可以在展示的时候使用自定义的data formatter了.</p><h2 id="扩展LLDB"><a href="#扩展LLDB" class="headerlink" title="扩展LLDB"></a>扩展LLDB</h2><h3 id="自定义LLDB命令"><a href="#自定义LLDB命令" class="headerlink" title="自定义LLDB命令"></a>自定义LLDB命令</h3><p>通过python脚本，可以为调试器添加新特性，实现自定义的操作/自动化的操作过程<br>比如计算递归的层数，想想LLDB怎么也算是个强大的程序，数数对它来说应该不是什么难事，更加说相比于你手工一个栈帧一个栈帧地数了。</p><h3 id="LLDB-对象模型"><a href="#LLDB-对象模型" class="headerlink" title="LLDB 对象模型"></a>LLDB 对象模型</h3><p>LLDB的强大在于它所使用的LLDB对象模型，我们称其为”SB”(scripting bridge)，这是个<code>python API</code>，xcode用其来构建debugger的UI，这意味着对你可以完全地通过LLDB脚本使用SB的所有功能，同时其也有一套对调试session的描述：<br>对于上述调试界面相信大家都比较熟悉，LLDB对象模型对其的描述是这样：<code>SBTarget</code>即是调试中的target，接着在点击了xcode中的运行按钮之后，这个target成为了一个活着的实体，对这个实体，你可以输入，点哪，点哪，点，这即是在机器底层上运行的进程称为SBProcess，进程有着很多用来完成任务的thread，即SBThread，而SBThread会不停地执行function，每个function都会而每次function调用都会对应栈上的一帧，即SBFrame，现在我们已经了解到了描述程序运行中的所有对象，接下来看看怎样完成我们想完成的任务。<br>首先需要知道的是python命令是如何执行的呢，python函数是与LLDB中的命令一一对应的，LLDB看到这个命令的时候即会调用相应的python命令，python命令的原型是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def MyCommand_Impl(debugger,user_input,result,unused):</span><br></pre></td></tr></table></figure></p><p><code>debugger</code>:是一个SBDebugger<br><code>user_input</code>:是用户输入的python字符串<br><code>result</code>:是SBCommandReturnObject，是用来反馈给LLDB的，反馈执行成功与否等信息<br>添加自定义的命令的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">co sc a foo -f foo/command script add foo --python-function foo</span><br></pre></td></tr></table></figure></p><h3 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h3><p>断点的痛点在于它会不停在中断程序的执行，条件断点会好一点，有了断点action，我们可以只在自己关注的场景停下来<br>断点action是将断点与一个python函数联系起来，断点命中的时候会调用此python函数，而其可以返回false以勾选断点编辑界面中的continue选择框以让LLDB继续运行<br>此python函数的原型是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def break_on_deep_traversal(frame,bp_loc,unused):</span><br></pre></td></tr></table></figure></p><p><code>frame</code>类型:为SBFrame<br><code>bp_loc</code>类型:为SBBreakpointLocation<br>绑定python函数的命令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br co a -s p -F foo 1 /breakpoint command add --script python --python-function foo 1</span><br></pre></td></tr></table></figure></p><p>首先需要注意的是WWDC中python代码样例的函数function中常看到<code>unused</code>作为结尾参数，在实际使用python函数时如果未理解其深意，可能会不知其所以然。<br>断点中的全局变量<code>frame</code>和<code>bp_loc</code>分别是断点栈帧的指针及断点处的代码描述信息，<code>bp_lo</code>c打印出来类似于这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1: where = YourApp`-[SomeViewController onDynamicMethod:paraList:] + 117 at SomeViewController.m:109, address = 0x000000010f9cf3d5, resolved, hit count = 4</span><br></pre></td></tr></table></figure></p><p>在将function作为python命令添加时，命中断点之后lldb会为指定的断点命令函数传入3个参数即<code>frame</code>,<code>bp_loc</code>和<code>internal_dict</code>。</p><p>LLDB在设计之初即提供了两种范畴的脚本化方式：<br>即可以在Unix环境的python应用中使用LLDB开启并进行一段不能进行交互的调试session；<br>在LLDB中使用python脚本进行诸如监视数据，遍历容器或者决定断点是该暂停程序执行还是继续程序的执行。</p><h4 id="在python中操作程序中的变量"><a href="#在python中操作程序中的变量" class="headerlink" title="在python中操作程序中的变量"></a>在python中操作程序中的变量</h4><p>在实现这个目标之前，需要解决的一个问题是，程序中的<code>变量</code>需要转换成python可以访问的形式，这个时候就需要用到<code>LLDB API</code>，它是作为python的LLDB模块提供的。<br>在LLDB中运行python时，LLDB会自动将当前帧对象通过<code>lldb.frame</code>这个python变量提供出来，其类型是SBFrame，可以通过<code>FindVariable</code>方法向帧对象询问其本地变量，通过此方法获得的对象是SBValue对象，可以通过SBValue.h中的方法，比如 <code>GetChildMemberWithName()</code>, <code>GetSummary()</code>, 及<code>GetValue()</code>等方法获取具体的信息。<br><strong>程序中的变量值最终是如何转换成python中任意取用的信息的呢？</strong><br>原来LLDB在捕获到程序作用域中的变量之后都是将其封装在SBValue对象中，通过SBValue的API即可获取到封装在其中的变量值的具体信息，对于对象类型的变量，可以通过<code>GetChildMemberWithName</code>获取其成员变量的值，若原本是一个字符串，则使用<code>GetSummary</code>获取字符串，通过<code>GetValue</code>获取数值相关的值等。</p><h4 id="用断点命令script完成最终的临门一脚"><a href="#用断点命令script完成最终的临门一脚" class="headerlink" title="用断点命令script完成最终的临门一脚"></a>用断点命令script完成最终的临门一脚</h4><p>有了操作局部变量的神技，实战操作的时候就可以这么玩了，在可疑处打断点，读取临时变量的值检查与预期是否相符，此处的一个小tip是:<br>将python脚本操作编写在一个python文件里面的function里面，通过import的形式导入并调用其中的function，以免在lldb中输入起来繁琐。<br><strong>断点命令script的奥义</strong><br>如果在lldb命令行中为某断点添加python脚本，比如通常是这样<code>breakpoint command add -s python breakpointnum</code> ，输入一到数行python脚本，则LLDB会自行将这数行代码封装成一个python函数并传递两个参数，即frame和bp_loc，断点命中时，即会调用此函数，并传入断点时当前帧对象<code>frame</code>及断点位置信息对象<code>bp_loc</code>。<br>由此可知，在实际编写断点命令的时候，需要注意这样两点：</p><ol><li>如果想访问你脚本之外创建的python变量，需要将其声明为<code>global</code>，否则其会被当做局部变量，即需要在断点命令脚本中显式声明，比如<code>global variable</code></li><li>所有python断点命令脚本都能够访问到frame和bp_loc</li></ol><p>举例在断点处的当前栈帧位于特定帧中时命中断点<br><img src="https://upload-images.jianshu.io/upload_images/268750-fd4dea29302d79d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt><br>第一步通过import导入本地的脚本文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command script import ~/lldb/inGivenFrame.py</span><br></pre></td></tr></table></figure></p><p>第二步通过codeline添加断点，<br>第三步添加断点命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br comm add --script-type python -o &quot;inGivenFrame.inGivenFrame(frame,location,&apos;-[NSObjec givenfuncname]&apos;)&quot; 1</span><br></pre></td></tr></table></figure></p><p>如果不需要传入第三个参数，则也可以使用<code>-F</code>选项，此时命令形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br comm add --script-type python -F inGivenFrame.inGivenFrameF 1</span><br></pre></td></tr></table></figure></p><p>此时在断点命中时，lldb传给<code>inGivenFrameF</code>函数的第三个参数的意义也有所变更，此时传入的是名为<code>internal_dict</code>的变量，包含额外的信息<br><img src="https://upload-images.jianshu.io/upload_images/268750-1d39bf553e26bac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt><br>使用<code>inGivenFrameF</code>作为断点命令的操作步骤及执行结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/268750-1ef6878f7a3a72ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt></p><p><strong>问题</strong><br>现在想通过lldb来调试自己的iOS项目，官方提供了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lldb /Projects/Sketch/build/Debug/Sketch.app     </span><br><span class="line">(lldb) process launch</span><br></pre></td></tr></table></figure><p>当按照这种方式指定到路径iOS项目时,打印：</p><p>(lldb) target create “/Users/admin/Desktop/Recommend.app”<br>Current executable set to ‘/Users/admin/Desktop/Recommend.app’ (arm64).</p><p>但是启动时出现问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) run     </span><br><span class="line">error: the platform is not currently connected</span><br></pre></td></tr></table></figure><p>大神，有没有解决办法？</p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowrocket无需越狱重签翻墙</title>
      <link href="/2018/09/05/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/shadowrocket%E6%97%A0%E9%9C%80%E8%B6%8A%E7%8B%B1%E9%87%8D%E7%AD%BE%E7%BF%BB%E5%A2%99/"/>
      <url>/2018/09/05/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/shadowrocket%E6%97%A0%E9%9C%80%E8%B6%8A%E7%8B%B1%E9%87%8D%E7%AD%BE%E7%BF%BB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-WCShadowrocket-f101e23" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-WCShadowrocket-f101e23", "huos3203", "WCShadowrocket", "f101e23", false);</script><p><a href="https://www.hinwen.com/3662.html/3/" target="_blank" rel="noopener">一次讲透：IOS翻墙利器“小火箭（Shadowrocket）”上手、进阶、配合Workflow获取免费节点攻略</a></p><h1 id="iOS版Shadowrocket-完美重签-无需付费-无需越狱"><a href="#iOS版Shadowrocket-完美重签-无需付费-无需越狱" class="headerlink" title="iOS版Shadowrocket 完美重签 无需付费 无需越狱~"></a>iOS版Shadowrocket 完美重签 无需付费 无需越狱~</h1><h3 id="越狱手机砸壳工具-详见https-github-com-AloneMonkey-frida-ios-dump"><a href="#越狱手机砸壳工具-详见https-github-com-AloneMonkey-frida-ios-dump" class="headerlink" title="越狱手机砸壳工具 详见https://github.com/AloneMonkey/frida-ios-dump"></a>越狱手机砸壳工具 详见<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">https://github.com/AloneMonkey/frida-ios-dump</a></h3><h3 id="砸壳教程https-github-com-we11cheng-WCStudy-blob-master-frida-ios-dump-md"><a href="#砸壳教程https-github-com-we11cheng-WCStudy-blob-master-frida-ios-dump-md" class="headerlink" title="砸壳教程https://github.com/we11cheng/WCStudy/blob/master/frida-ios-dump.md"></a>砸壳教程<a href="https://github.com/we11cheng/WCStudy/blob/master/frida-ios-dump.md" target="_blank" rel="noopener">https://github.com/we11cheng/WCStudy/blob/master/frida-ios-dump.md</a></h3><h3 id="dumpdecrypted砸壳https-github-com-we11cheng-WCStudy-blob-master-dumpdecrypted-20-E5-AF-BC-E5-87-BA-E5-A4-B4-E6-96-87-E4-BB-B6-md"><a href="#dumpdecrypted砸壳https-github-com-we11cheng-WCStudy-blob-master-dumpdecrypted-20-E5-AF-BC-E5-87-BA-E5-A4-B4-E6-96-87-E4-BB-B6-md" class="headerlink" title="dumpdecrypted砸壳https://github.com/we11cheng/WCStudy/blob/master/dumpdecrypted%20%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6.md"></a>dumpdecrypted砸壳<a href="https://github.com/we11cheng/WCStudy/blob/master/dumpdecrypted%20%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6.md" target="_blank" rel="noopener">https://github.com/we11cheng/WCStudy/blob/master/dumpdecrypted%20%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6.md</a></h3><h3 id="Clutch砸壳https-github-com-we11cheng-WCStudy-blob-master-Clutch-E7-A0-B8-E5-A3-B3-E8-8F-9C-E9-B8-A1-E7-89-88-md"><a href="#Clutch砸壳https-github-com-we11cheng-WCStudy-blob-master-Clutch-E7-A0-B8-E5-A3-B3-E8-8F-9C-E9-B8-A1-E7-89-88-md" class="headerlink" title="Clutch砸壳https://github.com/we11cheng/WCStudy/blob/master/Clutch%E7%A0%B8%E5%A3%B3(%E8%8F%9C%E9%B8%A1%E7%89%88).md"></a>Clutch砸壳<a href="https://github.com/we11cheng/WCStudy/blob/master/Clutch%E7%A0%B8%E5%A3%B3(%E8%8F%9C%E9%B8%A1%E7%89%88).md" target="_blank" rel="noopener">https://github.com/we11cheng/WCStudy/blob/master/Clutch%E7%A0%B8%E5%A3%B3(%E8%8F%9C%E9%B8%A1%E7%89%88).md</a></h3><h3 id="其他砸壳收集请戳https-github-com-we11cheng-WCCrackedCollect"><a href="#其他砸壳收集请戳https-github-com-we11cheng-WCCrackedCollect" class="headerlink" title="其他砸壳收集请戳https://github.com/we11cheng/WCCrackedCollect"></a>其他砸壳收集请戳<a href="https://github.com/we11cheng/WCCrackedCollect" target="_blank" rel="noopener">https://github.com/we11cheng/WCCrackedCollect</a></h3><h2 id="本repo使用方法如下"><a href="#本repo使用方法如下" class="headerlink" title="本repo使用方法如下:"></a>本repo使用方法如下:</h2><h4 id="1、安装MonkeyDev-如已安装，跳过"><a href="#1、安装MonkeyDev-如已安装，跳过" class="headerlink" title="1、安装MonkeyDev(如已安装，跳过)"></a>1、安装MonkeyDev(如已安装，跳过)</h4><ul><li>安装最新的theos</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure><ul><li>安装ldid(如安装theos过程安装了ldid，跳过)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure><ul><li>指定的Xcode</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode.app</span><br></pre></td></tr></table></figure><ul><li>执行安装命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure><ul><li>更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure><ul><li>卸载</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot;</span><br></pre></td></tr></table></figure><h4 id="2、运行工程"><a href="#2、运行工程" class="headerlink" title="2、运行工程"></a>2、运行工程</h4><ul><li>打开工程 WCShadowrocket.xcodeproj </li><li>选择证书：自动配置证书即可（相信大家都是没有问题的）。</li><li>选择设备(不可选择模拟器，且仅支持64位设备)运行。</li><li>本次测试机iphone6s 10.3.3 xcode 9.3（iOS11测试过可以运行,其他机型应该也没啥问题）。</li></ul><h2 id="版权及免责声明"><a href="#版权及免责声明" class="headerlink" title="版权及免责声明"></a>版权及免责声明</h2><ul><li>iOS逆向实践，不可使用于商业和个人其他意图。一切问题均由个人承担，与本人无关。</li><li>感谢MonkeyDev的作者庆总<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev</a>。</li><li>如内容对您的权利造成了影响，请<a href="https://github.com/we11cheng/WCShadowrocket/issues" target="_blank" rel="noopener">issues</a>, 我会在第一时间进行删除。</li></ul><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://p2bzzkn05.bkt.clouddn.com/18-4-10/70735207.jpg" alt></p><h2 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h2><p>点右上角的 Star 可以领红包，不信你试试。重签付费应用就是这么容易，感谢MonkeyDev作者。</p><h2 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h2><ul><li>提供免费付费软件砸壳，理论上支持越狱手机上所有软件砸壳，砸壳以后拖入MonkeyDev开始逆向之旅吧~。应用列表：Shu Thor Detour Kitsunebi Pythonista HyperApp JSBOx Surge Quantumult PPHub Tik Tok Mume Mume Red …</li><li>2018-5-29 添加自建vps ssr&amp;ss节点信息。虽然延迟有点高，但还是能用的。完全自己搭建，(有限制流量，不够再加)放心使用~  </li></ul><h3 id="SS-链接-ss-YWVzLTI1Ni1jdHI6Z3djcGF-f0AxOTguMTgxLjM1LjIzOjEwMDAx"><a href="#SS-链接-ss-YWVzLTI1Ni1jdHI6Z3djcGF-f0AxOTguMTgxLjM1LjIzOjEwMDAx" class="headerlink" title="SS    链接 : ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx"></a>SS    链接 : ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx</h3><h3 id="SS-二维码-http-doub-pw-qr-qr-php-text-ss-YWVzLTI1Ni1jdHI6Z3djcGF-f0AxOTguMTgxLjM1LjIzOjEwMDAx"><a href="#SS-二维码-http-doub-pw-qr-qr-php-text-ss-YWVzLTI1Ni1jdHI6Z3djcGF-f0AxOTguMTgxLjM1LjIzOjEwMDAx" class="headerlink" title="SS  二维码 : http://doub.pw/qr/qr.php?text=ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx"></a>SS  二维码 : <a href="http://doub.pw/qr/qr.php?text=ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx" target="_blank" rel="noopener">http://doub.pw/qr/qr.php?text=ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx</a></h3><h3 id="SSR-链接-ssr-MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw"><a href="#SSR-链接-ssr-MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw" class="headerlink" title="SSR   链接 : ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw"></a>SSR   链接 : ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw</h3><h3 id="SSR-二维码-http-doub-pw-qr-qr-php-text-ssr-MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw"><a href="#SSR-二维码-http-doub-pw-qr-qr-php-text-ssr-MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw" class="headerlink" title="SSR 二维码 : http://doub.pw/qr/qr.php?text=ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw"></a>SSR 二维码 : <a href="http://doub.pw/qr/qr.php?text=ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw" target="_blank" rel="noopener">http://doub.pw/qr/qr.php?text=ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw</a></h3><h3 id="规则详见https-github-com-lhie1-Rules，自行选择使用，更多规则https-github-com-h2y-Shadowrocket-ADBlock-Rules"><a href="#规则详见https-github-com-lhie1-Rules，自行选择使用，更多规则https-github-com-h2y-Shadowrocket-ADBlock-Rules" class="headerlink" title="规则详见https://github.com/lhie1/Rules，自行选择使用，更多规则https://github.com/h2y/Shadowrocket-ADBlock-Rules"></a>规则详见<a href="https://github.com/lhie1/Rules" target="_blank" rel="noopener">https://github.com/lhie1/Rules</a>，自行选择使用，更多规则<a href="https://github.com/h2y/Shadowrocket-ADBlock-Rules" target="_blank" rel="noopener">https://github.com/h2y/Shadowrocket-ADBlock-Rules</a></h3><h2 id="2018-6-26-新增ssr节点订阅模式-免费-。"><a href="#2018-6-26-新增ssr节点订阅模式-免费-。" class="headerlink" title="2018-6-26 新增ssr节点订阅模式(免费)。"></a>2018-6-26 新增ssr节点订阅模式(免费)。</h2><h3 id="参考https-tool-ssrshare-xyz-tool-free-ssr"><a href="#参考https-tool-ssrshare-xyz-tool-free-ssr" class="headerlink" title="参考https://tool.ssrshare.xyz/tool/free_ssr"></a>参考<a href="https://tool.ssrshare.xyz/tool/free_ssr" target="_blank" rel="noopener">https://tool.ssrshare.xyz/tool/free_ssr</a></h3><h3 id="如何订阅"><a href="#如何订阅" class="headerlink" title="如何订阅"></a>如何订阅</h3><ul><li>打开shadowrocket 首页，点击右上角+号。模式选择Subscribe</li><li>URL部分输入以下三个地址（一个或多选，多选表示订阅多个）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 所有(golbal)可用订阅:</span><br><span class="line">https://tool.ssrshare.xyz/tool/api/getGolSub?key=1529942400_8_xuo</span><br><span class="line">实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 中国(CN)可用订阅:</span><br><span class="line">https://tool.ssrshare.xyz/tool/api/getCnSub?key=1529942400_8_xuo</span><br><span class="line">非实时订阅链接（无密码）:</span><br><span class="line">https://raw.githubusercontent.com/ImLaoD/sub/master/ssrshare.com</span><br></pre></td></tr></table></figure><ul><li>点击完成，就能发现节点列表新增了我们订阅节点信息。选择一个可以的连接即可。</li></ul><h4 id="最后一个订阅地址是开源的-托管在git-。查看作者repo"><a href="#最后一个订阅地址是开源的-托管在git-。查看作者repo" class="headerlink" title="最后一个订阅地址是开源的(托管在git)。查看作者repo"></a>最后一个订阅地址是开源的(托管在git)。<a href="https://github.com/ImLaoD/sub" target="_blank" rel="noopener">查看作者repo</a></h4><h2 id="2018-7-17-更新"><a href="#2018-7-17-更新" class="headerlink" title="2018-7-17 更新"></a>2018-7-17 更新</h2><h4 id="添加了Capabilities下Person-VPN-Network-Extensions-帮助https-github-com-we11cheng-WCStudy-blob-master-iOS-20Widget-20Extensions-E8-AF-81-E4-B9-A6-E9-85-8D-E7-BD-AE-md"><a href="#添加了Capabilities下Person-VPN-Network-Extensions-帮助https-github-com-we11cheng-WCStudy-blob-master-iOS-20Widget-20Extensions-E8-AF-81-E4-B9-A6-E9-85-8D-E7-BD-AE-md" class="headerlink" title="添加了Capabilities下Person VPN Network Extensions 帮助https://github.com/we11cheng/WCStudy/blob/master/iOS%20Widget%20Extensions%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.md"></a>添加了Capabilities下Person VPN Network Extensions 帮助<a href="https://github.com/we11cheng/WCStudy/blob/master/iOS%20Widget%20Extensions%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.md" target="_blank" rel="noopener">https://github.com/we11cheng/WCStudy/blob/master/iOS%20Widget%20Extensions%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.md</a></h4><p><img src="https://github.com/we11cheng/WCImageHost/raw/master/WX20180717-102431.png" alt></p><h3 id="添加节点的时候，遇到问题，还没解决-求大佬们一起解决它"><a href="#添加节点的时候，遇到问题，还没解决-求大佬们一起解决它" class="headerlink" title="添加节点的时候，遇到问题，还没解决..求大佬们一起解决它.."></a>添加节点的时候，遇到问题，还没解决..求大佬们一起解决它..</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CoreData: annotation:  Failed to load optimized model at path &apos;/var/containers/Bundle/Application/9D19C752-5139-426B-815E-2A68B632352F/WCShadowrocket.app/Shadowrocket.momd/Shadowrocket 7.omo&apos;</span><br><span class="line">*** Terminating app due to uncaught exception &apos;NSFileHandleOperationException&apos;, reason: &apos;*** -[NSConcreteFileHandle seekToFileOffset:]: Bad file descriptor&apos;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/we11cheng/WCImageHost/raw/master/WX20180717-102320.png" alt></p><h3 id="最新福利，谷歌云上搭建了一个App-Engine-爬取ssr-ss节点，拿去不谢-https-sspy-210307-appspot-com-（已失效）"><a href="#最新福利，谷歌云上搭建了一个App-Engine-爬取ssr-ss节点，拿去不谢-https-sspy-210307-appspot-com-（已失效）" class="headerlink" title="最新福利，谷歌云上搭建了一个App Engine 爬取ssr/ss节点，拿去不谢 https://sspy-210307.appspot.com/（已失效）"></a>最新福利，谷歌云上搭建了一个App Engine 爬取ssr/ss节点，拿去不谢 <a href="https://sspy-210307.appspot.com/" target="_blank" rel="noopener">https://sspy-210307.appspot.com/</a>（已失效）</h3><h2 id="2018-7-26-更新几个ssr订阅"><a href="#2018-7-26-更新几个ssr订阅" class="headerlink" title="2018-7-26 更新几个ssr订阅"></a>2018-7-26 更新几个ssr订阅</h2><ul><li>逗比根据地 <a href="http://ss-ssshare.7e14.starter-us-west-2.openshiftapps.com/subscribe" target="_blank" rel="noopener">http://ss-ssshare.7e14.starter-us-west-2.openshiftapps.com/subscribe</a></li><li>香港节点 <a href="https://wepn.hk/link/idFgpbMYQQxvHjuK?mu=0" target="_blank" rel="noopener">https://wepn.hk/link/idFgpbMYQQxvHjuK?mu=0</a></li><li>loremwalker <a href="https://prom-php.herokuapp.com/cloudfra_ssr.txt" target="_blank" rel="noopener">https://prom-php.herokuapp.com/cloudfra_ssr.txt</a></li><li>App Engine <a href="https://sspy-210307.appspot.com/subscribe" target="_blank" rel="noopener">https://sspy-210307.appspot.com/subscribe</a>,update可能需要科学上网。（已失效）</li><li>他人共享<a href="https://raw.githubusercontent.com/forpw2009/lpss2009/master/ssr/lpssr" target="_blank" rel="noopener">https://raw.githubusercontent.com/forpw2009/lpss2009/master/ssr/lpssr</a> 作者github主页<a href="https://github.com/forpw2009" target="_blank" rel="noopener">https://github.com/forpw2009</a></li><li>Heroku <a href="https://isspy.herokuapp.com/subscribe" target="_blank" rel="noopener">https://isspy.herokuapp.com/subscribe</a></li></ul><h3 id="2018-8-21-App-Engine欠费关闭，改用Heroku部署，项目主页地址-https-isspy-herokuapp-com-ss-ssr订阅地址-https-isspy-herokuapp-com-subscribe"><a href="#2018-8-21-App-Engine欠费关闭，改用Heroku部署，项目主页地址-https-isspy-herokuapp-com-ss-ssr订阅地址-https-isspy-herokuapp-com-subscribe" class="headerlink" title="2018-8-21 App Engine欠费关闭，改用Heroku部署，项目主页地址 https://isspy.herokuapp.com/ ss/ssr订阅地址 https://isspy.herokuapp.com/subscribe"></a>2018-8-21 App Engine欠费关闭，改用Heroku部署，项目主页地址 <a href="https://isspy.herokuapp.com/" target="_blank" rel="noopener">https://isspy.herokuapp.com/</a> ss/ssr订阅地址 <a href="https://isspy.herokuapp.com/subscribe" target="_blank" rel="noopener">https://isspy.herokuapp.com/subscribe</a></h3>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>playground运行慢问题解决办法</title>
      <link href="/2018/09/05/swift/playground%E8%BF%90%E8%A1%8C%E6%85%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/09/05/swift/playground%E8%BF%90%E8%A1%8C%E6%85%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="在升级xcode之后，出现playground无法运行的情况，live-view-不显示等问题。"><a href="#在升级xcode之后，出现playground无法运行的情况，live-view-不显示等问题。" class="headerlink" title="在升级xcode之后，出现playground无法运行的情况，live view 不显示等问题。"></a>在升级xcode之后，出现playground无法运行的情况，live view 不显示等问题。</h3>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>七个习惯附录一</title>
      <link href="/2018/09/05/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%99%84%E5%BD%95%E4%B8%80/"/>
      <url>/2018/09/05/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%99%84%E5%BD%95%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="七个习惯资源"><a href="#七个习惯资源" class="headerlink" title="七个习惯资源"></a>七个习惯资源</h2><div id="badge-container-huos3203-7HabitFiles-ab2502a" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-7HabitFiles-ab2502a", "huos3203", "7HabitFiles", "ab2502a", false);</script><p><a href="http://p27uwfdhv.bkt.clouddn.com/static/pdf/%E8%87%AA%E6%88%91%E8%AF%84%E4%BC%B0.pages" target="_blank" rel="noopener">下载习惯的评估矫正.pages</a><br><a href="http://p27uwfdhv.bkt.clouddn.com/static/pdf/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E7%BB%BC%E5%90%88%E8%AF%84%E5%88%86.numbers" target="_blank" rel="noopener">下载七个习惯综合评估.numbers</a></p><p><a href="http://www.tablesgenerator.com/markdown_tables#" target="_blank" rel="noopener">生成markdown表格工具</a></p><table><thead><tr><th style="text-align:center">你的生活中心</th><th style="text-align:center">配偶</th><th style="text-align:center">家庭</th><th style="text-align:center">金钱</th><th style="text-align:center">工作</th><th style="text-align:center">财富</th><th style="text-align:center">享乐</th><th style="text-align:center">朋友</th><th style="text-align:center">敌人</th><th style="text-align:center">宗教</th><th style="text-align:center">自我</th><th style="text-align:center">原则</th></tr></thead><tbody><tr><td style="text-align:center">配偶</td><td style="text-align:center">*满足需求的主要来源</td><td style="text-align:center"><em>维持现状 </em>不太重要 *有夫妻共同维护</td><td style="text-align:center">*让配偶衣食无忧所必须的</td><td style="text-align:center">*挣钱养活配偶所必须的</td><td style="text-align:center">*关爱、打动或支配配偶的手段</td><td style="text-align:center">*一起活动或无足轻重</td><td style="text-align:center"><em>配偶是最好或唯一的朋友 </em>只有“我们的”朋友才是朋友</td><td style="text-align:center">*配偶捍卫我的利益或者共同的敌人令我们的婚姻稳固</td><td style="text-align:center"><em>共同的享受乐趣的生活 </em>仅次于婚姻关系</td><td style="text-align:center"><em>由配偶决定自我价值 </em>极易受到配偶态度和行为的影响</td><td style="text-align:center">*与配偶建立并维持关系的理念</td></tr><tr><td style="text-align:center">家庭</td><td style="text-align:center">*家庭的一部分</td><td style="text-align:center">*重中之重</td><td style="text-align:center">*家庭经济的支柱</td><td style="text-align:center">*达到某个目的的手段</td><td style="text-align:center">*带给家庭安逸和机遇</td><td style="text-align:center">*家庭活动或相对次要</td><td style="text-align:center"><em>家庭的朋友否则会引起斗争 </em>稳固家庭生活的威胁</td><td style="text-align:center"><em>由家庭决定 </em>家庭团结稳固的根源 *可能对家庭团结构成威胁</td><td style="text-align:center">*求助的对象</td><td style="text-align:center">*家庭的重要部分但地位次于家庭</td><td style="text-align:center"><em>保持家庭团结稳固的规则 </em>次于家庭</td></tr><tr><td style="text-align:center">金钱</td><td style="text-align:center">*赚钱的资本或负担</td><td style="text-align:center">*经济负担</td><td style="text-align:center">*安全感和满足感的来源</td><td style="text-align:center">*赚钱所必须的</td><td style="text-align:center">*经济成功的证据</td><td style="text-align:center">*经济负担或者经济压力的标志</td><td style="text-align:center">*由于经济地位或者影响力而结交</td><td style="text-align:center"><em>经济上的竞争者 </em>经济稳定的威胁</td><td style="text-align:center"><em>税金减免 </em>花钱的地方</td><td style="text-align:center"><em>自我价值 </em>由净资产决定</td><td style="text-align:center">*赚取和管理钱财的有效方法</td></tr><tr><td style="text-align:center">工作</td><td style="text-align:center">*工作的助力或阻力</td><td style="text-align:center"><em>帮助或者干扰工作 </em>培养家人的敬业精神</td><td style="text-align:center"><em>次要 </em>辛勤工作的证据</td><td style="text-align:center"><em>满足感和成就感的主要来源 </em>重中之重</td><td style="text-align:center"><em>提高工作效率的手段 </em>工作的成果和证明</td><td style="text-align:center"><em>浪费时间 </em>干扰工作</td><td style="text-align:center"><em>由于工作环境或者志趣相投而结交 </em>基本不必要</td><td style="text-align:center">*工作的效率障碍</td><td style="text-align:center"><em>对企业形象至关重要 </em>占用时间 *建立职业关系网的机会</td><td style="text-align:center">*由工作中的作用决定</td><td style="text-align:center"><em>让你在工作中获取成功的理念 </em>适应工作环境所必须的</td></tr><tr><td style="text-align:center">财富</td><td style="text-align:center"><em>主要财富 </em>获取财富的帮手</td><td style="text-align:center"><em>可供使用、利用、支配、压制和控制的财富 </em>炫耀</td><td style="text-align:center"><em>增加财富的关键  </em>可供炫耀的财富</td><td style="text-align:center">*获取地位、权势和承认的机会</td><td style="text-align:center">*地位标志</td><td style="text-align:center">*逛街、购物、加入俱乐部</td><td style="text-align:center"><em>个人所有 </em>可供利用</td><td style="text-align:center"><em>掠夺者、强盗 </em>拥有更多财富或者更高的声望的人</td><td style="text-align:center"><em>“我的”教堂地位的象征 </em>不公正批判和生活美好事物的根源</td><td style="text-align:center"><em>由我拥有的财产决定 </em>由社会地位和声望决定</td><td style="text-align:center">*让你获取和增加财富的观念</td></tr><tr><td style="text-align:center">享乐</td><td style="text-align:center">*享受乐趣的同伴或阻碍</td><td style="text-align:center">*载体或干扰</td><td style="text-align:center">*增加享乐机会的手段</td><td style="text-align:center"><em>达到目的的手段 </em>愿意从事有趣的工作</td><td style="text-align:center"><em>乐趣的客体 </em>获取更多乐趣的手段</td><td style="text-align:center"><em>生活中至高无上的目标 </em>满足感的主要来源</td><td style="text-align:center">*共享乐趣的伙伴</td><td style="text-align:center"><em>过于认真的看待生活 </em>带来罪恶感的人，破坏者</td><td style="text-align:center"><em>麻烦，娱乐的障碍 </em>带来罪恶感</td><td style="text-align:center">*享乐的工具</td><td style="text-align:center">*必须得到满足的固有冲动的本能</td></tr><tr><td style="text-align:center">朋友</td><td style="text-align:center"><em>可能是朋友可能是对手 </em>社会地位的象征</td><td style="text-align:center"><em>朋友建立友谊的障碍 </em>社会地位的象征</td><td style="text-align:center">*良好经济和社会状况的根源</td><td style="text-align:center">*社会机遇</td><td style="text-align:center"><em>收买友谊的手段 </em>消遣或提供社交娱乐的手段</td><td style="text-align:center"><em>与朋友一起总是很快乐 </em>以社交活动为主</td><td style="text-align:center"><em>对个人的快乐至关重要 </em>归属感、得到接纳和受欢迎至关重要</td><td style="text-align:center"><em>社交圈以外 </em>共同的敌人和巩固或缔结友谊</td><td style="text-align:center">*社交聚会的场所</td><td style="text-align:center"><em>由社会决定 </em>害怕尴尬或遭到排斥</td><td style="text-align:center">*让你与别人和睦相处的基本法则</td></tr><tr><td style="text-align:center">敌人</td><td style="text-align:center">*同情替罪羊</td><td style="text-align:center">*避难所（情感支持）或替罪羊</td><td style="text-align:center">*对抗或证明高人一等的手段</td><td style="text-align:center">*逃避方式或者发泄情绪的机会</td><td style="text-align:center"><em>斗争工具 </em>争取盟友的手段 *逃避、寻找逃难所</td><td style="text-align:center">*下一次战斗前的休息放松时间</td><td style="text-align:center"><em>情感上的支持者和同情者 </em>可能由于共同的敌人而结下友谊</td><td style="text-align:center"><em>仇恨的对象 </em>个人烦恼的根源 *自我保护和自我辩白的原因</td><td style="text-align:center">*自我辩护的根源</td><td style="text-align:center"><em>受害 </em>受制于敌人</td><td style="text-align:center"><em>指责敌人的理由 </em>敌人错误的根源</td></tr><tr><td style="text-align:center">宗教</td><td style="text-align:center"><em>为教堂服务的同伴或帮手 </em>信仰的考验</td><td style="text-align:center"><em>贯彻宗教教义的榜样 </em>信仰的考验</td><td style="text-align:center"><em>支持教会和家庭的手段 </em>如果比为教会教义服务更重要，则是罪恶</td><td style="text-align:center">*维持世俗生活所必须的</td><td style="text-align:center"><em>世俗财富毫不重要 </em>名誉和形象极其可贵</td><td style="text-align:center"><em>“无害”的乐趣，是与其他教友聚会的机会 </em>其他娱乐是有害的是浪费时间，应该禁止</td><td style="text-align:center">*其他教友</td><td style="text-align:center">*无信仰的人；不赞同宗教教义的人或者生活方式完全违背教义的人</td><td style="text-align:center">*生活方向的最重要指引</td><td style="text-align:center">*自我价值由宗教活动，对教会的贡献或按教义行事的表现决定</td><td style="text-align:center"><em>宗教信条 </em>比宗教次要</td></tr><tr><td style="text-align:center">自我</td><td style="text-align:center"><em>财富 </em>令自己满足和快乐</td><td style="text-align:center"><em>财富 </em>满足需求</td><td style="text-align:center">*满足需求的来源</td><td style="text-align:center">*“自行其是”的机会</td><td style="text-align:center">*自我界定保护和提高的来源</td><td style="text-align:center"><em>应得的感官享受 </em>我的权力 *我的需求</td><td style="text-align:center">*我的支持者和供应者</td><td style="text-align:center">*自我界定自我辩白的根源</td><td style="text-align:center">*服务私利的手段</td><td style="text-align:center"><em>比别人优秀、聪明、正确 </em>集中一起资源满足个人需求</td><td style="text-align:center"><em>辩白的根源 </em>最能为我的利益服务的理念；可以根据需求不同作出调整</td></tr><tr><td style="text-align:center">原则</td><td style="text-align:center">在互利互赖的关系中的平等伙伴</td><td style="text-align:center"><em>朋友 </em>服务、贡献和成就的机会 *改写几代人的行为模式和变革的机会</td><td style="text-align:center">*完成要务和重要目标的资源</td><td style="text-align:center"><em>以富有成效的方式运用才华和能力的机会 </em>获取经济资源的手段 *与其他时间投入相均衡的时间投入，与生活中的要务和价值观相一致</td><td style="text-align:center"><em>可供利用的资源 </em>得到适当照顾的责任 *与人相比是次要的</td><td style="text-align:center"><em>目标明确的生活中几乎所有活动产生的乐趣 </em>真正的娱乐是平衡而全面的生活方式的重要组成部分</td><td style="text-align:center"><em>相互依赖生活中的同伴 </em>知心人—能倾吐心声，能提供服务和支持</td><td style="text-align:center">*没有真正意义上的敌人；知识思维定势和考虑事项不同应该予以理解和关心</td><td style="text-align:center"><em>真正的原则的载体 </em>服务和贡献的机会</td><td style="text-align:center">*是诸多独特、有才华、富有创造力的个体当中的一个。 这些个体独立和互赖的工作能完成伟业</td><td style="text-align:center"><em>永恒的自然法则，一旦违反必受惩罚 </em>得到遵守时，则能维护尊严，从而实现真正的成长和幸福</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>习惯三要事第一自我管理原则</title>
      <link href="/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%89%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E5%8E%9F%E5%88%99/"/>
      <url>/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%89%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1）我的时间是怎样度过的"><a href="#1）我的时间是怎样度过的" class="headerlink" title="1）我的时间是怎样度过的"></a>1）我的时间是怎样度过的</h3><p>1.很不同意2.不同意3.略不同意4.略微同意5.同意6.很同意</p><table><thead><tr><th style="text-align:left">问题</th><th style="text-align:left">态度</th></tr></thead><tbody><tr><td style="text-align:left">1.我花了很多时间在重要而且需要立刻关注的活动上，例如危机、紧迫问题、截止日期即将到期的项目。</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">2.我觉得总是到处救火，不断处理危机</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">3.我觉得自己浪费了好多时间。</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">4.我花了很多时间在虽然紧迫但与我的最高优先毫无关系的事情上（诸如无端的干扰、不重要的会议，、非紧急的电话和电子邮件）</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">5.我花了很多时间在重要但不紧迫的事务上，例如做计划、准备、防范、改善人际关系、恢复和休整</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">6.我花了很多时间在繁忙的工作、强制性习惯、垃圾邮件、过多的电视节目、琐事和玩游戏上。</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">7.我觉得由于防范得当、精心准备和周密计划，一切由我掌控。</td><td style="text-align:left">打分</td></tr><tr><td style="text-align:left">8.我觉得自己总是在处理对他人重要、但却对自己不重要的事情。</td><td style="text-align:left">打分</td></tr></tbody></table><p>以上表格的设计，是用来帮你快速评估自己花费在时间矩阵的每个象限中的时间和精力各有多少。对于上面的8个问题圈出你的反应，从1到6.<br>得分操作指南：</p><ol><li>对于这8个问题圈出相应于你的反应的数字，从1到6.</li><li>把你在每个象限中的得分相加。</li><li>在每个象限中用阴影涂画出四分之一圆，其中半径等于你在该象限的得分。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>习惯二以终为始自我领导原则</title>
      <link href="/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%BA%8C%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B%E8%87%AA%E6%88%91%E9%A2%86%E5%AF%BC%E5%8E%9F%E5%88%99/"/>
      <url>/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%BA%8C%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B%E8%87%AA%E6%88%91%E9%A2%86%E5%AF%BC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1）检查你的愿景 现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。  2）制定一份个人使命宣言 为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。  步骤1：开动脑筋畅想    将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。<br>步骤2：放松一下 现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。<br>步骤3：整理你的思绪 回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语<br>步骤4：写出初稿 现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。<br>步骤5：完成你的使命宣言 周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。 步骤6：定期检查并加以评估</p><p>把你做本章开篇的参加葬礼心灵演练时的新的列表整理下来。</p><hr><h3 id="1）检查你的愿景"><a href="#1）检查你的愿景" class="headerlink" title="1）检查你的愿景"></a>1）检查你的愿景</h3><p>现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。我现在的生活状况如何？它是否让我快乐？我是否有成就感？</p><hr><p>是什么在一直吸引着我？它是否与我目前正在做的事情有所不同？</p><hr><p>我少年时想做的是什么？这些事情仍然给我带来满足感吗？我目前是在做着其中的一些事情吗？</p><hr><p>目前最让我感兴趣的是什么？</p><hr><p>最让我的灵魂感到满足的是什么？</p><hr><p>我做什么事情最擅长？我的显著特点和优势是什么？</p><hr><h3 id="2）制定一份个人使命宣言"><a href="#2）制定一份个人使命宣言" class="headerlink" title="2）制定一份个人使命宣言"></a>2）制定一份个人使命宣言</h3><p>为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。</p><h4 id="步骤1：开动脑筋畅想"><a href="#步骤1：开动脑筋畅想" class="headerlink" title="步骤1：开动脑筋畅想"></a>步骤1：开动脑筋畅想</h4><p>将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。<br>1．标识一个对你有影响的人。确定一个对你的生活有积极影响的人。你最赞赏这个人的什么品质？你从这个人那里学到了什么品质？</p><hr><p>2．详细说明你想成为怎样的人。<br>设想现在已是20年后，你已经达成了自己所希望的所有成就。你的成就清单是什么？你想拥有什么？你想成为怎样的人？你想成就怎样的事业？</p><hr><p>3．请确定，目前对你最重要的是什么？</p><hr><h4 id="步骤2：放松一下"><a href="#步骤2：放松一下" class="headerlink" title="步骤2：放松一下"></a>步骤2：放松一下</h4><p>现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。</p><h4 id="步骤3：整理你的思绪"><a href="#步骤3：整理你的思绪" class="headerlink" title="步骤3：整理你的思绪"></a>步骤3：整理你的思绪</h4><p>回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语。</p><h4 id="步骤4：写出初稿"><a href="#步骤4：写出初稿" class="headerlink" title="步骤4：写出初稿"></a>步骤4：写出初稿</h4><p>现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。</p><p>使命宣言初稿</p><hr><h4 id="步骤5：完成你的使命宣言"><a href="#步骤5：完成你的使命宣言" class="headerlink" title="步骤5：完成你的使命宣言"></a>步骤5：完成你的使命宣言</h4><p>周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。</p><p>我的使命宣言</p><hr><h4 id="步骤6：定期检查并加以评估"><a href="#步骤6：定期检查并加以评估" class="headerlink" title="步骤6：定期检查并加以评估"></a>步骤6：定期检查并加以评估</h4><p>每个月问自己下列问题：<br>●我是否觉得这个使命宣言代表了最佳的自我？<br>●当我回顾这个使命宣言的时候是否感到有了方向、目标、挑战和动力？<br>●我的生活是否遵从了这个使命宣言中的理想和价值观？</p><h3 id="3）你的角色"><a href="#3）你的角色" class="headerlink" title="3）你的角色"></a>3）你的角色</h3><p>既然你已有了逐步进展中的个人使命宣言初稿，重要的是考虑你在生活中的角色和目标，以及它们与你的使命宣言有着怎样的关系。</p><hr><p>在下页的空白处写下你的各个角色。别太在意一次把它们弄正确。只要写下你觉得正确的就行。尝试把列出的角色限制在七个以内。如果超过了七个，可以把若干职能归并为一个。在写下的角色旁边描述一下，你认为自己可能在该角色领域做出的最理想的业绩。<br>例如：<br>艺术家、护理者、同伴、指导者、激励者、朋友、祖父母、发明家、邻居、调解者、儿子、教师、训练员、志愿者、作家</p><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">在角色领域的最理想的业绩</th></tr></thead><tbody><tr><td style="text-align:left">志愿者</td><td style="text-align:left">在儿童中心服务两个小时</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td></tr></tbody></table><h3 id="4）你的生活中心"><a href="#4）你的生活中心" class="headerlink" title="4）你的生活中心"></a>4）你的生活中心</h3><p>阅读本书附录一所列的各种生活中心，看看你的行为符合其中哪个类型？他们是否让你的日常行为有一定依据？你是否满意？</p><hr><h3 id="5）告诉你自己怎么做"><a href="#5）告诉你自己怎么做" class="headerlink" title="5）告诉你自己怎么做"></a>5）告诉你自己怎么做</h3><p>设想近期内可能会从事的某个项目，用智力创造的原则，写下你的希望获得的结果与应采取的步骤。</p><hr><p>向家人或者同事讲述本章的精华，并建议大家共同拟定家庭或者团队的使用宣言。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>习惯一积极主动个人愿景原则</title>
      <link href="/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%80%E7%A7%AF%E6%9E%81%E4%B8%BB%E5%8A%A8%E4%B8%AA%E4%BA%BA%E6%84%BF%E6%99%AF%E5%8E%9F%E5%88%99/"/>
      <url>/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%80%E7%A7%AF%E6%9E%81%E4%B8%BB%E5%8A%A8%E4%B8%AA%E4%BA%BA%E6%84%BF%E6%99%AF%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>怎么在影响圈内,做到积极主动?</p><p>行动建议  花一整天，听听你自己和周围人的语言，你使用“但愿”、“我办不到”、“我不得不”等消极回答的频率有多高？     根据以往的经历，想象一下将来遇到什么会让你变得消极。假如你关注的是影响圈，再考虑一下这个场景，你能怎样积极回应？用几分钟时间，在头脑里鲜活地描绘那个场景，设想你用一种积极方式进行回应。你只需要随时提醒自己被动刺激和主动回应之间的区别，不要忘记有自由选择的权利。<br>1）多培养积极主动性    积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。<br>2）你的圈子有多大 挑战/问题 圈子 回应    列出本周内所面临的各种挑战和问题。设法让自己的影响圈逐步扩大，选一个打算在下周改变应对方式以克服的挑战。<br>3）采取积极主动    找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。<br>4）试行“积极主动”原则30天，写下自己的影像圈有和变化。</p><h3 id="1）多培养积极主动性"><a href="#1）多培养积极主动性" class="headerlink" title="1）多培养积极主动性"></a>1）多培养积极主动性</h3><p>积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。<br>想想过去几周内自己以消极方式做出回应的两三件事情。<br>描述一下自己是怎么说的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1．____________________________</span><br><span class="line">2．____________________________</span><br><span class="line">3．____________________________</span><br></pre></td></tr></table></figure></p><p>现在，想想在同样情况下自己可以采取的几种积极的回应。请写在下面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1．____________________________</span><br><span class="line">2．____________________________</span><br><span class="line">3．____________________________</span><br></pre></td></tr></table></figure></p><p>请记住，在下周仔细倾听自己使用的语言，你的语言是更积极了，还是更消极了？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">______________________________</span><br></pre></td></tr></table></figure></p><h3 id="2）你的圈子有多大"><a href="#2）你的圈子有多大" class="headerlink" title="2）你的圈子有多大"></a>2）你的圈子有多大</h3><p>写下你在本周内所面临的各种挑战和问题。它们分别归入哪个圈子？你的瞬间回应又是什么？  </p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">挑战/问题</th><th style="text-align:center">圈子</th><th style="text-align:center">回应</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">_交通拥堵</td><td style="text-align:center">关注圈</td><td style="text-align:center">愤怒、咒骂</td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>你需要设法让自己的影响圈逐步扩大。这两个圈子中，从每个圈子选一个你本来打算在下周做出应对的挑战。你将怎样改变自己的回应以更有效地应对该挑战？<br>1．影响圈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_________________________________</span><br></pre></td></tr></table></figure></p><p>2．关注圈</p><hr><h3 id="3）采取主动"><a href="#3）采取主动" class="headerlink" title="3）采取主动"></a>3）采取主动</h3><p>找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。</p><hr><p>试行“积极主动”的原则30天，写下自己的影响圈有何变化？</p><hr><p>你是否有什么事情一直想做，但又觉得缺乏天赋、时间或能力？为了克服自己的弱点，你应当做些什么呢？作为一周伊始，你又能在本周做一件什么事呢？</p><hr><p>如果你能开发自己的一项新的才能，你想要什么？</p><hr><p>如果你能到世界任何一个地方去旅行，你想去哪里？</p><hr><p>如果你能改变自己生活中的某件事情，你想改变哪一件？</p><hr><p>制定让你实现上面三个愿望（对三个问题的回答）的计划，把它写下来。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>七个习惯概论</title>
      <link href="/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%A6%82%E8%AE%BA/"/>
      <url>/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="七个习惯概论"><a href="#七个习惯概论" class="headerlink" title="七个习惯概论"></a>七个习惯概论</h2><p><img src="https://www.plantuml.com/plantuml/svg/VL9BJW914DttAIPnpy8Jw1My0H6Y2w89ahWGa-ONnc4S_E3mKHp5A0hgO1m1fqNl8bqzpSehMCq8OUMkg-kzL-zLzyfEAffCxKGJARAtH2RTcZZJPMx4VHzkkbfQuoDhyORmzokHS_cGag3jYiiC7p8mxiSqkrW6ZJp20zRamqFnLe1UKtxcnLCBOPpPd3q6pkqaSohl4E_BOWS6BqWHne4eFKZFaTxDpuUP5dqT5MMh6mu8or1QwUQ__Y4Jo3IWw6DZGbL3K2PgBZW-zosm7D3hS69oDW3w8TjP94XgAj4PHkGA0Ui8tOPoTL8_KgpZUpZtHFEQi_uyRkX6iSerC6qi8ViOL1n92uZ1zP4mRpXUjW_WinfQddAgyFoAq6zQKMUz5yu8B1TQkJ7DpCF9ho9OREhOLel5k2KxyDpvFfLrm_Z3NvJuw0BrqOVmcB8uPCX2C8ca8uJCtj0toThshhOPZyRYIMqPtQvgYUsj3MqzdaYGVR8ItugfZ_4B"></p><table><thead><tr><th>高效能人士</th><th>低效能人士</th></tr></thead><tbody><tr><td><strong>习惯一：积极主动</strong></td><td></td></tr><tr><td><b>积极主动</b><br>积极主动的人绝不浅尝辄止。他们知道要为自己的抉择负责，做出的选择总是基于原则和价值观，而不是基于情绪或受限于周围条件。积极的人是变化的催生者。</td><td><b>消极被动</b><br>消极的人不愿为自己的抉择负责，他们总是觉得自己是受害者—受到周围环境、自己的过去和他人的拖累。他们不把自己看作是生活的主人。</td></tr><tr><td><strong>习惯二：以终为始</strong></td><td></td></tr><tr><td><strong>以终为始（先定目标后有行动）</strong><br>个人、家庭、团队、组织通过创造性的构思来设计自己的未来，他们对于任何项目，无论大小，也不管是个人的还是团队的，都下决心完成。他们标识并献身于自己生活中最重要的原则、人际关系和目标。</td><td><strong>不定目标就行动</strong><br>他们缺乏个人愿景，没有目标。他们不思考生活的意义，也不愿制定使命宣言。他们的生活总是遵循社会流行的、而不是自己选择的价值观。</td></tr><tr><td><strong>习惯三：要事第一</strong></td><td></td></tr><tr><td><strong>要事第一</strong> <br>以要事为先的人总是按照事务重要性的顺序来安排生活并付诸实践。无论情势如何，他们的生活总是遵循自己最珍视的原则。</td><td><strong>不重要的事先做</strong><br>他们总是在应付各种危机。他们之所以无法关注最重要的事务，是因为他们总是纠缠于周围环境、过去的事情或人间是非。他们陷入成堆的琐事，被紧迫的事务弄得团团转。</td></tr><tr><td><strong>习惯四：双赢思维</strong></td><td></td></tr><tr><td><strong>双赢思维</strong><br>有双赢思维的人能在交往中寻求双方获利、互相尊重。他们基于到处是机遇和富足的心态，基于“我们”而不是“我”，来进行思考。他们总是通过向感情账户存款来建立与他人的互信关系。</td><td><strong>非赢即输</strong><br>他们抱的是匮乏心态，把生活看作是一场零和游戏。他们不善与他人沟通，总是从感情账户提款，结果是时时提防他人，陷入对抗的心理。</td></tr><tr><td><strong>习惯五：知彼解己</strong></td><td></td></tr><tr><td><strong>知彼解己（先理解别人，再争取别人的理解）</strong> <br>当我们怀着理解对方的想法，而不是为了回答对方的问题去聆听时，我们就能进行真正的沟通并建立友谊。这时再坦述己见、争取理解就很自然，也容易多了。理解别人需要的是体谅，而争取别人理解需要的是勇气。效能在于这二者的平衡或适当的结合。</td><td><strong>先寻求别人的理解</strong> <br>他们并未理解对方就先讲述自己的观点，完全基于自己的经验或动机。他们不先对问题做出诊断就盲目开出处方。</td></tr><tr><td><strong>习惯六：统合综效</strong></td><td></td></tr><tr><td><strong>统合综效</strong><br>统合综效的人与对方合作，寻求第三变通方案。不是我的，也不是你的，而是第三种更好的解决方案。统合综效的基础是尊重、赞赏甚至庆贺彼此间的差异。它是某种创造性的合作，1＋1＝3，11，111，或者更多。</td><td><strong>妥协、争斗或逃避</strong> <br>低效能人士相信总体小于部分之和。他们试图在自己的形象中克隆他人。他们把自己与他人的差异看作威胁。</td></tr><tr><td><strong>习惯七：不断更新</strong></td><td></td></tr><tr><td><strong>不断更新（磨刀不误砍柴工）</strong> <br>高效能人士不断在生活的四个方面（身体、社会／情感、智力、精神）更新自己。这将增加他们实践其他有效习惯的能力。</td><td><strong>把自己累得筋疲力尽</strong><br>低效能人士没有自我更新、自我改善的规划，最终失去了过去所拥有的锋利刀刃（竞争力）。</td></tr></tbody></table><h3 id="1）在七个习惯上给自己评分"><a href="#1）在七个习惯上给自己评分" class="headerlink" title="1）在七个习惯上给自己评分"></a>1）在七个习惯上给自己评分</h3><p>这个评估能帮你了解自己在实践七个习惯方面的现状。为了了解自己的进步，你可以在读完本书后重新进行一次评估。<br>仔细阅读下列表格中的每句话，利用自己的最佳判断，圈出标识自己在每个习惯方面做得如何的数字（1表示极差，而6表示杰出）。</p><table><thead><tr><th style="text-align:center">七个习惯上的评分</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><table><thead><tr><th style="text-align:left">感情账户</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">1. 待人和蔼，体谅对方<br>2.我信守诺言<br>3. 我不在别人背后说他坏话。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left">产出/产能平衡</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4. 我能在生活的各个方面（家庭、朋友、工作等）保持适当的平衡<br>5.当我致力于某个项目时，总是想着业主的需求和厉害关系。<br>6. 我努力工作，但绝不把自己累的精疲力尽。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯一：积极主动</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">7. 我能掌控自己的生活<br>8. 我把关注集中于我能有所作为的事情上，而不是集中在我无法控制的事件上。<br>9. 我敢于为自己的情绪负责，而不是埋怨环境、责备他人。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯二：以终为始</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">10. 我明白自己在生活中的追求什么。<br>11. 我的生活和工作井然有序，很少陷入危急态势。<br>12.我每周都有一个清晰的计划，注明我想完成的事情</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯三：要事第一</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">13.我致力于完成自己的计划（避免延误、浪费时间等等）。<br>14. 我不让日常琐事埋没了真正重要的事务。<br>15. 我每天做的事情都是有意义的，有助于实现我的生活目标。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯四：双赢思维</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">16. 我关心别人的成功，就像关心自己的成功一样。<br>17. 我能与别人合作。<br>18. 遇到矛盾时，我努力寻求有利于各方的解决方案。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯五：知彼知己</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">19. 我对他人的感觉也很敏感。<br>20. 我尽力理解对方的观点。<br>21. 倾听时，我试图从对方的角度，而不仅从自己的角度来观察问题。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯六：统合综效</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">22. 我赞赏并力图了解他人的见解。<br>23. 我竭力寻求新的、更好的想法和解决方案。<br>24. 我鼓励他人表达他们的观点</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr><tr><td style="text-align:left"><strong>习惯七：不断更新</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">25.我真系自己的身体和健康。<br>26.我努力建立并改善与他人的关系。<br>27. 我肯花时间追求生活的意义和乐趣。</td><td style="text-align:left">评分：<br><br>评分：<br><br>评分：</td></tr></tbody></table><h3 id="你的习惯"><a href="#你的习惯" class="headerlink" title="你的习惯"></a>你的习惯</h3><p><code>习惯</code>是知识、技巧和意愿的交叉点。<br><code>知识</code>是做什么和为何做，<code>技巧</code>是如何做，而<code>意愿</code>是动力——想做。所有这三者必须集合在一起才能形成一个习惯。<br>请列出你的两个习惯，一个好习惯，一个坏习惯。并写出关联于这两个习惯的知识、技巧和意愿。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>习惯有巨大的引力——比大多数人认识到的或愿意承认的还要大。打破一个根深蒂固的习惯需要做出极大的努力，而且一般还会涉及生活的重大变化。<br>看看你写下的坏习惯。你愿意为了打破这个坏习惯做出一切必要的努力吗？若是，请写下三件为了打破这个习惯你将着手做的事情。请记录下你的进步过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1．</span><br><span class="line">2．</span><br><span class="line">3．</span><br></pre></td></tr></table></figure></p><p>看一下图2-2七个习惯模型，你位于何处？花几分钟记录下你的现状及其原因。你的什么行为和态度让你处于目前这种状况？你开始看到自己最需要在哪方面做出努力了吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>七个习惯题由内而外全面造就自己</title>
      <link href="/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%A2%98%E7%94%B1%E5%86%85%E8%80%8C%E5%A4%96%E5%85%A8%E9%9D%A2%E9%80%A0%E5%B0%B1%E8%87%AA%E5%B7%B1/"/>
      <url>/2018/09/03/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%A2%98%E7%94%B1%E5%86%85%E8%80%8C%E5%A4%96%E5%85%A8%E9%9D%A2%E9%80%A0%E5%B0%B1%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="由内而外全面造就自己"><a href="#由内而外全面造就自己" class="headerlink" title="由内而外全面造就自己"></a>由内而外全面造就自己</h2><p>你是否有过这种经验，做出推测时发现自己的判断过于匆忙？请对这种经验加以描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>你当时做出的推测是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>想一下你做过的其他推测。本周你将对其中某一项采取什么行动？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><h3 id="1）检验你的思维定式"><a href="#1）检验你的思维定式" class="headerlink" title="1）检验你的思维定式"></a>1）检验你的思维定式</h3><p>你曾经到过其他国家，或本国其他地区吗？你觉得哪些事情是陌生的或奇怪的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>人们的行为是否如你预期？你对他们的行为有何看法？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>回想你的旅游经验，你认为当地人对你的看法如何？你是否认为他们对你的看法与你对他们的看法可能很类似？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>如果你有机会在旅途中认识当地人，你对他们的看法或推测会有什么改变？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><h3 id="2）转换你的思维定式"><a href="#2）转换你的思维定式" class="headerlink" title="2）转换你的思维定式"></a>2）转换你的思维定式</h3><p>回想一下通往你的工作场所或你的家的不同途径。是否有些途径比其他的更复杂？是否有时其中一条比其他的更方便？为什么方便，为什么不方便？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>你是否发现过一条你以前不知道的新途径？走不同途径的新鲜感又是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><p>现在想一下你与他人打交道的方式。与他们打交道是否有好几种途径？你还有可能会尝试哪些新的方式？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br></pre></td></tr></table></figure></p><h3 id="3）影响你生活的五个原则"><a href="#3）影响你生活的五个原则" class="headerlink" title="3）影响你生活的五个原则"></a>3）影响你生活的五个原则</h3><p>请列出影响你的日常生活的五个原则。它们以怎样的方式影响你？它们是以积极的，还是消极的方式影响你的生活？</p><ol><li><hr></li><li><hr></li><li><hr></li><li><hr></li><li><hr></li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MPMoviePlayerController遇到的坑</title>
      <link href="/2018/09/01/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MPMoviePlayerController%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2018/09/01/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MPMoviePlayerController%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>[MPMoviePlayerController播放过程中自动暂停的问题]<br>在使用系统播放器MPMoviePlayerController的过程中，会出现播放器自动暂停的情况，有两种解决办法：<a href="https://www.cnblogs.com/elsonpeng/p/5404969.html" target="_blank" rel="noopener">参看</a><br>1.1 <code>在播放开始的时候，设置useApplicationAudioSession ＝ NO;</code><br>1.2 <code>重启手机，也可以恢复</code></li><li><a href="https://stackoverflow.com/questions/3138660/why-does-mpmovieloadstate-have-state-5" target="_blank" rel="noopener">why does MPMovieLoadState have state 5?</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The playState is a bitmask. Any number of bits can be set, such as</span><br><span class="line">MPMovieLoadStatePlaythroughOK | MPMovieLoadStatePlayable</span><br><span class="line">Check for states like this:</span><br><span class="line">MPMovieLoadState state = [playerController loadState];</span><br><span class="line">if( state &amp; MPMovieLoadStatePlaythroughOK ) &#123;</span><br><span class="line">NSLog(@&quot;State is Playthrough OK&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><h4 id="投影不全屏"><a href="#投影不全屏" class="headerlink" title="投影不全屏"></a>投影不全屏</h4><p>现象：投影仪页面未同步现象，全屏查看视频，横屏全屏显示，但投影在大屏的画面没有同步</p><ol><li><p>隔离业务代码，编写demo复现投影问题。<a href="https://github.com/huos3203/ALMoviePlayerController/tree/master/ALMoviePlayerControllerDemo" target="_blank" rel="noopener">ALMoviePlayerControllerGit库</a></p><h5 id="demo问题"><a href="#demo问题" class="headerlink" title="demo问题"></a>demo问题</h5><p>解决办法：<br>注释掉：<code>- (id)initWithContentURL:(NSURL *)url</code>方法。demo正常播放<br>小插曲：遇到<code>Setting device discovery mode to DiscoveryMode_None</code>，排查之后不影响播放。故没有继续研究。。。</p><blockquote><p>教训：必须深入代码联调测试中，本可以通过断点排查，查处url为nil导致demo无法的播放的原因。却长时间纠结在不必要的日志中。</p></blockquote></li><li><p>通过在投影仪上联调测试<code>不影响播放</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAALMoviePlayerController[7438:3348866] [] &lt;&lt;&lt;&lt; AVOutputDeviceDiscoverySession (FigRouteDiscoverer) &gt;&gt;&gt;&gt; -[AVFigRouteDiscovererOutputDeviceDiscoverySessionImpl outputDeviceDiscoverySessionDidChangeDiscoveryMode:]: Setting device discovery mode to DiscoveryMode_None (client: VAALMoviePlayerController)</span><br></pre></td></tr></table></figure></li></ol><p>通过百度有两种方式：<br>1.在viewwillapear中添加<code>player=nil</code><br><a href="https://stackoverflow.com/questions/47438401/avplayer-is-not-playing-in-ios-11#" target="_blank" rel="noopener">AVPlayer is not playing in iOS 11</a><br><a href="https://stackoverflow.com/questions/46321860/avplayerviewcontroller-black-screen-when-swiping-on-ios-11" target="_blank" rel="noopener">AVPlayerViewController black screen when swiping on iOS 11</a></p><p>2.将工程设置为<code>arc=YES</code></p><h4 id="MP4音频不同步"><a href="#MP4音频不同步" class="headerlink" title="MP4音频不同步"></a>MP4音频不同步</h4><p>现象：视频播放到待定的时间点，画面卡顿，拖动进度条，声音画面不同步，复现：《视频美国儿童思维导图特训营》第一课：21:00时长复现</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thisdeviceisnotcurrentlyonline</title>
      <link href="/2018/09/01/%E8%B0%83%E8%AF%95/Thisdeviceisnotcurrentlyonline/"/>
      <url>/2018/09/01/%E8%B0%83%E8%AF%95/Thisdeviceisnotcurrentlyonline/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://forums.developer.apple.com/thread/16242" target="_blank" rel="noopener">参考</a></p><ol><li>you can restart your device!  then connect your device  to your mac-&gt;open Xcode-&gt;press command + i</li></ol><p>I’ve encountered this issue today. The record button is disabled and the tooltip says “This device is not currently online”. However my iPhone is connecting with my Mac and can be debugged with Xcode without any problem.</p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Instruments的工具</title>
      <link href="/2018/09/01/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Instruments%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/09/01/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Instruments%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>检测app内存爆增代码，优化性能<br><a href="https://www.jianshu.com/p/d0e149332380" target="_blank" rel="noopener">Instruments工具使用办法</a><br>整理Demo，列出几种常用instrument的场景。来熟悉具体操作<br><a href="https://gitee.com/leiming97/MemoryProblems-master.git" target="_blank" rel="noopener">demo</a></p><ol><li>集成归档模块代码，测试内存上升问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Xcode代码高亮提示功能失效</title>
      <link href="/2018/09/01/xcode/%E8%A7%A3%E5%86%B3Xcode%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/"/>
      <url>/2018/09/01/xcode/%E8%A7%A3%E5%86%B3Xcode%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li>打开失效的项目，选择菜单：Xcode-&gt;File-&gt;Project Settings -&gt; Advanced..，</li><li>删除图上所示的位置目录，重启xcode。<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3></li><li>cd进入~/Library/Developer/Xcode/DerivedData</li><li>找到你的项目所用的目录（一般以你的项目名开头）</li><li>cd 目录名</li><li>rm -r Index 删除掉你的项目所用的索引文件夹<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3></li><li>退出 Xcode</li><li>重启电脑</li><li>找到 这个 DerivedData 文件夹 删除 (路径: ~/Library/Developer/Xcode/DerivedData)</li><li>删除这个 com.apple.dt.Xcode 文件 (路径: ~/Library/Caches/com.apple.dt.Xcode)</li><li>运行 Xcode  就好了~~<blockquote><p>(1) 原文表示删除 ~/Library/Developer/Xcode/DerivedData下所有的文件，我尝试发现只需要删除当前项目相关的索引文件即可<br>(2)  DerivedData从字面上理解应该是收集到的数据，应该是Xcode针对这个项目缓存的一些数据，不会影响项目本身的完整性</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chisel-LLDB命令插件</title>
      <link href="/2018/09/01/%E8%B0%83%E8%AF%95/Chisel-LLDB%E5%91%BD%E4%BB%A4%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/09/01/%E8%B0%83%E8%AF%95/Chisel-LLDB%E5%91%BD%E4%BB%A4%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-facebook-chisel-56d0e0d" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-facebook-chisel-56d0e0d", "facebook", "chisel", "56d0e0d", false);</script><p>LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(这里有一个关于调试器如何工作的总体的解释。)</p><p>Chisel 为lldb提供了新增的便捷命令，是非常实用的命令。</p><h3 id="pviews"><a href="#pviews" class="headerlink" title="pviews"></a>pviews</h3><p>这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 <code>[view recursiveDescription]</code> 。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) pviews view</span><br><span class="line">&lt;TestView: 0x18df8070; baseClass = UIControl; frame = (144 9; 126 167); layer = &lt;CALayer: 0x18df8150&gt;&gt;</span><br><span class="line">| &lt;UIView: 0x18df81d0; frame = (0 0; 126 126); userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df8240&gt;&gt;</span><br><span class="line">| &lt;UIImageView: 0x18df8330; frame = (0 0; 126 126); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df83b0&gt;&gt;</span><br><span class="line">| &lt;UILabel: 0x18df8460; frame = (0 135; 126 14); text = &apos;haha&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x18df7fb0&gt;&gt;</span><br><span class="line">|    | &lt;_UILabelContentLayer: 0x131a3d50&gt; (layer)</span><br><span class="line">| &lt;UILabel: 0x18df8670; frame = (0 155; 126 12); text = &apos;hahaha&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x18df8730&gt;&gt;</span><br><span class="line">|    | &lt;_UILabelContentLayer: 0x131bea10&gt; (layer)</span><br><span class="line">| &lt;UIImageView: 0x18df88d0; frame = (0 9; 28 27); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df8ba0&gt;&gt;</span><br></pre></td></tr></table></figure></p><h3 id="pvc"><a href="#pvc" class="headerlink" title="pvc"></a>pvc</h3><p>这个命令也是递归打印层级，但是不是view，而是<code>viewController</code>。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 <code>[UIViewController _printHierarchy]</code> 同样的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) pvc</span><br><span class="line">&lt;TabBarController: 0x13772fd0; view = &lt;UILayoutContainerView; 0x151b3a30&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">| &lt;UINavigationController: 0x1602b800; view = &lt;UILayoutContainerView; 0x1b00aca0&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   | &lt;FirstViewController: 0x16029c00; view = &lt;UIView; 0x1b01e1c0&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">| &lt;UINavigationController: 0x138c5200; view = &lt;UILayoutContainerView; 0x1316a080&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   | &lt;SecondViewController: 0x16030400; view = &lt;UIView; 0x2094b370&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   |   | &lt;SecondChildViewController: 0x15af6000; view = &lt;UIView; 0x18d4e650&gt;; frame = (0, 64; 414, 628)&gt;</span><br><span class="line">| &lt;UINavigationController: 0x1383ca00; view = &lt;UILayoutContainerView; 0x13180070&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   | &lt;ThirdViewController: 0x138ddc00; view = &lt;UIView; 0x18df6650&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   |   | &lt;ThirdChild1ViewController: 0x1393fe00; view = &lt;UIView; 0x131ec000&gt;; frame = (0, 0; 414, 672)&gt;</span><br><span class="line">|   |   | &lt;ThirdChild2ViewController: 0x138dce00; view = &lt;UIView; 0x204075a0&gt;; frame = (414, 0; 414, 672)&gt;</span><br><span class="line">|   |   | &lt;ThirdChild3ViewController: 0x138a8e00; view = &lt;UIView; 0x20426250&gt;; frame = (828, 0; 414, 672)&gt;</span><br><span class="line">| &lt;UINavigationController: 0x160eca00; view = &lt;UILayoutContainerView; 0x152f7d90&gt;; frame = (0, 0; 414, 736)&gt;</span><br><span class="line">|   | &lt;FourViewController: 0x13157cc0; view not loaded&gt;</span><br></pre></td></tr></table></figure></p><h3 id="visualize"><a href="#visualize" class="headerlink" title="visualize"></a>visualize</h3><p>这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) visualize imageView</span><br></pre></td></tr></table></figure></p><h3 id="fv-amp-fvc"><a href="#fv-amp-fvc" class="headerlink" title="fv &amp; fvc"></a>fv &amp; fvc</h3><p><code>fv</code> 和 <code>fvc</code> 这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fv scrollView</span><br><span class="line">0x18d3b8c0 UIScrollView</span><br><span class="line">0x137d0c50 UIScrollView</span><br><span class="line">0x131b1580 UIScrollView</span><br><span class="line">0x131b2070 UIScrollView</span><br><span class="line">(lldb) fvc Home</span><br><span class="line">0x1393fe00 HomeFeedsViewController</span><br><span class="line">0x138a8e00 HomeFeedsViewController</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p><h3 id="show-amp-hide"><a href="#show-amp-hide" class="headerlink" title="show &amp; hide"></a>show &amp; hide</h3><p>这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。</p><h3 id="mask-umask-border-unborder"><a href="#mask-umask-border-unborder" class="headerlink" title="mask/umask border/unborder"></a>mask/umask border/unborder</h3><p>这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。<br>但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view.</p><h3 id="caflush"><a href="#caflush" class="headerlink" title="caflush"></a>caflush</h3><p>这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。<br>当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。<br>例, 其中 $122 即是目标UIView：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p view</span><br><span class="line">(long) $122 = 140718754142192</span><br><span class="line">(lldb) e (void)[$122 setBackgroundColor:[UIColor greenColor]]</span><br><span class="line">(lldb) caflush</span><br></pre></td></tr></table></figure></p><h3 id="bmessage"><a href="#bmessage" class="headerlink" title="bmessage"></a>bmessage</h3><p>使用场景：我们想在 <code>[MyViewController viewWillAppear:]</code> 里面打断点，但是 <code>MyViewController</code>并没有实现 <code>viewWillAppear:</code> 方法， 以往的作法可能就是在子类中实现下<code>viewWillAppear:</code>，然后打断点，然后<code>rebuild</code>。<br>那么幸好有了 <code>bmessage</code>命令。我们可以不用这样就可以打这个效果的断点：<code>(lldb) bmessage -[MyViewController viewWillAppear:]</code> 上面命令会在其父类的 <code>viewWillAppear:</code>方法中打断点，并添加上了条件：<code>[self isKindOfClass:[MyViewController class]]</code>.</p><p><a href="https://blog.cnbluebox.com/blog/2015/03/05/chisel/" target="_blank" rel="noopener">Chisel-LLDB命令插件，让调试更Easy</a></p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB命令使用</title>
      <link href="/2018/09/01/%E8%B0%83%E8%AF%95/LLDB%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/01/%E8%B0%83%E8%AF%95/LLDB%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p>最简单命令是 help，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 help <command> 来了解更多细节，例如 help print 或者 help thread。如果你甚至忘记了 help 命令是做什么的，你可以试试 help help。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。</p><h3 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h3><p>可以给 print 指定不同的打印格式。它们都是以 <code>print/&lt;fmt&gt;</code> 或者简化的 <code>p/&lt;fmt&gt;</code> 格式书写。<br>下面是一些例子：<br>默认的格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 16</span><br><span class="line">16</span><br></pre></td></tr></table></figure></p><p>十六进制:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x 16</span><br><span class="line">0x10</span><br></pre></td></tr></table></figure></p><p>二进制 (t 代表 two)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/t 16</span><br><span class="line">0b00000000000000000000000000010000</span><br><span class="line">(lldb) p/t (char)16</span><br><span class="line">0b00010000</span><br></pre></td></tr></table></figure></p><p>你也可以使用 <code>p/c</code> 打印字符，或者 <code>p/s</code> 打印以空终止的字符串 (译者注：以 ‘\0’ 结尾的字符串)。<br><a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">这里</a>是格式的完整清单。</p><h3 id="完全在调试器内运行"><a href="#完全在调试器内运行" class="headerlink" title="完全在调试器内运行"></a>完全在调试器内运行</h3><p>在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 <code>C/Objective-C/C++/Swift</code> 的命令。唯一的缺点就是不能创建新函数… 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。</p>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift爬虫工具</title>
      <link href="/2018/08/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/RxSwift%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/08/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/RxSwift%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-ReptileTool-60cac75" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-ReptileTool-60cac75", "huos3203", "ReptileTool", "60cac75", false);</script><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol><li>实践大话设计模式/swift基础语法/函数响应式开发</li></ol><p><a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80" target="_blank" rel="noopener">正则表达式语法</a>.aspx)<br><a href="http://www.cocoachina.com/ios/20150415/11568.html" target="_blank" rel="noopener">iOS开发之详解正则表达式</a>原文：NSRegularExpression Tutorial: Getting Started<br><a href="http://nshipster.cn/nspredicate/" target="_blank" rel="noopener">nshipster文章NSPredicate</a><br><a href="http://www.cocoachina.com/ios/20160111/14926.html" target="_blank" rel="noopener">iOS中的谓词（NSPredicate）使用</a></p><p>简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。<br>正则表达式的通用用例：</p><ol><li>执行搜索：高亮显示搜索和替换<ol><li>UITextView的NSAttributedString属性来高亮显示搜索的结果</li><li>用text kit来实现高亮的功能</li></ol></li><li>验证用户输入</li></ol><p>先来看看网络爬虫的基本原理：<br>一个通用的网络爬虫的框架如图所示：<br><img src="082246341592742.png" alt></p><p>网络爬虫的基本工作流程如下：</p><ol><li>首先选取一部分精心挑选的种子URL；</li><li>将这些URL放入待抓取URL队列；</li><li>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</li><li>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。<br>网络数据抓取</li></ol><p>概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。<br>用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。<br>建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。  </p><p>今天先来介绍一下第一种：正则表达式</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Safari浏览器调试WebView</title>
      <link href="/2018/08/23/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Safari%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95WebView/"/>
      <url>/2018/08/23/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Safari%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95WebView/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-width-=" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-width-=", "huos3203", "width", "=", false);</script><h3 id="使用RxSwift开发爬虫工具"><a href="#使用RxSwift开发爬虫工具" class="headerlink" title="使用RxSwift开发爬虫工具"></a>使用RxSwift开发爬虫工具</h3><h3 id="设置真机"><a href="#设置真机" class="headerlink" title="设置真机"></a>设置真机</h3><ol><li>首先打开模拟器或者真机设置中”Safari浏览器”→”高级”→”Web检查器”的开关。</li><li>然后我们打开Mac电脑的Safari浏览器,打开系统偏好设置(快捷键 commond + ,)，点击菜单中的”高级”,然后勾选”在菜单栏中显示”开发”菜单”.方便我们进行快速的调试。</li><li>这时候真机连接上数据线.或者开启模拟器就能在菜单栏”开发”选项中找到我们的设备或者是模拟器.</li><li>接下来我们只需要跑起我们的工程进入对应的WebView页面即可进行调试.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift函数响应式开发</title>
      <link href="/2018/08/23/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2018/08/23/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-beeth0ven-RxSwift-Chinese-Documentation-cbbc87e" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-beeth0ven-RxSwift-Chinese-Documentation-cbbc87e", "beeth0ven", "RxSwift-Chinese-Documentation", "cbbc87e", false);</script><h1 id="RxSwift学习"><a href="#RxSwift学习" class="headerlink" title="RxSwift学习"></a>RxSwift学习</h1><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift 中文文档</a></p><h1 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h1><table style="width:100%"><br><tr><br><td><img src="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/assets/MoreDemo/ImagePicker/ImagePickerFull.gif"></td><br><td><img src="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/assets/MoreDemo/TableViewSectionedViewController/TableViewSectionedViewControllerFull.png"></td><br><td><img src="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/assets/MoreDemo/Calculator/CalculatorFull.gif"></td><br></tr><br></table><p><a href="https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples" target="_blank" rel="noopener">RxExample</a> 中包含许多具有代表性的示例。它们都是<strong>很好的学习材料</strong>。这里我们取出其中几个示例来展示如何应用 <strong>RxSwift</strong> ：<br>演示RxExample的两种方式</p><ol><li>clone库，在根目录执行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open Rx.xcworkspace</span><br></pre></td></tr></table></figure></li></ol><p>然后，选择想要演示的schemes (RxExample-iOS, RxExample-OSX) and hit Run。</p><ol start="2"><li>使用pod工具创建RxExample项目<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod try RxSwift</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong><a href="more_demo/image_picker.md">ImagePicker</a> - 图片选择器</strong></p></li><li><p><strong><a href="more_demo/tableView_sectioned_viewController.md">TableViewSectionedViewController</a> - 多层级的列表页</strong></p></li><li><p><strong><a href="more_demo/calculator.md">Calculator</a> - 计算器</strong></p></li></ul><p>有兴趣的同学还可以研究一下 <a href="https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples" target="_blank" rel="noopener">RxExample</a> 中其他的示例。</p>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitBook编辑器使用</title>
      <link href="/2018/08/23/hexo/GitBook%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/23/hexo/GitBook%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-GitbookIO-gitbook-6efbb70" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-GitbookIO-gitbook-6efbb70", "GitbookIO", "gitbook", "6efbb70", false);</script><p><a href="https://legacy.gitbook.com/editor" target="_blank" rel="noopener">GitBook Editor</a><br><a href="https://legacy.gitbook.com/@iTBoyer/dashboard" target="_blank" rel="noopener">个人中心</a></p><h3 id="制作书籍"><a href="#制作书籍" class="headerlink" title="制作书籍"></a>制作书籍</h3><ol><li>在github找到文档库，fork为自己的库</li><li>登录GitBook<code>个人中心</code>，点击<code>+ New</code>新建book</li><li>在建库页面，选择导入<code>git hub</code>现有库<br> Import and sync an existing GitHub repository.</li><li>进入<code>Personal settings</code>，进入github设置面板</li><li>点击<code>Configure</code>按钮，进入github授权gitbook页面<br>GitBook does not have the permissions to access every GitHub repositories linked to your books. Please add them to your configuration to continue editing your  books.</li><li>github中设置 <code>Repository access</code></li><li>All repositories<br> This applies to all current and future repositories.</li><li>Only select repositories</li></ol><h3 id="gitbook终端命令行"><a href="#gitbook终端命令行" class="headerlink" title="gitbook终端命令行"></a>gitbook终端命令行</h3><p><a href="https://toolchain.gitbook.com/ebook.html" target="_blank" rel="noopener">命令行文档</a><br><a href="https://bookfere.com/post/288.html" target="_blank" rel="noopener">GitBook 制作 Kindle 电子书详细教程（命令行版）</a></p><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gitbook-cli -g</span><br></pre></td></tr></table></figure></li><li><p>创建电子书项目<br>新建一个目录，并进入该目录使用 gitbook 命令初始化电子书项目。举个例子，现在要创建一个名为“MyFirstBook”的空白电子书项目，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir MyFirstBook</span><br><span class="line">$ cd MyFirstBook</span><br><span class="line">$ gitbook init</span><br></pre></td></tr></table></figure></li><li><p>预览电子书内容<br>电子书内容编写完毕后可以使用浏览器预览一下。先输入下面的命令据 .md 文件生成 HTML 文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook build</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>Error: Couldn’t locate plugins “jsbin, anchors, video, ga, toggle-chapters, editlink, include-codeblock, splitter, github-buttons, chart, todo, quiz, include-highlight, tonic”, Run ‘gitbook install’ to install plugins from registry.<br>执行安装插件命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook install</span><br></pre></td></tr></table></figure></p></blockquote><p>生成完毕后，会在电子书项目目录中出现一个名为“_book”的文件夹。进入该文件夹，直接用浏览器打开“index.html”，或先输入下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook serve</span><br></pre></td></tr></table></figure></p><p>然后在浏览器中输入<code>“http://localhost:4000”</code>即可预览电子书内容，预览完毕后按 Ctrl + C 结束。</p><ol start="4"><li>生成电子书文件<br>确定电子书没有问题后，可以通过输入以下命令生成 mobi 电子书：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook mobi ./ ./MyFirstBook.mobi</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>error: error while generating page “introduction.md”: InstallRequiredError:”svgexport” is not installed. Install it using: “npm install svgexport -g”<br>执行安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install svgexport -g</span><br></pre></td></tr></table></figure></p></blockquote><p>如果出现以下错误提示，说明您还未安装 Calibre。由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以请先<a href="https://bookfere.com/tools#calibre" target="_blank" rel="noopener">点击这里</a>下载安装 Calibre。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Need to install ebook-convert from Calibre</span><br><span class="line">//或者使用命令安装</span><br><span class="line">brew install homebrew/cask/calibre</span><br></pre></td></tr></table></figure></p><p>Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin</span><br></pre></td></tr></table></figure></p><p>再次运行转换命令，即可生成 mobi 格式电子书。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SwiftLint检查代码使用</title>
      <link href="/2018/08/22/shell/SwiftLint%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/22/shell/SwiftLint%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-realm-SwiftLint-8deb453" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-realm-SwiftLint-8deb453", "realm", "SwiftLint", "8deb453", false);</script><h3 id="安装配置swiftlint语法矫正工具"><a href="#安装配置swiftlint语法矫正工具" class="headerlink" title="安装配置swiftlint语法矫正工具"></a>安装配置<code>swiftlint</code>语法矫正工具</h3><h4 id="安装包方式"><a href="#安装包方式" class="headerlink" title="安装包方式"></a>安装包方式</h4><p><code>brew install swiftlint</code> 或下载[swiftlint.pkg][<a href="https://github.com/realm/SwiftLint/releases/latest]" target="_blank" rel="noopener">https://github.com/realm/SwiftLint/releases/latest]</a></p><ol start="2"><li>Xcode项目支持<br>在<code>Xcode build Phase</code>新增 “Run Script Phase”:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> swiftlint &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">swiftlint</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="单个项目安装swiftlint"><a href="#单个项目安装swiftlint" class="headerlink" title="单个项目安装swiftlint"></a>单个项目安装swiftlint</h4><ol><li><p>通过cocoapods对单个项目安装swiftlint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwiftLint&apos;</span><br></pre></td></tr></table></figure></li><li><p>项目中添加支持  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：pod服务器上有时并不是最新版本，尝试<code>:=&gt; githuburl</code>无用。这种情况智能使用安装包方式。</p></blockquote><h3 id="规则配置文件-swiftlint-yml"><a href="#规则配置文件-swiftlint-yml" class="headerlink" title="规则配置文件.swiftlint.yml"></a>规则配置文件<code>.swiftlint.yml</code></h3><p>让 <code>SwiftLint</code> 在做代码规范检查时，不想检查某些源码，可以隔离规则，来自动忽略，例如： <code>CocoaPods</code>、<code>Carthage</code>、<code>SPM</code> 引入的第三方库文件。<br>在项目中新建 <code>.swiftlint.yml</code> 的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-project</span><br><span class="line">$ vi .swiftlint.yml</span><br><span class="line"></span><br><span class="line">excluded: </span><br><span class="line">    - Pods</span><br></pre></td></tr></table></figure></p><p><code>excluded</code>： 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件。<br><strong>支持嵌套</strong>：<br><code>.swiftlint.yml</code> 配置文件支持嵌套，可以给每个文件夹下的代码单独指定不同的规则，每个文件会匹配距离自己层级最近的父文件夹中的配置文件<br>嵌套的配置文件中的 <code>excluded</code> 和 <code>included</code> 配置会被忽略。</p><h3 id="终端插件集成swiftLint"><a href="#终端插件集成swiftLint" class="headerlink" title="终端插件集成swiftLint"></a>终端插件集成swiftLint</h3><p>支持vim编辑器：<br><a href="https://github.com/keith/swift.vim" target="_blank" rel="noopener">keith/swift.vim</a></p><h4 id="安装-syntastic"><a href="#安装-syntastic" class="headerlink" title="安装 syntastic"></a>安装 <a href="https://github.com/scrooloose/syntastic/" target="_blank" rel="noopener">syntastic</a></h4><p>使用<a href="https://github.com/tpope/vim-pathogen.git" target="_blank" rel="noopener">vim-pathogen</a>安装syntastic，</p><ol><li>第一步安装 <code>pathogen.vim</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.vim/<span class="built_in">autoload</span> ~/.vim/bundle &amp;&amp; \</span><br><span class="line">curl -LSso ~/.vim/<span class="built_in">autoload</span>/pathogen.vim https://tpo.pe/pathogen.vim</span><br></pre></td></tr></table></figure></li></ol><p>设置<code>~/.vimrc</code>配置项：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen<span class="comment">#infect()</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>第二步将<code>syntastic</code> 作为 <code>Pathogen</code> bundle的资源方式安装<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle &amp;&amp; \</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/vim-syntastic/syntastic.git</span><br></pre></td></tr></table></figure></li></ol><h4 id="终端集成使用"><a href="#终端集成使用" class="headerlink" title="终端集成使用"></a>终端集成使用</h4><p>在<code>vimrc</code>中添加配置，当启动vim即可使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:syntastic_swift_checkers = [<span class="string">'swiftpm'</span>, <span class="string">'swiftlint'</span>]</span><br></pre></td></tr></table></figure></p><ol><li>终端支持<code>Package.swift</code><br>当存在<code>Package.swift</code>的swift目录中启动vim，swiftpm将自动可用。</li><li>终端支持<code>.swiftlint.yml</code><br>当存在<code>.swiftlint.yml</code>的swift目录中启动vim，且SwiftLint已安装，自动启用swiftlint。</li></ol>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端支持swift自动补齐</title>
      <link href="/2018/08/21/shell/%E7%BB%88%E7%AB%AF%E6%94%AF%E6%8C%81swift%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90/"/>
      <url>/2018/08/21/shell/%E7%BB%88%E7%AB%AF%E6%94%AF%E6%8C%81swift%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="终端支持swift自动补齐"><a href="#终端支持swift自动补齐" class="headerlink" title="终端支持swift自动补齐"></a>终端支持swift自动补齐</h3><p>keith/sourcekittendaemon.vim：这个插件提供了Vim集成SourceKittenDaemon。这意味着你可以在vim中开发swift项目<br>需要两步：安装sourcekitten,   </p><h4 id="第一步安装sourcekitten"><a href="#第一步安装sourcekitten" class="headerlink" title="第一步安装sourcekitten"></a>第一步安装sourcekitten</h4><ol><li>安装<br>方式一：<code>brew install sourcekitten</code><br>方式二：clone源码 ,运行<code>swift build</code><br>方式三：clone 源码，运行 <code>make install</code><br>方式三：<a href="https://github.com/jpsim/SourceKitten/releases" target="_blank" rel="noopener">pkg安装包</a>  </li><li>执行<code>sourcekitten help</code>验证安装成功。  </li></ol><h4 id="第二步安装-SourceKittenDaemon"><a href="#第二步安装-SourceKittenDaemon" class="headerlink" title="第二步安装:SourceKittenDaemon"></a>第二步安装:SourceKittenDaemon</h4><ol><li>安装SourceKittenDaemon环境<br>安装并设置<a href="https://github.com/terhechte/SourceKittenDaemon" target="_blank" rel="noopener">SourceKittenDaemon</a><br>方式一：<a href="https://github.com/terhechte/SourceKittenDaemon/releases/" target="_blank" rel="noopener">pkg安装包</a><br>方式二: 1. Clone the repository   2. 安装 <code>make install</code>  </li><li>执行<code>SourceKittenDaemon help</code>验证安装成功。   </li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>启动后台驻守服务HTTP：<a href="https://github.com/terhechte/SourceKittenDaemon/blob/master/Protocol.org" target="_blank" rel="noopener">参考Protocol.org</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SourceKittenDaemon start --port 44876 --project /private/tmp/abcde/abcde.xcodeproj</span><br></pre></td></tr></table></figure></p><p><code>--port</code>: 服务使用的端口号，默认为<code>8081</code>，vim目前不支持指定SourceKittenDaemon端口，使用默认的8081。<br><code>--project=</code>: 指定服务将要加载的<code>.xcodeproj</code>文件路径，不支持指定<code>.xcworkspaces</code>文件路径</p><p>使用get方法请求后驻服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/complete  # X-Offset|X-Path|X-File</span><br><span class="line">/stop     # 停止后驻服务. 一般用于为其他target提供服务时，重新启动服务。</span><br><span class="line">/ping     # ping后驻服务，运行正常 return OK</span><br><span class="line">/project  # 打印当前加载的project文件路径。</span><br><span class="line">/files    # 打印一个当前加载的project中包含的所有swift文件列表</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown-preview实现md预览</title>
      <link href="/2018/08/21/shell/markdown-preview%E5%AE%9E%E7%8E%B0md%E9%A2%84%E8%A7%88/"/>
      <url>/2018/08/21/shell/markdown-preview%E5%AE%9E%E7%8E%B0md%E9%A2%84%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-iamcco-markdown-preview.vim-c09a1ca" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-iamcco-markdown-preview.vim-c09a1ca", "iamcco", "markdown-preview.vim", "c09a1ca", false);</script><p>nisha</p><h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarkdownPreview</span><br><span class="line">" open preview window in markdown buffer</span><br><span class="line"></span><br><span class="line">MarkdownPreviewStop</span><br><span class="line">" close the preview window and server</span><br></pre></td></tr></table></figure><h3 id="插件运行效果预览"><a href="#插件运行效果预览" class="headerlink" title="插件运行效果预览"></a>插件运行效果预览</h3><p><img src="https://cloud.githubusercontent.com/assets/5492542/15363504/839753be-1d4b-11e6-9ac8-def4d7122e8d.gif" alt></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图文组件及多媒体组件类图</title>
      <link href="/2018/08/18/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9B%BE%E6%96%87%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%A4%9A%E5%AA%92%E4%BD%93%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/08/18/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9B%BE%E6%96%87%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%A4%9A%E5%AA%92%E4%BD%93%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://www.plantuml.com/plantuml/svg/pJjhKnpNbT_xLzoAgy93Z5adjVkXmTGY94Su85Y1vAga4gMPla2lckb9Tm-8mcmX90H88B0jXCnBGfQ4afY7LZRY8SIFoToUcK_-2pddtdvF3w0aczhv8CrqttlkUJyljcRhb3ZV7XHl7x4d-yMjpSBhGxRyNahJZ4rDqayLbPgIy-nDOVukF7SUJHOEx-GFTt7Pn9l26rpyqxiPjhLMUB33Lbw9DMngiRZ-Ah-tAPw7uJjFtx9tSnBDg2vigQfMV0Z2_6x7UVp0URNELXU9-xnAgi8tQ_VbjAvOLftIOzccahRhD4InLqdJEYMJCMp5renC7Sta1c17SUkujBZ5dZoHgrCrXOrRpifqNVL7DVdZLUVUyxhg_wbXCnFUutCrRE9x-5ObyGD8cp9ivEoBcJujGwzfTAZ5oDYceUlK795IAU8ysdVUB00RI2ebfQe73Ksj6TBKFcgt3YXzOeUkfMzyeTdz5nHRaOaqAabP9Nq3tXB186VzhhEsIneRFpDqO49JquZa7jx26Hy_zbodOjgaDgkOy1g_0oBvWvd2mKPXUOiTBJWBEyxibdCmZoXTxchFsKgFJfjDKnckLKmJTrYmXKsjietxREPHP2-d9w3bZpbg3dSF6NmJ4j79J_tCC2yYQbbJisYNFQnJkLfWLIFGak209DvKW1VVNH6xdTBYON43jQ-q_cDfzLcFeGu7qDCcLMnwcGvPLmp3xaeZnv1x0AyqjbGydWm3on-lExUsGL-B3zwokKVvlSFyqJS8p-LVZ1EAgbuS1EGHEiTUhhxSnPaAQ0DRuRdBMN_zYSj69L1JIaojhzycHc-Yh2MV2-pv4llpru1Ww578kj242C9p5OTpSqIgHqEQsYtU6o-CxxUgfBPU-i-iQMIfQGzNPuoCOXi3MhgEf8tiS0svtDLbcrgcZxWVLyDQLGx7UJe7VFkxW0281gc-lZvi-Z-zMx9imwG0FH4QKA7rPIBmQjqD3MX2exuH2N6nWs-IB0XjhaUnQ0SSm7q2MgqpSok_Fn7JBP3qEL9zlgEZhKRBM82EaDwGhwEjgenxdxmeRZyhDpUnFMfjA75TpqPLtGNZeI3a5uOHGW5rpSF0Rhs06ulRXw2iFisd7OuGll00mCcZKfAUaLfmPMMiadqaIIEolB8hvFkJ0CjS4Pi2MOKq82AkKs1_VkayO1Q3pVPkizTZpkEdRESEctZ1vhw3av9MaiOl0KRN0E3IHXKp4uSpDmiG8Ap0zagBE1RyUHSgOPjcsJ4efBJuYXqi2da2f9CMdyelD_QS068ax61JWPlI3KMz2hh3jraHfC9BkjjGCm8KYES4ntozrbHlGpPdzVCDmVgmmxPZBWbqvHJYTTfhfyWL-iTWNHSrmRkwX2UyWR1N3QXO_M14u05ydq72JWDo0IFJLmFgSlLA6m39KGjm9ARurk3H0xz_HMsVIp9_Mltxcf2dhkbNCYfwuCYMJZ_a1dj-dJ66T0eHlrF98d71rj6Jh4syG274zSZrSgGQMVknOQg8fcBdBFBff-JVQjZRbsnxltGqxoOFF8Lg8f5eaY6wbhb1917q6dkQE4nDRQplQN9MNpWpasnh2OAfym2jfavYzvuMZuuYcPcNGmIHfI8fdrzgpgcQSKrJgO7Ybgyr8r-7Mo0Mzy7_oPJyHuqVqvpLOqm3_yyfyBnG7E689n8QsDnPmUJuUUprcZEsWLutJgeRCoCFOLjtnuKEcN3dZ31zt32vNRiFW5murwXfWUU5uEYyFGIQmWInpPVv_QV5usLsyBAml0SPjq331ryu-gfmk28mZ6Sla9263-0n0V23aD2cMFXVsiX16cOPfdr-6EDCZswaRx3bjUBExG1M74eBH9WUOAfSVQtvV5TpP-iLQcNXEGKp0E_34-IbSRRvM83WUM0kgm9VMfHqFyM8KrqZfT0XHHv0EliyV_1rS30HLFWCb5LDxQ8wJTjNZA5ckpMZqfkTYjqF0GwJ3abAajylG5jpsHI9oKnsrkwKnfwokN4G2qGwheQsaVMKK7BVJs-KbkyAJrfOkYEM1xgLUE8_Tc2beogSv9_ZIaTcimjiuhRpz9rGjwIJ_2KHvTgSbeHRgHSx0OU87Ps0G48ImHK0ObhyS0A7x0FqDAnJ9MVv1pHdB-EGkAW3ErdOWJ1tAWOYhbnhRgUgfc0Uq49rFU03S41OTsm56dPzFM5pNq5AuIpkbXP_-BBqU09IBV43DF3aU7ErjKtfeJgfjRK1ohysaF17m7U-tdGUldU-NmTgNFY2uMU73_Li0dYiAJt28fe6GTFFdslJQEvdIzrhYP_wXn0JsDGHVsDeYvUROvuOGSLLnX7VIu6KsRCreTDHmaNAVpBy1ixAUg6kA9s5uoYG4v7iidFgS1TDkr1Ap-xat-quOuSV3EYY1P869WUmmWRqmHY1wrDpEctmYi8UmuQLM1L6kIWLDxvprkR3DGFQ9WyYKCXAREMLi_aSCjdytgOVGDYzPRUR4muQlYabs6pKRNdk92XPjlUBhzT3nfHOP75fiwDl_EGGc0mu-b2Y1iuZ5QzyXamD-1ewc4U6RkF2ULu9yQ25_G586vwyAApSBsxSBJtxghZzqhazuHuXN8bN8eMgAYA2JuIiwYYP4BaoT8W_WOoJxnAREdLb69qEHavuFMpv08AiCH8SauHPnYb9k4U_HuRY53pnXUeME5C1HR0kNl0dnhiH3mNkTNkJ5qdLF0-we5bPeB1xE4l9ptzEUCPczHj3_06aQv_KICZom_NYxflYyRVvlJyxg-lvmrrWkI_XulOBjhMMVty_m2xKxFhy4Z_e2ar39WZABm9gONegadwT45jQser1ZSkXh6oAoz0QJ0WuI41XV9zD7gR1wGT5YuU7yC_isrT2cKhhFqfnriWO9gQUEuys2mzVWPA1k8h7Zvt7syxY1egEGoWip9HMdyKbT1B-8vAV2_lO22ImukSAxYF7vhVPlLTbgH5YY031QqFjWqe9_u5Avamz51rQVgKRggAtAncG2A-fuiz0YNc9rT7ptrBgMdDpMmZfi4Io5TwW3pk9L4-MaKE9LFP4BAjmY4zFXVSZKl8h2wAW-mtTjXkG7somgTrGBGrlmAEpgKbdzXbxFSVs5r8XHlVcTDrAcvHcEioB0prKLQcAxFOyUWtu-tP3fI8kY2DS7G5JlxKIarc7sQdaB2hOLf7RbNXXoM4QhhQ6d7BYSi6OypdmI60b0IdYIODKPaVug-4ap0Q2nmr-ZCyVF8Jo30lKcUdIrzYUkjhg7OfEfOiEqaphG9zth5kaX5-X5sXEeuiyLQC-_hA9LC3l0jG8VU2yvVpXTuNvkwG9SYL_Kd3Q9f4MvlVkvVV6dEN_3GckX_P2DeBxGEJSHpIuQ--NhLLwuRZofL7r-XTerqcUM5GQ7-29-Nx1jmlKLZGztbBpt9dmOg43IA9RBerDE_V_577BpZUp-QELCeqarc0Yy712SnfwRjUY-ulGEjbti613PmGHIyxEi0jLrLyZLdIQXcsa3TrJqKP2pdn-5DBvrjy4L1JVJx1xVyAcPgCK8pMfLeoLf9NAvrF2S5moVeHl8a48EeKoj3hsvA2mFbRMPOcw9O_jgN8saDh1h0h_-puU6EByk8LnS_sky_XzuVc1xw94LWmE598Pj9whhRmVMckX8tA7Hu8xGSpLCXhF0z4IzOGCqXg4JIBL41umTYOK7iMDAQ6uGOycxlv8K4p598Wy4WDBdqUfyXJ8Hnoe5qam7EAX_fcf351vu2G2t9xQensHWGWGVWUPevEyDQW1ooGJwg5v5M2PTDCvq--XUK86a87Vhc118pxEFiAfCo7ikiTWB3lnFPjuBMRRPtM9bwaxlP156uwzVS4cteRYiRyWA8NT6Ve9RRl1VuTYnFel79g69wROiFCgTBTpXoLAjmOYXUFiTWgiicGT35jNR1bWT9WTkehYrdg7-J9CyDlnfqPLx5fyPl31iCoxj3pLjV4VL0-BwZxAWhDk0VfFw3GgLfgVyS_gE8vA5PI3DE88oBMk5YLhvqmgGouDURnlbhwqOki8jxVNXpvQvwhZAshToGJlNI8uCLrsvbV00yPPPFT3W6_Dz1fyXZF9DXVH3qrFilafPse-dDfVRUNN201ysXZ8wlHcDxrfbusEGyebXRKliGmBZutTknNbxM_iZ7LxpTPO1pnKify3hLDuyUkRdglDtbWoR83ja3DX0GpOL80l1dMeXmdZliBXXZDz37LTydknj-9OHUn6VDrkQ9CKcfMNWqDIIvEpCOg4obUcIwg4NErfyzNmXOzozBa2SWeAKtZTfg8GIFHwpIH47LXYP6d6col98fMKhbydVgw5YPT8Fzn6_VNhGli26S4AqCAW0OzRm6V4s-yf7cJ0Qd43KepcBxlJHTmZC9Um7Sgxl-9A1xnaxnVPzZuxU8WTRmYHotTnET2AC5kGEnvOj9pp_1w6p7_oWRex3Nku3KoDE2aUUR4szypgewofz0qeP40nRv0KmPRTn0kt7VlsJV7e-myPDs3EF-iyt2t-iF_JkvdytaDdyQcpUhlqxNpnvItdzRYpk5kNT88uWDx4qUhr0SFk5sc-3nbuhNdVfL4Ikkxm-QNcj6bObcVoWd1nnSbLrKfM7Gb1RXysx0ryvJvxyF6KwbyIX4OhcdvADOOogO10J-FSlXhtnU8IGzGDkcr3Zs5G4TbAfa-d0SymysgsuMimB3Y7gkUdAVX3EjUh1UhkPeMNCOkiuOQ25ae8M_yBcvXm3M0q1BzTkqdLjkOhc5nuymWIZCn-Q-Lmibn-nEya7fHBO-EbYTcmuLzj5NSZ_5C0bn6q-CZblb0x60t-mvleVrUt_1_hZFin3oZYxUxbOoYZ_K5mVcyJBo0-duMmxdOfeztKyh5gf2l-oST4h12_Vtgt9FtYO-B2uxrtwPVURz6vZRVvUDyYexOefWee9XSuFDkivEg9uHQd4QsJOtSi0bUA9NNPSX4CatHBIdg8Pm8cCibgwHQqv4y_yIlro40UQ_LWZMYtHsvvlblA7nq3SzZi0Z1Vf3N1BKztLEhRe5SkLZOzZYaVrWd3y3LQN62vP0pGB80Q2LTwGGiXbdTXHuJ3uh4ZZVSogSgDEUiszsKIDKnSV6gzAgwZIMVTK5Omn4lHKARX2VTCS9CoN0HGKTCGaIWVunMyrqKlKuAWZmxfEiYR_24Io_uWM2_zDinapVAP_piVX7yWrsYkKC4LnrZhEtuNfG99vNeZHqxn1k4nefBkLRe39Pv3H36DwtIKZm4UPn2S71iyL62whzNUQd43Di3XWnGGpJtMz2dd6_T52IjFTtALpZXHSAU3bSDXcpIH_v_QALKbEkH4VqogF7_AfsnIbL2s-jBIV75n3jBVEh_m536fi3bDm4kK7cv1tIZoNN4LFhW1BwwzIrKf-11nYzw_ebyuE6RF9vqth-hOt7R-y0LEQ6yjOHNy_hwp2ZvdFB_tW4tjYDN5upLmH11L8Gz9LKbLdDq_SotaxKlNIBWj-74t-5bstz-DjNSdsDO-fkISL0YouU6vcCK3bI9h-nbHB0Av8m5wFk8V_gS1d0GtRml-L63bBspdlGX0CaSrVpHREDgIYLZ_aVUfIhnxNQwLag0eaLwfiQUf8eLSKeda0M5_7HiFwOhtrnMz1lmyxQyhS9zO-3S0"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iCompleteMe支持swift语法提示</title>
      <link href="/2018/08/11/shell/iCompleteMe%E6%94%AF%E6%8C%81swift%E8%AF%AD%E6%B3%95%E6%8F%90%E7%A4%BA/"/>
      <url>/2018/08/11/shell/iCompleteMe%E6%94%AF%E6%8C%81swift%E8%AF%AD%E6%B3%95%E6%8F%90%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-jerrymarino-iCompleteMe-ad0e1fe" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-jerrymarino-iCompleteMe-ad0e1fe", "jerrymarino", "iCompleteMe", "ad0e1fe", false);</script><p>iCompleteMe是基于YouCompleteMe。在花了一年多的时间试图实现对YouCompleteMe的快速支持之后，发现在YCM无法支持swift自动补齐。<br>iCompleteMe实现的行为对于Swift的补齐提示。iCompleteMe的核心子系统只与Swift一起工作。代码基占用的空间要小得多，这使得在CI上更容易安装、更容易理解和更稳定(理论上)。</p><h3 id="在space-vim中添加插件支持"><a href="#在space-vim中添加插件支持" class="headerlink" title="在space-vim中添加插件支持"></a>在space-vim中添加插件支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;jerrymarino/iCompleteMe&apos;</span><br></pre></td></tr></table></figure><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.vim/plugged/iCompleteMe/</span><br><span class="line">brew install cmake</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure></p><p>然后 <code>&lt;Leader&gt; f R</code> 使配置生效，并执行   <code>:PlugInstall</code>进行安装.</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SwiftPlayground命令操作</title>
      <link href="/2018/08/10/shell/SwiftPlayground%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/10/shell/SwiftPlayground%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-jerrymarino-SwiftPlayground.vim-f603700" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-jerrymarino-SwiftPlayground.vim-f603700", "jerrymarino", "SwiftPlayground.vim", "f603700", false);</script><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>在playgrounds后缀的目录中执行swift文件</p><h2 id="熟悉vim快捷键用法"><a href="#熟悉vim快捷键用法" class="headerlink" title="熟悉vim快捷键用法"></a>熟悉vim快捷键用法</h2><p>空格 + fs 保存文件：此时插件会自动运行playgrounds，显示效果<br>shift + H ：行头<br>shift + L：行尾<br>:copen : AsyncRun显示运行日志<br>:AsyncRun  shell命令</p><h3 id="支持结构"><a href="#支持结构" class="headerlink" title="支持结构"></a>支持结构</h3><p><code>*.playgroud/Contents.swift</code><br>不支持包含：Pages页面的playground。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FSCalendar支持自定义的日历开源库</title>
      <link href="/2018/07/18/%E5%BC%80%E6%BA%90%E5%BA%93/FSCalendar%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%97%A5%E5%8E%86%E5%BC%80%E6%BA%90%E5%BA%93/"/>
      <url>/2018/07/18/%E5%BC%80%E6%BA%90%E5%BA%93/FSCalendar%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%97%A5%E5%8E%86%E5%BC%80%E6%BA%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-FSCalendar-1a026a4c" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-FSCalendar-1a026a4c", "huos3203", "FSCalendar", "1a026a4c", false);</script><p><blockquote class="trello-card"><a href="https://trello.com/c/Tq2jnc1E/33-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%8E%86%E6%8E%A7%E4%BB%B6%EF%BC%8C%E6%97%A5%E6%9C%9F%E5%9B%BE%E6%A0%87" target="_blank" rel="noopener">自定义日历控件，日期图标</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><p><a href="https://github.com/huos3203/FSCalendar" target="_blank" rel="noopener">FSCalendar</a><br>FSCalendar是一款开源iOS日历控件，支持横向、纵向滑动模式，全屏模式，带有子标题、事件设置等功能。以下是项目截图：<br><img src="https://cloud.githubusercontent.com/assets/5186464/10262249/4fabae40-69f2-11e5-97ab-afbacd0a3da2.jpg" alt><br>Use Interface Builder<br>1、 Drag an UIView object to ViewController Scene 2、 Change the Custom Class to FSCalendar<br>3、 Link dataSource and delegate to the ViewController<br>4、 Finally, implement FSCalendarDataSource and FSCalendarDelegate in your ViewController<br><img src="https://cloud.githubusercontent.com/assets/5186464/9488580/a360297e-4c0d-11e5-8548-ee9274e7c4af.jpg" alt></p><h3 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h3>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高效人士的七个习惯</title>
      <link href="/2018/07/03/%E9%98%85%E8%AF%BB/%E9%AB%98%E6%95%88%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
      <url>/2018/07/03/%E9%98%85%E8%AF%BB/%E9%AB%98%E6%95%88%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://book.douban.com/annotation/18551525/" target="_blank" rel="noopener">豆瓣导图</a><br><a href="https://book.douban.com/annotation/39594570/" target="_blank" rel="noopener">豆瓣总结</a></p><h2 id="前言-如何善用本书"><a href="#前言-如何善用本书" class="headerlink" title="前言 如何善用本书"></a>前言 如何善用本书</h2><h2 id="第一部分-重新探索自我"><a href="#第一部分-重新探索自我" class="headerlink" title="第一部分 重新探索自我"></a>第一部分 重新探索自我</h2><h2 id="第一章-由内而外全面造就自己"><a href="#第一章-由内而外全面造就自己" class="headerlink" title="第一章 由内而外全面造就自己"></a>第一章 由内而外全面造就自己</h2><h2 id="第二章-七个习惯——概论"><a href="#第二章-七个习惯——概论" class="headerlink" title="第二章 七个习惯——概论"></a>第二章 七个习惯——概论</h2><h1 id="第二部分-个人的成功：从依赖到独立"><a href="#第二部分-个人的成功：从依赖到独立" class="headerlink" title="第二部分 个人的成功：从依赖到独立"></a>第二部分 个人的成功：从依赖到独立</h1><h2 id="第三章-习惯一：积极主动——个人愿景的原则"><a href="#第三章-习惯一：积极主动——个人愿景的原则" class="headerlink" title="第三章 习惯一：积极主动——个人愿景的原则"></a>第三章 习惯一：积极主动——个人愿景的原则</h2><h2 id="第四章-习惯二：以终为始——自我领导的原则"><a href="#第四章-习惯二：以终为始——自我领导的原则" class="headerlink" title="第四章 习惯二：以终为始——自我领导的原则"></a>第四章 习惯二：以终为始——自我领导的原则</h2><h3 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h3><p>以终为始最有效的方法，就是撰写一份个人使命宣言，即人生哲学或基础信念。<br>宣言：主要说明自己想成为怎样的品行的人。成什么样的事业，及为此奠基的价值观和原则。<br>家庭第一<br>借重宗教的力量<br>在诚信问题上决不妥协<br>念及相关的每个人<br>未听取正反双方的意见，不妄下断语<br>征求他人意见<br>维护不在场的人<br>诚恳但立场坚定<br>每年掌握一种新技能<br>今天计划明天的工作<br>利用等待的空闲时间<br>态度积极<br>保持幽默感<br>生活与工作有条不紊<br>别怕犯错，怕的是不能吸取教训<br>协助属下成功<br>多请教别人<br>专注于当前的工作，不为下一次任务或提升操心</p><p>定期储蓄或利用部分收入做投资</p><p>一个人的应变能力取决于他对自己的本性，人生目标以及价值观的不变的信念。<br>只要心中秉持着恒久不变的真理，就能屹立于动荡的环境中。</p><p>标记疗法的基础原理：许多心智或情感疾病，都是由于失落感或空虚感作祟，而标记疗法可以帮助病人找回生命的意义与使命感，以祛除这些感觉。</p><h2 id="第五章-习惯三：要事第一——自我管理的原则"><a href="#第五章-习惯三：要事第一——自我管理的原则" class="headerlink" title="第五章 习惯三：要事第一——自我管理的原则"></a>第五章 习惯三：要事第一——自我管理的原则</h2><p><a href="https://book.douban.com/people/140683087/annotation/1048007/?start=0" target="_blank" rel="noopener">豆瓣笔记</a></p><h1 id="第三部分-公众的成功：从独立到互赖"><a href="#第三部分-公众的成功：从独立到互赖" class="headerlink" title="第三部分 公众的成功：从独立到互赖"></a>第三部分 公众的成功：从独立到互赖</h1><h2 id="第六章-你不是一座孤岛"><a href="#第六章-你不是一座孤岛" class="headerlink" title="第六章 你不是一座孤岛"></a>第六章 你不是一座孤岛</h2><h2 id="第七章-习惯四：双赢思维——人际领导的原则"><a href="#第七章-习惯四：双赢思维——人际领导的原则" class="headerlink" title="第七章 习惯四：双赢思维——人际领导的原则"></a>第七章 习惯四：双赢思维——人际领导的原则</h2><h2 id="第八章-习惯五：知彼知己——同理心交流的原则"><a href="#第八章-习惯五：知彼知己——同理心交流的原则" class="headerlink" title="第八章 习惯五：知彼知己——同理心交流的原则"></a>第八章 习惯五：知彼知己——同理心交流的原则</h2><h2 id="第九章-习惯六：统合综效——创造性合作的原则"><a href="#第九章-习惯六：统合综效——创造性合作的原则" class="headerlink" title="第九章 习惯六：统合综效——创造性合作的原则"></a>第九章 习惯六：统合综效——创造性合作的原则</h2><h1 id="第四部分-全面观照生命"><a href="#第四部分-全面观照生命" class="headerlink" title="第四部分 全面观照生命"></a>第四部分 全面观照生命</h1><h2 id="第十章-习惯七：不断更新——平衡的自我更新的原则"><a href="#第十章-习惯七：不断更新——平衡的自我更新的原则" class="headerlink" title="第十章 习惯七：不断更新——平衡的自我更新的原则"></a>第十章 习惯七：不断更新——平衡的自我更新的原则</h2><h2 id="第十一章-再次由内而外造就自己"><a href="#第十一章-再次由内而外造就自己" class="headerlink" title="第十一章 再次由内而外造就自己"></a>第十一章 再次由内而外造就自己</h2><p>附录<br>一、你是哪种类型的人？——生活重心面面观<br>二、第四代时间管理——高效能人士的一天</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员跳槽全攻略</title>
      <link href="/2018/07/03/%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/"/>
      <url>/2018/07/03/%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书都不会读还想成功</title>
      <link href="/2018/07/02/%E9%98%85%E8%AF%BB/%E4%B9%A6%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%AF%BB%E8%BF%98%E6%83%B3%E6%88%90%E5%8A%9F/"/>
      <url>/2018/07/02/%E9%98%85%E8%AF%BB/%E4%B9%A6%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%AF%BB%E8%BF%98%E6%83%B3%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="处境"><a href="#处境" class="headerlink" title="处境"></a>处境</h3><p>人到中年，职场受排挤降级，情场被抛弃不如意，怨天尤人，自怨自艾，却不思进取，死扛着压力勉强养家糊口残喘于世。</p><h3 id="心态转折"><a href="#心态转折" class="headerlink" title="心态转折"></a>心态转折</h3><ol><li>红皇后的故事：寓意为什么在现实生活中不进则退的境地，见贤思齐，善于发现同事优点，定位榜样学习实线。<h3 id="读书习惯"><a href="#读书习惯" class="headerlink" title="读书习惯"></a>读书习惯</h3></li><li>100天33本书: 从量到质达到，培养读书习惯的目的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Framework实现使用swift开发</title>
      <link href="/2018/06/24/swift/Framework%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91/"/>
      <url>/2018/06/24/swift/Framework%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-JHHomeAPP-813e4b" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-JHHomeAPP-813e4b", "huos3203", "JHHomeAPP", "813e4b", false);</script><h2 id="在静态库组件中使用swift开发"><a href="#在静态库组件中使用swift开发" class="headerlink" title="在静态库组件中使用swift开发"></a>在静态库组件中使用swift开发</h2><p>基于静态库的开发，实现封装静态库/Framework并使用swiftOC混编开发</p><h3 id="创建三个角色"><a href="#创建三个角色" class="headerlink" title="创建三个角色"></a>创建三个角色</h3><ol><li>主项目：<code>JHHomeAPP</code></li><li>静态库组件：<code>FirstPlug</code> <ul><li><code>SwiftInStaticLib</code>(包含Swift源码实现的静态库)</li></ul></li><li>动态库<code>secondFramework</code></li></ol><h3 id="静态库：问题1"><a href="#静态库：问题1" class="headerlink" title="静态库：问题1"></a>静态库：问题1</h3><p>当静态库组件中存在swift源码时，依赖该组件的主工程会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ld: warning: Auto-Linking library not found for -lswiftDispatch</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftCoreFoundation</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftObjectiveC</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftDarwin</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftFoundation</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftCoreGraphics</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftCore</span><br><span class="line">ld: warning: Auto-Linking library not found for -lswiftSwiftOnoneSupport</span><br></pre></td></tr></table></figure></p><ol><li>联想方法：<br>设置 <code>Always Embed Swift Standard Libraries</code>: <code>YES</code><br>结果无效。</li><li>适用的解决方法<br>在主工程中新建一个空的swift源文件，不需要自动新建<code>$(SWIFT_MODULE_NAME)-Swift.h</code>映射文件和<code>JHHomeAPP/JHHomeAPP-Bridging-Header.h</code>头文件。<br><strong>使用方法2，问题1就不存在了，证明了在静态库中可以使用swift源码文件进行开发,同样证明了静态库可以封装包含swift源码的静态库。</strong></li></ol><h3 id="Framework：问题2"><a href="#Framework：问题2" class="headerlink" title="Framework：问题2"></a>Framework：问题2</h3><ol><li>在动态库中objc源码方法可以封装到静态库，并在可执行文件中调用。</li><li>当在Framework中新建swift源文件时，第一次编译运行出现崩溃问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/libswiftCoreImage.dylib</span><br><span class="line">Referenced from: .../../Debug-iphonesimulator/SecondFramework.framework/SecondFramework</span><br><span class="line">Reason: image not found</span><br></pre></td></tr></table></figure></li></ol><p>解决办法：需要在<code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code>设置为<code>YES</code>.再次编译出现问题3。</p><h3 id="Framework-问题3"><a href="#Framework-问题3" class="headerlink" title="Framework: 问题3"></a>Framework: 问题3</h3><p>当在oc源码文件中用引用<code>-Swift.h</code>头文件时，出现一下问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;SecondFramework-Swift.h&apos; file not found</span><br><span class="line">#import &quot;SecondFramework-Swift.h&quot;</span><br><span class="line">^~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure></p><p>结果将：<code>Install Objective-C Compatibility Header</code> : <code>NO</code>可以正常调用swift方法了。</p><blockquote><p>验证：framework可以封装到静态库中，当有swift源码实现时需要设置ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Product Module Name: 该项默认为项目名或自定义的名称</li><li>Defines Module: 设置为YES （framework默认为YES，静态库默认为NO）</li><li>Embedded Content Contains Swift: 设置为YES</li><li>Install Objective-C Compatibility Header：设置为YES （如上题说：在framework中设置为NO，才能正常运行，在静态库中似乎不影响）</li><li>Objective-C Bridging Header: 自定义需要桥接到Swift中的OC头文件（EX：$(SRCROOT)/Swift-Bridging-Header.h）</li></ol>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用CocoaPods开发静态库</title>
      <link href="/2018/06/22/macOS/%E4%BD%BF%E7%94%A8CocoaPods%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>/2018/06/22/macOS/%E4%BD%BF%E7%94%A8CocoaPods%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Cocoapods作为OS X和iOS开发平台的类库管理工具，已经非常完善和强大。通常我们用pod来管理第三方开源类库，但我们也极有可能会开发一个用pod管理依赖关系的静态类库给其他人使用，而又不愿意公开源代码，比如一些SDK，那么就需要打包成.a文件。本文将以一个依赖于ASIHTTPRequest的静态类库，来演示如何创建使用了CocoaPods的静态类库以及打包的过程。</p><h2 id="开发静态库（Static-Library）"><a href="#开发静态库（Static-Library）" class="headerlink" title="开发静态库（Static Library）"></a>开发静态库（Static Library）</h2><h3 id="搭建pod静态库项目"><a href="#搭建pod静态库项目" class="headerlink" title="搭建pod静态库项目"></a>搭建pod静态库项目</h3><h4 id="不基于pod手动创建-deprecated"><a href="#不基于pod手动创建-deprecated" class="headerlink" title="不基于pod手动创建(deprecated)"></a>不基于pod手动创建(deprecated)</h4><ol><li>在Xcode中创建一个Cocoa Touch Static Library；</li><li>创建Podfile文件；</li><li>执行pod install完成整个项目的搭建；</li><li>如果需要demo，手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行pod install完成示例项目的搭建。</li></ol><h4 id="基于pod自动创建"><a href="#基于pod自动创建" class="headerlink" title="基于pod自动创建"></a>基于pod自动创建</h4><p>只需要输入<code>pod lib</code>命令即可完成初始项目的搭建，下面详细说明具体步骤，以<code>JHLib</code>作为项目名演示。<br>1.执行命令<code>pod lib create JHLib</code>。在此期间需要确认下面4个问题。</p><h2 id="打包类库"><a href="#打包类库" class="headerlink" title="打包类库"></a>打包类库</h2><p>需要使用一个cocoapods的插件<code>cocoapods-packager</code>来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。</p><ol><li><p>安装打包插件<br>终端执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-packager</span><br></pre></td></tr></table></figure></li><li><p>打包<br>命令很简单，执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod package BZLib.podspec --library --force</span><br></pre></td></tr></table></figure></li></ol><p>其中<code>--library</code>指定打包成.a文件，如果不带上将会打包成.framework文件。<code>--force</code>是指强制覆盖。最终的目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|____BZLib.podspec</span><br><span class="line">|____ios</span><br><span class="line">| |____libBZLib.a</span><br></pre></td></tr></table></figure></p><p>需要特别强调的是，该插件通过对引用的三方库进行重命名很好的解决了类库命名冲突的问题。<br>比如你的类库使用了ASI，然后打包成静态库.a文件。外部调用的项目也使用了ASI，那么不会造成冲突。因为在打包的时候，你的类库里的ASI被重命名为项目+ASI的前缀。</p><p><a href="https://onevcat.com/2016/01/create-framework/" target="_blank" rel="noopener">如何打造一个让人愉快的框架</a><br><a href="http://www.cnblogs.com/brycezhang/p/4117180.html" target="_blank" rel="noopener">使用CocoaPods开发并打包静态库</a><br><a href="https://www.jianshu.com/p/2ea267bf0363" target="_blank" rel="noopener">iOS动态库,静态库以及framework</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用tag管理多个相关组件的版本发布</title>
      <link href="/2018/06/21/git/%E4%BD%BF%E7%94%A8tag%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
      <url>/2018/06/21/git/%E4%BD%BF%E7%94%A8tag%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="tag标签自增新建脚本"><a href="#tag标签自增新建脚本" class="headerlink" title="tag标签自增新建脚本"></a>tag标签自增新建脚本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">tag=$(git describe --tags `git rev-list --tags --max-count=1`)</span><br><span class="line">version=<span class="variable">$&#123;tag##*.&#125;</span></span><br><span class="line"><span class="built_in">let</span> <span class="string">"version+=1"</span></span><br><span class="line">newTag=<span class="variable">$&#123;tag%.*&#125;</span>.<span class="variable">$&#123;version&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Create New Tag '</span><span class="variable">$newTag</span></span><br></pre></td></tr></table></figure><h2 id="修改tag版本号的方法"><a href="#修改tag版本号的方法" class="headerlink" title="修改tag版本号的方法"></a>修改tag版本号的方法</h2><h3 id="方法一：覆盖"><a href="#方法一：覆盖" class="headerlink" title="方法一：覆盖"></a>方法一：覆盖</h3><ol><li><p>已有v1.0.2.8要覆盖该版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -f v1.0.2.8</span><br></pre></td></tr></table></figure></li><li><p>服务器已有v1.0.2.8，强制推到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -f v1.0.2.8</span><br></pre></td></tr></table></figure></li><li><p>同步服务器：获取服务器刚刚的v1.0.2.8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -–tag</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法：删除分支"><a href="#方法：删除分支" class="headerlink" title="方法：删除分支"></a>方法：删除分支</h3><ol><li><p>删除本地版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0.2.8</span><br></pre></td></tr></table></figure></li><li><p>删除服务器上的分支(用空版本覆盖)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="symbol">:v1</span>.<span class="number">0</span>.<span class="number">2.8</span></span><br></pre></td></tr></table></figure></li><li><p>服务器获取刚刚的v1.0.2.8</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch –-tag</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>弧形表盘进度仪表</title>
      <link href="/2018/06/20/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%BC%A7%E5%BD%A2%E8%A1%A8%E7%9B%98%E8%BF%9B%E5%BA%A6%E4%BB%AA%E8%A1%A8/"/>
      <url>/2018/06/20/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%BC%A7%E5%BD%A2%E8%A1%A8%E7%9B%98%E8%BF%9B%E5%BA%A6%E4%BB%AA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-ArcProgressUI-4b9bc85" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-ArcProgressUI-4b9bc85", "huos3203", "ArcProgressUI", "4b9bc85", false);</script><h1 id="ArcProgressUI"><a href="#ArcProgressUI" class="headerlink" title="ArcProgressUI"></a>ArcProgressUI</h1><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>To run the example project, clone the repo, and run <code>pod install</code> from the Example directory first.</p><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>ArcProgressUI is available through <a href="https://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a>. To install<br>it, simply add the following line to your Podfile:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'ArcProgressUI'</span></span><br></pre></td></tr></table></figure><h2 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h2><h3 id="独立进度表盘加载"><a href="#独立进度表盘加载" class="headerlink" title="独立进度表盘加载"></a>独立进度表盘加载</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ArcProgressView.h"</span></span></span><br><span class="line"><span class="built_in">NSArray</span> *viewArr = [[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"ArcProgressView"</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">UIView</span> *arcView = viewArr.lastObject;</span><br><span class="line">arcView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:arcView];</span><br></pre></td></tr></table></figure><h3 id="完整控制器页面"><a href="#完整控制器页面" class="headerlink" title="完整控制器页面"></a>完整控制器页面</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"PatrolScoreViewController.h"</span></span></span><br><span class="line">+(PatrolScoreViewController *)withStoryboard:(PatrolScoreStyle)style&#123;</span><br><span class="line"><span class="built_in">NSBundle</span> *podbundle = [<span class="built_in">NSBundle</span> bundleForClass:[PatrolScoreViewController <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSURL</span> *bundleURL = [podbundle URLForResource:<span class="string">@"ArcProgressUI"</span> withExtension:<span class="string">@"bundle"</span>];</span><br><span class="line"><span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithURL:bundleURL];</span><br><span class="line"><span class="built_in">UIStoryboard</span> *story = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"PatrolScore"</span> bundle:bundle];</span><br><span class="line">PatrolScoreViewController *VC = [story instantiateViewControllerWithIdentifier:<span class="string">@"PatrolScoreViewController"</span>];</span><br><span class="line">VC.scoreViewStyle = style;</span><br><span class="line"><span class="keyword">return</span> VC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态库开发："><a href="#静态库开发：" class="headerlink" title="静态库开发："></a>静态库开发：</h2><p>设想：通过cocoapod管理静态库的依赖关系。在项目调用静态库</p><ol><li>主工程：prj</li><li>一级静态库: first.a ：组件</li><li><p>二级静态库：组件依赖的静态库</p><p> sec.a    : 二级静态库.a<br> pod.a  ：包含二级静态库的集合</p></li></ol><p>其他经验：通过pod来开发一级静态库即组件。会生成组件的工作空间：<code>workspace</code> 将<code>prj主工程</code>拖入工作空间，来协作开发。</p><blockquote><p>坑：当再次切换prj主工程,关联.a组件依赖时，例如：libJHPatrol.a的other linker tag 路径一定要更新。</p></blockquote><p>结果：</p><ol><li>手动配置一级静态库组件，依赖的二级静态库可用<br>资源bundle文件直接添加到主工程资源拷贝列表中，在代码中会正常映射出IBoutlet相应的UI实例。参见 上述使用说明</li><li><code>-ObjC</code>设置<br>在主工程build setting 配置的<code>Other linker</code> ：<code>-ObjC</code>：表示尽可能的加载所有依赖静态库中的objc源码资源。<br>解决的问题：可以解决通过资源（xib/storyboard）初始化实例式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this class is not key value coding-compliant for the key ibReviewLabel</span><br></pre></td></tr></table></figure></li></ol><p>解决在storyboard中使用源码自定义UI控件时，无效果的问题。</p><ol start="3"><li><p>在封装静态库中，storyboard/xib中的控件不要设置model属性。</p></li><li><p>使用pod来一级静态库组件，管理依赖的二级静态库libpod.a无效</p></li></ol><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><a href="mailto:huo3203@hotmail.com" target="_blank" rel="noopener">huo3203@hotmail.com</a>, 724987481</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>ArcProgressUI is available under the MIT license. See the LICENSE file for more info.</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>storyboard的几种方式</title>
      <link href="/2018/06/20/iOS/UI/storyboard%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/06/20/iOS/UI/storyboard%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="通过IB（xib-storyboard）创建View的周期方法"><a href="#通过IB（xib-storyboard）创建View的周期方法" class="headerlink" title="通过IB（xib/storyboard）创建View的周期方法"></a>通过IB（xib/storyboard）创建View的周期方法</h2><ol><li><code>loadView</code>：加载View方法，UI是通过代码绘制时，初始化控制器的视图时，会调用该方法。优先级高于IB视图，当重载时，会直接覆盖IB中的视图,因为无论nib也好，xib也好，最终在执行UIViewController生命周期函数<code>loadView</code>之前，都会转化成可执行的nib文件。</li><li><code>initWithNibName</code>：是类的构造器方法，通过IB创建的类：简称<code>IB类</code>，<code>IB类</code>需要通过这个构造器来实例化对象。</li><li><code>initWithCoder</code>：当<code>IB类</code>实例化时会调用该方法，即通过<code>initWithNibName</code>构造器实例化对象时，会调用该方法来分配<code>IB对象</code>的内存空间。</li><li><code>awakeFromNib</code>：当实例化<code>IB视图类</code>时执行，即当IB文件被加载的时候，会发送一个<code>awakeFromNib</code>的消息到IB文件中的每个的对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。<blockquote><p>帮助记忆：一开始经过<code>initWithCoder</code>创建出来的控件是死的，然后通过<code>awakeFromNib</code>来唤醒，所以这会有一个先后的调用顺序</p></blockquote></li><li><code>viewDidLoad</code>：当view对象被加载到内存后就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad 。</li></ol><h2 id="加载xib方法"><a href="#加载xib方法" class="headerlink" title="加载xib方法"></a>加载xib方法</h2><h3 id="加载视图"><a href="#加载视图" class="headerlink" title="加载视图"></a>加载视图</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">NSArray</span>* nibView =  [[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"xibfileName"</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br><span class="line"> <span class="built_in">UIView</span> *xibView = nibView.lastObject;</span><br><span class="line"><span class="comment">//=======</span></span><br><span class="line"> <span class="comment">// 这里的bundle参数是nil,(这里nil默认就是mianBundle)</span></span><br><span class="line"> <span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"xib文件名"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"> <span class="built_in">NSArray</span> *views = [nib instantiateWithOwner:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><code>owner</code>:xib中的fileObject参数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载所有xib文件</span></span><br><span class="line"><span class="built_in">NSArray</span>* objects = [[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:nibName owner:<span class="keyword">self</span> options:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载指定xib文件</span></span><br><span class="line">ContactsTableViewCell  *cell = [[[<span class="built_in">NSBundle</span> mainBundle]loadNibNamed:<span class="string">@"ContactsTableViewCell"</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>] objectAtIndex:<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><h3 id="加载控制器对象"><a href="#加载控制器对象" class="headerlink" title="加载控制器对象"></a>加载控制器对象</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:<span class="string">@"xibName"</span> bundle:nibBundleOrNil];</span><br></pre></td></tr></table></figure><h2 id="加载storyboard"><a href="#加载storyboard" class="headerlink" title="加载storyboard"></a>加载storyboard</h2><h3 id="加载控制器对象-1"><a href="#加载控制器对象-1" class="headerlink" title="加载控制器对象"></a>加载控制器对象</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载storyboard</span></span><br><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Two"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建storyboard里面灰色的控制器</span></span><br><span class="line">　　　<span class="comment">//找到shtoryboard里面设置的初始控制器</span></span><br><span class="line">　　　<span class="comment">//    UIViewController *vc = [storyboard instantiateInitialViewController];</span></span><br><span class="line">　　　　　　　　</span><br><span class="line">　　　　　　　<span class="comment">// 从storyboard里面找出绑定标识的控制器</span></span><br><span class="line">　　　　　　　MJTwoViewController *vc = [storyboard instantiateViewControllerWithIdentifier:<span class="string">@"pink"</span>];</span><br><span class="line">　　　　　　　<span class="keyword">self</span>.window.rootViewController = vc;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用curl命令管理远程github库</title>
      <link href="/2018/06/20/git/%E4%BD%BF%E7%94%A8curl%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8Bgithub%E5%BA%93/"/>
      <url>/2018/06/20/git/%E4%BD%BF%E7%94%A8curl%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8Bgithub%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用<code>curl</code>命令管理远程github库</p><h2 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h2><ol><li><p>在本地准备工作<br>进入一个目录，这个目录是本地仓库的目录；<br>在本地建立仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &amp;&amp; git add . &amp;&amp; git commit -m <span class="string">'some information'</span></span><br></pre></td></tr></table></figure></li><li><p>新建一个<code>API token</code><br>打开此链接，<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">generate new token</a>，写入<code>description</code>，选择<code>scopes</code>（设置此token持有者的权限）。记住<code>personal access token</code>（也就是那一串字符和数字）！这一串东西只出现一次，下次查看不到。</p></li></ol><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>这是最直接的一种形式，直接把参数写到命令行搞定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -u git账号 -d &apos;&#123;&quot;name&quot;:&quot;新库名&quot;,&quot;description&quot;:&quot;库描述&quot;&#125;&apos; https://api.github.com/user/repos</span><br><span class="line">curl -u &quot;$username:$token&quot; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>注：这里需要把<code>$username</code>和<code>$token</code>分别换成实际的用户名和刚才记住的<code>personal access token</code>，把<code>$repo_name</code>换成任何想要的<code>repo name</code>。</p></blockquote><h3 id="bash-形式"><a href="#bash-形式" class="headerlink" title="bash 形式"></a>bash 形式</h3><p>我们可以把命令行写成bash脚本，下次只要执行里面的简单命令就可以执行以上整条命令。</p><ol><li><p>把<code>username</code>和<code>token</code>写入(apend或者修改)<code>~/.gitconfig</code>，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[github]</span><br><span class="line">    user = your user name </span><br><span class="line">    token = the token you get</span><br></pre></td></tr></table></figure></li><li><p>把如下 <code>bash code</code>写入（append）<code>~/.bash_profile</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">github-<span class="function"><span class="title">create</span></span>() &#123;</span><br><span class="line">    repo_name=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    dir_name=`basename $(<span class="built_in">pwd</span>)`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$repo_name</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Repo name (hit enter to use '<span class="variable">$dir_name</span>')?"</span></span><br><span class="line">        <span class="built_in">read</span> repo_name</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$repo_name</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        repo_name=<span class="variable">$dir_name</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    username=`git config github.user`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$username</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Could not find username, run 'git config --global github.user &lt;username&gt;'"</span></span><br><span class="line">        invalid_credentials=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    token=`git config github.token`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$token</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Could not find token, run 'git config --global github.token &lt;token&gt;'"</span></span><br><span class="line">        invalid_credentials=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$invalid_credentials</span>"</span> == <span class="string">"1"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Creating Github repository '<span class="variable">$repo_name</span>' ..."</span></span><br><span class="line">    curl -u <span class="string">"<span class="variable">$username</span>:<span class="variable">$token</span>"</span> https://api.github.com/user/repos -d <span class="string">'&#123;"name":"'</span><span class="variable">$repo_name</span><span class="string">'"&#125;'</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" done."</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Pushing local code to remote ..."</span></span><br><span class="line">    git remote add origin git@github.com:<span class="variable">$username</span>/<span class="variable">$repo_name</span>.git &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    git push -u origin master &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" done."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>也可以将脚本保存在<code>github-create.sh</code>文件中，让后在<code>~/.bash_profile</code>添加导入语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. &quot;$HOME/your path/github-create.sh&quot;</span><br></pre></td></tr></table></figure></li><li><p>也可以导入到<code>oh-my-zsh</code>配置文件<code>zshrc.zsh-template</code>中，每次创建myzsh窗口时，<code>github-create</code>方法会初始化在环境中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. &quot;$HOME/hsg/hexo/Util/tool/github-create.sh&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>重新打开或新启动一个终端窗口，或者也可以在当前<code>Terminal</code>下运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Source  ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>然后就可以用如下命令创建远程仓库了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github-create [repo name]</span><br></pre></td></tr></table></figure></li></ol><p>如果你不想用默认<code>repo name</code>（也就是当前目录名）创建repo可以重新输入另一个名字，否则直接按回车执行。</p><h3 id="bash形式–简化版"><a href="#bash形式–简化版" class="headerlink" title="bash形式–简化版"></a>bash形式–简化版</h3><ol><li><p>把如下<code>bash code</code>写入（append）<code>~/.bash_profile</code>文件。第十行按照形式一处理一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">simple-create() &#123;</span><br><span class="line">    if [ $1 ]</span><br><span class="line">    then</span><br><span class="line">        repo_name=$1</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Repo name?&quot;</span><br><span class="line">        read repo_name</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    curl -u &apos;$username:$token&apos; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos;</span><br><span class="line">    git remote add origin git@github.com:efatsi/$repo_name.git</span><br><span class="line">    git push -u origin master</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新打开或新启动一个终端窗口，或者也可以在当前<code>Terminal</code>下运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Source  ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simple-create [repo name]</span><br></pre></td></tr></table></figure></li></ol><h2 id="查询现有库"><a href="#查询现有库" class="headerlink" title="查询现有库"></a>查询现有库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u git账号 https://api.github.com/repos/账号/库名</span><br></pre></td></tr></table></figure><h2 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h2><p>找到仓库路径的字段<code>clone_url</code>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin clone_url</span><br><span class="line">//或者使用ssh,避免输入密码</span><br><span class="line">//git remote add origin ssh_url</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h2 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">githubDelRepo()&#123;</span><br><span class="line">    <span class="keyword">if</span> [[ $# != <span class="number">2</span> ]] ; <span class="keyword">then</span></span><br><span class="line">        echo <span class="string">"Needs username and repo-name as args 1 and 2 respectively."</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curl -X DELETE -u <span class="string">"$&#123;1&#125;"</span> <span class="symbol">https:</span>/<span class="regexp">/api.github.com/repos</span><span class="regexp">/"$&#123;1&#125;"/</span><span class="string">"$&#123;2&#125;"</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS系统下运行exe小程序</title>
      <link href="/2018/06/20/macOS/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%90%E8%A1%8Cexe%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/06/20/macOS/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%90%E8%A1%8Cexe%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>例如，当急需在Mac系统上，安装abletonLive，涉及到破解机exe小程序，使用文中提到的两种方法，就解了燃眉之急。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><a href="http://xiazai.crossoverchina.com/trial/Mac/crossover_mac_17.5.5.zip" target="_blank" rel="noopener">crossover</a></p><h3 id="Wrappe-k-小应用"><a href="#Wrappe-k-小应用" class="headerlink" title="Wrappe[k]小应用"></a>Wrappe[k]小应用</h3><p>这款软件适用于一些小型exe程序，其他，推荐方法一<br><a href="https://pan.baidu.com/s/1ujHKuXNr8G6m8PTPMO9ajQ" target="_blank" rel="noopener">下载</a> 密码: khqa<br><a href="http://www.sdifen.com/mac-exe.html" target="_blank" rel="noopener">参看</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在GarageBand中使用LaunchPad</title>
      <link href="/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%9C%A8GarageBand%E4%B8%AD%E4%BD%BF%E7%94%A8LaunchPad/"/>
      <url>/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%9C%A8GarageBand%E4%B8%AD%E4%BD%BF%E7%94%A8LaunchPad/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Garageband不支持控件表面，因此无法使用Launchpad/LaunchKey的全部功能。</p><p>在Garageband中，仅可以使用Launchpad来演奏虚拟乐器。<br>原因：<code>Faders</code>和<code>Knobs</code>将为输出MIDI CC消息(<a href="http://global.novationmusic.com/answerbase/what-midi-cc-messages-do-the-controls-on-the-launchkey-send" target="_blank" rel="noopener">详细介绍</a>)到支持手动操作的MIDI设备的插件。此外，打击垫还将发送固定的Note数据。<br>然而，Garageband本身没有传输、卷或Pan控件，不支持Launchpad的Volume or Pan Control。因此，只能在支持<code>HUI Protocol</code>的<a href="http://us.novationmusic.com/sites/default/files/novation/downloads/10606/launchkey-mk2-daw-setup-guide.pdf" target="_blank" rel="noopener">DAW</a>的DAW，或者选择<code>Ableton Live</code>，Launchpad才能发挥最大的作用。<br><a href="https://support.novationmusic.com/hc/en-gb/articles/207556325-Can-I-use-my-Launchkey-in-Garageband-" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaunchPadMini说明书</title>
      <link href="/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPadMini%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
      <url>/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPadMini%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://d2xhy469pqj8rc.cloudfront.net/sites/default/files/novation/downloads/9678/launchpad-demo-project-2014.zip" target="_blank" rel="noopener">工程demo</a><br><a href="https://global.novationmusic.com/launch/launchpad-mini/support-downloads" target="_blank" rel="noopener">官方资源</a></p><p>##<br><a href="https://global.novationmusic.com/answerbase/category/launchpad-video-tutorial" target="_blank" rel="noopener">Launchpad几种模式视频教程</a></p><h3 id="硬件设置"><a href="#硬件设置" class="headerlink" title="硬件设置"></a>硬件设置</h3><ol><li>贴纸：确保标签与相应的按钮对齐。</li><li>使用USB连接线将你的Launchpad Mini连接到你的Mac或PC上的USB端口。Ableton Live支持最多6台同时连接的设备。</li><li>配置设备在Ableton Live中的配置</li></ol><ul><li>打开Live偏好设置,选中<code>MIDI/Sync</code>选项卡，在<code>Input</code>中选择Launchpad Mini所连接的端口<br>以及窗口顶部的<code>Output</code>选择器</li><li>在<code>Control Surface</code>控制面板中选择自己的设备。</li><li>在<code>MIDI Ports</code>下，开启 <code>Track</code>和<code>Remote</code>选项.<h2 id="PRODUCT-OVERVIEW-ABLETON-LIVE"><a href="#PRODUCT-OVERVIEW-ABLETON-LIVE" class="headerlink" title="PRODUCT OVERVIEW: ABLETON LIVE"></a>PRODUCT OVERVIEW: ABLETON LIVE</h2><h3 id="Session-模式"><a href="#Session-模式" class="headerlink" title="Session 模式"></a>Session 模式</h3>当选择Launchpad作为活动控制面时，会话视图上会出现一个圆环，用于指示当前由pad矩阵控制的哪个部分。按下一个剪辑启动板，就会在相应的剪辑插槽中触发该剪辑。在没有武装的轨道上点击一个空的剪辑槽将停止在这个轨道上播放的剪辑。如果跟踪是武装到记录，按下按钮记录一个新的剪辑。<br>方向箭头和会话按钮通过在场景和跟踪中导航会话视图，增加了8×8网格的范围。你也可以使用Launchpad Mini的右手边的按钮来触发水平的剪辑(场景)。<h3 id="Session概述"><a href="#Session概述" class="headerlink" title="Session概述"></a>Session概述</h3>黄色:表示当前选定的剪辑块，它将被软件中的戒指所包围。<br>绿色:在那块剪辑中有一些剪辑在播放(虽然那可能不是被选中的剪辑块)。<br>红色:在这个范围内没有剪辑。<br>未激活色:在这个范围内没有音轨或场景。<h3 id="USER-模式"><a href="#USER-模式" class="headerlink" title="USER 模式"></a>USER 模式</h3>User1模式:说明在Lives中的MIDI音轨中可以使用<code>drum racks</code>鼓架(如果没有分配的话)<br>制造)，或在lives的MIDI可分配参数中自由分配Launchpad Mini的按钮。<br>User2模式:说明可以作为一个方便的地方来访问<code>Max for Live</code>预设配置(如果没有学习任务的话)，或者自由地分配给Live中的任何参数。<h2 id="Mixer混合器模式"><a href="#Mixer混合器模式" class="headerlink" title="Mixer混合器模式"></a>Mixer混合器模式</h2>底部的四行垫子提供了对每个轨道的直接访问控制，包括:停止、跟踪激活器、solo和跟踪臂。右下角的四个按钮为每个轨道提供额外的控制:<br>•<code>stop</code>：停止按钮，将停止当前播放的所有剪辑(可通过重新分配功能来避免)<br>•<code>trk on</code>：音轨激活器按钮，将打开所有轨道(非静音)<br>•<code>solo</code>：“独奏”按钮，将不再独奏所有曲目。<br>•<code>arm</code>: “音轨操作臂”按钮,will un-arm all armed tracks<h3 id="THE-VOLUME-PAN-SNDA-SNDB-PAGES"><a href="#THE-VOLUME-PAN-SNDA-SNDB-PAGES" class="headerlink" title="THE VOLUME / PAN / SNDA / SNDB PAGES"></a>THE VOLUME / PAN / SNDA / SNDB PAGES</h3>当Mixer模式激活时，按VOL/PAN/SNDA或SNDB按钮输入卷、PAN或发送页面，其中列的所有八个焊盘变成各自控制的连续轨迹“FADDER”。<br>VOLUME:音量<br>pan:<br>sndA:<br>sndB:<div class="pdf" target="https://d2xhy469pqj8rc.cloudfront.net/sites/default/files/novation/downloads/7376/launchpadminiabletonguide_0.pdf" height></div></li></ul><h3 id="launchPad-APP-for-iOS键盘功能映射"><a href="#launchPad-APP-for-iOS键盘功能映射" class="headerlink" title="launchPad APP for iOS键盘功能映射"></a>launchPad APP for iOS键盘功能映射</h3><h4 id="iPad兼容（Low-Power）vs全功率模式"><a href="#iPad兼容（Low-Power）vs全功率模式" class="headerlink" title="iPad兼容（Low Power）vs全功率模式"></a>iPad兼容（Low Power）vs全功率模式</h4><p>手机端节能模式设置</p><ol><li>在连接USB过程中，同时按住按钮<code>5</code>, <code>6</code>, <code>7</code>和<code>8</code>,开启设置节能</li><li>选择一种电源模式（左为高，右为低），参考pdf图文</li><li>完成设置后，按下绿色按钮退出<blockquote><p>在全功率模式下，Launchpad mini需要使用单独供电的USB集线器与iPad链接，否则无法正常工作。</p></blockquote><h4 id="键位功能说明"><a href="#键位功能说明" class="headerlink" title="键位功能说明"></a>键位功能说明</h4></li><li>F键位：Filters过滤器，8个垫子的每一列都变成一个滤光片:向上移动以除去低音，向下移动以除去高音。按<code>D</code>或<code>E</code>行的垫子重置Filter过滤器。</li><li>G键位：Volume音量，8个垫子的每一层都变成了一个音量调节器。按下<code>B</code>行垫子重置音量。</li><li>H键位：Trigger Sounds &amp; FX<div class="pdf" target="https://d2xhy469pqj8rc.cloudfront.net/sites/default/files/novation/downloads/6959/launchpad-mini-gsg-en_0.pdf" height></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AbletonLive10安装使用</title>
      <link href="/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/AbletonLive10%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/19/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/AbletonLive10%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="launchPad"><a href="#launchPad" class="headerlink" title="launchPad"></a>launchPad</h2><p><a href="https://global.novationmusic.com" target="_blank" rel="noopener">设备官网</a></p><p><a href="https://global.novationmusic.com/launch/launchpad-mini/support-downloads" target="_blank" rel="noopener">官方教程资源</a><br><a href="https://intro.novationmusic.com/join-the-dub-side" target="_blank" rel="noopener">官方工程试听资源支持下载</a></p><h2 id="ableton-live-软件"><a href="#ableton-live-软件" class="headerlink" title="ableton live 软件"></a>ableton live 软件</h2><p><a href="https://www.ableton.com/en/trial/" target="_blank" rel="noopener">官网下载</a><br><a href="http://abletive.com" target="_blank" rel="noopener">中国社区</a><br><a href="https://launchpadxm.com/class/ableton-live-10-0-1-suite-破解版下载.html" target="_blank" rel="noopener">ABLETON LIVE 10.0.1 SUITE 破解版下载 WINDOWS &amp; MAC</a><br><a href="http://p27uwfdhv.bkt.clouddn.com/static/soft/Ableton%2010%20KeyGen%20v1.3.0.zip" target="_blank" rel="noopener">ABLETON LIVE10.0.1破解机下载</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><h3 id="第二期：Chain的选择与设置-页数的映射"><a href="#第二期：Chain的选择与设置-页数的映射" class="headerlink" title="第二期：Chain的选择与设置/页数的映射"></a><a href="http://www.bilibili.com/video/av12189950" target="_blank" rel="noopener">第二期：Chain的选择与设置/页数的映射</a></h3><ol><li><p>音频轨道<br>拖拽音频文件或视频文件到<code>Simple</code>采样轨道中，视频格式会生成<code>asd</code>格式的新文件文件，加载到轨道中。</p></li><li><p>MIDI轨道可以为<code>Lights</code><br>1.1 灯光轨道<br>1.2 鼓点设置</p><h4 id="鼓点音色映射设置，来输出不同的音乐片段"><a href="#鼓点音色映射设置，来输出不同的音乐片段" class="headerlink" title="鼓点音色映射设置，来输出不同的音乐片段"></a>鼓点音色映射设置，来输出不同的音乐片段</h4></li><li>拖动IB控件到MIDI模块</li></ol><h4 id="鼓点灯光映射设置"><a href="#鼓点灯光映射设置" class="headerlink" title="鼓点灯光映射设置"></a>鼓点灯光映射设置</h4><ol><li>拖进MIDI Effects rack控件<br>1.1 点击黄色选项：展开Key:vel:chain:Hide页面<br>1.2 右击蓝色条，选择map selecter<br>1.3 选中右上角的<code>MIDI</code>切换到设置MIDI映射键模式。<br>1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置<br>1.5 新建八个chain，错位蓝色条，完成页数映射的设置<br>1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件</li></ol><h3 id="第三期：关于分轨和音频采样"><a href="#第三期：关于分轨和音频采样" class="headerlink" title="第三期：关于分轨和音频采样"></a><a href="http://www.bilibili.com/video/av12319673" target="_blank" rel="noopener">第三期：关于分轨和音频采样</a></h3><p><a href="https://www.reddit.com/r/SongStems/" target="_blank" rel="noopener">reddit.com</a><br><a href="https://www.beatport.com/stems" target="_blank" rel="noopener">beatport.com</a><br><a href="https://splice.com/explore/contests" target="_blank" rel="noopener">splice.com</a><br>选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。</p><h3 id="第四期：基础灯光效果制作"><a href="#第四期：基础灯光效果制作" class="headerlink" title="第四期：基础灯光效果制作"></a><a href="http://www.bilibili.com/video/av12431271" target="_blank" rel="noopener">第四期：基础灯光效果制作</a></h3><h4 id="Arpeggiator-（A效果器）"><a href="#Arpeggiator-（A效果器）" class="headerlink" title="Arpeggiator （A效果器）"></a>Arpeggiator （A效果器）</h4><p>设置纵横方向的属性变化<br>效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围</p><ol><li>rate速度：1/1一拍移动一下最慢，1/128最快。</li><li>Gate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光</li><li>style：纵向变化的方向：up/down/upDown/DownUp…</li><li>Hold激活不用长按，即可厂量</li><li><p>repeats：设置走马灯的循环次数</p></li><li><p>A效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。</p></li></ol><h4 id="Chord-（和弦）"><a href="#Chord-（和弦）" class="headerlink" title="Chord （和弦）"></a>Chord （和弦）</h4><ol><li>拖拽到Key列表中的一个垫子的灯光效果包上。</li><li>chord提供六个属性shift1，shift2….shift6，来设置和弦灯光错位，融合等效果<br>第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮<br>第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。<br>以此类推<br>一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮</li></ol><h4 id="MIDI-Effect-Rack"><a href="#MIDI-Effect-Rack" class="headerlink" title="MIDI Effect Rack"></a>MIDI Effect Rack</h4><p>在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。<br>设置灯光效果包</p><ol><li>选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果</li><li>选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置</li><li>新建Velocity（力度感应）</li><li>新建chord（和弦）</li><li>新建Arpeggiator（A效果器）</li></ol><h4 id="Note-Length"><a href="#Note-Length" class="headerlink" title="Note Length"></a>Note Length</h4><p>延迟灯光时间<br>Pitch<br>Random<br>Scale</p><h4 id="Velocity：力度感应"><a href="#Velocity：力度感应" class="headerlink" title="Velocity：力度感应"></a>Velocity：力度感应</h4><ol><li>拖到刚才的chain上，即在该键上添加力度感应属性设置。</li><li>设置灯光颜色：<code>Out Hi</code>的表盘参数，参考MIni支持的灯光色值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git如何永久删除文件(包括历史记录)</title>
      <link href="/2018/06/12/git/Git%E5%A6%82%E4%BD%95%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6(%E5%8C%85%E6%8B%AC%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95)/"/>
      <url>/2018/06/12/git/Git%E5%A6%82%E4%BD%95%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6(%E5%8C%85%E6%8B%AC%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有些时候不小心上传了一些敏感文件(例如密码), 或者不想上传的文件(没及时或忘了加到.gitignore里的),</p><p>而且上传的文件又特别大的时候, 这将导致别人clone你的代码或下载zip包的时候也必须更新或下载这些无用的文件,</p><p>因此, 我们需要一个方法, 永久的删除这些文件(包括该文件的历史记录).</p><p>首先, 可以参考 <a href="https://help.github.com/articles/remove-sensitive-data" target="_blank" rel="noopener">github帮助</a></p><h2 id="使用bfg工具"><a href="#使用bfg工具" class="headerlink" title="使用bfg工具"></a>使用bfg工具</h2><p><a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">bfg官网</a> </p><h3 id="创建bfg别名"><a href="#创建bfg别名" class="headerlink" title="创建bfg别名"></a>创建bfg别名</h3><ol><li><a href="https://search.maven.org/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST" target="_blank" rel="noopener">下载bfg</a> 到本地soft/bfg目录下。</li><li>创建别名<br>sudo vi ~/.bash_profile  添加如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot;</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --mirror git@github.com:OpenFibers/openfibers.github.com.git</span><br></pre></td></tr></table></figure></li><li><p>移除目标文件<br>然后就可以执行下面的任意一个或者多个操作。</p></li></ol><p>从历史纪录中删除所有文件名是 <code>id_rsa</code> 或 <code>id_dsa</code> 的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bfg --delete-files id_&#123;dsa,rsa&#125;  my-repo.git</span><br></pre></td></tr></table></figure></p><p>从历史纪录中删除所有大于1M的二进制文件 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bfg --strip-blobs-bigger-than 1M  my-repo.git</span><br></pre></td></tr></table></figure></p><p>从文件中删除所有列出的密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bfg --replace-text passwords.txt  my-repo.git</span><br></pre></td></tr></table></figure></p><p>删除目录及目录下文件:<br><code>demo</code>:删除的目录<br><code>--no-blob-protection</code>命令，可以解除保护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd </span><br><span class="line">$ bfg --delete-folders demo --delete-files demo --no-blob-protection</span><br><span class="line">//上述命令将demo索引状态重置为`add`的状态，需要执行reset即可</span><br><span class="line">$ git reset HEAD demo</span><br><span class="line">$ rm -fr demo</span><br></pre></td></tr></table></figure></p><h2 id="使用-filter-branch命令"><a href="#使用-filter-branch命令" class="headerlink" title="使用 filter-branch命令"></a>使用 filter-branch命令</h2><h2 id="步骤一-从资料库中清除文件"><a href="#步骤一-从资料库中清除文件" class="headerlink" title="步骤一: 从资料库中清除文件"></a>步骤一: 从资料库中清除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --force --index-filter <span class="string">'git rm --cached --ignore-unmatch path-to-your-remove-file'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p>其中, <code>path-to-your-remove-file</code> 是要删除的文件的相对路径(相对于git仓库的跟目录), 替换成你要删除的文件即可.</p><blockquote><p>这里的文件或文件夹，都不能以 ‘/‘ 开头，否则文件或文件夹会被认为是从 git 的安装目录开始。</p></blockquote><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p>在 <code>git rm --cached</code> 命令后面添加 <code>-r</code> 命令，表示递归的删除（子）文件夹和文件夹下的文件，类似于 <code>rm -rf</code> 命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --force --index-filter <span class="string">'git rm --cached -r --ignore-unmatch path-to-your-remove-folder'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure></p><h3 id="支持通配符"><a href="#支持通配符" class="headerlink" title="支持通配符"></a>支持通配符</h3><p>如果当要删除的文件很多, 文件或路径里有中文, 由于MinGW或CygWin对中文路径设置比较麻烦, 你可以使用通配符<em>号, 例如: `sound/music_</em>.mp3<code>, 这样就把</code>sound<code>目录下以</code>music_<code>开头的mp3文件都删除了.使用通配符</code>*`删除目录下的所有文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --force --index-filter <span class="string">'git rm --cached -r --ignore-unmatch path-to-your-remove-folder/*'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure></p><p>成功的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ref <span class="string">'refs/heads/master'</span> was rewritten</span><br><span class="line">Ref <span class="string">'refs/remotes/origin/master'</span> was rewritten</span><br><span class="line">WARNING: Ref <span class="string">'refs/remotes/origin/master'</span> is unchanged</span><br><span class="line">WARNING: Ref <span class="string">'refs/tags/v0.9.0'</span> is unchanged</span><br><span class="line">v0.9.0 -&gt; v0.9.0 (2694a7834dada67cf8768ef27e2d7c3d777f5472 -&gt; 2694a7834dada67cf8768ef27e2d7c3d777f5472)</span><br></pre></td></tr></table></figure></p><blockquote><p><code>Ref &#39;refs/heads/master&#39; was rewritten</code>:表示成功；<br><code>xxxxx unchanged</code>: 说明在当前分支里没有找到该文件.</p></blockquote><h2 id="步骤二-推送我们修改后的repo"><a href="#步骤二-推送我们修改后的repo" class="headerlink" title="步骤二: 推送我们修改后的repo"></a>步骤二: 推送我们修改后的repo</h2><h3 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a>分支同步</h3><p>通过步骤一，需要以强制覆盖的方式推送你的repo, 命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --force origin master</span><br></pre></td></tr></table></figure></p><p>这个过程其实是重新上传我们的repo, 比较耗时, 虽然跟删掉重新建一个repo有些类似, 但是好处是保留了原有的更新记录, 所以还是有些不同的. 如果你实在不在意这些更新记录, 也可以删掉重建, 两者也差不太多, 也许后者还更直观些.</p><h3 id="tag同步"><a href="#tag同步" class="headerlink" title="tag同步"></a>tag同步</h3><p>为了能从打了 tag 的版本中也删除你所指定的文件或文件夹，您可以使用这样的命令来强制推送您的 Git tags：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master --force --tags</span><br></pre></td></tr></table></figure></p><h2 id="步骤三-清理和回收空间"><a href="#步骤三-清理和回收空间" class="headerlink" title="步骤三: 清理和回收空间"></a>步骤三: 清理和回收空间</h2><p>虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间.</p><p>执行命令，再查看<code>.git</code>目录空间会明显变小:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf .git/refs/original/</span><br><span class="line"></span><br><span class="line">$ git reflog expire --expire=now --all</span><br><span class="line"></span><br><span class="line">$ git gc --prune=now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Counting objects: 2437, <span class="keyword">done</span>.</span><br><span class="line"><span class="comment"># Delta compression using up to 4 threads.</span></span><br><span class="line"><span class="comment"># Compressing objects: 100% (1378/1378), done.</span></span><br><span class="line"><span class="comment"># Writing objects: 100% (2437/2437), done.</span></span><br><span class="line"><span class="comment"># Total 2437 (delta 1461), reused 1802 (delta 1048)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git gc --aggressive --prune=now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Counting objects: 2437, <span class="keyword">done</span>.</span><br><span class="line"><span class="comment"># Delta compression using up to 4 threads.</span></span><br><span class="line"><span class="comment"># Compressing objects: 100% (2426/2426), done.</span></span><br><span class="line"><span class="comment"># Writing objects: 100% (2437/2437), done.</span></span><br><span class="line"><span class="comment"># Total 2437 (delta 1483), reused 0 (delta 0)</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5个图表解决工作中的12大难题</title>
      <link href="/2018/06/12/%E9%98%85%E8%AF%BB/5%E4%B8%AA%E5%9B%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%8412%E5%A4%A7%E9%9A%BE%E9%A2%98/"/>
      <url>/2018/06/12/%E9%98%85%E8%AF%BB/5%E4%B8%AA%E5%9B%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%8412%E5%A4%A7%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="https://www.plantuml.com/plantuml/svg/TP7VIW915CRlvoa6OkaYs253h3M291zasnrtb_OVEjQjHKYabK4M5LIRb7jZ4MLWPhrCisDlqOmJsOLU37pd-yxvSGv37E9YI2y_Xb6SlFJPIPmqpsdd7hYuGA2DTHCNmTVWamTfrZvWJtrwLMCNkt82pAimEQmdHn7RVwNLhd3RhUIv2L8yQ5M63p5zxB7EwJXOc381vwOC93V7T73BQyJVzzqxzz0mgjEzCw7OJaz4INURnJMk0FRDtwqriJ2tii0F28RY8303_t1SIw3K4YcrX8hc_rWeCA0KkWu1siGRiZA5kgKxFk-PT4zsX9AKqLv5nx89c5rsF4kp2GarXC9KfhnLCErDTNs3g8ORb4tJLut0GoMY4yT0ZgTRk8JIIZwZh6QKnJKbdrQMSaekhuQ-jJBU5XZO9xW82m6l-4Vs6gnHfTTlBAg89cd_0000"></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>执法巡查开发状态总结</title>
      <link href="/2018/06/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%89%A7%E6%B3%95%E5%B7%A1%E6%9F%A5%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%89%A7%E6%B3%95%E5%B7%A1%E6%9F%A5%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="UML状态图"><a href="#UML状态图" class="headerlink" title="UML状态图"></a>UML状态图</h2><p>使用状态图，查漏补觉，梳理相关业务流程。<br>建议：优化流程，使用流程图（活动图）/时序图来完善流程<br><img src="https://www.plantuml.com/plantuml/svg/TLFBRjfG4DtVh_2wKcZwI1UMsdqMMLLTLLsWs56GeX21fQf2GI02CU5XIaj9moEuWO1QrL25Gi4yViPpVRtY5thjwo13WhsmP-RCwyoC592EH0w6BMDQ9PeASj6AwMJssRmOu5WSAZE4ZiG3YJiK_O8OGizyN3IAqx-meXZZZA4FuA9ZVjMXUMOMKj4eUkwZiLHytO9f2PAjnIIBqsryLyArXFMzOFtCacwSp2j4TVNeXOypVrUiM1fAAUFV5UabIBVqRXUzN0OQzM5y2tAPg1squ-EiPCwSQZ2w0wLdwcUq12GU2svvuNq_xURLzZRtCI18X-ZzamzRMs-y5Q6mv9T4pbjL17a1IxofVy7rAXyGDfZ_w53Fy2oGsSvHsQgae20l9hBqwKHylREOfD4fycQYpapaGUaQUilbmCLGAwttlkPI2hG1pKEwFv1Nu9d02C6b7ivfD2F8AKlzQsTSmPBvETQRkAPIcYZAEhUvUsgg6cXN3y1MkGFZijkTCtuQSWL2w-BsWe9un1kJXXKhXgLWIDmLN4uVzO-uHiSjWfYt2oNTMvn8hkgOkwEwDtWZCiCfVT6ZwMpcsC8uUhi1ngUBhlRibVOApapOFcTDlMysucXDtjJr6epdw76GzWsk5vOwEqKjHl93KBvjTACtGxIvLTPmlWNA3KDxIsHJtlEVlBL3C0eUHA67H8TgJ7FCa_xOP-9Sfp7AG25lt-Bbp6oElUH3CGlDDZJxLb76ZI5C5BJ6dxkLzDaNZoKnn1q4W_I3xFEeNTktnnJ_0G00"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uml活动图常用语法</title>
      <link href="/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">:ClickServlet.handleRequest();</span><br><span class="line">:new page;</span><br><span class="line">if (Page.onSecurityCheck) then (true)</span><br><span class="line">:Page.onInit();</span><br><span class="line">if (isForward?) then (no)</span><br><span class="line">:Process controls;</span><br><span class="line">if (continue processing?) then (no)</span><br><span class="line">stop</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">if (isPost?) then (yes)</span><br><span class="line">:Page.onPost();</span><br><span class="line">else (no)</span><br><span class="line">:Page.onGet();</span><br><span class="line">endif</span><br><span class="line">:Page.onRender();</span><br><span class="line">endif</span><br><span class="line">else (false)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">if (do redirect?) then (yes)</span><br><span class="line">:redirect process;</span><br><span class="line">else</span><br><span class="line">if (do forward?) then (yes)</span><br><span class="line">:Forward request;</span><br><span class="line">else (no)</span><br><span class="line">:Render page template;</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">stop</span><br></pre></td></tr></table></figure><p><img src="https://www.plantuml.com/plantuml/svg/NL6xZiCW4Epv2agxoGSunHMHShekIhu0mJX6uS2tkqwKlpzZJ5uDiBipEwE1nP2eRXUylPn0rm3P32QwW2F-9h0qxLPr4JSzcZEsolUwESolJOeds8cyt7S3xANLCY3gHcX2gxeLyXFziY2pFEyJtGovhugDAICfMJ1hcw9G2bp0kV9nWXxBsCVp6uqbZGhH-Lwjom-9vG6vWvycyYIRG61KqJBvHXaiUshpE9UWPx_GUZDVxQkaIvhWFC5-wjPsDL-aAwd_IA5mrcpcbKlgRswBe-K3jE1t34RmSBUSEOv_"></p><p>title <code>uml模型图题目支持MD</code><br>center header<br><code>在此处添加标头</code><br>endheader<br>start ‘开始’<br>‘&gt;&gt;&gt;&gt;&gt; 活动关系模块 支持嵌套，条件/循环/并行&gt;&gt;&gt;&gt;&gt;&gt;’<br>if(<code>环境条件</code>) then (<code>分流线名</code>)<br>:<code>分支1活动</code>;<br>-[<code>颜色</code>]-&gt; <code>线备注</code>;<br>note left<br><code>活动备注</code><br>end note<br>elseif(<code>分流线名</code>)<br>:<code>分支2活动</code>;<br>else (<code>分流线名</code>)<br>:<code>分支3活动</code>;<br>endif</p><p>repeat<br>:<code>循环活动</code>;<br>repeat while (<code>环境条件</code>)</p><p>while (<code>环境条件</code>)<br>:<code>循环活动</code>;<br>endwhile</p><p>fork<br>:<code>并行活动</code>;<br>fork again<br>:<code>并行活动</code>;<br>end fork</p><p>‘&amp;&amp;&amp;&amp;&amp; 活动图组合模块 &amp;&amp;&amp;&amp;&amp;&amp;’<br>partition <code>活动组名</code>{<br>:<code>单元活动名称</code>;<br>}</p><p>|<code>#颜色</code> | <code>泳道名称</code>|<br>:<code>当前泳道活动</code>;</p><p>stop ‘结束／end关键字’<br>center footer<br><code>在此处添加脚注</code><br>endfooter</p>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uml用例图常用语法</title>
      <link href="/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:Main Admin: as Admin</span><br><span class="line">(Use the application) as (Use)</span><br><span class="line"></span><br><span class="line">User -&gt; (Start)</span><br><span class="line">User --&gt; (Use)</span><br><span class="line"></span><br><span class="line">Admin ---&gt; (Use)</span><br><span class="line"></span><br><span class="line">note right of Admin : This is an example.</span><br><span class="line"></span><br><span class="line">note right of (Use)</span><br><span class="line">A note can also be on several lines</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">note &quot;This note is connected\nto several objects.&quot; as N2</span><br><span class="line">(Start) .. N2</span><br><span class="line">N2 .. (Use)</span><br></pre></td></tr></table></figure><p>效果图<br><img src="https://www.plantuml.com/plantuml/svg/NKyn3eCm3DppYXCJ36LWPAZ40yhITkjYm2sfWeEIgEhpcmJKIfMYv7ntFiVjYRIWcnOjBSXlI9LNpmWpWzRLw962jb8bEGcLKl5sE1nHdWEvKErr8ZOzfqJYnuWD3ASVSu2zRrFGuZ9hZtX8m6zQLiFrltNhxv3PCHh9U8k1OGMUN-p8m6XXhrYcxDeJYXoUONn7Ay9ZuEacmNuRxV2CfA-Bj5lVg7qVr7Mg-YQ1_84F"></p><p>title <code>uml模型图题目支持MD</code><br>center header<br><code>在此处添加标头</code><br>endheader</p><p>‘<strong>***</strong>  声明用例模块 usecase <strong>***</strong>‘<br>(<code>用例名称</code>) as (<code>别名</code>) &lt;&lt;<code>构造类型</code>&gt;&gt;</p><h2 id="usecase-用例名称-as-“-描述一"><a href="#usecase-用例名称-as-“-描述一" class="headerlink" title="usecase 用例名称 as “ 描述一"></a>usecase <code>用例名称</code> as “ <code>描述一</code></h2><h1 id="描述2"><a href="#描述2" class="headerlink" title="描述2"></a><code>描述2</code></h1><p><code>描述3</code><br>.. <code>描述标题</code> ..<br><code>描述4</code><br>“<br>‘<strong>***</strong>  声明角色模块 actor <strong>***</strong>‘<br>:<code>角色名称</code>: as <code>别名</code><br>actor <code>角色名称</code></p><p>‘—- 声明备注:用例线备注可以当做用例来参与到关系连接中—‘<br>note “<code>备注内容</code>“ as <code>备注对象</code></p><p>‘#####  备注模块 位置：left/right/top/bottom  #####’<br>note <code>位置</code>  of <code>用例/角色</code>: <code>描述信息</code></p><p>‘&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  关系模块  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;’<br>left to right dirction  ‘指定布局方向’<br><code>角色</code> –&gt; <code>用例</code>:<code>关系线描述</code></p><p>‘—- 用例关系中的备注对象 —-‘<br><code>角色</code> –&gt;<code>备注对象</code><br><code>备注对象</code> –&gt;<code>用例</code></p><p>center footer<br><code>在此处添加脚注</code><br>endfooter</p>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uml类图常用语法</title>
      <link href="/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E7%B1%BB%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/06/05/%E5%AF%BC%E5%9B%BE/uml%E7%B1%BB%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class BaseClass</span><br><span class="line">namespace net.dummy #DDDDDD &#123;</span><br><span class="line">.BaseClass &lt;|-- Person</span><br><span class="line">Meeting o-- Person</span><br><span class="line">.BaseClass &lt;|- Meeting</span><br><span class="line">&#125;</span><br><span class="line">namespace net.foo &#123;</span><br><span class="line">net.dummy.Person &lt;|- Person</span><br><span class="line">.BaseClass &lt;|-- Person</span><br><span class="line">net.dummy.Meeting o-- Person</span><br><span class="line">&#125;</span><br><span class="line">BaseClass &lt;|-- net.unused.Person</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="https://www.plantuml.com/plantuml/svg/Iyv9B2vMS4eiJdK6iRZo4dDJYmiIarCLyb9Bz59AStCh5PHTm42XcaiFhb31faPNLo4WjQWuFu_BDpMr93ClNI4V8OIgKW6gWgiMpOAq_7oWiN2hz22wmLgm6WGNHcZ1Odaj5vecaEhIlDBYr1Ie3G00"></p><p>title <code>uml模型图题目支持MD</code><br>center header<br><code>在此处添加标头</code><br>endheader</p><p>‘<strong>***</strong> 类声明模块 <strong>***</strong>‘<br>‘类型:class,abstract,interface,annotation,enum’<br>‘访问域:(-)私有,(#)保护,(~)包私有,(+)公有’</p><p>class <code>类名</code>&lt;<code>扩展对象</code>&gt; as <code>类别名</code>{<br>– <code>属性组名</code> – ‘分隔符–,..,==,<strong>‘<br><code>访问域修饰符</code> <code>static/abstract</code> <code>属性名称</code>:<code>类型</code> = <code>值1</code></strong> <code>函数组名</code> __<br><code>访问域修饰符</code> func <code>函数名称</code>(<code>参数1</code>:<code>类型</code>,<code>参数2</code>:<code>类型</code>)<br>}<br>‘显示/隐藏类,类方法属性等 关键字支持class,interface,enum’<br>hide <code>类名/方法名</code></p><p>‘—- 声明类关系线备注,可以当做用例来参与到关系连接中 —‘<br>note “<code>备注内容</code>“ as <code>备注对象</code></p><p>‘多行备注对象’<br>note as <code>备注对象</code><br>“<code>备注内容</code>“<br>end note</p><p>‘###### 类备注模块 类声明末尾使用:note 位置: 备注#########’<br>note <code>left/right/top/bottom</code> of <code>object</code> #<code>颜色</code><br><code>支持markdown语法加粗／斜体／删除线／下划线／波浪下划线 和HTML</code><br>end note</p><p>‘&amp;&amp;&amp;&amp;&amp;&amp; 类组合模块 类模块 &amp;&amp;&amp;&amp;&amp;&amp;&amp;’<br>‘六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database’<br>scale  <code>750</code> <code>width/height</code><br>package <code>module名</code> &lt;&lt;<code>模块样式</code>&gt;&gt; <code>#背景色</code>{<br>class <code>类名</code>&lt;<code>扩展对象</code>&gt; as <code>类别名</code>{<br>– <code>属性组名</code> – ‘分隔符–,..,==,<strong>‘<br><code>访问域修饰符</code> <code>static/abstract</code> <code>属性名称</code>:<code>类型</code> = <code>值1</code></strong> <code>函数组名</code> __<br><code>访问域修饰符</code> func <code>函数名称</code>(<code>参数1</code>:<code>类型</code>,<code>参数2</code>:<code>类型</code>)<br>}<br>}</p><p>‘@@@@@@@ 命名空间模块 关系模块  @@@@@@@@’<br>namespace <code>com.cn</code> #<code>空间背景色</code>{</p><p>‘关系节点符:(|&gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(–)实线 ，(..)虚线’<br><code>类名/包名</code>“<code>基数</code>“ <code>节点符</code> <code>left/right..`</code>[#线色]<code>-</code>节点符<code>&quot;</code>基数<code>&quot;</code>类名/包名<code>:</code>消息<code>&gt;note</code>left/right/top/bottom<code>on link #</code>颜色<code></code>连接注释体`<br>end note}</p><p>‘&gt;&gt;&gt;&gt;&gt;&gt; 类关系图及连接备注模块 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;’<br>‘关系节点符:(|&gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(–)实线 ，(..)虚线’<br><code>类名/包名</code>“<code>基数</code>“ <code>节点符</code> <code>left/right..`</code>[#线色]<code>-</code>节点符<code>&quot;</code>基数<code>&quot;</code>类名/包名<code>:</code>消息<code>&gt;note</code>left/right/top/bottom<code>on link #</code>颜色<code></code>连接注释体`<br>end note</p><p>center footer<br><code>在此处添加脚注</code><br>endfooter</p>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Mac安装Fiddler</title>
      <link href="/2018/06/01/macOS/%E5%9C%A8Mac%E5%AE%89%E8%A3%85Fiddler/"/>
      <url>/2018/06/01/macOS/%E5%9C%A8Mac%E5%AE%89%E8%A3%85Fiddler/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="安装Mono"><a href="#安装Mono" class="headerlink" title="安装Mono"></a>安装Mono</h3><p>Mac下需要使用.Net编译后的程序，首先需要用到跨平台的方案<code>Mono</code>(现阶段微软已推出跨平台的方案.Net Core，不过暂时只支持控制台程序)。<br><a href="http://www.mono-project.com/download/stable/#download-mac" target="_blank" rel="noopener">下载地址</a></p><h3 id="配置Mono环境"><a href="#配置Mono环境" class="headerlink" title="配置Mono环境"></a>配置Mono环境</h3><ol><li>下载证书<br>从Mozilla LXR上下载所有受信任的root证书，存于Mono的证书库里。root证书能用于请求https地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd /Library/Frameworks/Mono.framework/Versions/&lt;mono version&gt;/bin/</span><br><span class="line">$./mozroots --import --sync</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>./mozroots命令失效，./cert-sync新命令，暂时不知道怎么使用</p><ol start="2"><li>配置Mono环境变量</li></ol></blockquote><p>在<code>.bash_profile</code>中加入如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MONO_HOME=/Library/Frameworks/Mono.framework/Versions/5.0.1</span><br><span class="line">export PATH=$PATH:$MONO_HOME/bin</span><br></pre></td></tr></table></figure></p><h2 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h2><p><a href="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/InstallFiddler" target="_blank" rel="noopener">官方文档</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">Fiddler-mac.zip</a>压缩包，解压到非中文字符的路径下。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>打开Terminal，进入到刚才解压的Fiddler路径，执行命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mono Fiddler.exe</span><br></pre></td></tr></table></figure></p><p><a href="http://www.cocoachina.com/apple/20170704/19729.html" target="_blank" rel="noopener">参看</a></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博文置顶方法</title>
      <link href="/2018/05/31/hexo/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/31/hexo/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>修改 <code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line"><span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">                <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">    <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">        perPage: config.index_generator.per_page,</span><br><span class="line">        layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">        format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            __index: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在文章中添加 <code>top</code> 值，数值越大文章越靠前:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 解决Charles乱码问题</span><br><span class="line">date: 2017-05-22 22:45:48</span><br><span class="line">tags: 技巧</span><br><span class="line">categories: 技巧</span><br><span class="line">copyright: true</span><br><span class="line">top: 100</span><br></pre></td></tr></table></figure></p><p>转：<a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>+0800格式转NSDate</title>
      <link href="/2018/05/31/iOS/+0800%E6%A0%BC%E5%BC%8F%E8%BD%ACNSDate/"/>
      <url>/2018/05/31/iOS/+0800%E6%A0%BC%E5%BC%8F%E8%BD%ACNSDate/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *timstr = [resData objectForKey:<span class="string">@"Data"</span>];</span><br><span class="line">timstr = [timstr stringByReplacingOccurrencesOfString:<span class="string">@"/Date("</span> withString:<span class="string">@""</span>];</span><br><span class="line">timstr = [timstr stringByReplacingOccurrencesOfString:<span class="string">@"+0800)/"</span> withString:<span class="string">@""</span>];</span><br><span class="line">model.time = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timstr.longLongValue/<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高德地图API使用</title>
      <link href="/2018/05/30/iOS/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/30/iOS/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AMapFoundationKit/AMapFoundationKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AMapLocationKit/AMapLocationKit.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *strKey = <span class="string">@"2d8a96d668576584acebf2bab0ba0c08"</span>;<span class="comment">//默认值</span></span><br><span class="line"><span class="comment">//配置里面取值</span></span><br><span class="line"><span class="built_in">NSString</span> *strBundleKey = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"IOSPostionkey"</span>];</span><br><span class="line"><span class="keyword">if</span> (strBundleKey) &#123;</span><br><span class="line">    strKey = strBundleKey;</span><br><span class="line">&#125;</span><br><span class="line">[AMapServices sharedServices].apiKey = strKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带逆地理信息的一次定位（返回坐标和地址信息）</span></span><br><span class="line"><span class="keyword">self</span>.GaodelocationManager = [[AMapLocationManager alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.GaodelocationManager setDesiredAccuracy:kCLLocationAccuracyHundredMeters];</span><br><span class="line"><span class="comment">//   定位超时时间，最低2s，此处设置为2s</span></span><br><span class="line"><span class="keyword">self</span>.GaodelocationManager.locationTimeout =<span class="number">10</span>;</span><br><span class="line"><span class="comment">//   逆地理请求超时时间，最低2s，此处设置为2s</span></span><br><span class="line"><span class="keyword">self</span>.GaodelocationManager.reGeocodeTimeout = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//设置不允许系统暂停定位</span></span><br><span class="line">[<span class="keyword">self</span>.GaodelocationManager setPausesLocationUpdatesAutomatically:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">//    //设置允许在后台定位</span></span><br><span class="line"><span class="comment">//    [locationManager setAllowsBackgroundLocationUpdates:YES];</span></span><br><span class="line"><span class="comment">//设置允许连续定位逆地理</span></span><br><span class="line">[<span class="keyword">self</span>.GaodelocationManager setLocatingWithReGeocode:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//    [locationManager setDelegate:self];</span></span><br><span class="line"><span class="comment">// [self.locationManager startUpdatingLocation];</span></span><br><span class="line"><span class="comment">//    // 带逆地理（返回坐标和地址信息）。将下面代码中的 YES 改成 NO ，则不会返回地址信息。</span></span><br><span class="line">[<span class="keyword">self</span>.GaodelocationManager requestLocationWithReGeocode:<span class="literal">YES</span> completionBlock:^(<span class="built_in">CLLocation</span> *gaodeLocation, AMapLocationReGeocode *regeocode, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gaodeLocation==<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"高德没有返回地理位置,使用苹果官方定位经纬度"</span>);</span><br><span class="line">        [<span class="keyword">self</span> GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"locError:&#123;%ld - %@&#125;;"</span>, (<span class="keyword">long</span>)error.code, error.localizedDescription);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error.code == AMapLocationErrorLocateFailed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AMapLocationErrorLocateFailed高德没有返回地理位置,使用苹果官方定位经纬度"</span>);</span><br><span class="line">            [<span class="keyword">self</span> GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"使用高德location:%@"</span>, gaodeLocation);</span><br><span class="line">    <span class="built_in">NSString</span> * gaodeWeidu =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.9f"</span>,gaodeLocation.coordinate.latitude];</span><br><span class="line">    <span class="built_in">NSString</span> * gaodeJingdu =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.9f"</span>,gaodeLocation.coordinate.longitude];</span><br><span class="line">    <span class="keyword">if</span> (regeocode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reGeocode:%@"</span>, regeocode);</span><br><span class="line">        <span class="keyword">self</span>.theRealAdress = regeocode.formattedAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> GetGISInfoByByLocationWithjingdu:gaodeJingdu AndWeidu:gaodeWeidu];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用nvm或n管理node和npm版本</title>
      <link href="/2018/05/29/shell/%E4%BD%BF%E7%94%A8nvm%E6%88%96n%E7%AE%A1%E7%90%86node%E5%92%8Cnpm%E7%89%88%E6%9C%AC/"/>
      <url>/2018/05/29/shell/%E4%BD%BF%E7%94%A8nvm%E6%88%96n%E7%AE%A1%E7%90%86node%E5%92%8Cnpm%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fatal error in , line 0</span><br><span class="line"># Check failed: !value_obj-&gt;IsJSReceiver() || value_obj-&gt;IsTemplateInfo().</span><br><span class="line">#FailureMessage Object: 0x7ffeefbf25c0[1]    22749 illegal hardware instruction  he</span><br></pre></td></tr></table></figure></p><p>参考<a href="https://stackoverflow.com/questions/45623774/fatal-error-in-deps-v8-src-api-cc-line-1197-when-gulp-watch" target="_blank" rel="noopener">Fatal error in ../deps/v8/src/api.cc, line 1197 when gulp watch</a>,需要降级node版本。</p><h2 id="nvm工具"><a href="#nvm工具" class="headerlink" title="nvm工具"></a>nvm工具</h2><p>nvm是node版本管理工具，参考<a href="https://github.com/creationix/nvm#installation" target="_blank" rel="noopener">官网nvm安装指南</a></p><ol><li><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install nvm</span><br></pre></td></tr></table></figure></li><li><p>安装node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install versionnum  //安装</span><br><span class="line">$ nvm use versionnum      //使用指定版本</span><br><span class="line">$ nvm ls                //查看本地node</span><br><span class="line">-&gt;  v6.14.4</span><br><span class="line">    v8.12.0</span><br><span class="line">    system</span><br><span class="line">    default -&gt; 8 (-&gt; v8.12.0)</span><br></pre></td></tr></table></figure></li><li><p>使用npm<br><code>nvm</code>安装<code>node</code>之后，会安装对应版本<code>npm</code>工具，如：node 8 对应 npm v5，node 7 对应 npm v4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm -v //查看当前node对应的npm版本号</span><br><span class="line">npm version //查看当前目录使用的node详情，即node_modules安装时使用node版本号</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：在hexo执行，npm install 之后，hexo g 失败时，需要降级npm版本，这是无论怎么使用nvm use 来设置当前node，都无效，必须删除node_modules目录，再使用nvm use切换低版本，重新安装package.json插件才行。</p></blockquote><h2 id="工具包升级node"><a href="#工具包升级node" class="headerlink" title="工具包升级node"></a>工具包升级node</h2><p><a href="https://github.com/everblogjs/everblog/issues/10#issuecomment-431242848" target="_blank" rel="noopener">issue-431242848</a><br>node有一个专门管理node.js的版本工具模块n<br>首先安装n模块：<code>npm install -g n</code><br>升级node.js到最新稳定版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n stable</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GB乐理知识体系</title>
      <link href="/2018/05/29/%E4%BD%9C%E6%96%87%E4%BD%9C%E6%9B%B2/GB%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2018/05/29/%E4%BD%9C%E6%96%87%E4%BD%9C%E6%9B%B2/GB%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="使用puml来梳理乐理知识点"><a href="#使用puml来梳理乐理知识点" class="headerlink" title="使用puml来梳理乐理知识点"></a>使用puml来梳理乐理知识点</h2><p>相关概念<br><img src="https://www.plantuml.com/plantuml/svg/RLBRJi9047tVhzWVQ7Wdn7yXKAC9WGHuKn94BWeKQWA90KtZ3KZmmgL6MxdyJBVRFlaBpZ354lHfPiwPEMSok_dZV4hbZgLBlIeCMzuLfV7alLLboNBlvm2oX9hEgrb-fCQJQfRvnPwthZdB6z5VKOCxA8dr-_UYwNPD57aqlVAL_z1oUoPJqybWBf6AvtBSD-OdZ7EtEFJCKHHBY008xSoncyAQYzkQM3K00KheMWI2_2fZHsK4UKHeTGZ4o-T1b0BoaxPNBqNSXYRQ7wmG-e513C81-d9_VEqiMvY9XIqMqmtMNKlZ9LJQ35tEG2CK0IQsjoC91di5avpMsrROVb7TfVlzFQ0o3e5VmpqdCd8-p_tEArCKx1vE56M3Oc4FjobSZ6GxKqmBZ9Hvx5HH_joORaCStZIeCrJYGdJy_wUtt-8mau70TZyGlZh1Fm00"></p><p><img src="https://www.plantuml.com/plantuml/svg/TLBBJi905DtFLtIf2HjG9A4hnSTt42bg993KVW0eBu4A9A0HD0rgi55H23LAAV0plTEouXUSwGY2ukxEEVUSU-xCI4TIHE3CNiagfV5xmbBpK1zEZ2pM-f1JdVeSxGjHIH2vGo4O4aGqZjViKSOSt10MttMfi7aAe_U9KS1LZHpXGREJvV7z1QvfI8Y6ldKdKb2Ka7-iT6rDvL4u9XuZFnWw61sU57B2r0lGwy9j1eRvAK-wBVsHHz6O970H8ImXjyVyV6BmnAWXAigcpLxU_8nRjQJRWryQ-B97mxmLcIdfD0SovVj9ceUZPiZl8pxMzM1SUVLIntwPL6mi5pm87aMTuL2IIRZ0zixktkRM8WkL3cFTdhLrxuRlZvQCerht2hIBqBfY0LPT0OyhiEOAhFDE5cVD1M5rP2ajdZcyD6SNbLBdWMatMtyP0_NwVqpg-Jz6Ja2gDKVE4ZffrFbdmTNsBx7UTB2PXgQhMFh8RdUcEZjtYlFoeeu0KFnOnEpssL9CKURzVwhf5mt7oDEAYFrdK7Ih4QTT3Fu2"></p><p><img src="https://www.plantuml.com/plantuml/svg/VPFBJi9058RtynHTDn8lb0t4XQA-1v6A90GCzW6g0WeMHOCneSGB4crCH8mrZXNbPMPwMV4Adg6bfKPPTURCEV__pT-Cb9Lo8aS-6bQZOhxjMTenLRz7WoDJ_wGrRRokeaqnBub5RbjCfSKYSkIMFJmaNsquDJklRF1-dmxVHWF5lD1XIxkwNJfpxaxCbex4VDgRYplNhw2VGBixkQmqtfeN_GJA5oIHoubR4d8R27uYk4lm8sp9nx5pgLigfkyzHCiQbEYvGkirrjegmRobzX3FkrhBJhC7d_abdcU-75DstRXK9fNDepWrxWFFOZQpBI7VYxOrOZGjOsZtNmYksUyQT2DREQ2gJYjbiohJ-WqS4tp2c7nttuajWhknA1jr_xQqeO1So3afH99275d6Cy4o77g9aA_w0gYxjK0zxlSbmdSYXX8KmQX_Ega4oQuBaGrXpjVd-KKM4dCPj_wNLlSX9ELZhmaJLco0rdJSGGXXI5pz3UbL0iWLo2Fc2VDyTDPl1B3fSHziFGIsz3VOBorLdIQ3b2ULW2p9uXiDMXEss2ospbL8m6NR42Ah8RReFsnJI-_PRHMWfOZSDqgl3UjMPbrk-GS0"><br><img src="https://www.plantuml.com/plantuml/svg/lLNTKjf05BxFKt2T6-_jfHTz3gP6POR13iq3f0eI_gcYA6AfhGYZLL6Y1fBemtJFRdBbA_HiDec9uFIkCmopUyxkTxxzphSRDQDcbHIPjbXhXzv_PQCg73-zs3erBAYC_75P-gJaL2MVsb3IgqfUyhIk-rmYJW-pzEU4RppVWkVx5xj6zmsSmfdX5hvvlngqQqXARZNOj-oEjy5kVf1ocwgIoYfhgaGh5RSwWEaTCUlGgdcNXyHfi6x1wq_OR8Y0S6mmQv-O6Z4ls6W2rrtC4lCAdhUZDHAjbN65oF4edg4uOHEBMGLcbTpxHteouEJq5Z5d_duEHtjbsfiHPmzN_j6sED4KPoPz-PpDg89jln-mpMVMDrJfjN2t4B64Llt5xgx0sH1tO9cFOiIkoWdKvMXpN01sRCAiBOGHYDWARziXrY1Q3xO6mohL3rojoAmzUjBdmA8BWYIjbV3qqBwLvTNDh2mdD18yVvzpfQ3uG9mZCOVU28LZnM5m35yoBhc-0_ebROpOTGUUEb2QBLIdTC4A3p1k8eFuWQ0Lo4AcLQzZO7K1BA56iWp54TGh_5_y_B4inrHAXv117M9QlcJ-D9LUJsToF5Xv9twrA5Y5s-_pyOL1NFmUI5YHSnNaad3-CR7tI_EY16Bvle3TMboxg3reIhTaSAc9i_FQ--OXr0vuLsviJ6F4EtmGfMXxYbdULK_xWTx6taO-eeM-EonJdTSHLol10Nk11WlDOkt1-4cAamhpsNIKJlO_F7GSD75J_cs3EISaRB2o09FUdUAT9PP5d7sebvQyepeq7pbqUFMWFY5MaTfj63JPaUErhmM9EVV-P_TWyzvOvnqJYVw-VI7zhYBmcwSFz75yAfJsRtaeFctiWjwX1rFSBru_zsOGVsomME9olz8AdlorJGpd9V5zWFwCdMfyaGZ_1G00"></p><h2 id="五度圈"><a href="#五度圈" class="headerlink" title="五度圈"></a>五度圈</h2><p><img src="https://www.plantuml.com/plantuml/svg/hLNVJzDG57w_VyLzrWu3BZ7fWycwjdlH5taqFb3NoHAocJ7ZQmDZJA0m5uooZU0KDiEFWO9OomR_2_QstHF_WkVsjck11y6GPTlfFT_tdNE-UtTNp1QdL6oPgyHiasRbebSX2nlkRD-Btw4fDLF4a-f4MYsWWLPtp-QjVfCqJkqlXqwrRBTdoDdFYzwI_U487idcaLjwF_YwRDUFqEYOPMmFDWulUdKl9BKbqci3rdjo3sPjhOD6Hx2xNoQL7SlGINK9LidABy2GlK-a-SsfbuW-xtOFOF71O4rd4HeRmKwhIxfr1hUCHG1QnYoLdTzsIiTGrJ4xiEYSbEnAbJLXdInRnWd4fAUHpkAWPLg6Pd_k0OpYTzlt1rgPpEr5bz33e1HzhfUOFDdiU9KNe4K8B6EFDhhwdLHrg0CSc2hQ3iEp5jpzBP22IgmuAUlG2AiAOxjdQupeD0moTxKYACFeqPLXNUjqtTvjMOO9LSwrfZo1nVmK7eVtCnK_cS1FitWyUwwjqwrQt_BTyrePIlpHPf2QI_jx_VpU2nnBvz_cOezn4YLnxCrhY5AyO-wpivBaH4xYP2v5apvGfcdIQ8Hf9FlCPCW43fVW12w9Kj4aumKf8KPF7kIaC0VhL1L9E5R8lfgaMI6KzPgXR2GnrKJ832CVXH8C8uNyCF8wy2hvA37a-paaHchuVDyF41UZTZ5UO5OmiXWI_P51L1uwAIWXLVRoWd8jxTSL52vmMr02X1GH628K92c1hvSa92KmpuFu6eceHW1HK6Ae8KKr4afWcmVnDSIeHW1Ha3ZKI4GrH2Nma4B2SnMFYFWOEOxaE0vKnAYA7EU6dYfHb12H2K1824yJgnFO6hWQHm9Fhusg3jyjq_vuFAXL7bbztUbt8ONPpuUVpYAPdqvdfk6LXW_O33uH1pjvCGw6yAauZCGdQTjyIa6vV575Nc6Spy0v8Yi_tDeCsTov7hYLcjtK_mbWajw5JHKL_fOCwTOCGRbHsrTc5Uzirg5awkubfV-Hl6mFR3U-fQCoVwKDE2mtq7Yfvefg0MVom2qWwtUL_Xblc4vBerSwM_uB"></p><p><img src="https://www.plantuml.com/plantuml/svg/AyaioKbLUBPWujEzYvxldlniNWjNScfUIMgHGaPgOafg4HUo52usLsfU2bGvbqDnIM9HIN5YJWbNDPS245I7W2aGq5O8po_AIK7mjHKSSrEBCfCJaOIq5PmJyn9JK8L2WnsH-TeAVgdb2f7vHTceeaxvnINvUIWwVLChCfFpaQrqBItABqX5KUHPafXJYIBYdbgKcvXNYMPyQb5EPXwAyzFWhg_bgkLo00O4sElGC4pBpoz12qDGM4640G00"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><img src="https://www.plantuml.com/plantuml/svg/AyaioKbLUB5mnRC5UxYIK_DAKeiKCb8JKrABkA22gNafK04kX-AInAAIuiIS4gvgPIu5LA2dK0CadVDpIdFp58mKG3mennYiD2Y_76goWY5OQLbYJcaga0rM2k4OeQiq0ievAkJavwKh9AVcv81KQd7LSZa07GLs1ip9QVdv9IXEXWW00000"></p><h2 id="MD表格"><a href="#MD表格" class="headerlink" title="MD表格"></a>MD表格</h2><p><img src="https://www.plantuml.com/plantuml/svg/AyaioKbLy7LviN35imLxk99JyqfIYnGoKXDJKekuuCAfUIbG8QuIa0Qk6bi582f9J09g1Z8WaWerN3KAYGerC765elnoi5WIXXZGG0M8IT5QiGgwkdOAmIM99Qc6N7dv9QaAHPdf6ILKiGDa71VCLsdvG1wgho120000"><br>音 –&gt; 音质 —&gt; 高低 —&gt; 十二平均律(七键) —&gt;音级/音名/唱名/音组 —&gt;<br>音 –&gt; 音质 —&gt; 长短 —&gt; 音符（全音/半音）<br>五线谱 –&gt; 节拍  拍号，调号，调域<br></p><h2 id="大音阶"><a href="#大音阶" class="headerlink" title="大音阶"></a>大音阶</h2><p> 12个调：7个大键 5个黑键 ： 全音/半音<br> 音名：C Db D Eb E Fb F Gb G Ab A Bb B<br> 音组：十二平均律<br> 音性质：高低，强弱，长短，音色<br> 音符时效：全音符，二分音符，四分音符，八分音符，十六分音符。<br> 斧头/符干/符尾   书写方法：斧头下干居右，斧头上干居左，符尾永居右<br> 节：<br> 拍号：<br> 乐速：BPM<br> 五线谱：<br> 音程： 度数：两个音符跨度的线和间的个数，音数：两个音符相差全音和半音的个数<br> 音程名：音数和度数决定。纯一度，小二度，大二度…<br> 节奏读法：短音符：嗒，二倍音符：嗒啊，三倍音符：嗒啊啊，休止符：嗯/嗯啊<br> 调式/调域/音阶<br> 调的主音+调式类别<br> C大调：<br> 自然大调：全全半全全全半 的音级关系<br> 自然小调：全半全全半半全全<br> 关系（大/小）调：c大调是a小调的关系大调。a小调是c大调的关系小调，使用其关系（大/小）调的首调唱名方法。<br> 和弦：以两个以上的音，按照三度的重叠关系，在纵向上加以结合，就是和弦。<br> 顺阶和弦：根音/三音/五音<br> 七个顺阶和弦：大三和弦（CFG）/小三和弦（m）/减三和弦（dim）<br> 大三和弦：根音–大三度–三音—小三度—五音<br> 小三和弦：根音–小三度–三音—大三度—五音<br> 减三和弦：根音–小三度–三音—小三度—五音<br> 调号：变音音符，为了让读者便于识别调式，同时方便写谱，五线谱就将相关调域自然大调音阶中出现的变音记号，按照一定的次序，记在谱号的后边，这些记号就是五线谱的调号。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">调试</span><br><span class="line">音阶</span><br><span class="line">调域</span><br><span class="line">固定唱名法/首调唱名法</span><br><span class="line">自然大调/自然小调</span><br><span class="line">和弦的---顺阶和弦</span><br><span class="line">调号</span><br><span class="line">五度圈</span><br><span class="line">大调中的主要和弦的功能与进行</span><br></pre></td></tr></table></figure><h3 id="C大调音阶"><a href="#C大调音阶" class="headerlink" title="C大调音阶"></a>C大调音阶</h3><p> do 在C上<br> 音名：C，D，E，F，G，A，B，C<br> 指法：1 ，2，3，1，2，3，4，5</p><h3 id="G大调音阶"><a href="#G大调音阶" class="headerlink" title="G大调音阶"></a>G大调音阶</h3><p> 音名：G，A，B，半音 C，D，E，全音F#，半音G</p><ol><li><del>扫描事件动画处理</del></li><li>巡查录入，执法权限验证进行执法</li><li>筛选商业调试UI</li><li>巡查年度列表</li><li>配置平台组件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 作文作曲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端实现预览plantuml的插件</title>
      <link href="/2018/05/29/shell/%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E9%A2%84%E8%A7%88plantuml%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/05/29/shell/%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E9%A2%84%E8%A7%88plantuml%E7%9A%84%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div id="badge-container-weirongxu-plantuml-previewer.vim-bf4b3e5" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-weirongxu-plantuml-previewer.vim-bf4b3e5", "weirongxu", "plantuml-previewer.vim", "bf4b3e5", false);</script><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">'huos3203/plantuml-syntax'</span>  <span class="string">"plantuml语法高亮 Plug 'aklt/plantuml-syntax'</span></span><br><span class="line"><span class="string">Plug 'tyru/open-browser.vim'</span></span><br><span class="line"><span class="string">Plug 'weirongxu/plantuml-previewer.vim' "</span>在线工具：http://sujoyu.github.io/plantuml-previewer/</span><br></pre></td></tr></table></figure><h3 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h3><p><a href="https://www.graphviz.org/download/" target="_blank" rel="noopener">下载地址</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure></p><h3 id="打开浏览器safari插件工具"><a href="#打开浏览器safari插件工具" class="headerlink" title="打开浏览器safari插件工具"></a>打开浏览器safari插件工具</h3><p>open-browser.vim</p><h3 id="语法高亮插件"><a href="#语法高亮插件" class="headerlink" title="语法高亮插件"></a>语法高亮插件</h3><p>aklt/plantuml-syntax (vim syntax file for plantuml)</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建uml文件"><a href="#创建uml文件" class="headerlink" title="创建uml文件"></a>创建uml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.uml</span><br></pre></td></tr></table></figure><h3 id="预览uml图"><a href="#预览uml图" class="headerlink" title="预览uml图"></a>预览uml图</h3><p>通过命令打开浏览器预览界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlantumlOpen</span><br></pre></td></tr></table></figure></p><p>在vi中执行保存命令<code>:w</code>,预览界面会自动刷新</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pyenv切换python的版本</title>
      <link href="/2018/05/29/hexo/pyenv%E5%88%87%E6%8D%A2python%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2018/05/29/hexo/pyenv%E5%88%87%E6%8D%A2python%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p><a href="https://stackoverflow.com/questions/32702098/err-stack-error-command-failed-python2-c-import-platform" target="_blank" rel="noopener">在hexo 项目中使用npm 配置环境，出现错误：gyp ERR! configure error</a></p><p>pyenv是python的多版本管理包，实现互相独立、互不干扰的python环境配置。</p><h2 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h2><p>安装电脑是mac，所以理所当然的使用神器：homebrew<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure></p><p>安装界面略过，安装结束后，系统提示如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Caveats</span><br><span class="line">To use Homebrew<span class="string">'s directories rather than ~/.pyenv add to your profile:</span></span><br><span class="line"><span class="string">export PYENV_ROOT=/usr/local/var/pyenv</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To enable shims and autocompletion add to your profile:</span></span><br><span class="line"><span class="string">if which pyenv &gt; /dev/null; then eval "$(pyenv init -)"; fi</span></span><br></pre></td></tr></table></figure></p><p>根据此提示，在bash的配置文件（由于我的bash是oh my zsh，所以我的配置文件为~/.zshrc）中添加以下两行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PYENV_ROOT=/usr/local/var/pyenv</span><br><span class="line">if which pyenv &gt; /dev/null; then eval &quot;$(pyenv init -)&quot;; fi</span><br></pre></td></tr></table></figure></p><h2 id="使用pyenv"><a href="#使用pyenv" class="headerlink" title="使用pyenv"></a>使用pyenv</h2><h4 id="安装指定版本的python"><a href="#安装指定版本的python" class="headerlink" title="安装指定版本的python"></a>安装指定版本的python</h4><p>显示所有可以安装的python版本软件，如2.1.3…3.5.1等。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv install -l</span><br><span class="line">pyenv install 2.7.11 -v</span><br></pre></td></tr></table></figure></p><p><code>-v</code>表示在显示安装过程。<br>安装完成后，2.7.11版本在系统中的存放位置为：<br><code>/usr/local/var/pyenv/versions/2.7.11</code></p><h3 id="为项目配置python环境"><a href="#为项目配置python环境" class="headerlink" title="为项目配置python环境"></a>为项目配置python环境</h3><p>接下来进入开发项目的主文件夹，如<code>~/Desktop/Python/TWD</code>，输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv local 2.7.11</span><br></pre></td></tr></table></figure></p><p>即在当前文件夹下配置完成python的开发环境。接下来可通过pip安装开发过程中的各种包。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-显示所有安装的python版本"><a href="#1-显示所有安装的python版本" class="headerlink" title="1.显示所有安装的python版本"></a>1.显示所有安装的python版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><h3 id="2-切换python版本"><a href="#2-切换python版本" class="headerlink" title="2.切换python版本"></a>2.切换python版本</h3><p>要切换python 版本，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global &lt;version&gt;</span><br></pre></td></tr></table></figure></p><p>比如，我使用以上命令pyenv global 2.7.11后，系统默认的python版本即为2.7.11，在命令行输入python后，进入的就是2.7.11的shell，不再是system的shell。</p><h3 id="3-切换python-shell版本"><a href="#3-切换python-shell版本" class="headerlink" title="3.切换python shell版本"></a>3.切换python shell版本</h3><p>若不使用pyenv global命令实现python shell版本切换，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv shell &lt;version&gt;</span><br></pre></td></tr></table></figure></p><p>比如，我使用pyenv shell 2.7.11后，在命令行输入python，进入的是2.7.11的shell。此时系统的默认python版本也变成了2.7.11，如下所示：</p><p><a href="https://www.jianshu.com/p/bcb3f1be9073" target="_blank" rel="noopener">转自</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>雨夜</title>
      <link href="/2018/05/17/%E4%BD%9C%E6%96%87%E4%BD%9C%E6%9B%B2/%E9%9B%A8%E5%A4%9C/"/>
      <url>/2018/05/17/%E4%BD%9C%E6%96%87%E4%BD%9C%E6%9B%B2/%E9%9B%A8%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="雨夜"><a href="#雨夜" class="headerlink" title="雨夜"></a>雨夜</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卧听风雨天窗跃，左耳贯注天籁音</span><br><span class="line">不闻春雷潜入夜，广厦飞瀑挂屋檐</span><br></pre></td></tr></table></figure><!-- 简单示例 (id, server, type)  --><h2 id="滑板"><a href="#滑板" class="headerlink" title="滑板"></a>滑板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">心如止水毽如飞，晨练漂移划湖心</span><br><span class="line">夜雨不及暑气盛，黑云压城君汗蒸</span><br></pre></td></tr></table></figure><h2 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h2><div class="owl-media owl-video owl-bilibili"><embed src="http://static.hdslb.com/miniloader.swf" flashvars="aid=1468496&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div><h2 id="QQ视频"><a href="#QQ视频" class="headerlink" title="QQ视频"></a>QQ视频</h2><div class="owl-media owl-video owl-tencent"><embed src="http://static.video.qq.com/TPout.swf?vid=s06895oernz&auto=0" type="application/x-shockwave-flash" quality="high" allowfullscreen="true" align="middle" allowscriptaccess="always"></div><h2 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h2>    <div id="aplayer-BGRiaZZh" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="002rhYYR0e7jWP" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>]]></content>
      
      
      <categories>
          
          <category> 作文作曲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汉字拼音排序方法</title>
      <link href="/2018/05/17/iOS/%E6%B1%89%E5%AD%97%E6%8B%BC%E9%9F%B3%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/17/iOS/%E6%B1%89%E5%AD%97%E6%8B%BC%E9%9F%B3%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--github库卡片--><div id="badge-container-huos3203-sortChinese-2deab8b" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-sortChinese-2deab8b", "huos3203", "sortChinese", "2deab8b", false);</script><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>实现模型对象排序，当万条数据时，出现卡顿问题。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>实现字符串数组的排序，暂时没有验证大量排序情况，尝试优化第一种方法的排序卡顿问题。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水关长城天漠行</title>
      <link href="/2018/04/13/%E6%97%85%E8%A1%8C/%E6%B0%B4%E5%85%B3%E9%95%BF%E5%9F%8E%E5%A4%A9%E6%BC%A0%E8%A1%8C/"/>
      <url>/2018/04/13/%E6%97%85%E8%A1%8C/%E6%B0%B4%E5%85%B3%E9%95%BF%E5%9F%8E%E5%A4%A9%E6%BC%A0%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><blockquote class="trello-card"><a href="https://trello.com/c/fHziBC4z/1-%E8%87%AA%E9%A9%BE%E6%B8%B8" target="_blank" rel="noopener">行程安排</a></blockquote><script src="https://p.trellocdn.com/embed.min.js"></script></p><div class="pdf" target="http://p27uwfdhv.bkt.clouddn.com/static/pdf/%E6%B0%B4%E5%85%B3%E9%95%BF%E5%9F%8E%E5%A4%A9%E6%BC%A0%E6%B8%B8.pdf" height></div>]]></content>
      
      
      <categories>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git工具交互式暂存</title>
      <link href="/2018/04/13/git/Git%E5%B7%A5%E5%85%B7%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/"/>
      <url>/2018/04/13/git/Git%E5%B7%A5%E5%85%B7%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个互交命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add -i</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:    unchanged        +0/-1 TODO</span><br><span class="line">2:    unchanged        +1/-1 index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">1: status     2: update      3: revert     4: add untracked</span><br><span class="line">5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p><p>在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。</p><h2 id="暂存与取消暂存文件"><a href="#暂存与取消暂存文件" class="headerlink" title="暂存与取消暂存文件"></a>暂存与取消暂存文件</h2><p>如果在 What now&gt; 提示符后键入 2 或 u，脚本将会提示想要暂存哪个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 2</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:    unchanged        +0/-1 TODO</span><br><span class="line">2:    unchanged        +1/-1 index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>要暂存 TODO 与 index.html 文件，可以输入数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt; 1,2</span><br><span class="line">staged     unstaged path</span><br><span class="line">* 1:    unchanged        +0/-1 TODO</span><br><span class="line">* 2:    unchanged        +1/-1 index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update&gt;&gt; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt;</span><br><span class="line">updated 2 paths</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">1: status     2: update      3: revert     4: add untracked</span><br><span class="line">5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:        +0/-1      nothing TODO</span><br><span class="line">2:        +1/-1      nothing index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p><p>现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 3 或 r（撤消）选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">1: status     2: update      3: revert     4: add untracked</span><br><span class="line">5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 3</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:        +0/-1      nothing TODO</span><br><span class="line">2:        +1/-1      nothing index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; 1</span><br><span class="line">staged     unstaged path</span><br><span class="line">* 1:        +0/-1      nothing TODO</span><br><span class="line">2:        +1/-1      nothing index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; [enter]</span><br><span class="line">reverted one path</span><br></pre></td></tr></table></figure></p><p>再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">1: status     2: update      3: revert     4: add untracked</span><br><span class="line">5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:    unchanged        +0/-1 TODO</span><br><span class="line">2:        +1/-1      nothing index.html</span><br><span class="line">3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p><p>如果想要查看已暂存内容的区别，可以使用 6 或 d（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff –cached 非常相似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">1: status     2: update      3: revert     4: add untracked</span><br><span class="line">5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 6</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:        +1/-1      nothing index.html</span><br><span class="line">Review diff&gt;&gt; 1</span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index 4d07108..4335f49 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -16,7 +16,7 @@ Date Finder</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class="line">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p><h2 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h2><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 5 或 p（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index dd5ecc4..57399e0 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def log(treeish = &apos;master&apos;)</span><br><span class="line">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def blame(path)</span><br><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure></p><p>这时有很多选项。 输入 ? 显示所有可以使用的命令列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure></p><p>通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 1</span><br><span class="line">staged     unstaged path</span><br><span class="line">1:    unchanged        +0/-1 TODO</span><br><span class="line">2:        +1/-1      nothing index.html</span><br><span class="line">3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p><p>simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。</p><p>也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 git add -p 或 git add –patch 来启动同样的脚本。</p><p>更进一步地，可以使用 reset –patch 命令的补丁模式来部分重置文件，通过 checkout –patch 命令来部分检出文件与 stash save –patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Otherlinkerflags设置ld命令执行的参数</title>
      <link href="/2018/04/12/xcode/Otherlinkerflags%E8%AE%BE%E7%BD%AEld%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2018/04/12/xcode/Otherlinkerflags%E8%AE%BE%E7%BD%AEld%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Other linker flags设置的值实际上就是ld命令执行时后面所加的参数。</p><p>3个常用参数：<br><code>-ObjC</code>：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中<br><code>-all_load</code>：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到<code>ld: duplicate symbol</code>错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到<code>-ObjC</code>失效的情况下使用<code>-force_load</code>参数。<br><code>-force_load</code>：所做的事情跟<code>-all_load</code>其实是一样的，但是<code>-force_load</code>需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载.</p><h3 id="加载FrameWork"><a href="#加载FrameWork" class="headerlink" title="加载FrameWork"></a>加载FrameWork</h3><h3 id="加载静态库"><a href="#加载静态库" class="headerlink" title="加载静态库"></a>加载静态库</h3>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS插件化开发之Small</title>
      <link href="/2018/04/12/xcode/iOS%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BSmall/"/>
      <url>/2018/04/12/xcode/iOS%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BSmall/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div id="badge-container-huos3203-SmallDemo-5931b43" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-SmallDemo-5931b43", "huos3203", "SmallDemo", "5931b43", false);</script><p><a href="http://code.wequick.net/Small/cn/home" target="_blank" rel="noopener">官网</a><br>small是android与iOS平台比较出名的轻巧的跨平台插件化框架，也正是被这一点吸引，决定将small应用到集团内部的应用引擎模块化方案中，本篇博文主要讲述本人基于small在iOS平台实现的定制化APP方案（运营自由配置、自由组合、自动打包）~<br><a href="http://code.wequick.net/Small/cn/feature" target="_blank" rel="noopener">特性与功能</a></p><h3 id="基于iOS组件化基础"><a href="#基于iOS组件化基础" class="headerlink" title="基于iOS组件化基础"></a>基于iOS组件化基础</h3><p>iOS组件化基于<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Framework.html#//apple_ref/doc/uid/TP40008195-CH56-SW1" target="_blank" rel="noopener">Cocoa Touch Framework</a>（以下简称CTF）通过<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="noopener">NSBundle</a>实现。</p><ul><li>CTF首次公开在WWDC2014，要求Xcode6 beta以上版本。</li><li>CTF官方表示支持8.0以上系统，但在6.0、7.0上测试正常。</li><li>如果你的App包含了CTF，但是<strong>Deployment Target</strong> &lt; 8.0，上传二进制文件到App Store时会报警中断。<br>受苹果官方限制，如果你的CTF没有签名，将无法实现代码级别更新。</li></ul><p>Framework 模式无法上传到App Store。只能应用到企业版</p><h3 id="使用Small模版新建l项目"><a href="#使用Small模版新建l项目" class="headerlink" title="使用Small模版新建l项目"></a>使用Small模版新建l项目</h3><p>Small提供了<code>Small-pods</code>模版，安装Xcode模版创建空白的Small项目。</p><ol><li><p><strong>安装Xcode模板</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wequick/Small.git</span><br><span class="line"><span class="built_in">cd</span> Small/iOS</span><br><span class="line">cp -r Templates ~/Library/Developer/Xcode/Templates</span><br></pre></td></tr></table></figure></li><li><p><strong>新建项目</strong><br><code>File-&gt;New-&gt;Project...</code>，选择<code>Small-pods</code>模板<br><img src="https://camo.githubusercontent.com/25aac173476e3a5eecdf2853b0e233bf8179bece/687474703a2f2f636f64652e7765717569636b2e6e65742f6173736574732f696d616765732f736d616c6c2d696f732d74656d706c6174652e706e67" alt="Small iOS Template"></p></li></ol><ul><li><p>库依赖配置文件<code>podfile</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'SmallAPP'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">"Small"</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">'https://github.com/wequick/Small.git'</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>路由文件<code>bundle.json</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"bundles"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"main"</span>,</span><br><span class="line">            <span class="attr">"pkg"</span>: <span class="string">"hsg.com.cn.SmallAPP.app.main"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>安装pod依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [your-project-path]</span><br><span class="line">pod install --no-repo-update</span><br><span class="line">open *.xcworkspace</span><br></pre></td></tr></table></figure></li></ol><h3 id="解读插件路由配置"><a href="#解读插件路由配置" class="headerlink" title="解读插件路由配置"></a>解读插件路由配置</h3><p><a href="http://code.wequick.net/Small/cn/router" target="_blank" rel="noopener">插件路由</a>:为了方便插件之间的跨平台调用，Small 提供了 <code>bundle.json</code> 来完成插件路由。<br>bundle.json路由配置包括<code>version</code>:指定插件的版本号，<code>bundles</code>:插件注册的清单数组，其中插件清单的每个插件四个属性，来确定加载组件的方式：<br><code>uri</code>：指定加载插件的跟路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取控制器</span><br><span class="line">let VC = Small.controller(forUri: &quot;fixurl&quot;)</span><br><span class="line">//将VC.view直接设置为window根视图</span><br><span class="line">Small.openUri(&quot;fixurl&quot;, from: self)</span><br></pre></td></tr></table></figure></p><p><code>pkg</code>：配置要求新建的Framework命名时必须包含<code>.lib.</code>、<code>.app.</code>，因为在加载组件过程中用它来判断你插件的类型：<br><code>rules</code>：规定页面的分发规则，可以通过rules来设置插件的多个入口，配和<code>uri</code>使用:<code>openuri(uri/ruleskey)</code>,当不配置rules时，默认通过<code>info.plist NSPrincipalClass</code>来加载组件<code>openuri(uri)</code>。<br>路由配置文件<code>bundle.json</code>部分内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,    </span><br><span class="line">    <span class="attr">"bundles"</span>: [                </span><br><span class="line">                &#123;  </span><br><span class="line">                   <span class="attr">"uri"</span>: <span class="string">"lib.utils"</span>,                </span><br><span class="line">                   <span class="attr">"pkg"</span>: <span class="string">"com.example.small.lib.utils"</span>,</span><br><span class="line">                   "rules": &#123;  //会覆盖掉`Principal class`默认的启动页配置</span><br><span class="line">                       "Storyboard": "storyboardName/controllerId",</span><br><span class="line">                       "xib": "controllerName"</span><br><span class="line">                   &#125;               </span><br><span class="line">                &#125;,                </span><br><span class="line">                &#123;                </span><br><span class="line">                   <span class="attr">"uri"</span>: <span class="string">"main"</span>,                </span><br><span class="line">                   <span class="attr">"pkg"</span>: <span class="string">"com.example.small.app.main"</span>              </span><br><span class="line">                &#125;</span><br><span class="line">               ]</span><br><span class="line">               ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>small加载接口的相关方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (void)openUri:(NSString *)uri fromView:(UIView *)view;</span><br><span class="line">+ (void)openURL:(NSURL *)url fromView:(UIView *)view;</span><br><span class="line"></span><br><span class="line">+ (void)openUri:(NSString *)uri fromController:(UIViewController *)controller;</span><br><span class="line">+ (void)openURL:(NSURL *)url fromController:(UIViewController *)controller;</span><br><span class="line"></span><br><span class="line">+ (UIViewController *)controllerForUri:(NSString *)uri;</span><br><span class="line">+ (UIViewController *)controllerForURL:(NSURL *)url;</span><br></pre></td></tr></table></figure></p><h4 id="支持Storyboard作为启动页的解析"><a href="#支持Storyboard作为启动页的解析" class="headerlink" title="支持Storyboard作为启动页的解析"></a>支持Storyboard作为启动页的解析</h4><p>根据<code>SMBundle</code>路由配置信息，通过<code>SMAppBundleLauncher</code>的实例方法<code>_controllerForBundle:</code>加载Framework，支持storyboard加载。</p><ol><li>路由<code>rules</code>字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;rules&quot;:&#123;</span><br><span class="line">&quot;&quot;:&quot;Main/MainViewController&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>空字串(<code>&quot;&quot;</code>)的<code>value</code>值两种格式类型：</p><pre><code>`&quot;$controllerName&quot;`: `SMAppBundleLauncher`通过反射，初始化controller`&quot;storyboardName/controllerId&quot;`:`SMAppBundleLauncher`会识别找到storyboard在更具id初始化controller</code></pre><p>最终可以<code>SMBundle</code>实例变量<code>target</code>中得到该key(<code>&quot;&quot;</code>)的value值来定位插件包，在该过程通过对<code>SMBundle</code>的属性<code>bundle.queryParams</code>的处理，完成对插件对象的值传递<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([bundle.target isEqualToString:<span class="string">@""</span>]) &#123;</span><br><span class="line">        targetClazz = bundle.principalClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *target = bundle.target;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = [target rangeOfString:<span class="string">@"/"</span>].location;</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">// Storyboard: "$storyboardName/$controllerId"</span></span><br><span class="line">            <span class="built_in">NSString</span> *storyboardName = [target substringToIndex:index];</span><br><span class="line">            targetBoard = [<span class="built_in">UIStoryboard</span> storyboardWithName:storyboardName bundle:bundle];</span><br><span class="line">            targetId = [target substringFromIndex:index + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Controller: "$controllerName"</span></span><br><span class="line">            targetClazz = [bundle classNamed:target];</span><br><span class="line">            <span class="keyword">if</span> (targetClazz == <span class="literal">nil</span> &amp;&amp; !SMStringHasSuffix(target, <span class="string">@"Controller"</span>)) &#123;</span><br><span class="line">            targetClazz = [bundle classNamed:[target stringByAppendingString:<span class="string">@"Controller"</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UIViewController</span> *controller = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (targetClazz != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">//尝试获取xib资源</span></span><br><span class="line">    <span class="built_in">NSString</span> *nibName = <span class="built_in">NSStringFromClass</span>(targetClazz);</span><br><span class="line">    <span class="built_in">NSString</span> *nibPath = [bundle pathForResource:nibName ofType:<span class="string">@"nib"</span>];</span><br><span class="line">    <span class="keyword">if</span> (nibPath != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过xib资源文件创建控制器实例</span></span><br><span class="line">        controller = [[targetClazz alloc] initWithNibName:nibName bundle:bundle];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/// 通过反射类方式创建控制器实例</span></span><br><span class="line">        controller = [[targetClazz alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Initialize controller parameters</span></span><br><span class="line"><span class="keyword">if</span> (bundle.queryParams != <span class="literal">nil</span>) &#123;</span><br><span class="line">    [controller setValuesForKeysWithDictionary:bundle.queryParams];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>使用 <a href="https://en.wikipedia.org/wiki/Query_string" target="_blank" rel="noopener">Query标准</a>来传递参数，即在 <code>uri</code> 之后加上 <code>?</code> 再带上键值对，多个键值对用<code>&amp;</code> 来分开。</p><ol><li><p>传值方式  <code>detail?id=1000&amp;title=test</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Small openUri:@&quot;detail?from=app.home&quot; fromController:controller];</span><br></pre></td></tr></table></figure></li><li><p>接收解析为属性值<br>例如<code>DetailController</code>)定义两个属性，属性名称和<code>uri</code>键值名保持一致，因为是通过<code>setValuesForKeysWithDictionary</code>来给相应属性赋值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DetailController.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DetailController.m</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">id</span> = <span class="keyword">self</span>.id;</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line"><span class="comment">// Initialize controller parameters</span></span><br><span class="line"><span class="keyword">if</span> (bundle.queryParams != <span class="literal">nil</span>) &#123;</span><br><span class="line">    [controller setValuesForKeysWithDictionary:bundle.queryParams];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插件命名规则和入口设置"><a href="#插件命名规则和入口设置" class="headerlink" title="插件命名规则和入口设置"></a>插件命名规则和入口设置</h3><p>路由配置对插件包的命名有严格要求，<code>SMBundle</code>主要通过<code>pkg</code>名称包含<code>.app.</code>(模块库)/<code>.lib.</code>(工具库)来定位插件包的，否则全部默认加载bundle包。<br><strong>模块命名规范</strong></p><ul><li><code>framework</code>编译成功后，名称跟<code>Product Name</code>一样命名规则:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xx_xx_lib_xx【com_example_small_lib_utils】</span><br><span class="line">xx_xx_app_xx</span><br><span class="line">xx_xx_xx_xx</span><br></pre></td></tr></table></figure></li></ul><p>注意lib、app这些对查找framework文件相当重要，这所以会有<code>_</code>，是small对<code>.</code>做了替换<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *bundlePath = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSString</span> *bundleSuffix = <span class="string">@"bundle"</span>; <span class="comment">//默认</span></span><br><span class="line">SMBundleType bundleType = SMBundleTypeAssets; </span><br><span class="line"><span class="keyword">if</span> ([pkg rangeOfString:<span class="string">@".app."</span>].location != <span class="built_in">NSNotFound</span></span><br><span class="line">|| [pkg rangeOfString:<span class="string">@".lib."</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">    bundleSuffix = <span class="string">@"framework"</span>;</span><br><span class="line">    bundleType = SMBundleTypeApplication;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSString</span> *bundleName = [pkg stringByReplacingOccurrencesOfString:<span class="string">@"."</span> withString:<span class="string">@"_"</span>];</span><br><span class="line">bundleName = [bundleName stringByAppendingFormat:<span class="string">@".%@"</span>, bundleSuffix];</span><br></pre></td></tr></table></figure></p><p><strong>设置加载模块的入口类</strong></p><ol><li><p><strong>info.plist</strong>方式实现<br>在 <code>framework</code>模块工程的<strong>info.plist</strong>文件中添加<code>Principal class</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSPrincipalClass&lt;/key&gt;</span><br><span class="line">&lt;string&gt;ESHomeController&lt;/string&gt; //指定入口类名</span><br></pre></td></tr></table></figure></li><li><p><strong>bundle.json</strong>路由方式实现<br>通过设置<strong>bundle.json</strong>的<code>rules</code>字典，指定初始化库的入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;rules&quot;: &#123;  </span><br><span class="line">               &quot;&quot;: &quot;默认入口类名&quot;</span><br><span class="line">    &quot;/Storyboard&quot;: &quot;storyboardName/controllerId&quot;,</span><br><span class="line">           &quot;/xib&quot;: &quot;controllerName&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>bundle.json</strong>中配置的入口，优先于<code>info.plist</code>中的<code>Principal class</code>的入口。</p></blockquote><h3 id="集成插件到主工程"><a href="#集成插件到主工程" class="headerlink" title="集成插件到主工程"></a>集成插件到主工程</h3><ol><li><strong>插件集成</strong><br>就是将<code>framework</code>添加到主工程，不能以Linked方式进行添加，使用<code>Build Phases</code>中的<code>Copy Bundle Resources</code> 选项，将<code>framework</code>拖动添加其中即可，这样可以完成对<code>framework</code>编译完后的拷贝.</li><li><p><strong>插件启动原理</strong><br>small框架会依次优先顺序检查<code>Documents/temp</code>（下载的zip）–&gt;<code>/Documents/bundles</code>(存放Framework)–&gt;<code>/iSmallApp.app/</code>(app根目录)，small规定插件<code>Framework</code>必须存放在这几个目录中，才能被small框架动态加载。<br>具体实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundleName = [pkg stringByReplacingOccurrencesOfString:@&quot;.&quot; withString:@&quot;_&quot;];</span><br><span class="line">bundleName = [bundleName stringByAppendingFormat:@&quot;.%@&quot;, bundleSuffix];</span><br><span class="line">NSString *documentBundlesPath = [SMFileManager documentBundlesPath];</span><br><span class="line">NSString *patchFilePath = [SMFileManager tempBundlePathForName:bundleName];</span><br><span class="line">//沙盒中查找插件包，一旦发现，解压加载</span><br><span class="line">if ([[NSFileManager defaultManager] fileExistsAtPath:patchFilePath]) &#123;</span><br><span class="line">    // Unzip</span><br><span class="line">    NSString *unzipPath = documentBundlesPath;</span><br><span class="line">    ZipArchive *zipArchive = [[ZipArchive alloc] init];</span><br><span class="line">    [zipArchive UnzipOpenFile:patchFilePath];</span><br><span class="line">    [zipArchive UnzipFileTo:unzipPath overWrite:YES];</span><br><span class="line">    [zipArchive UnzipCloseFile];</span><br><span class="line">    [[NSFileManager defaultManager] removeItemAtPath:patchFilePath error:nil];</span><br><span class="line">&#125;</span><br><span class="line">NSString *patchPath = [documentBundlesPath stringByAppendingPathComponent:bundleName];</span><br><span class="line">///主工程目录下查找</span><br><span class="line">NSString *builtinPath = [[SMFileManager mainBundlesPath] stringByAppendingPathComponent:bundleName];</span><br><span class="line">NSArray *bundlePaths = @[patchPath, builtinPath];</span><br><span class="line">for (NSString *aBundlePath in bundlePaths) &#123;</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:aBundlePath]) &#123;</span><br><span class="line">        bundlePath = aBundlePath;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong><br>完成添加，进入测试。使用过程中，有可以模块更新代码后，主工程调用发现功能未更新，这时候需要清理工程，重新编译；或者修改编译包配置，从而时时更新。<br><img src="https://img-blog.csdn.net/20160718094828722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br><img src="https://img-blog.csdn.net/20160718094836316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p></li></ol><h3 id="small的两种开发模式的demo"><a href="#small的两种开发模式的demo" class="headerlink" title="small的两种开发模式的demo"></a>small的两种开发模式的demo</h3><ol><li><p>使用者模式<br>使用场景：作为第三方集成到自己的项目，包含两个特殊的文件<code>podfile</code>和<code>Small-subprojects.rb</code>安装脚本文件。<br><strong>podfile</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;7.0&apos;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &apos;Sample&apos; do</span><br><span class="line">    pod &quot;Small&quot;, :path =&gt; &quot;../../&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>Small-subprojects.rb</code>安装脚本文件<br>通过脚本来设置<code>build settings</code>中的<strong>FRAMEWORK_SEARCH_PATHS</strong>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;] &lt;&lt; &quot;$(CONFIGURATION_BUILD_DIR)/**&quot;</span><br><span class="line">puts &quot;Small: Add framework search paths for &apos;#&#123;dep.name&#125;&apos;&quot;</span><br></pre></td></tr></table></figure></li><li><p>开发者模式<br>使用场景：需要对Small框架集成自己的功能需求时，可以使用该Demo快速部署对Small框架的开发环境</p><blockquote><p>需要去除并行编译模式：<code>Edit Scheme...-&gt;Build-&gt;Build Options-&gt; [ ] Parallelize Build</code></p></blockquote></li></ol><blockquote><p>各个组件需要签名后才支持代码级别更新。示例中更新例子为xib内容更新。<br></p></blockquote><p><a href="https://blog.csdn.net/zhaowensky_126/article/details/51939230" target="_blank" rel="noopener">使用Small创建iOS工程目录</a><br><a href="https://github.com/wequick/Small/wiki/UI-route" target="_blank" rel="noopener">Small UI route文档</a></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当项目过大需要通过SSH方式Clone</title>
      <link href="/2018/04/05/git/%E5%BD%93%E9%A1%B9%E7%9B%AE%E8%BF%87%E5%A4%A7%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87SSH%E6%96%B9%E5%BC%8FClone/"/>
      <url>/2018/04/05/git/%E5%BD%93%E9%A1%B9%E7%9B%AE%E8%BF%87%E5%A4%A7%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87SSH%E6%96%B9%E5%BC%8FClone/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="设置全局提交信息"><a href="#设置全局提交信息" class="headerlink" title="设置全局提交信息"></a>设置全局提交信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><h3 id="修改最后一次提交的用户名信息"><a href="#修改最后一次提交的用户名信息" class="headerlink" title="修改最后一次提交的用户名信息"></a>修改最后一次提交的用户名信息</h3><p><code>git   git config user.name &#39;wangz&#39;  git config user.email &#39;wangz@alib.com&#39;  git commit  --amend --author=wangz  `</code></p><h3 id="项目过大问题"><a href="#项目过大问题" class="headerlink" title="项目过大问题"></a>项目过大问题</h3><blockquote><p>git clone 主工程出现 fatal: The remote end hung up unexpectedly3)</p></blockquote><p>通常的解决办法：</p><ol><li><p>设置提交缓存的大小为 1G：1048576000<br> git config http.postBuffer 1048576000</p></li><li><p>否则，需要配置github/gitlab的公钥<br> 生成：<code>ssh-keygen -t rsa -C &quot;$your_email&quot;</code><br> 拷贝：<code>pbcopy &lt; ~/.ssh/id_rsa.pub</code><br> 创建SSHKey：<br> 在github/gitlab新建公钥<code>add SSH Key</code>：粘贴到密钥文本框中即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>右方停车练习说明书</title>
      <link href="/2018/04/04/%E6%97%A5%E8%AE%B0/%E5%8F%B3%E6%96%B9%E5%81%9C%E8%BD%A6%E7%BB%83%E4%B9%A0%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
      <url>/2018/04/04/%E6%97%A5%E8%AE%B0/%E5%8F%B3%E6%96%B9%E5%81%9C%E8%BD%A6%E7%BB%83%E4%B9%A0%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>车头前机盖与前停止线重合时停车<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2></li><li>打右灯，挂倒档，慢抬离合</li><li>看右后视镜，当库区右前角消失时，向右打死</li><li>看左后视镜，当左后视镜看到库右后角时，向左打轮回正</li><li>看左后视镜，当左后轮轧左库线时，向左打死，车正停车</li><li>打左灯看左镜，当看到右后角时向右打2圈半，车正向左回1圈</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>正确使用转向灯，将车身顺停车距右侧线50cm处。</li><li>车轮和车身任意一端不得超出库区</li><li>控制车速和打轮速度</li><li>不准中途停车</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A++审核问题总结</title>
      <link href="/2018/04/03/%E6%B5%8B%E8%AF%95/A++%E5%AE%A1%E6%A0%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/03/%E6%B5%8B%E8%AF%95/A++%E5%AE%A1%E6%A0%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://developer.apple.com/cn/app-store/review/guidelines/" target="_blank" rel="noopener">苹果审核规则</a><br>答审核人员回访时提到的几个问题：</p><ol><li>处理非法内容的预防措施<br>答：我们平台会采取24小时内删除非法内容并将违规用户拉黑销号处理，通过后台运作实现有效的防范措施。</li><li>app完整及数据内容规范化<br>答：我们对含有测试文本及敏感文字的数据进行清理，保证了功能完善内容规范。</li><li>经营模式<br>举例说明：A有事想，通过发布任务给B，询问B是否有朋友可以帮忙，如果有并且愿意介绍，A愿意以红包的方式进行打赏B，这个红包是象征意义的红包，目前不会在APP内进行支付，会在线下支付，也可不支付。主要通过寻找朋友的人脉寻求帮助的场景建立起一个社交的应用场景。</li><li>通讯录权限描述不清晰<br>答：我们重新校正了权限描述，让用户更清晰准确的理解APP使用通讯录的目的。</li></ol><p>希望早日通过审核，Thanks。</p><h2 id="规则1-2-Safety-User-Generated-Content"><a href="#规则1-2-Safety-User-Generated-Content" class="headerlink" title="规则1. 2 Safety: User Generated Content"></a>规则1. 2 Safety: User Generated Content</h2><pre><code>添加举报功能</code></pre><h2 id="规则5-1-2通讯录权限"><a href="#规则5-1-2通讯录权限" class="headerlink" title="规则5.1.2通讯录权限"></a>规则5.1.2通讯录权限</h2><p>微信通讯录权限描述:</p><h4 id="登录之后弹出两个提示"><a href="#登录之后弹出两个提示" class="headerlink" title="登录之后弹出两个提示:"></a>登录之后弹出两个提示:</h4><ol><li>说明APP使用目的<br>微信将上传手机通讯录至微信服务器以匹配及推荐朋友.\n(上传通讯录仅用于匹配,不会保存资料,亦不会用作他用)</li><li>说明APP请求使用权限<br>如果不允许,微信将无法推荐通讯录中的朋友给你.微信仅使用特征码用于匹配识别,不会保存你的通讯录内容.</li></ol><p>规避封帐号的风险：</p><ol><li>总结常被拒的问题，每次发布时做好自查。</li><li>把被拒概率大的单独申请账号审核。</li></ol><h2 id="被苹果惩罚的原因（不做以下勾当就不会招来苹果惩罚）"><a href="#被苹果惩罚的原因（不做以下勾当就不会招来苹果惩罚）" class="headerlink" title="被苹果惩罚的原因（不做以下勾当就不会招来苹果惩罚）"></a>被苹果惩罚的原因（不做以下勾当就不会招来苹果惩罚）</h2><p>✕ 刷榜<br>众所周知，刷榜绝对是开发者被苹果惩罚的最主要原因。<br>✕ 诱导性运营活动<br>引导用户评论以及消费都属于诱导性运营活动。<br>✕ 被刷榜<br>这边要说下这点。所谓“被刷榜”是指，被竞争对手恶意刷好评通过苹果机制强制下架。竞争对手采用这种方式陷害竞品，而目前苹果很难界定刷榜行为的主动和被动，所以这块开发者也要注意了。<br>✕ 违规做热搜排名<br>热搜排名在ASO优化中占据重要位置，但其实热搜带来的下载量并不多，并且这种行为很容易被苹果检测到，而一些开发者仍然乐意在这块冒险。<br>✕ 加入非官方支付代码<br>有些开发商为了方便玩家支付，擅自绕开苹果的支付体系，加入支付宝代码等，这种行为被苹果发现后绝对是会直接封号，毫不留情。<br>✕ 涉政、违法<br>这点大家应该都很清楚，如果应用的功能涉及侵犯他人的隐私滥用隐私权限或者存在与宗教、法律相悖的内容，也会遭到下架。</p><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><p>✓ 1.一旦你的产品被惩罚，第一时间，邮件，电话等等方式找苹果，表示自己毫不知情，是受害者，希望能够恢复。态度一定要诚恳，据说这招很灵，不妨一试。<br>✓ 2.发动用户找苹果投诉，表示自己在App Store找不到喜欢的产品了，影响了用户体验。不过这招一定不能用力过猛，否则可能再给你的应用帮倒忙。<br>✓ 3.没办法中的办法，就是重新申请一个开发者账号，重新申请一个新的应用，换一张皮，重新上架。<br>原文：<a href="http://m.ifeng.com/news/x1PWh003/shareNews?aid=108804258&amp;fresh=1&amp;autoFresh=1" target="_blank" rel="noopener">被苹果惩罚了之后怎么办？如何去规避风险呢</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期目标清单玩物丧志</title>
      <link href="/2018/03/14/%E6%97%A5%E8%AE%B0/%E8%BF%91%E6%9C%9F%E7%9B%AE%E6%A0%87%E6%B8%85%E5%8D%95%E7%8E%A9%E7%89%A9%E4%B8%A7%E5%BF%97/"/>
      <url>/2018/03/14/%E6%97%A5%E8%AE%B0/%E8%BF%91%E6%9C%9F%E7%9B%AE%E6%A0%87%E6%B8%85%E5%8D%95%E7%8E%A9%E7%89%A9%E4%B8%A7%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="玩物丧志自省"><a href="#玩物丧志自省" class="headerlink" title="玩物丧志自省"></a>玩物丧志自省</h2><ol><li>学开车，告一段落</li><li>学习抖音制作</li><li>购买：衣服鞋子手机</li><li></li><li><p>使用巧影玩法<br>分身术</p></li><li>手机新玩法：</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐藏导航条底部黑线</title>
      <link href="/2018/03/12/iOS/%E9%9A%90%E8%97%8F%E5%AF%BC%E8%88%AA%E6%9D%A1%E5%BA%95%E9%83%A8%E9%BB%91%E7%BA%BF/"/>
      <url>/2018/03/12/iOS/%E9%9A%90%E8%97%8F%E5%AF%BC%E8%88%AA%E6%9D%A1%E5%BA%95%E9%83%A8%E9%BB%91%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当需要导航条为透明色，与背景色一体时，需要去除底边线：<br>如下代码：使用空图片设置背景图，并指定bar的样式。</p><pre><code class="swift"><span class="keyword">self</span>.navigationController.navigationBar setBackgroundImage:[<span class="type">UIImage</span> new] forBarMetrics:<span class="type">UIBarMetricsDefault</span>];<span class="keyword">self</span>.navigationController.navigationBar.barStyle = <span class="type">UIBarStyleBlackTranslucent</span>;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2017年度总结</title>
      <link href="/2018/01/17/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/17/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="2017年年终总结"><a href="#2017年年终总结" class="headerlink" title="2017年年终总结"></a>2017年年终总结</h1><ul><li>霍曙光</li><li>阳光餐饮TOG产品部</li></ul><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>2017年度工作情况概述<br>抓住2017的尾巴，遇见金和网络，在勤恳付出下，顺利通过试用期工作考核。主要负责巡查系统：巡查录入，巡查管理，巡查地图。主要维护更新组件：视频剧集版，列表版。通过几款产品的磨练，逐渐掌握了金和开发模式，团队之间的协作也越来越默契。短短几个月高效工作，对技能和协作能力的培养有了新的突破。</p></blockquote><h2 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h2><blockquote><p>你感觉最有成就的两、三件事，详细描述</p><ol><li>第一件事加入金和大家庭，在大家的协作帮助下，顺利的金和试用期考核。</li><li>金和模式的学习，一分钟一款全新app的产能，一百多万款app累计产出，从功能组件化到产品批量化，激发了浓厚的兴趣。开始了对金和app整个开发体系的学习，对组件开发模式的深入理解和运用，收获之多，也是喜出望外了。</li></ol></blockquote><h2 id="待改进"><a href="#待改进" class="headerlink" title="待改进"></a>待改进</h2><blockquote><p>你认为最有遗憾或者需要改进的几点</p><ol><li>试用期一直忙于工作，疏于锻炼，希望以后有机会参加公司的羽毛球协会，在运动技能方面大展拳脚。</li><li>开发效率的提高，在工作中对需求分析能力，和开发之初的设计能力的提高。</li><li>偏于独立，在协作上不够积极，还需克服心理障碍，充分发挥自己的长处。</li></ol></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote><p>你认为自己最不被同事或领导接受的事情或做法有哪些</p><ol><li>慢热型性格，在团队间的协作，缺乏积极性。</li></ol></blockquote><h2 id="榜样"><a href="#榜样" class="headerlink" title="榜样"></a>榜样</h2><blockquote><p>你认为同部门或兄弟部门中，哪两个人是你学习的榜样，主要学习他哪些品质，分别阐述</p><ol><li>李总，具有领导力，亲合力，坚持每日站立会议，能在会议上很轻松讲解需求，统筹全局，鼓舞大家的工作积极性，活跃团队间的协作氛围。</li><li>付克清，对需求理解分析能力强，在实际开发中快速预研试错，团队协作的积极性，万事提前做。</li></ol></blockquote><h2 id="改进计划"><a href="#改进计划" class="headerlink" title="改进计划"></a>改进计划</h2><blockquote><p>新的一年重点需要改进的内容和工作思路，需改进的内容设置成量化的指标，同时指定1位同事监督</p><ol><li>通过在实际开发迭代中，提高团队协作的积极性，提高工作效率，在需求分析和技术预研能力的提高。</li><li>坚持每周多读管理书籍，技术博客，按时更新博客总结工作经验。</li><li>坚持每月参加线下活动，丰富生活阅历，提高生活质量。</li></ol></blockquote><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><blockquote><p>按100分，给自己本年度整体打个分<br>85</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>千百度</title>
      <link href="/2018/01/06/podcast/%E5%8D%83%E7%99%BE%E5%BA%A6/"/>
      <url>/2018/01/06/podcast/%E5%8D%83%E7%99%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里就是简介的描写，千百度，很好听的歌曲<br><a id="more"></a><br>        <div id="aplayer-TBponabY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;width:70%;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-TBponabY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "千百度",              author: "许嵩",              url: "/images/qbd.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script></p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><div id="aplayer-orSlFwNu" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[ti:千百度][ar:梅朵][00:02.41] 千百度[00:04.08] 演唱：梅朵[00:05.11] 作词：李红雨[00:06.14] 作曲：刘牧[00:22.55] 春色已满园[00:26.53] 细雨缠绵桃花红[00:30.61] 花蝶飞舞[00:34.58] 伴着伊人轻入梦[00:38.68] 秋风凛凛[00:42.69] 冷雨纷飞枫叶红[00:46.84] 鸿雁南飞[00:50.86] 遥望伊人轻轻回[00:55.00] 悄悄的来又轻轻的去[00:59.12] 没留下一点你的消息[01:03.17] 久久的等待苦苦的追寻[01:07.09] 亲爱的人你在哪里[01:13.34] 梦中寻你千百度[01:17.27] 会不会痴心的错付[01:21.31] 日思夜想想憔悴[01:25.37] 曾想一生将你托付[01:49.94] 春色已满园[01:53.99] 细雨缠绵桃花红[01:58.07] 花蝶飞舞[02:02.07] 伴着伊人轻入梦[02:06.23] 秋风凛凛[02:10.18] 冷雨纷飞枫叶红[02:14.24] 鸿雁南飞[02:18.34] 遥望伊人轻轻回[02:22.37] 悄悄的来又轻轻的去[02:26.48] 没留下一点你的消息[02:30.59] 久久的等待苦苦的追寻[02:34.60] 亲爱的人你在哪里[02:40.75] 梦中寻你千百度[02:44.75] 会不会痴心的错付[02:48.89] 日思夜想想憔悴[02:52.95] 曾想一生将你托付[02:59.05] 悄悄的来又轻轻的去[03:03.09] 没留下一点你的消息[03:07.23] 久久的等待苦苦的追寻[03:11.24] 亲爱的人你在哪里[03:17.43] 梦中寻你千百度[03:21.51] 会不会痴心的错付[03:25.44] 日思夜想想憔悴[03:29.42] 曾想一生将你托付[03:35.66] 曾想一生将你托付</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-orSlFwNu"),narrow: false,autoplay: true,showlrc: 2,music: {title: "千百度",author: "许嵩",url: "/images/qbd.mp3",pic: "",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p>第一个播客测试了。</p>]]></content>
      
      
      <categories>
          
          <category> podcast </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> audio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20分钟个人秀</title>
      <link href="/2017/10/01/20%E5%88%86%E9%92%9F%E4%B8%AA%E4%BA%BA%E7%A7%80/"/>
      <url>/2017/10/01/20%E5%88%86%E9%92%9F%E4%B8%AA%E4%BA%BA%E7%A7%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="2分钟"><a href="#2分钟" class="headerlink" title="2分钟"></a>2分钟</h2><ol><li>毕业院校<br>郑州轻工业学院，刚毕业和三四个同学组建了一个工作室，主要业务是对各大电子图书馆的数据支持。我们通过资源清单和数据需求，会针对对报刊，电子书等各大网站进行爬取，期间自主开发了若干个爬虫工具不同模版，实现电子数据自动化收集整理，保证了产能产量维持日常花销，期间也开始自学了android相关开发。</li><li>地下室两年，鼎盛中天<br>进入一家创业型公司，在小团队里磨练了两年，主要担任移动端开发，有众信旅游ERP客户端，展会通，易购8<br>ERP 是实现了针对众信旅游导游在外办公的带团，预约审批相关终端业务。积累黑莓和android端的相关开发。<br>展会通：通过蓝牙技术实现近距离查找潜在合作伙伴的社交工具，主要场景例如展会大厅。积累了iOS端的通讯录/蓝牙交互/远程推送的一些经验。<br>易购8:一款简单的商品推荐app，通过服务器端返回的优质的商品来</li></ol><h2 id="10分钟"><a href="#10分钟" class="headerlink" title="10分钟"></a>10分钟</h2><ol><li>鹏宇成<br>进入鹏宇成，鹏保宝产品</li><li>创世泰克</li></ol><h2 id="10分钟-1"><a href="#10分钟-1" class="headerlink" title="10分钟"></a>10分钟</h2><ol start="3"><li>个人作品<br>CGContext.fill<br>‘translucent’ has been renamed to ‘isTranslucent’<br>oInsideMargin( Missing argument label ‘margin:’ in call<br>CGSizeMake<br>izontalSV( Missing argument label ‘view:’ in call)<h2 id="10分钟技术提高"><a href="#10分钟技术提高" class="headerlink" title="10分钟技术提高"></a>10分钟技术提高</h2></li><li>自学swift 并开发了mac端Reader</li><li>学习第三方框架，自动约束，SDimage  ，访问网络框架</li><li>项目管理工具pod私库制作<br>提高工作效率，学习了一些工具，可自动化部署工具：<br>技术块：docker部署，Jenkins，Fabric，server的bot<br>单元测试：测试用例开发框架quick，Nimble等框架<br>playground：测试代码</li></ol><p>有自己的github开源项目 ：工具包设计封装思想（代理接口，）</p><ol><li>歌词同步/定时关闭小工具（正则，计时器，站在SDK角度思考封装思想）</li><li>iOS/Mac日志搜集工具（session网络框架的取舍）（同时支持pod私库方式来安装依赖）</li><li>其他demo（动态单元格样式切换）</li></ol><p>设计模式（五个）及子类场景<br>创建型（单例模式），结构型（MVC，装饰者模式（扩展，委托），适配者模式，外观模式），行为型（观察者模式，备忘录模式）<br>如何打造一个舒心的框架</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C的运行时库</title>
      <link href="/2017/09/26/swift/Objective-C%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93/"/>
      <url>/2017/09/26/swift/Objective-C%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Objective-C-运行时"><a href="#Objective-C-运行时" class="headerlink" title="Objective-C 运行时"></a>Objective-C 运行时</h2><p>Objective-C 是一门基于运行时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立。这将给开发人员极高的灵活性，因为我们可以修改这些链接。而不同的是，Swift 绝大多数时候是一门面向编译时的语言。因此在 Swift 当中，灵活性受到了限制，不过您会因此得到更多的安全性。</p><h3 id="runtime-h开源库"><a href="#runtime-h开源库" class="headerlink" title="runtime.h开源库"></a>runtime.h开源库</h3><p>Objective-C 的运行时本质上是一个库。它负责了 “Objective” 这个部分，因此您所知、所爱的面向对象编程，都是在这里实现的。如果您想要访问里面的函数的话，只需要导入这个库即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><code>runtime.h</code>开源库主要由 C 和汇编编写而成，其实现了诸如类、对象、方法调度、协议等面向对象编程这个部分。</p><h4 id="成员结构体"><a href="#成员结构体" class="headerlink" title="成员结构体"></a>成员结构体</h4><p>在运行时中<code>对象</code>和<code>类</code>本质上是一个非常简单的结构体，在运行时环境下，我们就可以创建，读取，修改这些属性方法等，例如：使用<code>allocateClassPair</code>函数创建类。</p><ol><li><p><strong>对象结构体</strong><br>对象结构体中仅提供一个<strong><code>isa</code></strong>属性，是关联<code>类引用</code>的指针。这也就是 Objective-C 当中的所有对象都需要实现的。<br>在 <code>runtime.h</code> 当中对象的定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>类结构体</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">long</span> version;</span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>isa</strong>属性：建立自身与 <code>super_class</code> 这个值进行关联。<br><strong>super_class</strong>:除了 NSObject 这个类之外，super_class 的值永远不会为 nil，因为 Objective-C 当中的其余类都是以某种方式继承自 NSObject 的。<br><strong>ivars</strong>：变量列表，<strong>methodLists</strong>：方法列表，<strong>protocols</strong>：协议列表，其他属性：<code>name</code>、<code>version</code>、<code>info</code> 之类的值。  </p><ol start="3"><li><p><strong>变量结构体</strong><br>包含了变量类型和变量名称。偏移量 (offset) 则是内存管理方面的内容。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法结构体</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    <span class="keyword">char</span> *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>method_name</strong>： 方法名，使用<code>Selector</code>来表示方法编号，对应在 <code>performSelector</code> 当中所匹配的内容。<br><strong>method_types</strong>：方法类型，使用<code>char</code>字符来表示。<br><strong>method_imp</strong>：方法的实现，<code>IMP</code>是一个函数指针，方法实现的一种特定的表示方式，是方法混淆特性的根本所在。</p><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>运行时库提供一系列运行时函数，实现在运行时动态的对成员结构体（类/对象）进行创建，修改等相关操作，例如：创建类，在<code>类别</code>中添加存储属性</p><h5 id="动态创建运行时类"><a href="#动态创建运行时类" class="headerlink" title="动态创建运行时类"></a>动态创建运行时类</h5><p>在制作库框架会大量运用使用到运行时函数。如果您无法知道用户将会创建什么样的数据，那么您就需要在运行时进行类的创建了。Core Data 就使用了这个功能。此外，如果您愿意的话，它还可以用在 JSON 解析当中。<br>类的创建要用的 Objective-C 两个运行时函数：<code>allocateClassPair</code>和<code>objc_registerClassPair</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类函数的构造器</span></span><br><span class="line">Class myClass = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">"MyClass"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在这里添加变量、方法和协议</span></span><br><span class="line">objc_registerClassPair(myClass);</span><br><span class="line"><span class="comment">// 当类注册之后，变量列表将会被锁定</span></span><br><span class="line">[[myClass alloc] init];   <span class="comment">//可见这个运行时类和Objective-C创建的类毫无区别</span></span><br></pre></td></tr></table></figure></p><p><strong>[NSObject class]</strong>：就是<code>类结构体</code>的属性<strong>isa</strong>要关联的类引用<br><strong>“MyClass”</strong>：指定<code>类结构体</code>的<strong>name</strong>属性值<br>额外字节的定义：通常我们都直接赋值 0 即可</p><ol start="2"><li>添加变量、方法以及协议</li><li><code>registerClassPair</code>注册这个 ClassPair,注册之后，我们就无法修改变量列表了，不过其余的内容仍然可以修改。</li></ol><h5 id="为类别中新增存储属性"><a href="#为类别中新增存储属性" class="headerlink" title="为类别中新增存储属性"></a>为类别中新增存储属性</h5><p>类别可以在既有的类中添加函数、计算属性，无法添加存储属性。但是在运行时环境下，可以借助 <code>setAssociatedObject</code> 和 <code>getAssociatedObject</code>实现向既有的类当中添加存储属性。<br>例如在<code>NSObject</code>新增一个<code>Name</code>存储属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Name)</span><br><span class="line">@dynamic Name;</span><br><span class="line">- (void)setName:(id)object &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(Name), object,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (id)Name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(Name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="内省机制"><a href="#内省机制" class="headerlink" title="内省机制"></a>内省机制</h5><p>内省机制是用来判别这个类是否实现具备某项功能。当我们使用了一个带有可选方法的协议时，为了避免崩溃发生，可以借助这个<strong>内省机制</strong>来判断这个对象是否可以调用此可选方法。<br>内省机制提供了两个运行时函数<br><code>isMemberOfClass</code>: 对比两者的 <strong>isa</strong> 是否相同。<br><code>respondsToSelector</code>:则封装了一个运行时函数：<code>class_respondsToSelector</code>，两个参数<code>类</code>和 <code>Selector</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类成员判断</span></span><br><span class="line">[myObject isMemberOfClass:<span class="built_in">NSObject</span>.class];</span><br><span class="line"><span class="comment">//类方法判断</span></span><br><span class="line">[myObject respondsToSelector:<span class="keyword">@selector</span>(doStuff:)];</span><br><span class="line"><span class="comment">//等价上一句</span></span><br><span class="line">class_respondsToSelector(myObject.class, <span class="keyword">@selector</span>(doStuff:));</span><br></pre></td></tr></table></figure></p><h5 id="使用运行时实现单元测试"><a href="#使用运行时实现单元测试" class="headerlink" title="使用运行时实现单元测试"></a>使用运行时实现单元测试</h5><p>当我们在编写 <code>XCTestCase</code> 的时候，需要完成 <code>setUp</code> 和 <code>tearDown</code> 的设定，随后才能编写相关的 <code>test</code> 函数。当测试运行的时候，系统会自行遍历所有的测试函数，并自动运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">Method *methods = class_copyMethodList(myObject.class,&amp;count);  //方法列表</span><br><span class="line">//Ivar *list = class_copyIvarList(myObject.class,&amp;count);       //变量列表</span><br><span class="line"></span><br><span class="line">for(unsigned i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    SEL selector = method_getName(methods[i]);                  //获取到方法名</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(selector);  //转为字符串</span><br><span class="line">    if ([selectorString containsString:@&quot;test&quot;]) &#123;</span><br><span class="line">        [myObject performSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(methods);</span><br></pre></td></tr></table></figure></p><p>单元测试的原理就是借助了运行时函数<code>class_copyMethodList</code>获取到方法名，然后将其转换为字符串，检查其是否包含有 “test”，如果有便可以运行。</p><h5 id="运行时方法调度"><a href="#运行时方法调度" class="headerlink" title="运行时方法调度"></a>运行时方法调度</h5><p>动态的向对象当中添加方法并调用新增的方法。方法转发，方法混淆：替换或交换</p><ol><li><strong>动态的为类新增方法</strong><br>了解到运行时的方法的结构体组成：方法名，SEL和<code>IMP</code>实现，需要三个运行时函数来新建一个运行时方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">Method doStuff = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(doStuff));</span><br><span class="line"><span class="comment">//获取方法的实现</span></span><br><span class="line">IMP doStuffImplementation = method_getImplementation(doStuff);</span><br><span class="line"><span class="comment">//获取方法的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(doStuff); <span class="comment">//“v@:@"</span></span><br><span class="line"></span><br><span class="line">class_addMethod(myClass.class, <span class="keyword">@selector</span>(doStuff:), doStuffImplementation, types);</span><br></pre></td></tr></table></figure></li></ol><p><code>class_getInstanceMethod</code>:获取方法的<code>SEL</code><br><code>method_getImplementation</code>:方法的实现<code>IMP</code><br><code>method_getTypeEncoding</code>: 获取方法的类型，char字符表示<br><code>class_addMethod</code>: 向对象当中添加方法的运行时函数。它所需的参数，即上述方法结构体当中的那三个值：Selector、方法实现和方法类型。</p><ol start="2"><li><strong>调用运行时方法</strong><br>我们可以使用 <code>[self doStuff]</code> 或者<code>[self performSelector:@selector(doStuff)]</code>来进行调用。<br>实际上在运行时级别，它们都是借助 <code>objc_msgSend</code> 向对象发送了一个消息：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(message));</span><br></pre></td></tr></table></figure></li></ol><p>但是如果调用方法所在的对象为 nil 的时候，我们就会得到一个异常，应用便会崩溃。但事实证明，在崩溃之前会预留几个步骤，从而允许我们对某个不存在的函数进行一些操作：方法转发/替换等。</p><ol start="3"><li>方法转发<br>当桥接两个不同的框架的时候，可以将方法转发给其它目标，或者，当我们调用某个未实现的方法时，运行时有如下处理步骤：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1添加实例方法/类方法，如果 return YES，就会调用原始方法</span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">+(BOOL)resolveClassMethod:(SEL)sel;</span><br><span class="line">// 2 返回可以处理 Selector 的对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">// 3 创建 NSInvocation</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">// 4 在您所选择的目标上调用 Selector</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.1. 首先调用两个类方法：一个名为 <code>resolveInstanceMethod</code>/<code>resolveClassMethod</code>类方法，这时候我们便有机会来添加方法了，如果我们返回了 YES，就意味着原始方法将会再次被调用。<br>3.2.  <code>forwardingTargetForSelector</code>：当不要添加新方法时，可以直接返回需要调用方法的目标对象，之后这个对象就会调用 Selector。<br>3.3. <code>forwardInvocation</code>：实现目标对象调用 Selector，所有的调用过程都被封装到 <code>NSInvocation</code> 对象当中。需要 通过<code>methodSignatureForSelector</code>函数创建。</p><ol start="4"><li>动态特性方法混淆：替换或交换<br>方法混淆是通过 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 实现方法的替换。常用于日志记录和 Mock 测试。<br>当类加载之后，会调用一个名为 <code>load</code> 的类函数。由于我们只打算混淆一次，因此我们需要使用 <code>dispatch_once</code>。接着我们便可以得到该方法，然后使用 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 来替换方法。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(doSomething);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(mo_doSomething);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>,</span><br><span class="line">        originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>,</span><br><span class="line">        swizzledSelector);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector,</span><br><span class="line">                                method_getImplementation(swizzledMethod),</span><br><span class="line">                                method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>,swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVVM介绍</title>
      <link href="/2017/09/25/iOS/MVVM%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/09/25/iOS/MVVM%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：</p><p><img src="https://www.objccn.io/images/issues/issue-13/mvvm1.png" alt="Typical Model-View-Controller setup"></p><p>我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。</p><p>稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？</p><p><img src="https://www.objccn.io/images/issues/issue-13/intermediate.png" alt="Intermediate"></p><p>这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。</p><p>在典型的 MVC 应用里，<em>许多</em>逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 <code>NSDate</code> 转换为一个格式化过的 <code>NSString</code>。<br>我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：</p><p><img src="https://www.objccn.io/images/issues/issue-13/mvvm.png" alt="Model-View-ViewModel"></p><p>看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>现在我们知道了<em>什么</em>是 MVVM，但<em>为什么</em>我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。</p><p>此处有三个重点是我希望你看完本文能带走的：</p><ul><li>MVVM 可以兼容你当下使用的 MVC 架构。</li><li>MVVM 增加你的应用的可测试性。</li><li>MVVM 配合一个绑定机制效果最好。</li></ul><p>如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>让我们看一个简单的 <code>Person</code> Model 以及相应的 View Controller：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initwithSalutation:(<span class="built_in">NSString</span> *)salutation firstName:(<span class="built_in">NSString</span> *)firstName lastName:(<span class="built_in">NSString</span> *)lastName birthdate:(<span class="built_in">NSDate</span> *)birthdate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *salutation;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *birthdate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>现在我们假设我们有一个 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 里，只需要基于它的 <code>model</code> 属性设置一些 Label 即可。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.model.salutation.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.nameLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@ %@"</span>, <span class="keyword">self</span>.model.salutation, <span class="keyword">self</span>.model.firstName, <span class="keyword">self</span>.model.lastName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.nameLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>, <span class="keyword">self</span>.model.firstName, <span class="keyword">self</span>.model.lastName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    [dateFormatter setDateFormat:<span class="string">@"EEEE MMMM d, yyyy"</span>];</span><br><span class="line">    <span class="keyword">self</span>.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonViewModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPerson:(Person *)person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Person *person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *nameText;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *birthdateText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>我们的 View Model 的实现大概如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation PersonViewModel</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithPerson:(Person *)person &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line"></span><br><span class="line">    _person = person;</span><br><span class="line">    if (person.salutation.length &gt; 0) &#123;</span><br><span class="line">        _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];</span><br><span class="line">    _birthdateText = [dateFormatter stringFromDate:person.birthdate];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>我们已经将 <code>viewDidLoad</code> 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 <code>viewDidLoad</code> 就会非常轻量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.nameLabel.text = <span class="keyword">self</span>.viewModel.nameText;</span><br><span class="line">    <span class="keyword">self</span>.birthdateLabel.text = <span class="keyword">self</span>.viewModel.birthdateText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来<a href="http://objccn.io/issue-1/" target="_blank" rel="noopener">更轻量的 View Controllers</a>。</p><h3 id="可测试"><a href="#可测试" class="headerlink" title="可测试"></a>可测试</h3><p>View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SpecBegin(Person)</span><br><span class="line">NSString *salutation = @&quot;Dr.&quot;;</span><br><span class="line">NSString *firstName = @&quot;first&quot;;</span><br><span class="line">NSString *lastName = @&quot;last&quot;;</span><br><span class="line">NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class="line"></span><br><span class="line">it (@&quot;should use the salutation available. &quot;, ^&#123;</span><br><span class="line">    Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class="line">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class="line">    expect(viewModel.nameText).to.equal(@&quot;Dr. first last&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it (@&quot;should not use an unavailable salutation. &quot;, ^&#123;</span><br><span class="line">    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class="line">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class="line">    expect(viewModel.nameText).to.equal(@&quot;first last&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it (@&quot;should use the correct date format. &quot;, ^&#123;</span><br><span class="line">    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class="line">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class="line">    expect(viewModel.birthdateText).to.equal(@&quot;Thursday January 1, 1970&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">SpecEnd</span><br></pre></td></tr></table></figure></p><p>如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Label 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。</p><h3 id="响应式同步"><a href="#响应式同步" class="headerlink" title="响应式同步"></a>响应式同步</h3><p>注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。</p><p>在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。</p><p>我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看<a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="noopener">这篇博客</a>，它用更多细节解释了 MVVM 的好处，或者<a href="http://www.teehanlax.com/blog/krush-ios-architecture/" target="_blank" rel="noopener">这一篇</a>关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 <a href="https://github.com/AshFurrow/C-41" target="_blank" rel="noopener">C-41</a> ，它是开源的。去看看吧，如果你有任何疑问，请<a href="https://twitter.com/ashfurrow" target="_blank" rel="noopener">告诉我</a>。</p><hr><p><a href="http://objccn.io/issue-13" target="_blank" rel="noopener">话题 #13 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-13/mvvm.html" target="_blank" rel="noopener">Introduction to MVVM</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程安全类的设计</title>
      <link href="/2017/09/25/iOS/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/09/25/iOS/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这篇文章将专注于实用技巧，设计模式，以及对于写出线程安全类和使用 GCD 来说所特别需要注意的一些<a href="http://zh.wikipedia.org/wiki/反面模式" target="_blank" rel="noopener">反面模式</a>。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="Apple-的框架"><a href="#Apple-的框架" class="headerlink" title="Apple 的框架"></a>Apple 的框架</h3><p>首先让我们来看看 Apple 的框架。一般来说除非特别声明，大多数的类默认都不是线程安全的。对于其中的一些类来说，这是很合理的，但是对于另外一些来说就很有趣了。</p><p>就算是在经验丰富的 iOS/Mac 开发者，也难免会犯从后台线程去访问 UIKit/AppKit 这种错误。比如因为图片的内容本身就是从后台的网络请求中获取的话，顺手就在后台线程中设置了 <code>image</code> 之类的属性，这样的错误其实是屡见不鲜的。Apple 的代码都经过了性能的优化，所以即使你从别的线程设置了属性的时候，也不会产生什么警告。</p><p>在设置图片这个例子中，症结其实是你的改变通常要过一会儿才能生效。但是如果有两个线程在同时对图片进行了设定，那么很可能因为当前的图片被释放两次，而导致应用崩溃。这种行为是和时机有关系的，所以很可能在开发阶段没有崩溃，但是你的用户使用时却不断 crash。</p><p>现在没有<strong>官方</strong>的用来寻找类似错误的工具，但我们确实有一些技巧来避免这个问题。<a href="https://gist.github.com/steipete/5664345" target="_blank" rel="noopener">UIKit Main Thread Guard</a> 是一段用来监视每一次对 <code>setNeedsLayout</code> 和 <code>setNeedsDisplay</code> 的调用代码，并检查它们是否是在主线程被调用的。因为这两个方法在 UIKit 的 setter （包括 image 属性）中广泛使用，所以它可以捕获到很多线程相关的错误。虽然这个小技巧并不包含任何私有 API， 但我们还是不建议将它是用在发布产品中，不过在开发过程中使用的话还是相当赞的。</p><p>Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。</p><h4 id="为什么-UIKit-不是线程安全的？"><a href="#为什么-UIKit-不是线程安全的？" class="headerlink" title="为什么 UIKit 不是线程安全的？"></a>为什么 UIKit 不是线程安全的？</h4><p>对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。将 non-atomic 的属性变为 atomic 的属性只不过是需要做的变化里的微不足道的一小部分。</p><ol><li>通常来说，UI需要同时改变若干个属性，才能看到它所带来的结果。为了解决这个问题，苹果可能不得不提供像 Core Data 中的 <code>performBlock:</code> 和 <code>performBlockAndWait:</code> 那样类似的方法来同步变更。</li><li>绝大多数对 UIKit 类的调用其实都是以<strong>配置</strong>为目的的，这使得将 UIKit 改为线程安全这件事情更显得毫无意义了。</li></ol><p>然而即使是那些与配置共享的内部状态之类事情无关的调用，其实也不是线程安全的。如果你做过 iOS 3.2 或之前的黑暗年代的 app 开发的话，你肯定有过一边在后台准备图像时一边使用 NSString 的 <code>drawInRect:withFont:</code> 时的随机崩溃的经历。值得庆幸的事，在 iOS 4 中 <a href="http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html" target="_blank" rel="noopener">苹果将大部分绘图的方法和诸如 <code>UIColor</code> 和 <code>UIFont</code> 这样的类改写为了后台线程可用</a>。</p><p>但不幸的是 Apple 在线程安全方面的文档是极度匮乏的。他们推荐只访问主线程，并且甚至是绘图方法他们都没有明确地表示保证线程安全。因此在阅读文档的同时，去读读 <a href="http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html" target="_blank" rel="noopener">iOS 版本更新说明</a>会是一个很好的选择。</p><p>对于大多数情况来说，UIKit 类确实只应该用在应用的主线程中。这对于那些继承自 UIResponder 的类以及那些操作你的应用的用户界面的类来说，不管如何都是很正确的。</p><h4 id="内存回收-deallocation-问题"><a href="#内存回收-deallocation-问题" class="headerlink" title="内存回收 (deallocation) 问题"></a>内存回收 (deallocation) 问题</h4><p>另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。Apple 在技术笔记 <a href="http://developer.apple.com/library/ios/#technotes/tn2109/_index.html" target="_blank" rel="noopener">TN2109</a> 中概述了这个问题，并提供了多种解决方案。<br>这个问题其实是要求 UI 对象应该在主线程中被回收，因为在它们的 <code>dealloc</code> 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行。</p><p>因为调用者被其他线程持有是非常常见的（不管是由于 operation 还是 block 所导致的），这也是很容易犯错并且难以被修正的问题。在 <a href="https://github.com/AFNetworking/AFNetworking/issues/56" target="_blank" rel="noopener">AFNetworking 中也一直长久存在这样的 bug</a>，但是由于其自身的隐蔽性而鲜为人知，也很难重现其所造成的崩溃。在异步的 block 或者操作中一致使用 <code>__weak</code>，并且不去直接访问局部变量会对避开这类问题有所帮助。</p><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><p>Apple 有一个<a href="https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1" target="_blank" rel="noopener">针对 iOS 和 Mac 的很好的总览性文档</a>，为大多数基本的 foundation 类列举了其线程安全特性。<br>总的来说，比如 <code>NSArry</code> 这样不可变类是线程安全的。然而它们的可变版本，比如 <code>NSMutableArray</code> 是线程不安全的。<br>事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。要记住的是即使你申明了返回类型是不可变的，方法里还是有可能返回的其实是一个可变版本的集合类。<br>一个好习惯是写类似于 <code>return [array copy]</code> 这样的代码来确保返回的对象事实上是不可变对象。</p><p>与和<a href>Java</a>这样的语言不一样，Foundation 框架并不提供直接可用的集合类，这是有其道理的，因为大多数情况下，你想要的是在更高层级上的锁，以避免太多的加解锁操作。但缓存是一个值得注意的例外，iOS 4 中 Apple 添加的 <code>NSCache</code> 使用一个可变的字典来存储不可变数据，它不仅会对访问加锁，更甚至在低内存情况下会清空自己的内容。</p><p>也就是说，在你的应用中存在可变的且线程安全的字典是可以做到的。借助于 class cluster 的方式，我们也很容易<a href="https://gist.github.com/steipete/5928916" target="_blank" rel="noopener">写出这样的代码</a>。</p><h3 id="原子属性-Atomic-Properties"><a href="#原子属性-Atomic-Properties" class="headerlink" title="原子属性 (Atomic Properties)"></a>原子属性 (Atomic Properties)</h3><p>你曾经好奇过 Apple 是怎么处理 atomic 的设置/读取属性的么？至今为止，你可能听说过自旋锁 (spinlocks)，信标 (semaphores)，锁 (locks)，@synchronized 等，Apple 用的是什么呢？因为 <a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Objctive-C 的 runtime 是开源</a>的，所以我们可以一探究竟。</p><p>一个非原子的 setter 看起来是这个样子的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUserName:(<span class="built_in">NSString</span> *)userName &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName != _userName) &#123;</span><br><span class="line">        [userName <span class="keyword">retain</span>];</span><br><span class="line">        [_userName release];</span><br><span class="line">        _userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个手动 retain/release 的版本，ARC 生成的代码和这个看起来也是类似的。当我们看这段代码时，显而易见要是 <code>setUserName:</code> 被并发调用的话会造成麻烦。我们可能会释放 <code>_userName</code> 两次，这回使内存错误，并且导致难以发现的 bug。</p><p>对于任何没有手动实现的属性，编译器都会生成一个 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Accessors.subproj/objc-accessors.mm#L127" target="_blank" rel="noopener"><code>objc_setProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</code></a> 的调用。在我们的例子中，这个调用的参数是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setProperty_non_gc(<span class="keyword">self</span>, _cmd,</span><br><span class="line">(ptrdiff_t)(&amp;_userName) - (ptrdiff_t)(<span class="keyword">self</span>), userName, <span class="literal">NO</span>, <span class="literal">NO</span>);`</span><br></pre></td></tr></table></figure></p><p><code>ptrdiff_t</code> 可能会吓到你，但是实际上这就是一个简单的指针算术，因为其实 Objective-C 的类仅仅只是 C 结构体而已。</p><p><code>objc_setProperty</code> 调用的是如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue,</span><br><span class="line">ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:NULL];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:NULL];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];</span><br><span class="line">        _spin_lock(slotlock);</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">        _spin_unlock(slotlock);</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除开方法名字很有趣以外，其实方法实际做的事情非常直接，它使用了在 <code>PropertyLocks</code> 中的 128 个自旋锁中的 1 个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作。</p><p>虽然这些方法没有定义在任何公开的头文件中，但我们还是可用手动调用他们。我不是说这是一个好的做法，但是知道这个还是蛮有趣的，而且如果你想要同时实现原子属性<strong>和</strong>自定义的 setter 的话，这个技巧就非常有用了。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动声明运行时的方法</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> objc_setProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset,</span><br><span class="line"><span class="keyword">id</span> newValue, <span class="built_in">BOOL</span> atomic, <span class="built_in">BOOL</span> shouldCopy);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset,</span><br><span class="line"><span class="built_in">BOOL</span> atomic);</span><br><span class="line"></span><br><span class="line"><span class="meta">#define PSTAtomicRetainedSet(dest, src) objc_setProperty(self, _cmd,</span></span><br><span class="line">(ptrdiff_t)(&amp;dest) - (ptrdiff_t)(<span class="keyword">self</span>), src, <span class="literal">YES</span>, <span class="literal">NO</span>)</span><br><span class="line"><span class="meta">#define PSTAtomicAutoreleasedGet(src) objc_getProperty(self, _cmd,</span></span><br><span class="line">(ptrdiff_t)(&amp;src) - (ptrdiff_t)(<span class="keyword">self</span>), <span class="literal">YES</span>)</span><br></pre></td></tr></table></figure></p><p><a href="https://gist.github.com/steipete/5928690" target="_blank" rel="noopener">参考这个 gist</a> 来获取包含处理结构体的完整的代码，但是我们其实并不推荐使用它。</p><h4 id="为何不用-synchronized-？"><a href="#为何不用-synchronized-？" class="headerlink" title="为何不用 @synchronized ？"></a>为何不用 @synchronized ？</h4><p>你也许会想问为什么苹果不用 <code>@synchronized(self)</code> 这样一个已经存在的运行时特性来锁定属？？你可以看看<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm#L291" target="_blank" rel="noopener">这里的源码</a>，就会发现其实发生了很多的事情。Apple 使用了<a href="http://googlemac.blogspot.co.at/2006/10/synchronized-swimming.html" target="_blank" rel="noopener">最多三个加/解锁序列</a>，还有一部分原因是他们也添加了<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3" target="_blank" rel="noopener">异常开解(exception unwinding)</a>机制。相比于更快的自旋锁方式，这种实现要慢得多。由于设置某个属性一般来说会相当快，因此自旋锁更适合用来完成这项工作。<code>@synchonized(self)</code> 更适合使用在你需要确保在发生错误时代码不会死锁，而是抛出异常的时候。</p><h3 id="你自己的类"><a href="#你自己的类" class="headerlink" title="你自己的类"></a>你自己的类</h3><p>单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到<a href="http://objccn.io/issue-3-1" target="_blank" rel="noopener">竞态条件</a>的困扰。看看下面的代码片段：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.contents) &#123;</span><br><span class="line">    <span class="built_in">CFAttributedStringRef</span> stringRef = <span class="built_in">CFAttributedStringCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">    (__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.contents, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 渲染字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我之前在 <a href="http://pspdfkit.com" target="_blank" rel="noopener">PSPDFKit</a> 中就犯了这个错误。时不时地应用就会因为 <code>contents</code> 属性在通过检查之后却又被设成了 nil 而导致 EXC_BAD_ACCESS 崩溃。捕获这个变量就可以简单修复这个问题；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *contents = self.contents;</span><br><span class="line">if (contents) &#123;</span><br><span class="line">    CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL,</span><br><span class="line">    (__bridge CFStringRef)contents, NULL);</span><br><span class="line">    // 渲染字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里这样就能解决问题，但是大多数情况下不会这么简单。<br>想象一下我们还有一个 <code>textColor</code> 的属性，我们在一个线程中将两个属性都做了改变。我们的渲染线程有可能使用了新的内容，但是依旧保持了旧的颜色，于是我们得到了一组奇怪的组合。这其实也是为什么 Core Data 要将 model 对象都绑定在一个线程或者队列中的原因。</p><p>对于这个问题，其实没有万用解法。使用 <a href="http://www.cocoawithlove.com/2008/04/value-of-immutable-values.html" target="_blank" rel="noopener">不可变模型</a>是一个可能的方案，但是它也有自己的问题。另一种途径是限制对存在在主线程或者某个特定队列中的既存对象的改变，而是先进行一次拷贝之后再在工作线程中使用。对于这个问题的更多对应方法，我推荐阅读 Jonathan Sterling 的关于 <a href="http://www.jonmsterling.com/posts/2012-12-27-a-pattern-for-immutability.html" target="_blank" rel="noopener">Objective-C 中轻量化不可变对象</a>的文章。</p><p>一个简单的解决办法是使用 <code>@synchronize</code>。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。</p><h4 id="可行的线程安全设计"><a href="#可行的线程安全设计" class="headerlink" title="可行的线程安全设计"></a>可行的线程安全设计</h4><p>在尝试写一些线程安全的东西之前，应该先想清楚是不是真的需要。确保你要做的事情不会是过早优化。如果要写的东西是一个类似配置类 (configuration class) 的话，去考虑线程安全这种事情就毫无意义了。更正确的做法是扔一个断言上去，以保证它被正确地使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PSPDFAssertIfNotMainThread(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="built_in">NSAssert</span>(<span class="built_in">NSThread</span>.isMainThread,</span><br><span class="line"><span class="string">@"Error: Method needs to be called on the main thread. %@"</span>,</span><br><span class="line">[<span class="built_in">NSThread</span> callStackSymbols]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 <code>dispatch_queue</code> 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。一旦你使用多个队列来给不同的部分上锁的话，整件事情很快就会变得难以控制了。</p><p>于是你也可以重新组织你的代码，这样某些特定的锁就不再需要了。看看下面这段实现了一种多委托的代码（其实在大多数情况下，用 NSNotifications 会更好，但是其实也还是有<a href="https://code.google.com/r/riky-adsfasfasf/source/browse/Utilities/GCDMulticastDelegate.h" target="_blank" rel="noopener">多委托的实用例子</a>）的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *delegates;</span><br><span class="line"></span><br><span class="line">// init方法中</span><br><span class="line">_delegateQueue = dispatch_queue_create(&quot;com.PSPDFKit.cacheDelegateQueue&quot;,</span><br><span class="line">DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123;</span><br><span class="line">    dispatch_barrier_async(_delegateQueue, ^&#123;</span><br><span class="line">        [self.delegates addObject:delegate];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAllDelegates &#123;</span><br><span class="line">    dispatch_barrier_async(_delegateQueue, ^&#123;</span><br><span class="line">        self.delegates removeAllObjects];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callDelegateForX &#123;</span><br><span class="line">    dispatch_sync(_delegateQueue, ^&#123;</span><br><span class="line">        [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">            // 调用delegate</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除非 <code>addDelegate:</code> 或者 <code>removeDelegate:</code> 每秒要被调用上千次，否则我们可以使用一个相对简洁的实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">@property (atomic, copy) NSSet *delegates;</span><br><span class="line"></span><br><span class="line">- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.delegates = [self.delegates setByAddingObject:delegate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAllDelegates &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.delegates = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callDelegateForX &#123;</span><br><span class="line">    [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        // 调用delegate</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就算这样，这个例子还是有点理想化，因为其他人可以把变更限制在主线程中。但是对于很多数据结构，可以在可变更操作的方法中创建不可变的拷贝，这样整体的代码逻辑上就不再需要处理过多的锁了。</p><h2 id="GCD-的陷阱"><a href="#GCD-的陷阱" class="headerlink" title="GCD 的陷阱"></a>GCD 的陷阱</h2><p>对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。然后，GCD 中还是有不少陷阱，我们在这里探索一下其中的一些。</p><h3 id="将-GCD-当作递归锁使用"><a href="#将-GCD-当作递归锁使用" class="headerlink" title="将 GCD 当作递归锁使用"></a>将 GCD 当作递归锁使用</h3><p>GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 <code>@synchronized</code> 有很大区别。 GCD队列并非是<a href="http://zh.wikipedia.org/w/index.php?title=可重入&amp;variant=zh-cn" target="_blank" rel="noopener">可重入</a>的，因为这将破坏队列的特性。很多有试图使用 <code>dispatch_get_current_queue()</code> 来绕开这个限制，但是这是一个<a href="https://gist.github.com/steipete/3713233" target="_blank" rel="noopener">糟糕的做法</a>，Apple 在 iOS6 中将这个方法标记为废弃，自然也是有自己的理由。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// This is a bad idea.</span><br><span class="line">inline void pst_dispatch_sync_reentrant(dispatch_queue_t queue,</span><br><span class="line">dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_get_current_queue() == queue ? block() : dispatch_sync(queue, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对当前的队列进行测试也许在简单情况下可以行得通，但是一旦你的代码变得复杂一些，并且你可能有多个队列在同时被锁住的情况下，这种方法很快就悲剧了。一旦这种情况发生，几乎可以肯定的是你会遇到<a href="http://objccn.io/issue-2-1/#dead_locks" target="_blank" rel="noopener">死锁</a>。当然，你可以使用 <code>dispatch_get_specific()</code>，这将截断整个队列结构，从而对某个特定的队列进行测试。要这么做的话，你还得为了在队列中附加标志队列的元数据，而去写自定义的队列构造函数。嘛，最好别这么做。其实在实用中，使用 <code>NSRecursiveLock</code> 会是一个更好的选择。</p><h3 id="用-dispatch-async-修复时序问题"><a href="#用-dispatch-async-修复时序问题" class="headerlink" title="用 dispatch_async 修复时序问题"></a>用 dispatch_async 修复时序问题</h3><p>在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// Some UIKit call that had timing issues but works fine</span></span><br><span class="line">    <span class="comment">// in the next runloop.</span></span><br><span class="line">    [<span class="keyword">self</span> updatePopoverSize];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的”时序问题”。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。</p><p>记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 <code>performSelector:afterDelay:</code> 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。</p><h3 id="在性能关键的代码中混用-dispatch-sync-和-dispatch-async"><a href="#在性能关键的代码中混用-dispatch-sync-和-dispatch-async" class="headerlink" title="在性能关键的代码中混用 dispatch_sync 和 dispatch_async"></a>在性能关键的代码中混用 dispatch_sync 和 dispatch_async</h3><p>这个问题我花了好久来研究。在 <a href="http://pspdfkit.com" target="_blank" rel="noopener">PSPDFKit</a> 中有一个使用了 LRU（最久未使用）算法列表的缓存类来记录对图片的访问。当你在页面中滚动时，这个方法将被调用<strong>非常多次</strong>。最初的实现使用了 <code>dispatch_sync</code> 来进行实际有效的访问，使用 <code>dispatch_async</code> 来更新 LRU 列表的位置。这导致了帧数远低于原来的 60 帧的目标。</p><p>当你的 app 中的其他运行的代码阻挡了 GCD 线程的时候，dispatch manager 需要花时间去寻找能够执行 dispatch_async 代码的线程，这有时候会花费一点时间。在找到合适的执行线程之前，你的同步调用就会被 block 住了。其实在这个例子中，异步情况的执行顺序并不是很重要，但没有能将这件事情告诉 GCD 的好办法。读/写锁这里并不能起到什么作用，因为在异步操作中基本上一定会需要进行顺序写入，而在此过程中读操作将被阻塞住。如果误用了 <code>dispatch_async</code> 代价将会是非常惨重的。在将它用作锁的时候，一定要非常小心。</p><h3 id="使用-dispatch-async-来派发内存敏感的操作"><a href="#使用-dispatch-async-来派发内存敏感的操作" class="headerlink" title="使用 dispatch_async 来派发内存敏感的操作"></a>使用 dispatch_async 来派发内存敏感的操作</h3><p>我们已经谈论了很多关于 NSOperations 的话题了，一般情况下，使用这个更高层级的 API 会是一个好主意。当你要处理一段内存敏感的操作的代码块时，这个优势尤为突出、</p><p>在 PSPDFKit 的老版本中，我用了 GCD 队列来将已缓存的 JPG 图片写到磁盘中。当 retina 的 iPad 问世之后，这个操作出现了问题。ß因为分辨率翻倍了，相比渲染这张图片，将它编码花费的时间要长得多。所以，操作堆积在了队列中，当系统繁忙时，甚至有可能因为内存耗尽而崩溃。</p><p>我们没有办法追踪有多少个操作在队列中等待运行（除非你手动添加了追踪这个的代码），我们也没有现成的方法来在接收到低内存通告的时候来取消操作、这时候，切换到 NSOperations 可以使代码变得容易调试得多，并且允许我们在不添加手动管理的代码的情况下，做到对操作的追踪和取消。</p><p>当然也有一些不好的地方，比如你不能在你的 <code>NSOperationQueue</code> 中设置目标队列（就像 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 之于 缓速 I/O 那样）。但这只是为了可调试性的一点小代价，而事实上这也帮助你避免遇到<a href="http://objccn.io/issue-2-1/#priority_inversion" target="_blank" rel="noopener">优先级反转</a>的问题。我甚至不推荐直接使用已经包装好的 <code>NSBlockOperation</code> 的 API，而是建议使用一个 NSOperation 的真正的子类，包括实现其 description。诚然，这样做工作量会大一些，但是能输出所有运行中/准备运行的操作是及其有用的。</p><hr><p><a href="http://objccn.io/issue-2" target="_blank" rel="noopener">话题 #2 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-2/thread-safe-class-design.html" target="_blank" rel="noopener">Thread-Safe Class Design</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GCD底层并发API</title>
      <link href="/2017/09/25/iOS/GCD%E5%BA%95%E5%B1%82%E5%B9%B6%E5%8F%91API/"/>
      <url>/2017/09/25/iOS/GCD%E5%BA%95%E5%B1%82%E5%B9%B6%E5%8F%91API/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这篇文章里，我们将会讨论一些 iOS 和 OS X 都可以使用的底层 API。除了 <code>dispatch_once</code> ，我们一般不鼓励使用其中的任何一种技术。</p><p>但是我们想要揭示出表面之下深层次的一些可利用的方面。这些底层的 API 提供了大量的灵活性，随之而来的是大量的复杂度和更多的责任。在我们的文章<a href="http://objccn.io/issue-2-2/" target="_blank" rel="noopener">常见的后台实践</a>中提到的高层的 API 和模式能够让你专注于手头的任务并且免于大量的问题。通常来说，高层的 API 会提供更好的性能，除非你能承受起使用底层 API 带来的纠结于调试代码的时间和努力。</p><p>尽管如此，了解深层次下的软件堆栈工作原理还是有很有帮助的。我们希望这篇文章能够让你更好的了解这个平台，同时，让你更加感谢这些高层的 API。</p><p>首先，我们将会分析大多数组成 <em>Grand Central Dispatch</em> 的部分。它已经存在了好几年，并且苹果公司持续添加功能并且改善它。现在苹果已经将其开源，这意味着它对其他平台也是可用的了。最后，我们将会看一下<a href="#atomic_operations">原子操作</a>——另外的一种底层代码块的集合。</p><p>或许关于并发编程最好的书是 <em>M. Ben-Ari</em> 写的《Principles of Concurrent Programming》,<a href="https://en.wikipedia.org/wiki/Special:BookSources/0-13-701078-8" target="_blank" rel="noopener">ISBN 0-13-701078-8</a>。如果你正在做任何与并发编程有关的事情，你需要读一下这本书。这本书已经30多年了，仍然非常卓越。书中简洁的写法，优秀的例子和练习，带你领略并发编程中代码块的基本原理。这本书现在已经绝版了，但是它的一些复印版依然广为流传。有一个新版书，名字叫《Principles of Concurrent and Distributed Programming》,<a href="https://en.wikipedia.org/wiki/Special:BookSources/0-321-31283-X" target="_blank" rel="noopener">ISBN 0-321-31283-X</a>,好像有很多相同的地方，不过我还没有读过。</p><h2 id="常用的GCD"><a href="#常用的GCD" class="headerlink" title="常用的GCD"></a>常用的GCD</h2><h3 id="单例：dispatch-once"><a href="#单例：dispatch-once" class="headerlink" title="单例：dispatch_once"></a>单例：dispatch_once</h3><p>或许GCD中使用最多并且被滥用功能的就是 <code>dispatch_once</code> 了。正确的用法看起来是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIColor</span> *)boringColor;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">UIColor</span> *color;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.380</span>f green:<span class="number">0.376</span>f blue:<span class="number">0.376</span>f alpha:<span class="number">1.000</span>f];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用 <code>dispatch_once_t</code> 会使得测试变得非常困难（单例和测试不是很好配合）。</p><p>要确保 <code>onceToken</code> 被声明为 <code>static</code> ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。换句话说，<strong>不要</strong>把 <code>dispatch_once_t</code> 作为一个对象的成员变量，或者类似的情形。</p><p>退回到远古时代（其实也就是几年前），人们会使用 <code>pthread_once</code> ，因为 <code>dispatch_once_t</code> 更容易使用并且不易出错，所以你永远都不会再用到 <code>pthread_once</code> 了。</p><h3 id="延后执行：dispatch-after"><a href="#延后执行：dispatch-after" class="headerlink" title="延后执行：dispatch_after"></a>延后执行：dispatch_after</h3><p>它能使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。一般用法是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</span><br><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">[<span class="keyword">self</span> bar];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一眼看上去这段代码是极好的。但是这里存在一些缺点。我们不能（直接）取消我们已经提交到 <code>dispatch_after</code> 的代码，它将会运行。</p><h4 id="时序性bug"><a href="#时序性bug" class="headerlink" title="时序性bug"></a>时序性bug</h4><p>当人们使用 <code>dispatch_after</code> 去处理他们代码中存在的时序 bug 时，会存在一些有问题的倾向。一些代码执行的过早而你很可能不知道为什么会这样，所以你把这段代码放到了 <code>dispatch_after</code> 中，现在一切运行正常了。但是几周以后，之前的工作不起作用了。由于你并不十分清楚你自己代码的执行次序，调试代码就变成了一场噩梦。所以不要像上面这样做。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>大多数的情况下，你最好把代码放到正确的位置。如果代码放到 <code>-viewWillAppear</code> 太早，那么或许 <code>-viewDidAppear</code> 就是正确的地方。<br>通过在自己代码中建立直接调用（类似 <code>-viewDidAppear</code> ）而不是依赖于  <code>dispatch_after</code> ，你会为自己省去很多麻烦。</p><h4 id="推荐场景"><a href="#推荐场景" class="headerlink" title="推荐场景"></a>推荐场景</h4><p>如果你需要一些事情在某个特定的时刻运行，那么 <code>dispatch_after</code> 或许会是个好的选择。确保同时考虑了 <code>NSTimer</code>，这个API虽然有点笨重，但是它允许你取消定时器的触发。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>GCD是一个很大抽象层级用户 API，提供管理线程池队列的管理。<br>当使用 GCD 来完成并发的工作时，你不必考虑线程方面的问题，只需考虑队列和功能点（提交给队列的 block）。虽然往下深究，依然都是线程，但是 GCD 的抽象层级为你惯用的编码提供了更好的方式。<br>隔离队列：默认情况下，它们是串行的，也就是说，任何给定的时间内，只能有一个单独的 block 运行。<br>并行队列：同一时间内允许多个 block 一起执行。<br>GCD 中一个基本的代码块就是队列。下面我们会给出一些如何使用它的例子。当使用队列的时候，给它们一个明显的标签会帮自己不少忙。在调试时，这个标签会在 Xcode (和 lldb)中显示，这会帮助你了解你的 app 是由什么决定的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.isolation.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.work.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        <span class="keyword">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="解决扇出问题"><a href="#解决扇出问题" class="headerlink" title="解决扇出问题"></a>解决扇出问题</h4><p>队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程，并且想要做一些并发的事情，我们很可能将我们的工作分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当我们处理这些功能点时，可能会调用一些函数作为功能的一部分。写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在，你有了 8 × 8 = 64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。</p><h4 id="GCD中创建线程"><a href="#GCD中创建线程" class="headerlink" title="GCD中创建线程"></a>GCD中创建线程</h4><p>GCD 通过创建所谓的<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern" target="_blank" rel="noopener">线程池</a>来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。</p><h4 id="线程阻塞问题"><a href="#线程阻塞问题" class="headerlink" title="线程阻塞问题"></a>线程阻塞问题</h4><p>如果你的代码阻塞了许多线程，这会带来很大的问题。首先，线程消耗资源，此外，创建线程会变得代价高昂。创建过程需要一些时间。并且在这段时间中，GCD 无法以全速来完成功能点。有不少能够导致线程阻塞的情况，但是最常见的情况与 I/O 有关，也就是从文件或者网络中读写数据。正是因为这些原因，你不应该在GCD队列中以阻塞的方式来做这些操作。看一下下面的<a href="#input_output">输入输出</a>段落去了解一些关于如何以 GCD 运行良好的方式来做 I/O 操作的信息。</p><h3 id="目标队列"><a href="#目标队列" class="headerlink" title="目标队列"></a>目标队列</h3><p>目标队列可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 <code>lldb</code>。<code>(lldb) thread list</code> 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。<br>如果一个队列的目标队列是串行的（也就是非并发），那么实际上这个队列也会转换为一个串行队列。<br>你能够为你创建的任何一个队列设置一个<strong>目标队列</strong>。这会是很强大的，并且有助于调试。</p><p>使用私有队列同样强调封装性。这时你自己的队列，你要自己决定如何使用它。</p><h4 id="队列转发控制"><a href="#队列转发控制" class="headerlink" title="队列转发控制"></a>队列转发控制</h4><p>默认情况下，一个新创建的队列转发到默认优先级的全局队列中。我们就将会讨论一些有关优先级的东西。</p><p>你可以改变你队列转发到的队列——你可以设置自己队列的目标队列。以这种方式，你可以将不同队列链接在一起。你的 <code>Foo</code> 类有一个队列，该队列转发到 <code>Bar</code> 类的队列，<code>Bar</code> 类的队列又转发到全局队列。</p><p>当你为了隔离目的而使用一个队列时，这会非常有用。<code>Foo</code> 有一个隔离队列，并且转发到 <code>Bar</code> 的隔离队列，与 <code>Bar</code> 的隔离队列所保护的有关的资源，会自动成为线程安全的。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>你可以通过设置目标队列为一个全局队列来改变自己队列的优先级，但是你应该克制这么做的冲动。</p><p>在大多数情况下，改变优先级不会使事情照你预想的方向运行。一些看起简单的事情实际上是一个非常复杂的问题。你很容易会碰到一个叫做<a href="http://en.wikipedia.org/wiki/Priority_inversion" target="_blank" rel="noopener">优先级反转</a>的情况。我们的文章<a href="http://objccn.io/issue-2-1/#priority_inversion" target="_blank" rel="noopener">《并发编程：API 及挑战》</a>有更多关于这个问题的信息，这个问题几乎导致了NASA的探路者火星漫游器变成砖头。</p><p>此外，使用 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 队列时，你需要格外小心。除非你理解了 <em>throttled I/O</em> 和 <em>background status as per setpriority(2)</em> 的意义，否则不要使用它。不然，系统可能会以难以忍受的方式终止你的 app 的运行。打算以不干扰系统其他正在做 I/O 操作的方式去做 I/O 操作时，一旦和优先级反转情况结合起来，这会变成一种危险的情况。</p><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>隔离队列是 GCD 队列使用中非常普遍的一种模式。这里有两个变种。</p><h3 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h3><p>多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。</p><p>我们在<a href="http://objccn.io/issue-2-1/#shared_resources" target="_blank" rel="noopener">有关多线程技术的文章</a>中讨论了<em>资源</em>在并发编程中意味着什么，它通常就是一块内存或者一个对象，每次只有一个线程可以访问它。</p><h4 id="串行队列读写共享资源"><a href="#串行队列读写共享资源" class="headerlink" title="串行队列读写共享资源"></a>串行队列读写共享资源</h4><p>举例来说，我们需要以多线程（或者多个队列）方式访问 <code>NSMutableDictionary</code> 。我们可能会照下面的代码来做：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.isolationQueue, ^()&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.counts removeObjectForKey:key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.counts[key] = @(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSUInteger</span> count;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.isolationQueue, ^()&#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *n = <span class="keyword">self</span>.counts[key];</span><br><span class="line">        count = [n unsignedIntegerValue];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过以上代码，只有一个线程可以访问 <code>NSMutableDictionary</code> 的实例。</p><p>注意以下四点：</p><ol><li>不要使用上面的代码，请先阅读<a href="#multiple_readers_single_writer">多读单写</a>和<a href="#contention">锁竞争</a></li><li>我们使用 <code>async</code> 方式来保存值，这很重要。我们不想也不必阻塞当前线程只是为了等待<em>写操作</em>完成。当读操作时，我们使用 <code>sync</code> 因为我们需要返回值。</li><li>从函数接口可以看出，<code>-setCount:forKey:</code> 需要一个 <code>NSString</code> 参数，用来传递给 <code>dispatch_async</code>。函数调用者可以自由传递一个 <code>NSMutableString</code> 值并且能够在函数返回后修改它。因此我们<em>必须</em>对传入的字符串使用 <em>copy</em> 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 <code>NSString</code> 类型），调用<em>copy</em>基本上是个空操作。</li><li><code>isolationQueue</code> 创建时，参数 <code>dispatch_queue_attr_t</code> 的值必须是<em>DISPATCH_QUEUE_SERIAL</em>（或者0）。</li></ol><p><a id="multiple_readers_single_writer" name="multiple_readers_single_writer"> </a></p><h4 id="barrier分发block实现并行队列多读单写"><a href="#barrier分发block实现并行队列多读单写" class="headerlink" title="barrier分发block实现并行队列多读单写"></a><strong>barrier</strong>分发block实现并行队列多读单写</h4><p>我们能够改善上面的那个例子。GCD 有可以让多线程运行的并发队列。我们能够安全地使用多线程来从 <code>NSMutableDictionary</code> 中读取只要我们不同时修改它。<br>我们使用 <em>barrier</em> 来分发一个block实现对字典的多读单写操作。这样的一个 block 的运行时机是，<strong>在它之前所有计划好的 block 完成之后，并且在所有它后面的 block 运行之前</strong>。</p><p>以如下方式创建队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></p><p>并且用以下代码来改变setter函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key <span class="keyword">copy</span>];</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.counts removeObjectForKey:key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.counts[key] = @(count);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用并发队列时，要确保所有的 <em>barrier</em> 调用都是 <em>async</em> 的。如果你使用 <code>dispatch_barrier_sync</code> ，那么你很可能会使你自己（更确切的说是，你的代码）产生死锁。写操作<em>需要</em>  barrier，并且<em>可以</em>是 async 的。</p><p><a id="contention" name="contention"> </a></p><h3 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h3><p>首先，这里有一个警告：上面这个例子中我们保护的资源是一个  <code>NSMutableDictionary</code>，出于这样的目的，这段代码运行地相当不错。但是在真实的代码中，把隔离放到正确的复杂度层级下是很重要的。</p><p>如果你对 <code>NSMutableDictionary</code> 的访问操作变得非常频繁，你会碰到一个已知的叫做锁竞争的问题。锁竞争并不是只是在 GCD 和队列下才变得特殊，任何使用了锁机制的程序都会碰到同样的问题——只不过不同的锁机制会以不同的方式碰到。</p><h4 id="时序性避免使用锁"><a href="#时序性避免使用锁" class="headerlink" title="时序性避免使用锁"></a>时序性避免使用锁</h4><p>所有对  <code>dispatch_async</code>，<code>dispatch_sync</code> 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码。GCD 某些程序上可以使用时序(译注：原词为 scheduling)来避免使用锁，但在最后，问题只是稍有变化。<br>根本问题仍然存在：如果你有<strong>大量</strong>的线程在相同时间去访问同一个锁或者队列，你就会看到性能的变化。性能会严重下降。</p><h4 id="平衡两个开销"><a href="#平衡两个开销" class="headerlink" title="平衡两个开销"></a>平衡两个开销</h4><p>你应该直接从复杂层次中隔离开。当你发现了性能下降，这明显表明代码中存在设计问题。这里有两个开销需要你来平衡：<br>第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。例如：一个在隔离队列中运行 block，它可能潜在的阻塞了其他将要在这个隔离队列中运行的代码。<br>第二个是太频繁出入临界区的开销。例如频繁调用 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 。<br><strong>无论再怎么优化，这两个操作都不是无代价的。</strong><br>令人忧伤的，不存在通用的标准来指导如何正确的平衡，你需要自己评测和调整。启动 Instruments 观察你的 app 忙于什么操作。</p><h4 id="设计层保护隔离队列"><a href="#设计层保护隔离队列" class="headerlink" title="设计层保护隔离队列"></a>设计层保护隔离队列</h4><p>在你自己的代码中，要考虑自己是否在更高的层次保护了隔离队列。<br>举个例子：<br>类 <code>Foo</code> 有一个隔离队列并且它本身保护着对 <code>NSMutableDictionary</code> 的访问，代替的，可以有一个用到了 <code>Foo</code> 类的 <code>Bar</code> 类有一个隔离队列保护所有对类 <code>Foo</code> 的使用。<br>换句话说，你可以把类 <code>Foo</code> 变为非线程安全的（没有隔离队列），并在 <code>Bar</code> 中，使用一个隔离队列来确保任何时刻只能有一个线程使用 <code>Foo</code> 。</p><p><a name="async" id="async"> </a></p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>全都使用异步分发</p><h4 id="同步分发死锁"><a href="#同步分发死锁" class="headerlink" title="同步分发死锁"></a>同步分发死锁</h4><ol><li>在 GCD 中，同步和异步地分发一个  block，一个工作单元。以同步分发的方式非常容易出现<a href="http://zh.wikipedia.org/wiki/死锁" target="_blank" rel="noopener">死锁</a>。见下面的代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA; <span class="comment">// assume we have this</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>一旦我们进入到第二个 <code>dispatch_sync</code> 就会发生死锁。我们不能分发到queueA，因为有人（当前线程）正在队列中并且永远不会离开。</p><ol start="2"><li>更隐晦的产生死锁方式：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA; <span class="comment">// assume we have this</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB; <span class="comment">// assume we have this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^()&#123;</span><br><span class="line">        bar();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class="line">        baz();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>单独的每次调用 <code>dispatch_sync()</code> 看起来都没有问题，但是一旦组合起来，就会发生死锁。</p><h4 id="解决：异步调用不会产生死锁"><a href="#解决：异步调用不会产生死锁" class="headerlink" title="解决：异步调用不会产生死锁"></a>解决：异步调用不会产生死锁</h4><p>这是使用同步分发存在的固有问题，如果我们使用异步分发，比如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA; <span class="comment">// assume we have this</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queueA, ^()&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queueA, ^()&#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>一切运行正常。<em>异步调用不会产生死锁</em>。因此值得我们在任何可能的时候都使用异步分发。我们使用一个异步调用结果 block 的函数，来代替编写一个返回值（必须要用同步）的方法或者函数。这种方式，我们会有更少发生死锁的可能性。</p><p>异步调用的副作用就是它们很难调试。当我们在调试器里中止代码运行，回溯并查看已经变得没有意义了。</p><p>要牢记这些。死锁通常是最难处理的问题。</p><h3 id="如何设计健壮的异步-API"><a href="#如何设计健壮的异步-API" class="headerlink" title="如何设计健壮的异步 API"></a>如何设计健壮的异步 API</h3><p>记住几种好的实践：</p><ol><li>需要倾向于异步 API。<br>当你创建一个 API，它会在你的控制之外以各种方式调用，如果你的代码能产生死锁，那么死锁就会发生。</li><li>主动在自己的函数或者方法中调用异步分发<code>dispatch_async()</code>。<br>不要让你的函数调用者来这么做，这个调用应该在你的方法或者函数中来做。</li><li>返回值传递，异步地将方法或函数的返回值传递给回调处理程序。<br>这个API（方法或函数）应该同时持有一个<code>结果 block</code> 和一个<code>将结果传递过去的队列</code>。不需要API调用者自己来做分发。<br>这么做的原因很简单：几乎所有事件，函数调用都应该在一个适当的队列中，而且以这种方式编写的代码是很容易阅读的。总之，你的函数将会（必须）调用 <code>dispatch_async()</code> 去运行回调处理程序，所以它同时也可能在需要调用的队列上做这些工作。</li></ol><p>如果你写一个类，让你类的使用者设置一个回调处理队列或许会是一个好的选择。你的代码可能像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.isolationQueue, ^(void)&#123;</span><br><span class="line">        // do actual processing here</span><br><span class="line">        dispatch_async(self.resultQueue, ^(void)&#123;</span><br><span class="line">            handler(YES);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你以这种方式来写你的类，让类之间协同工作就会变得容易。如果类 A 使用了类 B，它会把自己的隔离队列设置为 B 的回调队列。</p><h2 id="迭代执行"><a href="#迭代执行" class="headerlink" title="迭代执行"></a>迭代执行</h2><p>如果你正在倒弄一些数字，并且手头上的问题可以拆分出同样性质的部分，那么 <code>dispatch_apply</code> 会很有用。</p><p>如果你的代码看起来是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (size_t y = <span class="number">0</span>; y &lt; height; ++y) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; ++x) &#123;</span><br><span class="line">        <span class="comment">// Do something with x and y here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小小的改动或许就可以让它运行的更快：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(height, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(size_t y) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; x += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with x and y here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>代码运行良好的程度取决于你在循环内部做的操作。</p><p>block 中运行的工作必须是非常重要的，否则这个头部信息就显得过于繁重了。除非代码受到计算带宽的约束，每个工作单元为了很好适应缓存大小而读写的内存都是临界的。这会对性能会带来显著的影响。受到临界区约束的代码可能不会很好地运行。详细讨论这些问题已经超出了这篇文章的范围。使用 <code>dispatch_apply</code> 可能会对性能提升有所帮助，但是性能优化本身就是个很复杂的主题。维基百科上有一篇关于 <a href="https://en.wikipedia.org/wiki/Memory_bound" target="_blank" rel="noopener">Memory-bound function</a> 的文章。内存访问速度在 L2，L3 和主存上变化很显著。当你的数据访问模式与缓存大小不匹配时，10倍性能下降的情况并不少见。</p><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>很多时候，你发现需要将异步的 block 组合起来去完成一个给定的任务。这些任务中甚至有些是并行的。<br>现在，如果你想要在这些任务都执行完成后运行一些代码，”groups” 可以完成这项任务。看这里的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_group_async(group, queue, ^()&#123;</span><br><span class="line">    <span class="comment">// Do something that takes a while</span></span><br><span class="line">    [<span class="keyword">self</span> doSomeFoo];</span><br><span class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">        <span class="keyword">self</span>.foo = <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^()&#123;</span><br><span class="line">    <span class="comment">// Do something else that takes a while</span></span><br><span class="line">    [<span class="keyword">self</span> doSomeBar];</span><br><span class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">        <span class="keyword">self</span>.bar = <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This block will run once everything above is done:</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"foo: %d"</span>, <span class="keyword">self</span>.foo);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"bar: %d"</span>, <span class="keyword">self</span>.bar);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>需要注意的重要事情是，所有的这些都是非阻塞的。我们从未让当前的线程一直等待直到别的任务做完。恰恰相反，我们只是简单的将多个 block 放入队列。由于代码不会阻塞，所以就不会产生死锁。</p><p>同时需要注意的是，在这个小并且简单的例子中，我们是怎么在不同的队列间进切换的。</p><h3 id="对现有API使用-dispatch-group-t"><a href="#对现有API使用-dispatch-group-t" class="headerlink" title="对现有API使用 dispatch_group_t"></a>对现有API使用 dispatch_group_t</h3><p>一旦你将  groups 作为你的工具箱中的一部分，你可能会怀疑为什么大多数的异步API不把 <code>dispatch_group_t</code> 作为一个可选参数。这没有什么无法接受的理由，仅仅是因为自己添加这个功能太简单了，但是你还是要小心以确保自己使用 groups 的代码是成对出现的。</p><p>举例来说，我们可以给 Core Data 的 <code>-performBlock:</code> API 函数添加上 groups，就像这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span> performBlock:block];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="keyword">self</span> performBlock:^()&#123;</span><br><span class="line">block();</span><br><span class="line">dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 Core Data 上的一系列操作(很可能和其他的代码组合起来)完成以后，我们可以使用 <code>dispatch_group_notify</code> 来运行一个 block 。</p><p>很明显，我们可以给 <code>NSURLConnection</code> 做同样的事情：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group</span><br><span class="line">sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">queue:(<span class="built_in">NSOperationQueue</span> *)queue</span><br><span class="line">completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    [<span class="keyword">self</span> sendAsynchronousRequest:request</span><br><span class="line">                            queue:queue</span><br><span class="line">                completionHandler:handler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line">        [<span class="keyword">self</span> sendAsynchronousRequest:request</span><br><span class="line">                                queue:queue</span><br><span class="line">                    completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</span><br><span class="line">            handler(response, data, error);</span><br><span class="line">            dispatch_group_leave(group);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了能正常工作，你需要确保:</p><ul><li><code>dispatch_group_enter()</code> 必须要在 <code>dispatch_group_leave()</code>之前运行。</li><li><code>dispatch_group_enter()</code> 和 <code>dispatch_group_leave()</code> 一直是成对出现的（就算有错误产生时）。</li></ul><h2 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h2><p>GCD 有一个较少人知道的特性：事件源 <code>dispatch_source_t</code>。</p><p>跟 GCD 一样，它也是很底层的东西。当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。</p><p>GCD 事件源是以极其资源高效的方式实现的。</p><h3 id="监视进程"><a href="#监视进程" class="headerlink" title="监视进程"></a>监视进程</h3><p>如果一些进程正在运行而你想知道他们什么时候存在，GCD 能够做到这些。你也可以使用 GCD 来检测进程什么时候分叉，也就是产生子进程或者传送给了进程的一个信号（比如 <code>SIGTERM</code>）。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunningApplication</span> *mail = [<span class="built_in">NSRunningApplication</span></span><br><span class="line">runningApplicationsWithBundleIdentifier:<span class="string">@"com.apple.mail"</span>];</span><br><span class="line"><span class="keyword">if</span> (mail == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pid_t <span class="keyword">const</span> pid = mail.processIdentifier;</span><br><span class="line"><span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid,</span><br><span class="line">DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^()&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Mail quit."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.source);</span><br></pre></td></tr></table></figure></p><p>当 Mail.app 退出的时候，这个程序会打印出 <strong>Mail quit.</strong>。</p><p>注意：在所有的事件源被传递到你的事件处理器之前，必须调用 <code>dispatch_resume()</code>。</p><p><a name="watching_files" id="watching_files"> </a></p><h3 id="监视文件"><a href="#监视文件" class="headerlink" title="监视文件"></a>监视文件</h3><p>这种可能性是无穷的。你能直接监视一个文件的改变，并且当改变发生时事件源的事件处理将会被调用。</p><p>你也可以使用它来监视文件夹，比如创建一个 <em>watch folder</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSURL *directoryURL; // assume this is set to a directory</span><br><span class="line">int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</span><br><span class="line">if (fd &lt; 0) &#123;</span><br><span class="line">char buffer[80];</span><br><span class="line">strerror_r(errno, buffer, sizeof(buffer));</span><br><span class="line">NSLog(@&quot;Unable to open \&quot;%@\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</span><br><span class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">dispatch_source_set_event_handler(source, ^()&#123;</span><br><span class="line">unsigned long const data = dispatch_source_get_data(source);</span><br><span class="line">if (data &amp; DISPATCH_VNODE_WRITE) &#123;</span><br><span class="line">NSLog(@&quot;The directory changed.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (data &amp; DISPATCH_VNODE_DELETE) &#123;</span><br><span class="line">NSLog(@&quot;The directory has been deleted.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;);</span><br><span class="line">self.source = source;</span><br><span class="line">dispatch_resume(self.source);</span><br></pre></td></tr></table></figure></p><p>你应该总是添加 <code>DISPATCH_VNODE_DELETE</code> 去检测文件或者文件夹是否已经被删除——然后就停止监听。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>大多数情况下，对于定时事件你会选择 <code>NSTimer</code>。定时器的GCD版本是底层的，它会给你更多控制权——但要小心使用。</p><p>需要特别重点指出的是，为了让 OS 节省电量，需要为 GCD 的定时器接口指定一个低的余地值(译注：原文leeway value)。如果你不必要的指定了一个低余地值，将会浪费更多的电量。</p><p>这里我们设定了一个5秒的定时器，并允许有十分之一秒的余地值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">dispatch_source_set_event_handler(source, ^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Time flies."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_time_t start</span><br><span class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>,</span><br><span class="line"><span class="number">100</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</span><br><span class="line"><span class="keyword">self</span>.source = source;</span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.source);</span><br></pre></td></tr></table></figure></p><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>所有的事件源都允许你添加一个 <em>cancel handler</em> 。这对清理你为事件源创建的任何资源都是很有帮助的，比如关闭文件描述符。GCD 保证在 <em>cancel handle</em>  调用前，所有的事件处理都已经完成调用。</p><p>参考上面的<a href="#watching_files">监视文件例子</a>中对 <code>dispatch_source_set_cancel_handler()</code> 的使用。</p><p><a id="input_output" name="input_output"> </a></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。GCD 有一些能够帮上忙的地方。不会涉及太多的细节，我们只简单的分析下问题是什么，GCD 是怎么处理的。</p><p>习惯上，当你从一个网络套接字中读取数据时，你要么做一个阻塞的读操作，也就是让你个线程一直等待直到数据变得可用，或者是做反复的轮询。这两种方法都是很浪费资源并且无法度量。然而，<code>kqueue</code> 通过当数据变得可用时传递一个事件解决了轮询的问题，GCD 也采用了同样的方法，但是更加优雅。当向套接字写数据时，同样的问题也存在，这时你要么做阻塞的写操作，要么等待套接字直到能够接收数据。</p><p>在处理 I/O 时，还有一个问题就是数据是以数据块的形式到达的。当从网络中读取数据时，依据 MTU(<a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit" target="_blank" rel="noopener">]最大传输单元</a>)，数据块典型的大小是在1.5K字节左右。这使得数据块内可以是任何内容。一旦数据到达，你通常只是对跨多个数据块的内容感兴趣。而且通常你会在一个大的缓冲区里将数据组合起来然后再进行处理。假设（人为例子）你收到了这样8个数据块：</p><p>0: HTTP/1.1 200 OK\r\nDate: Mon, 23 May 2005 22:38<br>1: :34 GMT\r\nServer: Apache/1.3.3.7 (Unix) (Red-H<br>2: at/Linux)\r\nLast-Modified: Wed, 08 Jan 2003 23<br>3: :11:55 GMT\r\nEtag: “3f80f-1b6-3e1cb03b”\r\nCon<br>4: tent-Type: text/html; charset=UTF-8\r\nContent-<br>5: Length: 131\r\nConnection: close\r\n\r\n<html>\r<br>6: \n<head><meta name="generator" content="Hexo 3.9.0">\r\n  <title>An Example Page</title>\r\n<br>7: </head>\r\n<body>\r\n  Hello World, this is a ve<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body></html></p><p>如果你是在寻找 HTTP 的头部，将所有数据块组合成一个大的缓冲区并且从中查找 <code>\r\n\r\n</code> 是非常简单的。但是这样做，你会大量地复制这些数据。大量 <em>旧的</em> C 语言 API 存在的另一个问题就是，缓冲区没有所有权的概念，所以函数不得不将数据再次拷贝到自己的缓冲区中——又一次的拷贝。拷贝数据操作看起来是无关紧要的，但是当你正在做大量的 I/O 操作的时候，你会在 profiling tool(Instruments) 中看到这些拷贝操作大量出现。即使你仅仅每个内存区域拷贝一次，你还是使用了两倍的存储带宽并且占用了两倍的内存缓存。</p><h3 id="GCD-和缓冲区"><a href="#GCD-和缓冲区" class="headerlink" title="GCD 和缓冲区"></a>GCD 和缓冲区</h3><p>最直接了当的方法是使用数据缓冲区。GCD 有一个 <code>dispatch_data_t</code> 类型，在某种程度上和 Objective-C 的 <code>NSData</code> 类型很相似。但是它能做别的事情，而且更通用。</p><p>注意，<code>dispatch_data_t</code> 可以被 retained 和 releaseed ，并且 <code>dispatch_data_t</code> <em>拥有</em>它持有的对象。</p><p>这看起来无关紧要，但是我们必须记住 GCD 只是纯 C 的 API，并且不能使用Objective-C。通常的做法是创建一个缓冲区，这个缓冲区要么是基于栈的，要么是  <code>malloc</code> 操作分配的内存区域 —— 这些都没有所有权。</p><p><code>dispatch_data_t</code> 的一个相当独特的属性是它可以基于零碎的内存区域。这解决了我们刚提到的组合内存的问题。当你要将两个数据对象连接起来时：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_data_t a; <span class="comment">// Assume this hold some valid data</span></span><br><span class="line">dispatch_data_t b; <span class="comment">// Assume this hold some valid data</span></span><br><span class="line">dispatch_data_t c = dispatch_data_create_concat(a, b);</span><br></pre></td></tr></table></figure></p><p>数据对象 c 并不会将 a 和 b 拷贝到一个单独的，更大的内存区域里去。相反，它只是简单地 retain 了 a 和 b。你可以使用 <code>dispatch_data_apply</code> 来遍历对象 c 持有的内存区域：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_data_apply(c, ^<span class="keyword">bool</span>(dispatch_data_t region, size_t offset, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t size) &#123;</span><br><span class="line">fprintf(stderr, <span class="string">"region with offset %zu, size %zu\n"</span>, offset, size);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>类似的，你可以使用 <code>dispatch_data_create_subrange</code> 来创建一个不做任何拷贝操作的子区域。</p><h3 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h3><p>在 GCD 的核心里，<em>调度 I/O</em>（译注：原文为 Dispatch I/O） 与所谓的<em>通道</em>有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。创建这样一个通道最基本的方式就是调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd,</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">void</span> (^cleanup_handler)(<span class="keyword">int</span> error));</span><br></pre></td></tr></table></figure></p><p>这将返回一个持有文件描述符的创建好的通道。在你通过它创建了通道之后，你不准以任何方式修改这个文件描述符。</p><p>有两种从根本上不同类型的通道：流和随机存取。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。</p><p>如果你想要为一个文件创建一个通道，你最好使用需要一个路径参数的 <code>dispatch_io_create_with_path</code> ，并且让 GCD 来打开这个文件。这是有益的，因为GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量。</p><p>类似通常的 read(2)，write(2) 和 close(2) 的操作，GCD 提供了 <code>dispatch_io_read</code>，<code>dispatch_io_write</code> 和 <code>dispatch_io_close</code>。无论何时数据读完或者写完，读写操作调用一个回调 block 来结束。这些都是以非阻塞，异步 I/O 的形式高效实现的。</p><p>在这你得不到所有的细节，但是这里会提供一个创建TCP服务端的例子：</p><p>首先我们创建一个监听套接字，并且设置一个接受连接的事件源：</p><p>_isolation = dispatch_queue_create([[self description] UTF8String], 0);<br>_nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);<br>struct sockaddr_in sin = {};<br>sin.sin_len = sizeof(sin);<br>sin.sin_family = AF_INET6;<br>sin.sin_port = htons(port);<br>sin.sin_addr.s_addr= INADDR_ANY;<br>int err = bind(result.nativeSocket, (struct sockaddr *) &amp;sin, sizeof(sin));<br>NSCAssert(0 &lt;= err, @””);</p><p>_eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, _nativeSocket, 0, _isolation);<br>dispatch_source_set_event_handler(result.eventSource, ^{<br>acceptConnection(_nativeSocket);<br>});</p><p>当接受了连接，我们创建一个I/O通道：</p><p>typedef union socketAddress {<br>struct sockaddr sa;<br>struct sockaddr_in sin;<br>struct sockaddr_in6 sin6;<br>} socketAddressUnion;</p><p>socketAddressUnion rsa; // remote socket address<br>socklen_t len = sizeof(rsa);<br>int native = accept(nativeSocket, &amp;rsa.sa, &amp;len);<br>if (native == -1) {<br>// Error. Ignore.<br>return nil;<br>}</p><p>_remoteAddress = rsa;<br>_isolation = dispatch_queue_create([[self description] UTF8String], 0);<br>_channel = dispatch_io_create(DISPATCH_IO_STREAM, native, _isolation, ^(int error) {<br>NSLog(@”An error occured while listening on socket: %d”, error);<br>});</p><p>//dispatch_io_set_high_water(_channel, 8 <em> 1024);<br>dispatch_io_set_low_water(_channel, 1);<br>dispatch_io_set_interval(_channel, NSEC_PER_MSEC </em> 10, DISPATCH_IO_STRICT_INTERVAL);</p><p>socketAddressUnion lsa; // remote socket address<br>socklen_t len = sizeof(rsa);<br>getsockname(native, &amp;lsa.sa, &amp;len);<br>_localAddress = lsa;</p><p>如果我们想要设置 <code>SO_KEEPALIVE</code>（如果使用了HTTP的keep-alive），我们需要在调用 <code>dispatch_io_create</code> 前这么做。</p><p>创建好 I/O 通道后，我们可以设置读取处理程序：</p><p>dispatch_io_read(_channel, 0, SIZE_MAX, _isolation, ^(bool done, dispatch_data_t data, int error){<br>if (data != NULL) {<br>if (_data == NULL) {<br>_data = data;<br>} else {<br>_data = dispatch_data_create_concat(_data, data);<br>}<br>[self processData];<br>}<br>});</p><p>如果所有你想做的只是读取或者写入一个文件，GCD 提供了两个方便的封装： <code>dispatch_read</code> 和 <code>dispatch_write</code> 。你需要传递给 <code>dispatch_read</code> 一个文件路径和一个在所有数据块读取后调用的 block。类似的，<code>dispatch_write</code> 需要一个文件路径和一个被写入的 <code>dispatch_data_t</code> 对象。</p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>在 GCD 的一个不起眼的角落，你会发现一个适合优化代码的灵巧小工具：</p><p>uint64_t dispatch_benchmark(size_t count, void (^block)(void));</p><p>把这个声明放到你的代码中，你就能够测量给定的代码执行的平均的纳秒数。例子如下：</p><p>size_t const objectCount = 1000;<br>uint64_t n = dispatch_benchmark(10000, ^{<br>@autoreleasepool {<br>id obj = @42;<br>NSMutableArray *array = [NSMutableArray array];<br>for (size_t i = 0; i &lt; objectCount; ++i) {<br>[array addObject:obj];<br>}<br>}<br>});<br>NSLog(@”-[NSMutableArray addObject:] : %llu ns”, n);</p><p>在我的机器上输出了：</p><p>-[NSMutableArray addObject:] : 31803 ns</p><p>也就是说添加1000个对象到 NSMutableArray 总共消耗了31803纳秒，或者说平均一个对象消耗32纳秒。</p><p>正如 <code>dispatch_benchmark</code> 的<a href="http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3" target="_blank" rel="noopener">帮助页面</a>指出的，测量性能并非如看起来那样不重要。尤其是当比较并发代码和非并发代码时，你需要注意特定硬件上运行的特定计算带宽和内存带宽。不同的机器会很不一样。如果代码的性能与访问临界区有关，那么我们上面提到的锁竞争问题就会有所影响。</p><p>不要把它放到发布代码中，事实上，这是无意义的，它是私有API。它只是在调试和性能分析上起作用。</p><p>访问帮助界面：</p><p>curl “<a href="http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt&quot;" target="_blank" rel="noopener">http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt&quot;</a><br>| /usr/bin/groffer –tty -T utf8</p><p><a id="atomic_operations" name="atomic_operations"> </a></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>头文件 <code>libkern/OSAtomic.h</code> 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。</p><p>这些函数都是很底层的，并且你需要知道一些额外的事情。就算你已经这样做了，你还可能会发现一两件你不能做，或者不易做的事情。当你正在为编写高性能代码或者正在实现无锁的和无等待的算法工作时，这些函数会吸引你。</p><p>这些函数在 <code>atomic(3)</code> 的帮助页里全部有概述——运行 <code>man 3 atomic</code> 命令以得到完整的文档。你会发现里面讨论到了内存屏障。查看维基百科中关于<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障</a>的文章。如果你还存在疑问，那么你很可能需要它。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p><code>OSAtomicIncrement</code> 和 <code>OSAtomicDecrement</code> 有一个很长的函数列表允许你以原子操作的方式去增加和减少一个整数值 —— 不必使用锁（或者队列）同时也是线程安全的。如果你需要让一个全局的计数器值增加，而这个计数器为了统计目的而由多个线程操作，使用原子操作是很有帮助的。如果你要做的仅仅是增加一个全局计数器，那么无屏障版本的 <code>OSAtomicIncrement</code> 是很合适的，并且当没有锁竞争时，调用它们的代价很小。</p><p>类似的，<code>OSAtomicOr</code> ，<code>OSAtomicAnd</code>，<code>OSAtomicXor</code> 的函数能用来进行逻辑运算，而 <code>OSAtomicTest</code> 可以用来设置和清除位。</p><h4 id="10-2、比较和交换"><a href="#10-2、比较和交换" class="headerlink" title="10.2、比较和交换"></a>10.2、比较和交换</h4><p><code>OSAtomicCompareAndSwap</code> 能用来做无锁的惰性初始化，如下：</p><p>void <em> sharedBuffer(void)<br>{<br>static void </em> buffer;<br>if (buffer == NULL) {<br>void * newBuffer = calloc(1, 1024);<br>if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {<br>free(newBuffer);<br>}<br>}<br>return buffer;<br>}</p><p>如果没有 buffer，我们会创建一个，然后原子地将其写到 <code>buffer</code> 中如果 <code>buffer</code> 为NULL。在极少的情况下，其他人在当前线程同时设置了 <code>buffer</code> ，我们简单地将其释放掉。因为比较和交换方法是原子的，所以它是一个线程安全的方式去惰性初始化值。NULL的检测和设置 <code>buffer</code> 都是以原子方式完成的。</p><p>明显的，使用 <code>dispatch_once()</code> 我们也可以完成类似的事情。</p><h3 id="原子队列"><a href="#原子队列" class="headerlink" title="原子队列"></a>原子队列</h3><p><code>OSAtomicEnqueue()</code> 和 <code>OSAtomicDequeue()</code> 可以让你以线程安全，无锁的方式实现一个LIFO队列(常见的就是栈)。对有潜在精确要求的代码来说，这会是强大的代码。</p><p>还有  <code>OSAtomicFifoEnqueue()</code> 和 <code>OSAtomicFifoDequeue()</code> 函数是为了操作FIFO队列，但这些只有在头文件中才有文档 —— 阅读他们的时候要小心。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>最后，<code>OSAtomic.h</code> 头文件定义了使用自旋锁的函数：<code>OSSpinLock</code>。同样的，维基百科有深入的有关<a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank" rel="noopener">自旋锁</a>的信息。使用命令 <code>man 3 spinlock</code> 查看帮助页的 <code>spinlock(3)</code> 。当没有锁竞争时使用自旋锁代价很小。</p><p>在合适的情况下，使用自旋锁对性能优化是很有帮助的。一如既往：先测量，然后优化。不要做乐观的优化。</p><p>下面是 OSSpinLock 的一个例子：</p><p>@interface MyTableViewCell : UITableViewCell</p><p>@property (readonly, nonatomic, copy) NSDictionary *amountAttributes;</p><p>@end</p><p>@implementation MyTableViewCell<br>{<br>NSDictionary *_amountAttributes;<br>}</p><ul><li>(NSDictionary <em>)amountAttributes;<br>{<br>if (_amountAttributes == nil) {<br>static __weak NSDictionary </em>cachedAttributes = nil;<br>static OSSpinLock lock = OS_SPINLOCK_INIT;<br>OSSpinLockLock(&amp;lock);<br>_amountAttributes = cachedAttributes;<br>if (_amountAttributes == nil) {<br>NSMutableDictionary *attributes = [[self subtitleAttributes] mutableCopy];<br>attributes[NSFontAttributeName] = [UIFont fontWithName:@”ComicSans” size:36];<br>attributes[NSParagraphStyleAttributeName] = [NSParagraphStyle defaultParagraphStyle];<br>_amountAttributes = [attributes copy];<br>cachedAttributes = _amountAttributes;<br>}<br>OSSpinLockUnlock(&amp;lock);<br>}<br>return _amountAttributes;<br>}</li></ul><p>就上面的例子而言，或许用不着这么麻烦，但它演示了一种理念。我们使用了ARC的 <code>__weak</code> 来确保一旦 <code>MyTableViewCell</code> 所有的实例都不存在， <code>amountAttributes</code> 会调用 <code>dealloc</code> 。因此在所有的实例中，我们可以持有字典的一个单独实例。</p><p>这段代码运行良好的原因是我们不太可能访问到方法最里面的部分。这是很深奥的——除非你真正需要，不然不要在你的 App 中使用它。</p><hr><p><a href="http://objccn.io/issue-2" target="_blank" rel="noopener">话题 #2 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html" target="_blank" rel="noopener">Low-Level Concurrency APIs</a></p><p>译文 <a href="http://webfrogs.me/2013/07/18/low-level_concurrency_apis/" target="_blank" rel="noopener">Objc的底层并发API - webfrogs</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的后台实现</title>
      <link href="/2017/09/24/iOS/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%8E%E5%8F%B0%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/09/24/iOS/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%8E%E5%8F%B0%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文主要探讨一些常用后台任务的最佳实践：</p><ol><li>如何做异步网络请求</li><li>如何异步处理大型文件，以保持较低的内存占用</li></ol><h3 id="操作队列-Operation-Queues-还是-GCD"><a href="#操作队列-Operation-Queues-还是-GCD" class="headerlink" title="操作队列 (Operation Queues) 还是 GCD ?"></a>操作队列 (Operation Queues) 还是 GCD ?</h3><p>操作队列提供了在 GCD 中不那么容易复制的有用特性。其中最重要的一个就是可以取消在任务处理队列中的任务，而且操作队列在管理操作间的依赖关系方面也容易一些。<br>GCD 给予你更多的控制权力以及操作队列中所不能使用的底层函数。详细介绍可以参考<a href="http://www.objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a> 这篇文章。</p><h2 id="后台-UI-代码"><a href="#后台-UI-代码" class="headerlink" title="后台 UI 代码"></a>后台 UI 代码</h2><p>首先要强调：UIKit 只能在主线程上运行。而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理，以避免其将主线程阻塞太久。</p><h3 id="后台获取UI数据"><a href="#后台获取UI数据" class="headerlink" title="后台获取UI数据"></a>后台获取UI数据</h3><p>例如使用操作队列隔离以下昂贵操作：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span>* result = findLargestMersennePrime();</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        MyClass* strongSelf = weakSelf;</span><br><span class="line">        strongSelf.textLabel.text = [result stringValue];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>如你所见，这些代码其实一点也不直接明了。我们首先声明了一个 weak 引用来参照 self，否则会形成循环引用（ block 持有了 self，私有的 <code>operationQueue</code> retain 了 block，而 self 又 retain 了 <code>operationQueue</code> ）。为了避免在运行 block 时访问到已被释放的对象，在 block 中我们又需要将其转回 strong 引用。</p><blockquote><p>这在 ARC 和 block 主导的编程范式中是解决 retain cycle 的一种常见也是最标准的方法。</p></blockquote><h3 id="后台绘制UI"><a href="#后台绘制UI" class="headerlink" title="后台绘制UI"></a>后台绘制UI</h3><p>如果你确定 <code>drawRect:</code> 是你的应用的性能瓶颈，那么你可以将这些绘制代码放到后台去做。但是在你这样做之前，检查下看看是不是有其他方法来解决，比如、考虑使用 core animation layers 或者预先渲染图片而不去做 Core Graphics 绘制。</p><p>如果你确实认为在后台执行绘制代码会是你的最好选择时再这么做。其实解决起来也很简单，把 <code>drawRect:</code> 中的代码放到一个后台操作中去做就可以了。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 <code>UIGraphicsBeginImageContextWithOptions</code> 来取代 <code>UIGraphicsGetCurrentContext</code> ：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// drawing code here</span></span><br><span class="line"><span class="built_in">UIImage</span> *i = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure></p><p>通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。</p><h4 id="cell在操作队列中异步绘制"><a href="#cell在操作队列中异步绘制" class="headerlink" title="cell在操作队列中异步绘制"></a>cell在操作队列中异步绘制</h4><p>如果你在 table view 或者是 collection view 的 cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。你可以将它们添加到后台操作队列，也可以在用户将 cell 滚动出边界时的 <code>didEndDisplayingCell</code> 委托方法中进行取消。这些技巧都在 2012 年的WWDC <a href="https://developer.apple.com/videos/wwdc/2012/" target="_blank" rel="noopener">Session 211 – Building Concurrent User Interfaces on iOS</a>中有详细阐述。</p><h4 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h4><p>除了在后台自己调度绘制代码，以也可以试试看使用 <code>CALayer</code> 的 <code>drawsAsynchronously</code> 属性。然而你需要精心衡量这样做的效果，因为有时候它能使绘制加速，有时候却适得其反。</p><h2 id="异步网络请求处理"><a href="#异步网络请求处理" class="headerlink" title="异步网络请求处理"></a>异步网络请求处理</h2><p>你的所有网络请求都应该采取异步的方式完成。</p><p>然而，在 GCD 下，有时候你可能会看到这样的代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 警告：不要使用这些代码。</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSData</span>* contents = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 处理取到的日期</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>乍看起来没什么问题，但是这段代码却有致命缺陷。你没有办法去取消这个同步的网络请求。它将阻塞主线程直到它完成。如果请求一直没结果，那就只能干等到超时（比如 <code>dataWithContentsOfURL:</code> 的超时时间是 30 秒）。</p><h3 id="分析状况"><a href="#分析状况" class="headerlink" title="分析状况"></a>分析状况</h3><ol><li>当队列是串行执行时，它将一直被阻塞住。</li><li>当队列是并行执行时，GCD 需要重开一个线程来补凑你阻塞住的线程。</li></ol><p>两种结果都不太妙，所以最好还是不要阻塞线程。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>要解决上面的困境，我们可以使用 <code>NSURLConnection</code> 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。<br>例如：在<code>NSOperation</code>子类<code>DownloadOperation</code>中重写<code>start</code>方法，并实现<code>NSURLConnectionDelegate</code>代理方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperation</span> : <span class="title">NSOperation</span>&lt;<span class="title">NSURLConnectionDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span>* request = [<span class="built_in">NSURLRequest</span> requestWithURL:<span class="keyword">self</span>.url];</span><br><span class="line">    <span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.isConcurrent = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，在这里还有一些事情值得注意： <code>NSURLConnection</code> 是通过 run loop 来发送事件的。因为发送事件不会花多少时间，因此最简单的是就只使用 main run loop 来做这个。然后，我们就可以用后台线程来处理输入的数据了。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>另一种可能的方式是使用像 <a href="http://afnetworking.com" target="_blank" rel="noopener">AFNetworking</a> 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。</p><p>要处理URL 连接，我们重写自定义的 operation 子类中的 <code>start</code> 方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span>* request = [<span class="built_in">NSURLRequest</span> requestWithURL:<span class="keyword">self</span>.url];</span><br><span class="line">    <span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnectionconnectionWithRequest</span>:request</span><br><span class="line">        delegate:<span class="keyword">self</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于重写的是 <code>start</code> 方法，所以我们需要自己要管理操作的 <code>isExecuting</code> 和 <code>isFinished</code> 状态。要取消一个操作，我们需要取消 connection ，并且设定合适的标记，这样操作队列才知道操作已经完成。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> cancel];</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.isExecuting = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当连接完成加载后，它向代理发送回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.data = <span class="keyword">self</span>.buffer;</span><br><span class="line">    <span class="keyword">self</span>.buffer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.isExecuting = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这么多了。完整的代码可以参见<a href="https://github.com/objcio/issue-2-background-networking" target="_blank" rel="noopener">GitHub上的示例工程</a>。</p><p>总结来说，我们建议要么你花时间来把事情做对做好，要么就直接使用像 <a href="http://afnetworking.com/" target="_blank" rel="noopener">AFNetworking</a> 这样的框架。其实 <a href="http://afnetworking.com/" target="_blank" rel="noopener">AFNetworking</a> 还提供了不少好用的小工具，比如有个 <code>UIImageView</code> 的 category，来负责异步地从一个 URL 加载图片。在你的 table view 里使用的话，还能自动帮你处理取消加载操作，非常方便。</p><p>扩展阅读：</p><ul><li><a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="noopener">Concurrency Programming Guide</a></li><li><a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23//apple_ref/doc/uid/TP40004591-RH2-SW15" target="_blank" rel="noopener">NSOperation Class Reference: Concurrent vs. Non-Concurrent Operations</a></li><li><a href="http://www.cocoaintheshell.com/2011/04/nsurlconnection-synchronous-asynchronous/" target="_blank" rel="noopener">Blog: synchronous vs. asynchronous NSURLConnection</a></li><li><a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloaderOperation.m" target="_blank" rel="noopener">GitHub: <code>SDWebImageDownloaderOperation.m</code></a></li><li><a href="http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/" target="_blank" rel="noopener">Blog: Progressive image download with ImageIO</a></li><li><a href="https://developer.apple.com/videos/wwdc/2012/" target="_blank" rel="noopener">WWDC 2012 Session 211: Building Concurrent User Interfaces on iOS</a></li></ul><h2 id="进阶：后台文件-I-O"><a href="#进阶：后台文件-I-O" class="headerlink" title="进阶：后台文件 I/O"></a>进阶：后台文件 I/O</h2><p>构建一个类，负责一行一行读取文件而不是一次将整个文件读入内存，另外要在后台队列处理文件，以保持应用相应用户的操作。<br>为了达到这个目的，我们使用能让我们异步处理文件的 <code>NSInputStream</code> 。根据<a href="http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html" target="_blank" rel="noopener">官方文档</a>的描述：</p><blockquote><p>如果你总是需要从头到尾来读/写文件的话，streams 提供了一个简单的接口来异步完成这个操作</p></blockquote><p>不管你是否使用 streams，大体上逐行读取一个文件的模式是这样的：</p><ol><li>建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据</li><li>从 stream 中读取一块数据</li><li>对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出</li><li>将剩余的字节添加到中间缓冲层去</li><li>回到 2，直到 stream 关闭</li></ol><p>为了将其运用到实践中，我们又建立了一个<a href="https://github.com/objcio/issue-2-background-file-io" target="_blank" rel="noopener">示例应用</a>，里面有一个 <code>Reader</code> 类完成了这件事情，它的接口十分简单<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Reader</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block completion:(<span class="keyword">void</span> (^)())completion;</span><br><span class="line">- (<span class="keyword">id</span>)initWithFileAtPath:(<span class="built_in">NSString</span>*)path;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h4 id="runloop分发NSInputStream事件"><a href="#runloop分发NSInputStream事件" class="headerlink" title="runloop分发NSInputStream事件"></a>runloop分发NSInputStream事件</h4><p>注意，这个类不是 NSOperation 的子类。与 URL connections 类似，输入的 streams 通过 run loop 来传递它的事件。这里，我们仍然采用 main run loop 来分发事件，然后将数据处理过程派发至后台操作线程里去处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block</span><br><span class="line">completion:(<span class="keyword">void</span> (^)())completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.queue == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.queue.maxConcurrentOperationCount = <span class="number">1</span>;  <span class="comment">//串行队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.callback = block;</span><br><span class="line">    <span class="keyword">self</span>.completion = completion;</span><br><span class="line">    <span class="keyword">self</span>.inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.fileURL];</span><br><span class="line">    <span class="keyword">self</span>.inputStream.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//分发NSInputStream事件</span></span><br><span class="line">    [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop]</span><br><span class="line">                                forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)import:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Clarissa Harlowe"</span> withExtension:<span class="string">@"txt"</span>];</span><br><span class="line">    <span class="built_in">NSAssert</span>([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]], <span class="string">@"Please download the sample data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.reader = [[Reader alloc] initWithFileAtURL:fileURL];</span><br><span class="line">    [<span class="keyword">self</span>.reader enumerateLinesWithBlock:^(<span class="built_in">NSUInteger</span> i, <span class="built_in">NSString</span> *line)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i % <span class="number">2000</span>ull) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i: %d"</span>, i);</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            [<span class="keyword">self</span>.button setTitle:line forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">NSUInteger</span> numberOfLines)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"lines: %d"</span>, numberOfLines);</span><br><span class="line">        [<span class="keyword">self</span>.button setTitle:<span class="string">@"Done"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSInputStream代理方法"><a href="#NSInputStream代理方法" class="headerlink" title="NSInputStream代理方法"></a>NSInputStream代理方法</h4><p>现在，input stream 将（在主线程）向我们发送代理消息，然后我们可以在操作队列中加入一个 block 操作来执行处理了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span>*)stream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventCode) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventHasBytesAvailable</span>: &#123;</span><br><span class="line">            <span class="built_in">NSMutableData</span> *buffer = [<span class="built_in">NSMutableData</span> dataWithLength:<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">NSUInteger</span> length = [<span class="keyword">self</span>.inputStream read:[buffer mutableBytes]</span><br><span class="line">                                             maxLength:[buffer length]];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; length) &#123;</span><br><span class="line">                [buffer setLength:length];</span><br><span class="line">                __<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">                [<span class="keyword">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class="line">                    <span class="comment">//在后台串行队列的线程池中逐行处理缓冲区</span></span><br><span class="line">                    [weakSelf processDataChunk:buffer];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="缓冲区处理"><a href="#缓冲区处理" class="headerlink" title="缓冲区处理"></a>缓冲区处理</h4><p>处理数据块的过程是先查看当前已缓冲的数据，并将新加入的数据附加上去。接下来它将按照换行符分解成小的部分，并逐行处理。<br>数据处理过程中会不断的从buffer中获取已读入的数据。然后把这些新读入的数据按行分开并存储。剩余的数据被再次存储到缓冲区中：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processDataChunk:(<span class="built_in">NSMutableData</span> *)buffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.remainder != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.remainder appendData:buffer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.remainder = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.remainder obj_enumerateComponentsSeparatedBy:<span class="keyword">self</span>.delimiter</span><br><span class="line">                            usingBlock:^(<span class="built_in">NSData</span>* component, <span class="built_in">BOOL</span> last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!last) &#123;</span><br><span class="line">            [<span class="keyword">self</span> emitLineWithData:component];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; [component length]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = [component mutableCopy];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)emitLineWithData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> lineNumber = <span class="keyword">self</span>.lineNumber;</span><br><span class="line">    <span class="keyword">self</span>.lineNumber = lineNumber + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; data.length) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *line = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">self</span>.callback(lineNumber, line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你运行示例应用的话，会发现它在响应事件时非常迅速，内存的开销也保持很低（在我们测试时，不论读入的文件有多大，堆所占用的内存量始终低于 800KB）。绝大部分时候，使用逐块读入的方式来处理大文件，是非常有用的技术。</p><p>延伸阅读：</p><ul><li><a href="http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html" target="_blank" rel="noopener">File System Programming Guide: Techniques for Reading and Writing Files Without File Coordinators</a></li><li><a href="http://stackoverflow.com/questions/3707427/how-to-read-data-from-nsfilehandle-line-by-line" target="_blank" rel="noopener">StackOverflow: How to read data from NSFileHandle line by line?</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过我们所列举的几个示例，我们展示了如何异步地在后台执行一些常见任务。在所有的解决方案中，我们尽力保持了代码的简单，这是因为在并发编程中，稍不留神就会捅出篓子来。</p><p>很多时候为了避免麻烦，你可能更愿意在主线程中完成你的工作，在你能这么做事，这确实让你的工作轻松不少，但是当你发现性能瓶颈时，你可以尝试尽可能用最简单的策略将那些繁重任务放到后台去做。</p><p>我们在上面例子中所展示的方法对于其他任务来说也是安全的选择。在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。</p><hr><p><a href="http://objccn.io/issue-2" target="_blank" rel="noopener">话题 #2 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-2/common-background-practices.html" target="_blank" rel="noopener">Common Background Practices</a></p><p>译文 <a href="http://onevcat.com/2014/03/common-background-practices/" target="_blank" rel="noopener">常见的后台实践</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS多线程API介绍</title>
      <link href="/2017/09/24/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8BAPI%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/09/24/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8BAPI%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29" target="_blank" rel="noopener">并发</a>所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上<a href="http://en.wikipedia.org/wiki/Preemption_%28computing%29" target="_blank" rel="noopener">分时（时间共享）</a>的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。</p><p>OS X 和 iOS 提供了几种不同的 API 来支持并发编程。每一个 API 都具有不同的功能和使用限制，这使它们适合不同的任务。同时，这些 API 处在不同的抽象层级上。我们有可能用其进行非常深入底层的操作，但是这也意味着背负起将任务进行良好处理的巨大责任。</p><p>实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱。当开发者在使用类似 <code>Grand Central Dispatch</code>（GCD）或 <code>NSOperationQueue</code> 的 API 时，很容易遗忘这些问题和陷阱。本文首先对 OS X 和 iOS 中不同的并发编程 API 进行一些介绍，然后再深入了解并发编程中独立于与你所使用的特定 API 的一些内在挑战。</p><h2 id="OS-X-和-iOS-中的并发编程"><a href="#OS-X-和-iOS-中的并发编程" class="headerlink" title="OS X 和 iOS 中的并发编程"></a>OS X 和 iOS 中的并发编程</h2><p>OS X 和 iOS 提供了相同的并发编程API。 本文会介绍 <code>pthread</code> 、 <code>NSThread</code> 、<code>GCD</code> 、<code>NSOperationQueue</code>，以及 <code>NSRunLoop</code>（并非并发）。</p><p>由于高层 API 是基于底层 API 构建的，所以我们首先将从底层的 API 开始介绍，然后逐步扩展到高层 API。不过在具体编程中，选择 API 的顺序刚好相反：因为大多数情况下，选择高层的 API 不仅可以完成底层 API 能完成的任务，而且能够让并发模型变得简单。</p><p>如果你对我们为何坚持推荐使用高抽象层级以及简单的并行代码有所疑问的话，那么你可以看看这篇文章的第二部分<a href="#challenges">并发编程中面临的挑战</a>，以及 Peter Steinberger 写的关于<a href="http://objccn.io/issue-2-4/" target="_blank" rel="noopener">线程安全</a>的文章。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><a href="http://zh.wikipedia.org/wiki/线程" target="_blank" rel="noopener">线程</a>（thread）是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。</p><p>多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。</p><p>你可以使用 Instruments 中的 <a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html" target="_blank" rel="noopener">CPU strategy view</a> 来得知你的代码或者你在使用的框架代码是如何在多核 CPU 中调度执行的。</p><p>需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，以及无法控制执行多长时间后将被暂停，以便轮换执行别的任务。这种线程调度是非常强大的一种技术，但是也非常复杂，我们稍后研究。</p><p>先把线程调度的复杂情况放一边，开发者可以使用 <a href="http://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">POSIX 线程</a> API，或者 Objective-C 中提供的对该 API 的封装 <code>NSThread</code>，来创建自己的线程。</p><h4 id="线程实例"><a href="#线程实例" class="headerlink" title="线程实例"></a>线程实例</h4><p><strong>在一百万个数字中查找最小值和最大值</strong>。</p><h5 id="pthread-方式实现"><a href="#pthread-方式实现" class="headerlink" title="pthread 方式实现"></a><code>pthread</code> 方式实现</h5><p>下面这个小示例利用 <code>pthread</code> 来<strong>在一百万个数字中查找最小值和最大值</strong>。其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> * inputValues;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadResult</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> min;</span><br><span class="line"><span class="keyword">uint32_t</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">findMinAndMax</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadInfo</span> <span class="title">const</span> * <span class="title">const</span> <span class="title">info</span> = (<span class="title">struct</span> <span class="title">threadInfo</span> *) <span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> min = UINT32_MAX;</span><br><span class="line"><span class="keyword">uint32_t</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; info-&gt;count; ++i) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> v = info-&gt;inputValues[i];</span><br><span class="line">min = MIN(min, v);</span><br><span class="line">max = MAX(max, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(arg);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadResult</span> * <span class="title">const</span> <span class="title">result</span> = (<span class="title">struct</span> <span class="title">threadResult</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">result</span>));</span></span><br><span class="line">result-&gt;min = min;</span><br><span class="line">result-&gt;max = max;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> <span class="keyword">const</span> count = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> inputValues[count];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用随机数字填充 inputValues</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">inputValues[i] = arc4random();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始4个寻找最小值和最大值的线程</span></span><br><span class="line"><span class="keyword">size_t</span> <span class="keyword">const</span> threadCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> tid[threadCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadInfo</span> * <span class="title">const</span> <span class="title">info</span> = (<span class="title">struct</span> <span class="title">threadInfo</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">info</span>));</span></span><br><span class="line"><span class="keyword">size_t</span> offset = (count / threadCount) * i;</span><br><span class="line">info-&gt;inputValues = inputValues + offset;</span><br><span class="line">info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line"><span class="keyword">int</span> err = pthread_create(tid + i, <span class="literal">NULL</span>, &amp;findMinAndMax, info);</span><br><span class="line">NSCAssert(err == <span class="number">0</span>, @<span class="string">"pthread_create() failed: %d"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待线程退出</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadResult</span> * <span class="title">results</span>[<span class="title">threadCount</span>];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> err = pthread_join(tid[i], (<span class="keyword">void</span> **) &amp;(results[i]));</span><br><span class="line">NSCAssert(err == <span class="number">0</span>, @<span class="string">"pthread_join() failed: %d"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找 min 和 max</span></span><br><span class="line"><span class="keyword">uint32_t</span> min = UINT32_MAX;</span><br><span class="line"><span class="keyword">uint32_t</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">min = MIN(min, results[i]-&gt;min);</span><br><span class="line">max = MAX(max, results[i]-&gt;max);</span><br><span class="line"><span class="built_in">free</span>(results[i]);</span><br><span class="line">results[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"min = %u"</span>, min);</span><br><span class="line">NSLog(@<span class="string">"max = %u"</span>, max);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="NSThread方式实现"><a href="#NSThread方式实现" class="headerlink" title="NSThread方式实现"></a>NSThread方式实现</h5><p><code>NSThread</code> 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切。例如，<strong>开发者可以利用 NSThread 的一个子类来定义一个线程，在这个子类的中封装需要在后台线程运行的代码</strong>。针对上面的那个例子，我们可以定义一个这样的 <code>NSThread</code> 子类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FindMinMaxThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> min;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> max;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FindMinMaxThread</span> </span>&#123;</span><br><span class="line"><span class="built_in">NSArray</span> *_numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">_numbers = numbers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSUInteger</span> min;</span><br><span class="line"><span class="built_in">NSUInteger</span> max;</span><br><span class="line"><span class="comment">// 进行相关数据的处理</span></span><br><span class="line"><span class="keyword">self</span>.min = min;</span><br><span class="line"><span class="keyword">self</span>.max = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的 <code>start</code> 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableSet</span> *threads = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line"><span class="built_in">NSUInteger</span> numberCount = <span class="keyword">self</span>.numbers.count;</span><br><span class="line"><span class="built_in">NSUInteger</span> threadCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line"><span class="built_in">NSUInteger</span> offset = (count / threadCount) * i;</span><br><span class="line"><span class="built_in">NSUInteger</span> count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class="line"><span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(offset, count);</span><br><span class="line"><span class="built_in">NSArray</span> *subset = [<span class="keyword">self</span>.numbers subarrayWithRange:range];</span><br><span class="line">FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class="line">[threads addObject:thread];</span><br><span class="line">[thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以<strong>通过检测到线程的 <code>isFinished</code> 属性来检测新生成的线程是否已经结束，并获取结果</strong>。</p><h4 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h4><p>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。</p><p>接下来，我们将介绍两个基于队列的并发编程 API ：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern" target="_blank" rel="noopener">线程池</a>，来解决上面遇到的问题。</p><h3 id="Grand-Central-Dispatch"><a href="#Grand-Central-Dispatch" class="headerlink" title="Grand Central Dispatch"></a>Grand Central Dispatch</h3><p>为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。在下一篇关于<a href="http://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a> 的文章中，我们将更深入地介绍 GCD。</p><p>通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern" target="_blank" rel="noopener">线程池</a>。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p><p>GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</p><p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。<br>另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p><p><img src="https://www.objccn.io/images/issues/issue-2/gcd-queues.png" alt="GCD queues"></p><p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。更多相关内容，在本文的<a href="#Priority-Inversion">优先级反转</a>部分中会有介绍。</p><p>虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的<a href="#challenges">并发编程中面临的挑战</a>，这样可以注意到一些潜在的问题。本期的另外一篇优秀文章：<a href="http://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a> 中，包含了很多深入的解释和一些有价值的提示。</p><h3 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h3><p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。</p><h4 id="操作队列成员"><a href="#操作队列成员" class="headerlink" title="操作队列成员"></a>操作队列成员</h4><ol><li>主队列：在主线程上运行</li><li>自定义队列：在后台子线程上执行</li><li>操作任务：<code>NSOperation</code> 的子类，即在前两种队列中所要执行的任务代码</li></ol><h4 id="实现操作任务"><a href="#实现操作任务" class="headerlink" title="实现操作任务"></a>实现操作任务</h4><p>你可以通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 <code>operations</code> 。</p><h5 id="重写-main方法"><a href="#重写-main方法" class="headerlink" title="重写 main方法"></a>重写 <code>main</code>方法</h5><p>当 <code>main</code> 方法返回的时候，这个 operation 就结束了。无法控制操作状态属性（例如 <code>isExecuting</code> 和 <code>isFinished</code>）。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 进行处理 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h5 id="重写-start方法"><a href="#重写-start方法" class="headerlink" title="重写 start方法"></a>重写 <code>start</code>方法</h5><p>这种方式可以拥有更多的控制权，以及在一个操作中可以执行异步任务，重写 <code>start</code> 方法必须手动管理操作的状态（例如 <code>isExecuting</code> 和 <code>isFinished</code>）。</p><ol><li><p>重写实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)start</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 开始处理，在结束时应该调用 finished ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)finished</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span>.isExecuting = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.isFinished = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p> 注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。</p></li><li><p>取消功能的实现<br>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 <code>isCancelled</code> 属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (notDone &amp;&amp; !<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line"><span class="comment">// 进行处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写 operation 的<code>description</code> 方法<br>这样就可以很容易的标示出在某个队列中当前被调度的所有操作 。</p><h4 id="操作队列管理"><a href="#操作队列管理" class="headerlink" title="操作队列管理"></a>操作队列管理</h4><h5 id="添加操作任务"><a href="#添加操作任务" class="headerlink" title="添加操作任务"></a>添加操作任务</h5><p>当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">YourOperation *operation = [[YourOperation alloc] init];</span><br><span class="line">[queue addOperation:operation];</span><br></pre></td></tr></table></figure></li></ol><h5 id="添加一次性任务"><a href="#添加一次性任务" class="headerlink" title="添加一次性任务"></a>添加一次性任务</h5><p>另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line"><span class="comment">// 代码...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h5 id="操作队列的任务个数"><a href="#操作队列的任务个数" class="headerlink" title="操作队列的任务个数"></a>操作队列的任务个数</h5><p>除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 <code>maxConcurrentOperationCount</code> 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。</p><h5 id="操作优先级"><a href="#操作优先级" class="headerlink" title="操作优先级"></a>操作优先级</h5><p>另外还有一个方便的功能就是根据队列中 <code>operation</code> 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。</p><h5 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h5><p>如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系。<br>使用<code>NSOperation</code>类的实例方法<code>addDependency:</code>实现操作之间的依赖关系。<br>对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。<br>如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[intermediateOperation addDependency:operation1];</span><br><span class="line">[intermediateOperation addDependency:operation2];</span><br><span class="line">[finishedOperation addDependency:intermediateOperation];</span><br></pre></td></tr></table></figure></p><p>这些简单的代码可以确保 <code>operation1</code> 和 <code>operation2</code> 在 <code>intermediateOperation</code> 之前执行，当然，也会在 <code>finishOperation</code> 之前被执行。</p><p>从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。</p><h3 id="Run-Loops"><a href="#Run-Loops" class="headerlink" title="Run Loops"></a>Run Loops</h3><p>实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p><p>Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的，在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置计时器、使用 <code>NSURLConnection</code> 或者调用 <code>performSelector:withObject:afterDelay:</code>，其实背后都是 run loop 在处理这些异步任务。</p><h4 id="runloop运行模式"><a href="#runloop运行模式" class="headerlink" title="runloop运行模式"></a>runloop运行模式</h4><p>无论何时你使用 run loop 来执行一个方法的时候，都需要记住一点：run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行这种任务上是一种聪明的做法。</p><p>关于这点，在 iOS 中非常典型的一个示例就是滚动。在进行滚动时，run loop 并不是运行在默认模式中的，因此， run loop 此时并不会响应比如滚动前设置的计时器。一旦滚动停止了，run loop 会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其设为 <code>NSRunLoopCommonModes</code> 的模式，并添加到 run loop 中。</p><h4 id="子线程中使用runloop"><a href="#子线程中使用runloop" class="headerlink" title="子线程中使用runloop"></a>子线程中使用runloop</h4><p>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于<a href="http://objccn.io/issue-2-2/" target="_blank" rel="noopener">常见的后台实践</a>的文章里阐述了一些关于这种模式的很好的例子。</p><p>如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。</p><p><a name="challenges" id="challenges"> </a></p><h2 id="并发编程中面临的挑战"><a href="#并发编程中面临的挑战" class="headerlink" title="并发编程中面临的挑战"></a>并发编程中面临的挑战</h2><p>使用并发编程会带来许多陷阱。只要一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。</p><p>关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务<a href="http://research.microsoft.com/en-us/um/people/mbj/Mars_Pathfinder/Mars_Pathfinder.html" target="_blank" rel="noopener">嘎然而止</a>，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为<a href="#priority_inversion">优先级反转</a>，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。</p><p><a name="shared_resources" id="shared_resources"> </a></p><h3 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h3><p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等。在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>为了演示这类问题，我们举一个关于资源的简单示例：<br>描述：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。<br>问题：你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。</p><p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 <code>17</code> ，然后线程A将计数器的值加1，并将结果 <code>18</code> 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 <code>18</code> 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 <code>17</code> 被加 1 了两次，而它的值却是 <code>18</code>。</p><p><img src="https://www.objccn.io/images/issue-2/race-condition.png" alt="竞态条件"></p><p>这个问题被叫做<a href="http://en.wikipedia.org/wiki/Race_conditions#Software" target="_blank" rel="noopener">竞态条件</a>，<strong>在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生</strong>。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p><p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（<a href="http://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="noopener">乱序执行</a>）。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><a href="http://en.wikipedia.org/wiki/Mutex" target="_blank" rel="noopener">互斥</a>访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29" target="_blank" rel="noopener">互斥锁</a>，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p><p><img src="https://www.objccn.io/images/issue-2/locking.png" alt="互斥锁"></p><p>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障</a>。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。</p><p>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：<a href="http://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发技术</a>。</p><h4 id="解决方案：原子声明属性"><a href="#解决方案：原子声明属性" class="headerlink" title="解决方案：原子声明属性"></a>解决方案：原子声明属性</h4><p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p><h4 id="性能开销及锁的竞争"><a href="#性能开销及锁的竞争" class="headerlink" title="性能开销及锁的竞争"></a>性能开销及锁的竞争</h4><p>在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。<br>在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出<a href="http://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener">临界区段</a>（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。</p><h4 id="不同类型的锁"><a href="#不同类型的锁" class="headerlink" title="不同类型的锁"></a>不同类型的锁</h4><p>锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity" target="_blank" rel="noopener">锁的竞争</a>是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。</p><p>我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 <a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html" target="_blank" rel="noopener">CPU strategy view</a> 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。</p><p><a name="dead_locks" id="dead_locks"> </a></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks" target="_blank" rel="noopener">其他问题</a>，其中一个就是<a href="http://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">死锁</a>。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p><p><img src="https://www.objccn.io/images/issue-2/dead-lock.png" alt="死锁"></p><p>看看下面的代码，它交换两个变量的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A, B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lock(lockA);</span><br><span class="line">lock(lockB);</span><br><span class="line"><span class="keyword">int</span> a = A;</span><br><span class="line"><span class="keyword">int</span> b = B;</span><br><span class="line">A = b;</span><br><span class="line">B = a;</span><br><span class="line">unlock(lockB);</span><br><span class="line">unlock(lockA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap(X, Y); <span class="comment">// 线程 1</span></span><br><span class="line">swap(Y, X); <span class="comment">// 线程 2</span></span><br></pre></td></tr></table></figure></p><p>此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p><p>再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>建议阅读一下<a href="http://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发编程 API</a> 中的<a href="http://objccn.io/issue-2-3/#async" target="_blank" rel="noopener">全部使用异步分发</a>一节。</p><h3 id="资源饥饿（Starvation）"><a href="#资源饥饿（Starvation）" class="headerlink" title="资源饥饿（Starvation）"></a>资源饥饿（Starvation）</h3><p>当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起<a href="http://en.wikipedia.org/wiki/Readers-writers_problem" target="_blank" rel="noopener">读写问题</a>。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致<a href="http://en.wikipedia.org/wiki/Resource_starvation" target="_blank" rel="noopener">资源饥饿</a>的发生。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 <a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" target="_blank" rel="noopener">writer preference</a>，或者使用 <a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank" rel="noopener">read-copy-update</a> 算法。Daniel 在<a href="http://objccn.io/issue-2-3/#multiple-readers-single-writer" target="_blank" rel="noopener">底层并发编程 API </a>中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。</p><p><a name="priority_inversion" id="priority_inversion"> </a></p><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的<a href="http://en.wikipedia.org/wiki/Priority_inversion" target="_blank" rel="noopener">优先级反转</a>。</p><p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。</p><p>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p><p><img src="https://www.objccn.io/images/issue-2/priority-inversion.png" alt="优先级反转"></p><p>在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。</p><p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p><p>从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。</p><p>但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。</p><p>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p><hr><p><a href="http://objccn.io/issue-2" target="_blank" rel="noopener">话题 #2 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html" target="_blank" rel="noopener">Concurrent Programming: APIs and Challenges</a></p><p>精细校对 <a href="http://im.onevcat.com" target="_blank" rel="noopener">@onevcat</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS视图渲染</title>
      <link href="/2017/09/23/iOS/UI/iOS%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93/"/>
      <url>/2017/09/23/iOS/UI/iOS%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="图形堆栈"><a href="#图形堆栈" class="headerlink" title="图形堆栈"></a>图形堆栈</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的<a href="https://zh.wikipedia.org/wiki/%E6%A9%AB%E5%90%91%E9%9B%BB%E5%A0%B4%E6%95%88%E6%87%89%E9%A1%AF%E7%A4%BA%E6%8A%80%E8%A1%93" target="_blank" rel="noopener">液晶显示器</a>上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。</p><h3 id="软件堆栈组成"><a href="#软件堆栈组成" class="headerlink" title="软件堆栈组成"></a>软件堆栈组成</h3><p>从简单的角度来看，软件堆栈看起来有点像这样：</p><p><img src="https://objccn.io/images/issue-3/pixels-software-stack.png" alt="软件堆栈"></p><h4 id="GPU强大的图形硬件"><a href="#GPU强大的图形硬件" class="headerlink" title="GPU强大的图形硬件"></a>GPU强大的图形硬件</h4><p><code>Display</code>的上一层便是图形处理单元 GPU，<code>GPU</code> 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。</p><p>GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的<a href="https://zh.wikipedia.org/wiki/I/O%E6%80%BB%E7%BA%BF" target="_blank" rel="noopener">总线</a>，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。</p><p><code>GPU Driver</code>是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.</p><h4 id="OpenGL的扩展API"><a href="#OpenGL的扩展API" class="headerlink" title="OpenGL的扩展API"></a>OpenGL的扩展API</h4><p>OpenGL(<a href="http://zh.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener">Open Graphics Library</a>) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL  和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p><p>在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。<br>在OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。</p><h2 id="GPU纹理合成渲染流程"><a href="#GPU纹理合成渲染流程" class="headerlink" title="GPU纹理合成渲染流程"></a>GPU纹理合成渲染流程</h2><p><img src="https://objccn.io/images/issue-3/pixels%2C%20hardware.png" alt="挑战"></p><p>合成挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p><p>耗时挑战：下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p><p>最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p><p>这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。</p><h3 id="合成-纹理概念"><a href="#合成-纹理概念" class="headerlink" title="合成/纹理概念"></a>合成/纹理概念</h3><p>合成：在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。</p><p>纹理：屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中的纹理就是 CALayer。</p><p>纹理合成：在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。</p><h3 id="纹理合成像素的计算公式"><a href="#纹理合成像素的计算公式" class="headerlink" title="纹理合成像素的计算公式"></a>纹理合成像素的计算公式</h3><p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p><p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = S + D * ( 1 – Sa )</span><br></pre></td></tr></table></figure></p><p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p><p>显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = S</span><br></pre></td></tr></table></figure></p><p>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。</p><p>如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.5   0               0.5</span><br><span class="line">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class="line">0     1               0.5</span><br></pre></td></tr></table></figure></p><p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p><p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p><h4 id="opaque-的属性：不透明-VS-透明"><a href="#opaque-的属性：不透明-VS-透明" class="headerlink" title="opaque 的属性：不透明 VS 透明"></a>opaque 的属性：不透明 VS 透明</h4><p>当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。<br> CALayer 有一个叫做 opaque 的属性会告诉 GPU 纹理上的像素是透明还是不透明的。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。<br> 所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。</p><h4 id="像素对齐-VS-不重合在一起"><a href="#像素对齐-VS-不重合在一起" class="headerlink" title="像素对齐 VS 不重合在一起"></a>像素对齐 VS 不重合在一起</h4><ol><li>像素对齐<br>到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</li><li>滚动/错位<br>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。<br>第一个便是滚动：当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。<br>另一个原因便是：当纹理的起点不在一个像素的边界上。</li></ol><p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p><p>Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p><h3 id="Masks位图蒙板"><a href="#Masks位图蒙板" class="headerlink" title="Masks位图蒙板"></a>Masks位图蒙板</h3><p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和蒙板下面包含的像素合并之前都会把 mask 应用到图层的像素上去，最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。<br>例如：当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。</p><h3 id="离屏渲染-Offscreen-Rendering"><a href="#离屏渲染-Offscreen-Rendering" class="headerlink" title="离屏渲染(Offscreen Rendering)"></a>离屏渲染(Offscreen Rendering)</h3><p>离屏渲染：即在屏幕外对图层树的合并/渲染，此时会有一个屏幕外缓冲区缓存图层树，然后该缓冲区会被渲染到屏幕上。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。</p><p>离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。<br>Instrument 的 Core Animation 工具有一个叫做 <em>Color Offscreen-Rendered Yellow</em> 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p><h4 id="GPU离屏渲染多图层动画"><a href="#GPU离屏渲染多图层动画" class="headerlink" title="GPU离屏渲染多图层动画"></a>GPU离屏渲染多图层动画</h4><p>如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。</p><ol><li>两个权衡点<br>第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。<br>第二，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。</li><li><p>副作用：mask蒙板渲染至缓冲区<br>离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。</p></li><li><p>避免使用离屏渲染<br>因为直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。<br>layer的几种触发离屏渲染<br>为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。<br>至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。<br>所以当你打开 <em>Color Offscreen-Rendered Yellow</em> 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。</p></li><li>离屏渲染空间限制<br>同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。</li></ol><h2 id="更多的关于合成"><a href="#更多的关于合成" class="headerlink" title="更多的关于合成"></a>更多的关于合成</h2><p>像往常一样，维基百科上有更多关于<a href="https://en.wikipedia.org/wiki/Alpha_compositing" target="_blank" rel="noopener">透明合成</a>的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。</p><h2 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h2><p>如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 <em>Quartz Debug</em> 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 <a href="https://developer.apple.com/downloads/" target="_blank" rel="noopener">developer portal</a> 中下载到。</p><h2 id="Core-Animation-OpenGL-ES"><a href="#Core-Animation-OpenGL-ES" class="headerlink" title="Core Animation  OpenGL ES"></a>Core Animation  OpenGL ES</h2><p>正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。</p><p>Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。</p><p>Core Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。</p><p>举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 <code>-drawInContext</code> 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在<code>drawInContext</code>中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。</p><p>Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。</p><h2 id="CPU限制-VS-GPU限制"><a href="#CPU限制-VS-GPU限制" class="headerlink" title="CPU限制 VS GPU限制"></a>CPU限制 VS GPU限制</h2><p>当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。</p><p>为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要把尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。</p><p>既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。</p><p>要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。</p><h2 id="Core-Graphics-Quartz-2D"><a href="#Core-Graphics-Quartz-2D" class="headerlink" title="Core Graphics / Quartz 2D"></a>Core Graphics / Quartz 2D</h2><p>通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。</p><p>Quartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。</p><p>让我们简单的了解一下 <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html" target="_blank" rel="noopener">Quartz 2D</a> 主要的概念。有关详细信息可以到苹果的官方文档中了解。</p><p>放心，当 Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。</p><p>主要的概念相对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的<a href="https://developer.apple.com/videos/wwdc/2011/?id=129" target="_blank" rel="noopener">股票应用</a>作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。</p><p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。</p><p>比方说，我们要画一个<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BE%B9%E5%BD%A2" target="_blank" rel="noopener">八角形</a>，我们通过 UIKit 能做到这一点<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">16.72</span>, <span class="number">7.22</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">3.29</span>, <span class="number">20.83</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0.4</span>, <span class="number">18.05</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">18.8</span>, <span class="number">-0.47</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">37.21</span>, <span class="number">18.05</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">34.31</span>, <span class="number">20.83</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">20.88</span>, <span class="number">7.22</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">20.88</span>, <span class="number">42.18</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">16.72</span>, <span class="number">42.18</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">16.72</span>, <span class="number">7.22</span>)];</span><br><span class="line">[path closePath];</span><br><span class="line">path.lineWidth = <span class="number">1</span>;</span><br><span class="line">[[<span class="built_in">UIColor</span> redColor] setStroke];</span><br><span class="line">[path stroke];</span><br></pre></td></tr></table></figure></p><p>相对应的 Core Graphics 代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextBeginPath</span>(ctx);</span><br><span class="line"><span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">16.72</span>, <span class="number">7.22</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">3.29</span>, <span class="number">20.83</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">0.4</span>, <span class="number">18.05</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">18.8</span>, <span class="number">-0.47</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">37.21</span>, <span class="number">18.05</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">34.31</span>, <span class="number">20.83</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">20.88</span>, <span class="number">7.22</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">20.88</span>, <span class="number">42.18</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">16.72</span>, <span class="number">42.18</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">16.72</span>, <span class="number">7.22</span>);</span><br><span class="line"><span class="built_in">CGContextClosePath</span>(ctx);</span><br><span class="line"><span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> redColor].CGColor);</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</span><br></pre></td></tr></table></figure></p><p>需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 <code>-drawInContext:</code> 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 <code>CGBitmapContextCreate()</code>.这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。</p><p>注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 <code>UIGraphicsGetCurrentContext()</code> 来得到最顶层的上下文。你可以使用 <code>UIGraphicsPushContext()</code> 和 <code>UIGraphicsPopContext()</code> 在 UIKit 的堆栈中推进或取出上下文。</p><p>最为突出的是，UIKit 使用 <code>UIGraphicsBeginImageContextWithOptions()</code> 和 <code>UIGraphicsEndImageContext()</code> 方便的创建类似于 <code>CGBitmapContextCreate()</code> 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(<span class="number">45</span>, <span class="number">45</span>), <span class="literal">YES</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextBeginPath</span>(ctx);</span><br><span class="line"><span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">16.72</span>, <span class="number">7.22</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">3.29</span>, <span class="number">20.83</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure></p><p>或者另外一种方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="number">90</span>, <span class="number">90</span>, <span class="number">8</span>, <span class="number">90</span> * <span class="number">4</span>, space, bitmapInfo);</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">UIGraphicsPushContext</span>(ctx);</span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">16.72</span>, <span class="number">7.22</span>)];</span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">3.29</span>, <span class="number">20.83</span>)];</span><br><span class="line">...</span><br><span class="line">[path stroke];</span><br><span class="line"><span class="built_in">UIGraphicsPopContext</span>(ctx);</span><br><span class="line"><span class="built_in">CGContextRelease</span>(ctx);</span><br></pre></td></tr></table></figure></p><p>你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 <a href="https://zh.wikipedia.org/wiki/Adobe_Illustrator" target="_blank" rel="noopener">Adobe Illustrator</a> 和 <a href="https://zh.wikipedia.org/wiki/Adobe_Photoshop" target="_blank" rel="noopener">Adobe Photoshop</a> 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 <a href="https://zh.wikipedia.org/wiki/NEXTSTEP" target="_blank" rel="noopener">NeXTSTEP</a> 。(原来也是乔老爷的作品)。</p><h2 id="CGLayer"><a href="#CGLayer" class="headerlink" title="CGLayer"></a>CGLayer</h2><p>我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 <a href="http://iosptl.com/posts/cglayer-no-longer-recommended/" target="_blank" rel="noopener">Dave Hayden指出</a>，这些<a href="http://iosptl.com/posts/cglayer-no-longer-recommended/" target="_blank" rel="noopener">小道消息</a>不再可靠。</p><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><p>屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。</p><p>稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。</p><h3 id="默认的像素布局"><a href="#默认的像素布局" class="headerlink" title="默认的像素布局"></a>默认的像素布局</h3><p>在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A   R   G   B   A   R   G   B   A   R   G   B</span><br><span class="line">| pixel 0       | pixel 1       | pixel 2</span><br><span class="line">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p><p>这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: <code>240,99,24</code>.一个完全不透明的橙色像素拥有的 ARGB 值为:<code>255，240，99，24</code>，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:<code>84，80，33，8.</code></p><p>另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   R   G   B   x   R   G   B   x   R   G   B</span><br><span class="line">| pixel 0       | pixel 1       | pixel 2</span><br><span class="line">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p><p>这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。</p><p>当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。</p><h3 id="深奥的布局"><a href="#深奥的布局" class="headerlink" title="深奥的布局"></a>深奥的布局</h3><p>大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式：</p><p>另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。</p><p>还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。</p><p>整件事件中，Core Graphics 也支持一些像灰度模式和 <a href="https://zh.wikipedia.org/wiki/%E5%8D%B0%E5%88%B7%E5%9B%9B%E5%88%86%E8%89%B2%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">CMYK</a> 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。</p><h3 id="二维数据"><a href="#二维数据" class="headerlink" title="二维数据"></a>二维数据</h3><p>当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。</p><p>在某些情况下，一些视频框架便会使用二维数据。</p><h3 id="YCbCr"><a href="#YCbCr" class="headerlink" title="YCbCr"></a>YCbCr</h3><p>当我们处理视频数据时，<a href="https://zh.wikipedia.org/wiki/YCbCr" target="_blank" rel="noopener">YCbCr</a> 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。</p><p>出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。</p><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。</p><h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><p>每个人都知道 JPEG。它是相机的产物。它代表着照片如何存储在电脑上。甚至你妈妈都听说过 JPEG。</p><p>一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真相真是差十万八千里了。</p><p>将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">离散余弦变换</a>(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">哈夫曼编码</a>的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。</p><p>这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。</p><p>那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。</p><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p><a href="https://zh.wikipedia.org/wiki/PNG" target="_blank" rel="noopener">PNG</a>读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。</p><p>在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。</p><h3 id="挑选一个格式"><a href="#挑选一个格式" class="headerlink" title="挑选一个格式"></a>挑选一个格式</h3><p>当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。</p><p>已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。</p><p>当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是<a href="https://developer.apple.com/library/ios/qa/qa1681/_index.html" target="_blank" rel="noopener">有效的PNG文件</a>。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。</p><p>让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。</p><h2 id="图层后备存储的渲染"><a href="#图层后备存储的渲染" class="headerlink" title="图层后备存储的渲染"></a>图层后备存储的渲染</h2><h3 id="UIKit-和-Pixels"><a href="#UIKit-和-Pixels" class="headerlink" title="UIKit 和 Pixels"></a>UIKit 和 Pixels</h3><p>每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。</p><h3 id="With-–drawRect"><a href="#With-–drawRect" class="headerlink" title="With –drawRect:"></a>With –drawRect:</h3><p>如果你的视图类实现了 <code>-drawRect:</code>，他们将像这样工作:</p><ol><li>设置一个标示<br>当你调用 <code>-setNeedsDisplay</code>，UIKit 将会在这个视图的图层上调用 <code>-setNeedsDisplay</code>。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以多次调用 <code>-setNeedsDisplay</code>并不会造成性能损失。</li><li>装备后备存储<br>当渲染系统准备好，它会调用视图图层的<code>-display</code>方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。<br>2.1 使用 UIKit 的绘制方法<br>当你使用 UIKit 的绘制方法，例如: <code>UIRectFill()</code> 或者 <code>-[UIBezierPath fill]</code> 代替你的 <code>-drawRect:</code> 方法，他们将会使用这个上下文。<br>使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 <code>UIGraphicsGetCurrent()</code> 将会返回那个对应的上下文。既然 UIKit 使用 <code>UIGraphicsGetCurrent()</code> 绘制方法，绘图将会进入到图层的后备存储。<br>2.2  直接使用 Core Graphics 方法<br>通过调用 <code>UIGraphicsGetCurrent()</code> 得到相同的上下文，并将这个上下文传给 Core Graphics 方法。</li></ol><p>从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 <code>-setNeedsDisplay</code> ，将会依次将图层的后备存储更新到视图上。</p><h3 id="不使用-drawRect"><a href="#不使用-drawRect" class="headerlink" title="不使用 -drawRect:"></a>不使用 -drawRect:</h3><p>当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。</p><p>在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。</p><h2 id="实现-drawRect-还是不实现-drawRect"><a href="#实现-drawRect-还是不实现-drawRect" class="headerlink" title="实现-drawRect: 还是不实现 -drawRect:"></a>实现-drawRect: 还是不实现 -drawRect:</h2><p>最快的绘制就是你不要做任何绘制。<br>大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。</p><p>当你需要自定义绘图代码时，Apple 在<a href="https://developer.apple.com/videos/wwdc/2012/?id=506" target="_blank" rel="noopener">WWDC 2012’s session 506</a>:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。</p><p>另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 <code>-drawRect:</code> 方法。有时，通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 或者 <code>CGBitmapContextCeate()</code> 创建位图会显得更有意义，从位图上面抓取图像，并设置为 <code>CALayer</code> 的内容。下面我们将给出一个例子来测试，检验。</p><h3 id="单一颜色"><a href="#单一颜色" class="headerlink" title="单一颜色"></a>单一颜色</h3><p>如果我们看这个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">[[<span class="built_in">UIColor</span> redColor] setFill];</span><br><span class="line"><span class="built_in">UIRectFill</span>([<span class="keyword">self</span> bounds]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。</p><p>我们跟本不需要实现 <code>-drawRect:</code>，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。</p><h3 id="可变尺寸的图像"><a href="#可变尺寸的图像" class="headerlink" title="可变尺寸的图像"></a>可变尺寸的图像</h3><p>类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×50 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。</p><p>Core Animation 可以通过 CALayer 的 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/contentsCenter" target="_blank" rel="noopener"><code>contentsCenter</code></a> 属性来改变图像，大多数情况下，你可能更倾向于使用，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/instm/UIImage/resizableImageWithCapInsets:resizingMode:" target="_blank" rel="noopener"><code>-[UIImage resizableImageWithCapInsets:resizingMode:]</code></a>。</p><p>同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。</p><h3 id="并发绘图"><a href="#并发绘图" class="headerlink" title="并发绘图"></a>并发绘图</h3><p>上一次 <a href="http://objccn.io/issue-2/" target="_blank" rel="noopener">objc.io</a> 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？</p><p>如果你必须实现 <code>-drawRect:</code>，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。</p><p>我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。<br>为了同时绘制，我们需要做下面的操作:</p><ol><li>正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread.</li><li>我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 <a href="https://developer.apple.com/videos/wwdc/2012/?id=211" target="_blank" rel="noopener">WWDC 2012 session 211</a> 中讨论过。(异步下载图片经常用到这个)</li></ol><p>增加一个你可以在其中绘制的新方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)renderInImageOfSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制代码块</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *result = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 方法，并根据给定的大小创建一个新的 CGContextRef 位图上下文。这个方法也会将这个上下文设置为<em>当前UIKit</em>的上下文。现在你可以在这里做你想在 <code>-drawRect:</code> 中做的事了。然后通过 <code>UIGraphicsGetImageFromCurrentImageContext()</code>,获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。</p><p>很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。<br>另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。</p><p>要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 <code>UIGraphicsBeginImageContextWithOptions()</code> 开始，以 <code>UIGraphicsEndIamgeContext()</code> 结束。</p><p>你需要像下面这样触发渲染代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *view; <span class="comment">// assume we have this</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *renderQueue; <span class="comment">// assume we have this</span></span><br><span class="line"><span class="built_in">CGSize</span> size = view.bounds.size;</span><br><span class="line">[renderQueue addOperationWithBlock:^()&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [renderer renderInImageOfSize:size];</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^()&#123;</span><br><span class="line">        view.image = image;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>要注意，我们是在主队列中调用 <code>view.image = image</code>.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。</p><p>像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 <code>-renderInImageOfSize:</code>。</p><p>最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。</p><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。</p><p>通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。</p><p>尽管还有很多其他种类的图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。</p><h3 id="自定义绘制的图层"><a href="#自定义绘制的图层" class="headerlink" title="自定义绘制的图层"></a>自定义绘制的图层</h3><p>如果一个 CALayer 的子类实现了 <code>-drawInContext:</code> 或者它的代理，类似于 <code>-drawLayer:inContest:</code>, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。</p><h3 id="形状和文本图层"><a href="#形状和文本图层" class="headerlink" title="形状和文本图层"></a>形状和文本图层</h3><p>形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 <code>-drawInContext:</code> 方法，然后在方法内绘制形状或文本，他们的性能也很接近。</p><p>在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。</p><h3 id="异步绘图"><a href="#异步绘图" class="headerlink" title="异步绘图"></a>异步绘图</h3><p>CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。</p><p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 <code>-drawRect:/-drawInContext:</code> 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p><p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p><p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p><hr><p><a href="http://objccn.io/issue-3/" target="_blank" rel="noopener">话题 #3 下的更多文章</a></p><p>原文 <a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html" target="_blank" rel="noopener">Getting Pixels onto the Screen</a></p><p>译文 <a href="http://answerhuang.duapp.com/index.php/2013/09/04/pixels-get-onto-the-screen/" target="_blank" rel="noopener">将像素绘制到屏幕上去 - answer-huang</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公司背调</title>
      <link href="/2017/09/11/%E5%85%AC%E5%8F%B8%E8%83%8C%E8%B0%83/"/>
      <url>/2017/09/11/%E5%85%AC%E5%8F%B8%E8%83%8C%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>北京乐信圣文有限责任公司<br>职位：高级iOS开发工程师</p><ol><li>上机题算法，手写代码<br>2.</li></ol><p>经验：可通过拉勾APP了解面试评论区，来获取面试者的经历，充分做好面试前准备<br>经验2: 看准网，查看面试经</p><h3 id="从操作系统的角度说一下，为什么要有进程和线程？"><a href="#从操作系统的角度说一下，为什么要有进程和线程？" class="headerlink" title="从操作系统的角度说一下，为什么要有进程和线程？"></a>从操作系统的角度说一下，为什么要有进程和线程？</h3><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p><h3 id="说一下你会的数据结构知识"><a href="#说一下你会的数据结构知识" class="headerlink" title="说一下你会的数据结构知识"></a>说一下你会的数据结构知识</h3><p>IOS常用数据结构NSArray、NSMutableArray、NSDictionary、NSMutableDictionary介绍</p><h3 id="代理和block的区别"><a href="#代理和block的区别" class="headerlink" title="代理和block的区别"></a>代理和block的区别</h3><p>假如你需要对状态做精细的处理，比如UIScrollView将要滑动，已经开始滑动，结束减速这样的， 你应该优先使用delegate<br>假如你只需要结果，比如网络请求，你只需要知道请求成功和失败，那么你应该优先使用block</p><h3 id="接口和抽象类的本质区别"><a href="#接口和抽象类的本质区别" class="headerlink" title="接口和抽象类的本质区别"></a>接口和抽象类的本质区别</h3><p>抽象类要被子类继承，接口要被类实现。<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现<br><a href="http://www.cnblogs.com/yongjiapei/p/5494894.html" target="_blank" rel="noopener">http://www.cnblogs.com/yongjiapei/p/5494894.html</a></p><h3 id="输入url到展示页面整个过程发生了什么？"><a href="#输入url到展示页面整个过程发生了什么？" class="headerlink" title="输入url到展示页面整个过程发生了什么？"></a>输入url到展示页面整个过程发生了什么？</h3><h3 id="展示独自实现的最牛的功能和界面，数据处理和页面搭建用了哪些好的框架，为了提高用户体验做了哪些优化。"><a href="#展示独自实现的最牛的功能和界面，数据处理和页面搭建用了哪些好的框架，为了提高用户体验做了哪些优化。" class="headerlink" title="展示独自实现的最牛的功能和界面，数据处理和页面搭建用了哪些好的框架，为了提高用户体验做了哪些优化。"></a>展示独自实现的最牛的功能和界面，数据处理和页面搭建用了哪些好的框架，为了提高用户体验做了哪些优化。</h3><p>上机题：<br>排序或递归实现n的阶乘</p><p>爱奇艺</p><h3 id="多线程相关问题-：NSThread，GCD，NSOperation"><a href="#多线程相关问题-：NSThread，GCD，NSOperation" class="headerlink" title="多线程相关问题 ：NSThread，GCD，NSOperation"></a>多线程相关问题 ：NSThread，GCD，NSOperation</h3><h3 id="项目中遇到的困难怎么解决的。先说思路，再找策略，举例说明"><a href="#项目中遇到的困难怎么解决的。先说思路，再找策略，举例说明" class="headerlink" title="项目中遇到的困难怎么解决的。先说思路，再找策略，举例说明"></a>项目中遇到的困难怎么解决的。先说思路，再找策略，举例说明</h3><h3 id="内存管理：-swift-oc区别"><a href="#内存管理：-swift-oc区别" class="headerlink" title="内存管理： swift oc区别"></a>内存管理： swift oc区别</h3><h3 id="视频相关-：-参看objc介绍"><a href="#视频相关-：-参看objc介绍" class="headerlink" title="视频相关 ： 参看objc介绍"></a>视频相关 ： 参看objc介绍</h3><p>华韵在线</p><h3 id="简述iOS内存管理机制，在实际开发中有哪些要注意的地方？"><a href="#简述iOS内存管理机制，在实际开发中有哪些要注意的地方？" class="headerlink" title="简述iOS内存管理机制，在实际开发中有哪些要注意的地方？"></a>简述iOS内存管理机制，在实际开发中有哪些要注意的地方？</h3><p>iOS7之后，arc，代理和block问题</p><h3 id="简述iOS的runtime机制，列举一些应用场景。"><a href="#简述iOS的runtime机制，列举一些应用场景。" class="headerlink" title="简述iOS的runtime机制，列举一些应用场景。"></a>简述iOS的runtime机制，列举一些应用场景。</h3><p>oc是基于运行时的编程语言，添加属性，方法混淆，内省机制，单元测试</p><h3 id="如何解决一个按钮被一个半透明的view部分遮挡，需要点击到按钮的时候，按钮始终响应。"><a href="#如何解决一个按钮被一个半透明的view部分遮挡，需要点击到按钮的时候，按钮始终响应。" class="headerlink" title="如何解决一个按钮被一个半透明的view部分遮挡，需要点击到按钮的时候，按钮始终响应。"></a>如何解决一个按钮被一个半透明的view部分遮挡，需要点击到按钮的时候，按钮始终响应。</h3><p>系统是如何寻找最合适的View</p><ol><li>先判断自己是否能接收触摸事件</li><li>再判断触摸的当前点在不在自己身上</li><li>如果在自己身上,它会从后往前遍历子控件,遍历出每一个控件后,重启前两步</li><li>如果没有符合条件的子控件,那么自身就是最合适的View<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line">//当触摸点在按钮上的时候,才让按钮去响应事件.</span><br><span class="line">//把当前点转换成按钮坐标系上的点.</span><br><span class="line">CGPoint btnP =  [self convertPoint:point toView:self.btn];</span><br><span class="line">if ( [self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">return self.btn;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>事件是如何产生与传递的?<br>当发生触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中. UIApplication会从时间队列中取出最前面的时间,并将事件分发下去以便处理.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸时间.<br>触摸时间的传递是从父控件传递到子控件的,如果一个父控件不能接收事件,那么他里面的子控件也不能接收.</p><h3 id="如何访问并修改一个类的私有属性？"><a href="#如何访问并修改一个类的私有属性？" class="headerlink" title="如何访问并修改一个类的私有属性？"></a>如何访问并修改一个类的私有属性？</h3><p>KVC<br>runtime<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">Person *p = [Person new];</span><br><span class="line">// IVar是runtime声明的一个宏</span><br><span class="line">unsigned int count = 0; //count记录变量的数量</span><br><span class="line">// 获取类的所有属性变量</span><br><span class="line">Ivar *members = class_copyIvarList([Person class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">Ivar ivar = members[i];</span><br><span class="line">// 取得属性名并转成字符串类型</span><br><span class="line">const char *memberName = ivar_getName(ivar);</span><br><span class="line">NSLog(@&quot;%s&quot;,memberName);</span><br><span class="line">Ivar name = members[0];</span><br><span class="line">// 修改属性值</span><br><span class="line">object_setIvar(Person, name, @&quot;yyMae&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="设计一个对于插入删除和遍历操作线程安全的mutable-array"><a href="#设计一个对于插入删除和遍历操作线程安全的mutable-array" class="headerlink" title="设计一个对于插入删除和遍历操作线程安全的mutable array"></a>设计一个对于插入删除和遍历操作线程安全的mutable array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ThreadSafetyArray : NSObject &#123;</span><br><span class="line">@private NSMutableArray* _array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addObject:(NSObject*)obj;</span><br><span class="line">- (void)walk:(void (^)(NSObject*))walkfun;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ThreadSafetyArray</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_array = [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addObject:(NSObject*)obj &#123;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">[_array addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)walk:(void (^)(NSObject*))walkfun &#123;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">for (NSObject* obj in _array) &#123;</span><br><span class="line">walkfun(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作简历</title>
      <link href="/2017/09/10/%E5%B7%A5%E4%BD%9C%E7%AE%80%E5%8E%86/"/>
      <url>/2017/09/10/%E5%B7%A5%E4%BD%9C%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>手机：13522834108</li><li>Email：<a href="mailto:724987481@qq.com" target="_blank" rel="noopener">724987481@qq.com</a></li></ul><hr><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul><li>霍曙光/男/1988</li><li>本科/郑州轻工业学院 计算机网络技术</li><li>工作年限：6年</li><li>QQ：724987481</li><li>技术博客：<a href="https://huos3203.github.io">https://huos3203.github.io</a></li><li>期望职位：iOS开发工程师／主程</li><li>期望薪资：税前月薪18K—20K</li><li>期望城市：北京</li></ul><h3 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h3><p>个人风趣幽默，犯二常有，人缘好，热爱生活，酷爱表达：能整宿撸码，也能写诗作对，有个人博客和公众号，分享技术，旅游和生活点滴。周末经常参加<code>活动行</code>组织的线下技术沙龙和娱乐活动。</p><p>简单说是项目组开心果，技术的杠把子，天生的号召力，活跃在团建里，欢乐在工作里，致力于将繁重紧急的工作，化繁为简为有趣小题目游戏，来激发大家兴趣斗志，同甘共苦坚守在APP生死线上。</p><hr><h3 id="个人作品"><a href="#个人作品" class="headerlink" title="个人作品"></a>个人作品</h3><p>2015/05 – 2016/11<br>iResearcher：是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。<br>爱跑：是一款鼓励用户多运动的APP社区应用，能安排运动日程，统计每日运动量，统计圈子排行榜，支持圈子好友即时通讯。</p><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="2013-11-–-至今"><a href="#2013-11-–-至今" class="headerlink" title="2013/11 – 至今"></a>2013/11 – 至今</h3><p><strong>北京创世泰克科技股份有限公司</strong></p><ol><li>公司简介<br>微软代理软件签名技术研发公司，自主研发多款APP和云服务，致力于数字化知识产权保护，备受原创者和网络教育的热捧。</li><li>APP产品<br>鹏保宝，PBBReader（iOS/macOS），绥知</li><li>个人经验<br>在鹏保宝三款产品开发中，担任项目主程，参与分析产品需求，预研具体的技术实现和重要的技术问题，完成核心功能的编码研发，负责组内任务分解、工作分配、代码审查，确保按时按量交付。</li></ol><h3 id="2012-02-–-2013-11"><a href="#2012-02-–-2013-11" class="headerlink" title="2012/02 – 2013/11"></a>2012/02 – 2013/11</h3><p><strong>北京鼎盛中天科技有限公司</strong></p><ol><li>公司简介<br>一家创业型公司，针对大型展会和众信旅游等公司合作，业务多样性包括近距离电子名片，ERP客户端开发，精选商品推荐等。</li><li>APP产品<br>众信旅游ERP客户端，会议通，易购8</li><li>个人经验<br>公司创业期间，项目架构设计，技术调研学习，以及开发前期工作也亲力亲为，例如：产品需求分析，原型设计等，常处于1个人当作2个人的高压状态。两年历练更渴望能独当一面提升自己。</li></ol><h3 id="2011-01-–-2012-02"><a href="#2011-01-–-2012-02" class="headerlink" title="2011/01 – 2012/02"></a>2011/01 – 2012/02</h3><p><strong>郑州四棵松工作室</strong></p><ol><li>公司简介<br>归属北京超星图书旗下，做爬取报刊／书籍以及目录自动化整理的小应用开发，爬取HTML数据，存储到SQLServer数据库中。</li><li>爬虫工具</li><li>技术描述<br>使用HttpClient，HtmlParser解析工具和正则匹配表达式，对字符串，flash动画和js脚本进行处理，来获取目标文本内容和资源路径。优化传统的爬取方式，使得每月从50万+至100万+产量，大幅提升了在超星旗下的竞争力。</li></ol><h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><hr><h2 id="北京创世泰克科技股份有限公司-2013年11月-至今"><a href="#北京创世泰克科技股份有限公司-2013年11月-至今" class="headerlink" title="北京创世泰克科技股份有限公司 (2013年11月~至今)"></a>北京创世泰克科技股份有限公司 (2013年11月~至今)</h2><h3 id="工作描述："><a href="#工作描述：" class="headerlink" title="工作描述："></a>工作描述：</h3><p>1．负责IOS移动端App的开发及团队管理,监控产品开发质量、进度和成本控制；<br>2．负责移动平台软件框架的研究，设计和实现、关键技术验证和选型等工作；<br>3．负责移动规范制订、技术文档编写;</p><hr><h3 id="PBB-Reader-macOS版"><a href="#PBB-Reader-macOS版" class="headerlink" title="PBB Reader macOS版"></a><a href="http://www.pyc.com.cn/Application/download.aspx" target="_blank" rel="noopener">PBB Reader macOS版</a></h3><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><p>调研macOS开发的可行性，学习APPKit开发，搭建项目框架，完成mac用户操作习惯的设计及核心代码实现。<br>macOS版本中主要调研的核心功能，视频播放器／pdf阅读器。主要通过研究ffmpeg/mupdf源码处理多媒体文件的原理，定制支持播放密文文件的播放器。采用FrameWork/cocopods私库方式集成到主项目中，这样利于库的依赖管理，便于主项目的开发协作，同时也便于对开源框架的升级与维护。</p><p>在产品上，实现以流解密方式浏览多媒体，有力的保障用户的版权和隐私，相比以前体验更加流畅适用。<br>APP基于xcodeserver平台，使用shell脚本配合Git／Fabric(fastlane)工具实现自动化集成测试及发布产品。</p><h4 id="swift经验"><a href="#swift经验" class="headerlink" title="swift经验"></a>swift经验</h4><p>采用swift/oc混编方式，抽取iOS端业务层集成到macOS工程中。<br>推出之后，引起不少高端用户的青睐，日活跃量增加三成，交易量创新高。</p><h3 id="鹏保宝"><a href="#鹏保宝" class="headerlink" title="鹏保宝"></a><a href="https://itunes.apple.com/cn/app/peng-bao-bao/id794859712?mt=8" target="_blank" rel="noopener">鹏保宝</a></h3><p>鹏保宝是一款用于为数字内容的传播及销售环节保价护航，确保受保护的视频、文档、图纸等内容不被二次传播或转售，广泛用于在教育培训、淘宝数字内容销售、设计企业、印刷、电子书出版等领域，建立起了很好的用户基础。</p><h4 id="四人项目，担任IOS组组长"><a href="#四人项目，担任IOS组组长" class="headerlink" title="四人项目，担任IOS组组长"></a>四人项目，担任IOS组组长</h4><p>主要负责：任务分解和分配，每天了解开发进度更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><h4 id="项目管理成长"><a href="#项目管理成长" class="headerlink" title="项目管理成长"></a>项目管理成长</h4><p>由周期长、响应速度慢、维护修改困难，以文档为核心的传统开发模式到敏捷开发以人为本，专注于交付对客户有价值的软件，在高度协作的开环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行自我调整和完善。</p><h4 id="技术突破"><a href="#技术突破" class="headerlink" title="技术突破"></a>技术突破</h4><p>在阅读鹏保宝视频文件时，MediaPlayer.framework仅支持普通视频播放，如何在保证鹏保宝文件不被解密的情况下，实现用户正常阅读。通过调研发现ffmpeg是基于C开发的开源程序，能够通过编译源码支持多平台，在此基础上，我们对ffmpeg定制开发，在底层代码中加入解密算法，传入文件秘钥，实现了ffmpeg支持鹏保宝视频文件的阅读。<br>对于鹏保宝PDF加密文件时，我们对mupdf开源程序，进行二次开发，实现了mupdf支持鹏保宝PDF文件的阅读。</p><h3 id="PBB-Reader"><a href="#PBB-Reader" class="headerlink" title="PBB Reader"></a><a href="https://itunes.apple.com/cn/app/pbb-reader/id954969456?mt=8" target="_blank" rel="noopener">PBB Reader</a></h3><p><code>Pbb Reader</code>是鹏保宝加密文件的阅读器，使用此软件可以打开被鹏保宝加密后的文件，最新版本集成了<code>开会APP</code>的相关功能，并支持绥知文件的阅读。</p><h4 id="四人项目，担任IOS组组长-1"><a href="#四人项目，担任IOS组组长-1" class="headerlink" title="四人项目，担任IOS组组长"></a>四人项目，担任IOS组组长</h4><p>主要负责：任务分解，了解开发进度，更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><h4 id="技术描述"><a href="#技术描述" class="headerlink" title="技术描述"></a>技术描述</h4><ul><li>作为<code>鹏保宝</code>lite阅读器，使用<code>URL Schemes</code>实现文件共享；</li><li>使用一个target对应一个新的product方案，创建<code>PBB Reader</code>阅读器；</li><li>AutoLayout与Size Class技术适配iPad机型；</li></ul><h4 id="项目收获"><a href="#项目收获" class="headerlink" title="项目收获"></a>项目收获</h4><ol><li>使用target功能充分复用代码，对开发新产品，以最小的成本产出lite版应用；</li><li>使用autolayout和size class重构界面实现，简化机型适配的复杂度；</li><li>学习自动化部署工具包<code>fastlane</code>部署Appstore；</li></ol><h3 id="绥知"><a href="#绥知" class="headerlink" title="绥知"></a><a href="https://itunes.apple.com/cn/app/sui-zhi/id848758969?mt=8" target="_blank" rel="noopener">绥知</a></h3><p>绥知是一款可加强保护这些数字化的音视频节目内容的版权，涉及的技术就是数字权限管理技术。本应用现可支持在PC端进行图书，音乐，视频加密后买卖交易，在移动端可进行解密查看。</p><h3 id="开会"><a href="#开会" class="headerlink" title="开会"></a><a href="https://itunes.apple.com/cn/app/kai-hui/id1063916218?mt=8" target="_blank" rel="noopener">开会</a></h3><p>开会是一款会议管理系统，主要功能包括创建会议、发布会议通知、管理会议资料、管理会务等相关功能，通过该系统可实现无纸化会议办公，使得企业可以环保高效的开展会议。本APP为该系统的移动客户端，主要为参会人员提供了会议资料的领取、使用、收藏、管理等功能。</p><h2 id="个人作品-1"><a href="#个人作品-1" class="headerlink" title="个人作品"></a>个人作品</h2><h3 id="iResearcher"><a href="#iResearcher" class="headerlink" title="iResearcher"></a><a href="https://itunes.apple.com/cn/app/iresearcher/id1048834926?mt=8" target="_blank" rel="noopener">iResearcher</a></h3><p>iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。</p><h4 id="工作描述"><a href="#工作描述" class="headerlink" title="工作描述"></a>工作描述</h4><p>四人项目，项目负责人<br>本项目包含IOS端，安卓端，<a href="http://www.iresearch.xyz" target="_blank" rel="noopener">PC端</a></p><ul><li>和业务方沟通确定产品需求和流程，形成文档和原型设计，敲定开发方案；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>负责IOS项目架构设计，UI界面和功能实现；</li><li>android端APP发布（友盟，应用宝，小米应用商店）；</li><li>IOS端自动化部署发布appstore；</li></ul><h4 id="能力提高"><a href="#能力提高" class="headerlink" title="能力提高"></a>能力提高</h4><p>Scrum开发的认识与学习：强调团队需要是“自组织”的，需要群体进行决策而不是领导，Scrum强调的是信息的透明化，定期地查看自己和团队的状态，保证大家信息充分共享，透明的方法，即有了信息的透明，这样团队成员就能共同发现项目执行中的问题，进而一起寻找解决办法，从而达到“自组织”的团队。在开发时间上也保持着一周一次的Sprint评审会议，保证项目开发进度和质量。</p><h3 id="爱跑"><a href="#爱跑" class="headerlink" title="爱跑"></a>爱跑</h3><p><code>爱跑</code>是一款鼓励用户多运动的APP社区应用，能安排运动日程，统计每日运动量，统计圈子排行榜，支持圈子好友即时通讯，提供穿戴设备购买的入口。</p><h4 id="工作描述-1"><a href="#工作描述-1" class="headerlink" title="工作描述"></a>工作描述</h4><p>四人项目，项目负责人</p><ul><li>沟通需求，敲定开发方案，组织人员开发；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>android端APP发布；</li><li>部署后台服务器；</li></ul><h4 id="技术描述-1"><a href="#技术描述-1" class="headerlink" title="技术描述"></a>技术描述</h4><ul><li>集成融云IMKit组件，嵌入到现有代码框架中，实现圈子好友聊天功能；</li><li>日历控件上的日程和提醒；</li></ul><h4 id="能力提高-1"><a href="#能力提高-1" class="headerlink" title="能力提高"></a>能力提高</h4><p>组织能力，协作沟通能力。</p><h2 id="北京鼎晟中天科技有限公司（2012年3月-2013年11月）"><a href="#北京鼎晟中天科技有限公司（2012年3月-2013年11月）" class="headerlink" title="北京鼎晟中天科技有限公司（2012年3月~2013年11月）"></a>北京鼎晟中天科技有限公司（2012年3月~2013年11月）</h2><hr><h4 id="工作描述-2"><a href="#工作描述-2" class="headerlink" title="工作描述"></a>工作描述</h4><ol><li>负责公司IOS平台的iPhone应用程序的软件设计及开发；</li><li>参与项目需求分析，产品模块的概要和详细设计；</li><li>优化软件性能，提高用户体验；</li></ol><h4 id="会议通"><a href="#会议通" class="headerlink" title="会议通"></a>会议通</h4><p>本项目以蓝牙技术为基础，进行近距离的人员搜索，结合移动互联网技术让参展人员可以方便的进行进行电子名片的交换和管理。同时系统通过对参展人员交换名片的行为进行多维度的分析，使得会展组织者可以及时准确的了解展会效果，为组织者指定下一步工作计划提供数据基础。</p><h4 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h4><ul><li><code>sqlite</code>数据库工具FMDB开发</li><li><code>ABAddressBook</code>通讯录数据库开发</li><li><code>CoreBluetooth</code>蓝牙开发</li><li><code>ASIHTTPRequest</code>实现了图片上传下载</li><li><code>JavaPNS</code>服务器推送工具，IOS推送技术推送</li></ul><h3 id="易购8"><a href="#易购8" class="headerlink" title="易购8"></a><a href="https://itunes.apple.com/cn/app/yi-gou8/id663698075?mt=8" target="_blank" rel="noopener">易购8</a></h3><p><code>易购8</code>是一款简易的口袋购物软件，支持通过输入关键字直接在淘宝查询商品，支持用户选择“商品价格分段”、“商家信誉分段”、“商品销量分段”以及其他条件对商品进行过滤。</p><h3 id="众信旅游ERP客户端（Java）"><a href="#众信旅游ERP客户端（Java）" class="headerlink" title="众信旅游ERP客户端（Java）"></a>众信旅游ERP客户端（Java）</h3><p>本系统通过对旅行社关键业务的分析，将旅行社业务中需要移动处理的部分抽取出来，通过与企业内部业务管理系统协作，既能够与企业现有的流程一致，又保持一定的独立性，避免影响核心业务系统的运转。</p><p>系统用户群定位：旅行社的销售人员、管理人员、导游！</p><p>具体实现:是以移动互联网技术为基础，结合当前主流的移动终端技术，将企业内部的ERP延伸到移动终端，可以让旅行社工作人员随时随地高效、安全的进行业务操作！</p><h3 id="淘宝信息搜集工具（Java）"><a href="#淘宝信息搜集工具（Java）" class="headerlink" title="淘宝信息搜集工具（Java）"></a>淘宝信息搜集工具（Java）</h3><p>实现了定时爬取指定商品的基本信息包括:商品原价，实价，评价数量，评价星级，运费，和店铺等级，店铺信誉度，以及商品连接，店铺连接，和缩略图获取。</p><h3 id="今古博文-门户网站（java）"><a href="#今古博文-门户网站（java）" class="headerlink" title="今古博文 门户网站（java）"></a>今古博文 门户网站（java）</h3><p>作为公司的企业文化，地理位置，招聘信息，等最新信息的展示平台。</p><h2 id="郑州四棵松工作室（2011年01月-～-2011年11月）"><a href="#郑州四棵松工作室（2011年01月-～-2011年11月）" class="headerlink" title="郑州四棵松工作室（2011年01月 ～ 2011年11月）"></a>郑州四棵松工作室（2011年01月 ～ 2011年11月）</h2><hr><p>归属北京超星图书旗下，做爬取报刊／书籍以及目录自动化整理的小应用开发，爬取HTML数据，存储到SQLServer数据库中。</p><h4 id="工作描述-3"><a href="#工作描述-3" class="headerlink" title="工作描述"></a>工作描述</h4><ol><li>SQLserver管理；</li><li>爬虫工具开发；<br>使用HttpClient，HtmlParser解析工具和正则匹配表达式，对字符串，flash动画和js脚本进行处理，来获取目标文本内容和资源路径。优化传统的爬取方式，使得每月从50万+至100万+产量，大幅提升了在超星旗下的竞争力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简历</title>
      <link href="/2017/09/10/%E7%AE%80%E5%8E%86/"/>
      <url>/2017/09/10/%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>####联系方式</p><ul><li>手机：13522834108</li><li>Email：<a href="mailto:724987481@qq.com" target="_blank" rel="noopener">724987481@qq.com</a> </li><li>QQ：724987481</li></ul><hr><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>霍曙光/男/1988 </li><li>本科/郑州轻工业学院 计算机网络技术 </li><li>工作年限：5年</li><li>QQ：724987481</li><li>技术博客：<a href="https://huos3203.github.io">布衣男儿</a></li><li>Github：<a href="https://github.com/huos3203/" target="_blank" rel="noopener">https://github.com/huos3203/</a> </li><li><p><a href="https://huoshuguang.gitbooks.io" target="_blank" rel="noopener">GitBook</a></p></li><li><p>期望职位：iOS高级程序员，应用架构师</p></li><li>期望薪资：税前月薪20k~25k</li><li>期望城市：北京</li></ul><hr><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>##北京创世泰克科技有限公司 (2013年11月~至今)</p><p>###工作描述：  </p><ol><li>负责<code>iPhone/iPad/macOS</code>应用软件设计与开发；  </li><li>参与项目需求分析，产品模块的概要设计；  </li><li>优化软件性能，提高用户体验；  </li><li><code>scrum</code>任务分解控制开发进度；</li><li>管理<code>Itunes，搭建</code>Fastlane<code>自动化部署</code>Appstore`</li></ol><hr><h3 id="鹏保宝"><a href="#鹏保宝" class="headerlink" title="鹏保宝"></a><a href="https://itunes.apple.com/cn/app/peng-bao-bao/id794859712?mt=8" target="_blank" rel="noopener">鹏保宝</a></h3><p>鹏保宝是一款用于为数字内容的传播及销售环节保价护航，确保受保护的视频、文档、图纸等内容不被二次传播或转售，广泛用于在教育培训、淘宝数字内容销售、设计企业、印刷、电子书出版等领域，建立起了很好的用户基础。</p><h4 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h4><p>四人项目，担任IOS组组长</p><p>主要负责：任务分解和分配，每天了解开发进度更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><ul><li>使用<a href="https://cocoapods.org" target="_blank" rel="noopener">cocoaPods</a>工具管理第三方类库，<a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a>控制版本迭代协作开发；</li><li>定制<a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="noopener">ffmpeg</a>,<a href="http://mupdf.com/repos/mupdf" target="_blank" rel="noopener">mupdf</a>阅读器底层业务,集成IJKPlayer支持鹏保宝加密阅读；</li><li>使用storyboard/xib，AutoLayout与Size Class技术适配iPad/iPhone；</li><li>使用<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>开源包实现socket协议传输数据；</li><li>使用<a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>处理web服务api,解析JSON映射响应对象；</li><li>通过<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a>/<a href="http://nshipster.cn/javascriptcore/" target="_blank" rel="noopener">JavaScriptCore</a>网页和原生代码传输数据实现<code>In-APP Purchase内购</code>；</li><li>封装<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>接口，SQLite数据库设计及<a href="http://www.sqlcipher.net" target="_blank" rel="noopener">SQLCipher</a>数据库加密；</li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a>Android风格的Toast控件,用户提示便捷得体；</li><li>集成微信SDK，腾讯SDK，ShareSDK，JpushSDK；</li></ul><h5 id="项目管理成长："><a href="#项目管理成长：" class="headerlink" title="项目管理成长："></a>项目管理成长：</h5><p>由周期长、响应速度慢、维护修改困难，以文档为核心的传统开发模式到敏捷开发以人为本，专注于交付对客户有价值的软件，在高度协作的开环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行调整和完善。</p><h5 id="技术突破："><a href="#技术突破：" class="headerlink" title="技术突破："></a>技术突破：</h5><p>在阅读鹏保宝视频文件时，MediaPlayer.framework仅支持普通视频播放，如何在保证鹏保宝文件不被解密的情况下，实现用户正常阅读。我通过google发现ffmpeg是基于C开发的开源程序，能够通过编译源码支持多平台，在此基础上，我们对ffmpeg定制开发，在底层代码中加入解密算法，传入文件秘钥，实现了ffmpeg支持鹏保宝视频文件的阅读。<br>  雷同，对于鹏保宝PDF加密文件时，我们对mupdf开源程序，进行二次开发，实现了mupdf支持鹏保宝PDF文件的阅读。</p><h3 id="PBB-Reader"><a href="#PBB-Reader" class="headerlink" title="PBB Reader"></a><a href="https://itunes.apple.com/cn/app/pbb-reader/id954969456?mt=8" target="_blank" rel="noopener">PBB Reader</a></h3><p><code>Pbb Reader</code>是鹏保宝加密文件的阅读器，使用此软件可以打开被鹏保宝加密后的文件，最新版本集成了<code>开会APP</code>的相关功能，并支持绥知文件的阅读。</p><p>四人项目，担任IOS组组长  </p><p>主要负责：任务分解，了解开发进度，更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><h5 id="技术描述：-1"><a href="#技术描述：-1" class="headerlink" title="技术描述："></a>技术描述：</h5><ul><li>作为<code>鹏保宝</code>lite阅读器，使用<code>URL Schemes</code>实现文件共享；</li><li>使用一个target对应一个新的product方案，创建<code>PBB Reader</code>阅读器；</li><li>使用扫描二维码技术登录<code>开会</code>APP；</li><li>AutoLayout与Size Class技术适配iPad机型；</li></ul><h5 id="项目收获："><a href="#项目收获：" class="headerlink" title="项目收获："></a>项目收获：</h5><ol><li>使用target功能充分利用代码，开发新产品，以最小的代价产出lite版应用；</li><li>使用autolayout和size class重构界面实现，去除机型判断，坐标硬适配的冗长代码；</li><li>学习自动化部署工具包<code>fastlane</code>部署Appstore；</li></ol><p>###<a href="https://itunes.apple.com/cn/app/sui-zhi/id848758969?mt=8" target="_blank" rel="noopener">绥知</a><br>绥知是一款可加强保护这些数字化的音视频节目内容的版权，涉及的技术就是数字权限管理技术。本应用现可支持在PC端进行图书，音乐，视频加密后买卖交易，在移动端可进行解密查看。</p><h3 id="开会"><a href="#开会" class="headerlink" title="开会"></a><a href="https://itunes.apple.com/cn/app/kai-hui/id1063916218?mt=8" target="_blank" rel="noopener">开会</a></h3><p>开会是一款会议管理系统，主要功能包括创建会议、发布会议通知、管理会议资料、管理会务等相关功能，通过该系统可实现无纸化会议办公，使得企业可以环保高效的开展会议。本APP为该系统的移动客户端，主要为参会人员提供了会议资料的领取、使用、收藏、管理等功能。</p><hr><h1 id="个人作品："><a href="#个人作品：" class="headerlink" title="个人作品："></a>个人作品：</h1><h3 id="iResearcher"><a href="#iResearcher" class="headerlink" title="iResearcher"></a><a href="https://itunes.apple.com/cn/app/iresearcher/id1048834926?mt=8" target="_blank" rel="noopener">iResearcher</a></h3><p><code>iResearcher</code>是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务，iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。</p><h5 id="工作描述："><a href="#工作描述：" class="headerlink" title="工作描述："></a>工作描述：</h5><p>本项目包含IOS端，安卓端，<a href="http://www.iresearch.xyz" target="_blank" rel="noopener">PC端</a>，担任项目Scrum Master</p><ul><li>和业务方沟通确定产品需求和流程，形成文档和原型设计，敲定开发方案；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>负责IOS项目架构设计，UI界面和功能实现；</li><li>android端APP发布（友盟，应用宝，小米应用商店）；</li><li>IOS端自动化部署发布appstore；</li></ul><h5 id="技术描述：-2"><a href="#技术描述：-2" class="headerlink" title="技术描述："></a>技术描述：</h5><ul><li>使用<a href="https://cocoapods.org" target="_blank" rel="noopener">cocoaPods</a>工具管理第三方类库，<a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a>控制版本迭代协作开发；</li><li><a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="noopener">RESideMenu</a>侧滑布局类库,支持左右滑动，滑动距离;</li><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a>易于集成，支持设备的方向，可通过类的方法来启用和禁用键盘管理器；</li><li><a href="https://github.com/antoniocasero/ACPDownload" target="_blank" rel="noopener">ACPDownload</a>实现类似AppStore下载状态样式；</li><li><a href="https://github.com/thibaultCha/TCBlobDownload" target="_blank" rel="noopener">TCBlobDownload</a>支持后台线程执行大文件下载任务，暂停和重新恢复下载；</li><li><a href="https://github.com/shingwasix/MobShareSDK" target="_blank" rel="noopener">MobShareSDK</a>实现微信朋友，朋友圈分享;</li><li><a href="https://zwaldowski.github.io/BlocksKit" target="_blank" rel="noopener">BlocksKit</a>没有创建新的宏，函数，方法和类，仅对Cocoa基础类的一个扩展，是取代了通常的delegate用法;</li><li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>图片缓存的框架; <!--点点滴滴--></li><li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a>下拉刷新上拉加载更多MJRefresh类库;</li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a>Android风格的Toast控件,用户提示便捷得体；</li><li><a href="https://github.com/kcandr/IQLabelView" target="_blank" rel="noopener">IQLabelView</a>对文本控件覆盖，缩放和旋转；</li><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></li><li><a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>处理web服务api,解析JSON映射响应对象；</li><li><a href="https://github.com/Masonry/Masonry" target="_blank" rel="noopener">Masonry</a>一个轻量级的布局框架,拥有自己的描述语法，采用更优雅的链式语法封装自动布局；</li><li>BaiduMobStat使用百度统计，统计用户使用时长、使用频率、访问页面、使用间隔等数据；</li></ul><h5 id="能力提高："><a href="#能力提高：" class="headerlink" title="能力提高："></a>能力提高：</h5><p>Scrum开发的认识与学习：强调团队需要是“自组织”的，需要群体进行决策而不是领导，Scrum强调的是信息的透明化，定期地查看自己和团队的状态，保证大家信息充分共享，透明的方法，即有了信息的透明，这样团队成员就能共同发现项目执行中的问题，进而一起寻找解决办法，从而达到“自组织”的团队。在开发时间上也保持着一周一次的Sprint评审会议，保证项目开发进度和质量。</p><h3 id="爱跑"><a href="#爱跑" class="headerlink" title="爱跑"></a>爱跑</h3><p><code>爱跑</code>是一款鼓励用户多运动的APP社区应用，能安排运动日程，统计每日运动量，统计圈子排行榜，支持圈子好友即时通讯，提供穿戴设备购买的入口。</p><p>######工作描述：<br>四人项目，项目负责人  </p><ul><li>沟通需求，敲定开发方案，组织人员开发；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>android端APP发布；</li><li>部署后台服务器；</li></ul><h6 id="技术描述：-3"><a href="#技术描述：-3" class="headerlink" title="技术描述："></a>技术描述：</h6><ul><li>集成融云IMKit组件，嵌入到现有代码框架中，实现圈子好友聊天功能；</li><li>日历控件上的日程和提醒；</li></ul><h5 id="能力提高：-1"><a href="#能力提高：-1" class="headerlink" title="能力提高："></a>能力提高：</h5><p>组织能力，协作沟通能力。</p><hr><h2 id="北京鼎晟中天科技有限公司（2011年3月-2013年11月）"><a href="#北京鼎晟中天科技有限公司（2011年3月-2013年11月）" class="headerlink" title="北京鼎晟中天科技有限公司（2011年3月~2013年11月）"></a>北京鼎晟中天科技有限公司（2011年3月~2013年11月）</h2><h3 id="工作描述：-1"><a href="#工作描述：-1" class="headerlink" title="工作描述："></a>工作描述：</h3><ol><li>负责公司IOS平台的iPhone应用程序的软件设计及开发；  </li><li>参与项目需求分析，产品模块的概要和详细设计；  </li><li>优化软件性能，提高用户体验；  </li></ol><h3 id="会议通"><a href="#会议通" class="headerlink" title="会议通"></a>会议通</h3><p>本项目以蓝牙技术为基础，进行近距离的人员搜索，结合移动互联网技术让参展人员可以方便的进行进行电子名片的交换和管理。同时系统通过对参展人员交换名片的行为进行多维度的分析，使得会展组织者可以及时准确的了解展会效果，为组织者指定下一步工作计划提供数据基础。</p><p>#####技术描述：</p><ul><li><code>sqlite</code>数据库工具FMDB开发</li><li><code>ABAddressBook</code>通讯录数据库开发</li><li><code>CoreBluetooth</code>蓝牙开发</li><li><code>ASIHTTPRequest</code>实现了图片上传下载</li><li><code>JavaPNS</code>服务器推送工具，IOS推送技术推送</li></ul><h3 id="易购8-已下架"><a href="#易购8-已下架" class="headerlink" title="易购8(已下架)"></a><a href="https://itunes.apple.com/cn/app/yi-gou8/id663698075?mt=8" target="_blank" rel="noopener">易购8</a>(已下架)</h3><p><code>易购8</code>是一款简易的口袋购物软件，支持通过输入关键字直接在淘宝查询商品，支持用户选择“商品价格分段”、“商家信誉分段”、“商品销量分段”以及其他条件对商品进行过滤。</p><h3 id="众信旅游ERP客户端（Java）"><a href="#众信旅游ERP客户端（Java）" class="headerlink" title="众信旅游ERP客户端（Java）"></a>众信旅游ERP客户端（Java）</h3><p>本系统通过对旅行社关键业务的分析，将旅行社业务中需要移动处理的部分抽取出来，通过与企业内部业务管理系统协作，既能够与企业现有的流程一致，又保持一定的独立性，避免影响核心业务系统的运转。<br>系统用户群定位：旅行社的销售人员、管理人员、导游！<br>具体实现:是以移动互联网技术为基础，结合当前主流的移动终端技术，将企业内部的ERP延伸到移动终端，可以让旅行社工作人员随时随地高效、安全的进行业务操作！  </p><h3 id="淘宝信息搜集工具（Java）"><a href="#淘宝信息搜集工具（Java）" class="headerlink" title="淘宝信息搜集工具（Java）"></a>淘宝信息搜集工具（Java）</h3><p>实现了定时爬取指定商品的基本信息包括:商品原价，实价，评价数量，评价星级，运费，和店铺等级，店铺信誉度，以及商品连接，店铺连接，和缩略图获取。</p><h3 id="今古博文（java）"><a href="#今古博文（java）" class="headerlink" title="今古博文（java）"></a><a href="http://www.jgbw.cn/" target="_blank" rel="noopener">今古博文</a>（java）</h3><p>作为公司的企业文化，地理位置，招聘信息，等最新信息的展示平台….</p><hr><h1 id="技能清单："><a href="#技能清单：" class="headerlink" title="技能清单："></a>技能清单：</h1><ol><li>熟练掌握Object C/swift/java，ruby脚本，Linux 命令，regex</li><li>熟练掌握MVC，MVVM，MVP，单例，观察者，代理，工厂等设计模式</li><li>熟悉socket通信，HTTP协议，xmpp框架，Restful框架，json/xml解析</li><li>熟悉cocoa，uikit，block,多线程,disptach</li><li>熟练interface builder，Playground，autolayout，SizeClass</li><li>熟悉IOS内购，QQ登录，极光推送，融云等第三方SDK</li><li>熟悉ffmpeg视频播放器，mupdf阅读器，实现密文阅读</li><li>熟悉Pods，Alcatraz，Xvim，VVDocumenter，Dash等</li><li>Scrum开发：Jira/worklite/Trello/OmniPlan</li><li>自动化部署工具:fastlane/jenkins/Docker</li><li>数据库：MySQL/SQLServer/SQLite/Realm</li><li>测试平台：蒲公英，HockeyApp，Crashlytics，OXServer</li><li>异常分析：instruments，dsym，友盟，百度统计，Crashlytics</li><li>版本管理：Svn/Git GUI:cornerstone/smartSVN/sourceTree</li><li>文档工具：appleDoc/jazzy/GistBox/MOU/GitBook/Snippets</li><li>前端工具：PhoneGap/PaintCode/Photoshop/flash/dreamweaver</li><li>Web开发：PHP/JSP/ASP</li><li>Web框架：Nutz、Octopress</li><li>云和开放平台：SAE/AWS/微信应用开发</li></ol><hr><p>##致谢</p><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iResearcher简介</title>
      <link href="/2017/09/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/iResearcher%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/09/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/iResearcher%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。</p><h3 id="APP截图"><a href="#APP截图" class="headerlink" title="APP截图"></a>APP截图</h3><p>由于运营方已停止服务器访问，暂时只能截图呈现APP相关功能。</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSURLSession的使用说明</title>
      <link href="/2017/09/09/iOS/NSURLSession%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/09/09/iOS/NSURLSession%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。</p><p>现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。</p><h2 id="NSURLConnection机制"><a href="#NSURLConnection机制" class="headerlink" title="NSURLConnection机制"></a>NSURLConnection机制</h2><p><code>NSURLConnection</code> 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。<code>NSURLConnection</code> 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLProtocol</code>、 <code>NSURLCache</code>、 <code>NSHTTPCookieStorage</code>、<code>NSURLCredentialStorage</code> 以及同名类 <code>NSURLConnection</code>。</p><p><code>NSURLRequest</code> 被传递给 <code>NSURLConnection</code>。被委托对象（遵守以前的非正式协议 <code>&lt;NSURLConnectionDelegate&gt;</code> 和 <code>&lt;NSURLConnectionDataDelegate&gt;</code>）异步地返回一个 <code>NSURLResponse</code> 以及包含服务器返回信息的 <code>NSData</code>。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据<strong>策略（policy）</strong>以及<strong>可用性（availability）</strong>的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p><h3 id="鉴权查询"><a href="#鉴权查询" class="headerlink" title="鉴权查询"></a>鉴权查询</h3><p>在把请求发送给服务器的过程中，服务器可能会发出<strong>鉴权查询（authentication challenge）</strong>，这可以由共享的 cookie 或<strong>机密存储（credential storage）</strong>来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要的时候无缝地改变其加载行为。</p><p>不管怎样，<code>NSURLConnection</code> 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 <code>NSURLConnection</code> 的几个核心概念提出了挑战，让苹果有理由对它进行重构。</p><p>在 2013 的 WWDC 上，苹果推出了 <code>NSURLConnection</code> 的继任者：<code>NSURLSession</code>。</p><hr><h2 id="NSURLSession成员"><a href="#NSURLSession成员" class="headerlink" title="NSURLSession成员"></a>NSURLSession成员</h2><p>和 <code>NSURLConnection</code> 一样，<code>NSURLSession</code> 指的也不仅是同名类 <code>NSURLSession</code>，还包括一系列相互关联的类。<code>NSURLSession</code> 包括了与之前相同的组件，<code>NSURLRequest</code> 与 <code>NSURLCache</code>，但是把 <code>NSURLConnection</code> 替换成了 <code>NSURLSession</code>、<code>NSURLSessionConfiguration</code> 以及 <code>NSURLSessionTask</code> 的 3 个子类：<code>NSURLSessionDataTask</code>，<code>NSURLSessionUploadTask</code>，<code>NSURLSessionDownloadTask</code>。</p><ol><li>NSURLSessionConfiguration可配置性初始化<br>与 <code>NSURLConnection</code> 相比，<code>NSURLsession</code> 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及<strong>证书策略（credential policy）</strong>，甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 <code>NSURLSession</code> 对象都由一个 <code>NSURLSessionConfiguration</code> 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</li><li>抽象类NSURLSessionTask数据加载<br><code>NSURLSession</code> 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。<code>NSURLSessionTask</code> 与 <code>NSURLConnection</code> 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 <code>NSURLSession</code> 这一<strong>公共委托者（common delegate）</strong>。</li></ol><p>我们先来深入探讨 task，过后再来讨论 <code>NSURLSessionConfiguration</code>。</p><h3 id="NSURLSessionTask"><a href="#NSURLSessionTask" class="headerlink" title="NSURLSessionTask"></a>NSURLSessionTask</h3><p><code>NSURLsessionTask</code> 是一个抽象类，其下有 3 个实体子类封装了现代程序三个最基本的网络任务：</p><ol><li><code>NSURLSessionDataTask</code>：加载数据，当加载任务完成时，它会返回相关联的数据，比如 JSON 或者 XML</li><li><code>NSURLSessionUploadTask</code>：上传文件，当上传任务完成时，也会有上传相关数据返回，所以继承自 <code>NSURLSessionDataTask</code>。</li><li><code>NSURLSessionDownloadTask</code>：下载文件，当下载任务结束时，它会返回已下载文件的一个临时的文件路径。</li></ol><p><img alt="NSURLSessionTask class diagram" src="https://www.objccn.io/images/issues/issue-5/NSURLSession.png" width="612" height="294"></p><p>所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个<strong>恢复数据（resume data）</strong>，然后可以传递给下一次新创建的 download task，以便继续之前的下载。</p><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>不同于直接使用 <code>alloc-init</code> 初始化方法，task 是由一个 <code>NSURLSession</code> 创建的。每个 task 的构造方法都对应有或者没有 <code>completionHandler</code> 这个 block 的两个版本:</p><ol><li>block回调构造方式: <code>–dataTaskWithRequest:completionHandler:</code><br>通过指定 <code>completionHandler</code> 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。</li><li>代理回调构造方式：<code>–dataTaskWithRequest:</code><br>对于需要 <code>override</code> 原有 session task 的 delegate 的默认行为的情况,使用代理回调</li></ol><p>这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 <code>resume</code> 方法来让它开始运行。</p><h5 id="数据加载工厂"><a href="#数据加载工厂" class="headerlink" title="数据加载工厂"></a>数据加载工厂</h5><p>Data task 可以通过 <code>NSURL</code> 或 <code>NSURLRequest</code> 创建（使用前者相当于是使用一个对于该 URL 进行标准 <code>GET</code> 请求的 <code>NSURLRequest</code>，这是一种快捷方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</span><br><span class="line">completionHandler:</span><br><span class="line">^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure></p><h5 id="数据上传工厂"><a href="#数据上传工厂" class="headerlink" title="数据上传工厂"></a>数据上传工厂</h5><p>Upload task 的创建需要使用一个 request，另外加上一个要上传的 <code>NSData</code> 对象或者是一个本地文件的路径对应的 <code>NSURL</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line"><span class="built_in">NSData</span> *data = ...;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [session uploadTaskWithRequest:request</span><br><span class="line">fromData:data</span><br><span class="line">completionHandler:</span><br><span class="line">^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure></p><h5 id="数据下载工厂"><a href="#数据下载工厂" class="headerlink" title="数据下载工厂"></a>数据下载工厂</h5><p>Download task 也需要一个 request，不同之处在于 <code>completionHandler</code> 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 <code>completionHandler</code> 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/file.zip"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [session downloadTaskWithRequest:request</span><br><span class="line">completionHandler:</span><br><span class="line">^(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="built_in">NSString</span> *documentsPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line"><span class="built_in">NSURL</span> *documentsDirectoryURL = [<span class="built_in">NSURL</span> fileURLWithPath:documentsPath];</span><br><span class="line"><span class="built_in">NSURL</span> *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];</span><br><span class="line">[[<span class="built_in">NSFileManager</span> defaultManager] copyItemAtURL:location toURL:newFileLocation error:<span class="literal">nil</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure></p><blockquote><p><span class="secondary radius label">编者注</span> 原文中这块代码以及上文的表述中存有一些问题，详见这个 <a href="https://github.com/objcio/articles/issues/24" target="_blank" rel="noopener">issue</a>，本文已进行更正，如果您有不同意见，欢迎在 <a href="https://github.com/objccn/articles" target="_blank" rel="noopener">Github</a> 上给我们反馈。</p></blockquote><h4 id="NSURLSession-的-delegate-方法"><a href="#NSURLSession-的-delegate-方法" class="headerlink" title="NSURLSession 的 delegate 方法"></a>NSURLSession 的 delegate 方法</h4><p><code>NSURLSession</code> 的 delegate 方法是 <code>NSURLConnection</code> 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个<a href="https://gist.github.com/floriankugler/6870499" target="_blank" rel="noopener">映射表</a>来进行一个完整的概览。</p><h5 id="连接层-任务层代理"><a href="#连接层-任务层代理" class="headerlink" title="连接层/任务层代理"></a>连接层/任务层代理</h5><p><code>NSURLSession</code> 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。</p><ol><li>session 的 delegate 方法处理连接层的问题：诸如服务器信任，客户端证书的评估，<a href="http://en.wikipedia.org/wiki/NTLM" target="_blank" rel="noopener">NTLM</a> 和 <a href="http://zh.wikipedia.org/wiki/Kerberos" target="_blank" rel="noopener">Kerberos</a> 协议这类问题。</li><li>task 的 delegate 处理网络请求为基础的问题：如 Basic，Digest，以及<strong>代理身份验证（Proxy authentication）</strong>等。</li><li>网络请求结束代理<br>在 <code>NSURLConnection</code> 中两个delegate方法：<br>数据加载完成：<code>NSURLConnectionDataDelegate</code> 中的 <code>-connectionDidFinishLoading:</code><br>网络连接失败： <code>NSURLConnectionDelegate</code> 中的 <code>-connection:didFailWithError:</code>，<br>在 <code>NSURLSession</code> 中改为一个 delegate 方法：<ol><li><code>NSURLSessionTaskDelegate</code> 的 <code>-URLSession:task:didCompleteWithError:</code></li><li><code>NSURLSession</code> 中表示传输多少字节的参数类型现在改为 <code>int64_t</code>，以前在 <code>NSURLConnection</code> 中相应的参数的类型是 <code>long long</code>。</li></ol></li></ol><h5 id="block参数回调代理模式"><a href="#block参数回调代理模式" class="headerlink" title="block参数回调代理模式"></a>block参数回调代理模式</h5><p><code>NSURLSession</code> 给 Foundation 框架引入了一种全新的模式：即 代理方法中以<code>completionHandler:</code>  这种block 作为参数的方式。</p><ol><li>这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程；</li><li>Delgate 只需要简单地调用 <code>dispatch_async</code> 就可以切换到后台进行相关的操作，然后在操作完成时调用 <code>completionHandler</code> 即可。</li><li>它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。</li></ol><p>以 <code>NSURLSessionTaskDelegate</code>代理中的方法为例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-URLSession:task:didReceiveChallenge:completionHandler:</span><br></pre></td></tr></table></figure></p><p><code>completionHandler</code> 接受的两个参数：<br>参数一：<code>NSURLSessionAuthChallengeDisposition</code>:鉴权查询的策略<br>参数二：<code>NSURLCredential</code>:证书（仅当第一个参数——应对鉴权查询的策略为使用证书，即 <code>NSURLSessionAuthChallengeUseCredential</code> 时有效，否则该参数为 <code>NULL</code>）。</p><blockquote><p>想要查看更多关于 session task 的信息，可以查看 <a href="http://asciiwwdc.com/2013/sessions/705" target="_blank" rel="noopener">WWDC Session 705: “What’s New in Foundation Networking”</a></p></blockquote><h3 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h3><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。</p><ol><li>配置开发灵活性<br><code>NSURLSessionConfiguration</code> 扩充了 <code>NSMutableURLRequest</code> 所提供的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html" target="_blank" rel="noopener">网络请求层的设置选项</a>，从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何你想要进行配置的选项，提供给我们相当大的灵活性和控制权。</li><li>配置加载机制<br><code>NSURLSession</code> 在初始化时会把配置它的 <code>NSURLSessionConfiguration</code> 对象进行一次 copy，并保存到自己的 <code>configuration</code> 属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个 configuration 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。</li></ol><h4 id="三个配置类工厂方法"><a href="#三个配置类工厂方法" class="headerlink" title="三个配置类工厂方法"></a>三个配置类工厂方法</h4><p>针对<code>NSURLSession</code> 不同的使用场景，如下三个配置类方法：</p><ol><li><code>+defaultSessionConfiguration</code>： 返回一个标准的 configuration，这个配置实际上与 <code>NSURLConnection</code> 的<strong>网络堆栈（networking stack）</strong>是一样的，具有相同的共享 <code>NSHTTPCookieStorage</code>，共享 <code>NSURLCache</code> 和共享 <code>NSURLCredentialStorage</code>。</li><li><code>+ephemeralSessionConfiguration</code>： 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</li><li><code>+backgroundSessionConfiguration:(NSString *)identifier</code> 的独特之处在于，它会创建一个<em>后台 session</em>。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的<strong>守护进程（daemon）</strong>提供上下文。</li></ol><p>想要查看更多关于后台 session 的信息，可以查看 <a href="http://asciiwwdc.com/2013/sessions/204" target="_blank" rel="noopener">WWDC Session 204: “What’s New with Multitasking”</a></p><h4 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h4><p><code>NSURLSessionConfiguration</code> 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p><h5 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h5><ol><li><p><code>HTTPAdditionalHeaders</code>: 指定了一组默认的可以设置<strong>出站请求（outbound request）</strong>的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *userPasswordString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:%@"</span>, user, password];</span><br><span class="line"><span class="built_in">NSData</span> * userPasswordData = [userPasswordString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSString</span> *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *authString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Basic %@"</span>, base64EncodedCredential];</span><br><span class="line"><span class="built_in">NSString</span> *userAgentString = <span class="string">@"AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)"</span>;</span><br><span class="line"></span><br><span class="line">configuration.HTTPAdditionalHeaders = @&#123;<span class="string">@"Accept"</span>: <span class="string">@"application/json"</span>,</span><br><span class="line"><span class="string">@"Accept-Language"</span>: <span class="string">@"en"</span>,</span><br><span class="line"><span class="string">@"Authorization"</span>: authString,</span><br><span class="line"><span class="string">@"User-Agent"</span>: userAgentString&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>networkServiceType</code>: 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。</p></li><li><code>allowsCellularAccess</code> 和 <code>discretionary</code> 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 <code>discretionary</code> 这个属性，而不是 <code>allowsCellularAccess</code>，因为前者会把 WiFi 和电源的可用性考虑在内。</li><li><code>timeoutIntervalForRequest</code> 和 <code>timeoutIntervalForResource</code> 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 <code>timeoutInterval</code> 去限制发送请求的总时间，但其实它真正的含义是：<strong>分组（packet）</strong>之间的时间。实际上我们应该使用 <code>timeoutIntervalForResource</code> 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。</li><li><code>HTTPMaximumConnectionsPerHost</code>: 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 <code>NSURLConnection</code> 用于管理私有的连接池。现在有了 <code>NSURLSession</code>，开发者可以在需要时限制连接到特定主机的数量。</li><li><code>HTTPShouldUsePipelining</code>: 这个属性在 <code>NSMutableURLRequest</code> 下也有，它可以被用于开启 <strong>HTTP 管线化（<a href="http://en.wikipedia.org/wiki/HTTP_pipelining" target="_blank" rel="noopener">HTTP pipelining</a>）</strong>，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。</li><li><code>sessionSendsLaunchEvents</code>: 是另一个新的属性，该属性指定该 session 是否应该从后台启动。</li><li><code>connectionProxyDictionary</code>: 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。</li></ol><blockquote><p>关于连接代理的更多信息可以在 <a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFProxySupport/Reference/reference.html" target="_blank" rel="noopener"><code>CFProxySupport</code> Reference</a> 找到。</p></blockquote><h5 id="Cookie-策略"><a href="#Cookie-策略" class="headerlink" title="Cookie 策略"></a>Cookie 策略</h5><ol><li><code>HTTPCookieStorage</code>: 存储了 session 所使用的 cookie。默认情况下会使用 <code>NSHTTPCookieShorage</code> 的 <code>+sharedHTTPCookieStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li><li><code>HTTPCookieAcceptPolicy</code>: 决定了什么情况下 session 应该接受从服务器发出的 cookie。</li><li><code>HTTPShouldSetCookies</code>: 指定了请求是否应该使用 session 存储的 cookie，即 <code>HTTPCookieSorage</code> 属性的值。</li></ol><h5 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h5><ol><li><code>URLCredentialStorage</code>: 存储了 session 所使用的证书。默认情况下会使用 <code>NSURLCredentialStorage</code> 的 <code>+sharedCredentialStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li><li><code>TLSMaximumSupportedProtocol</code> 和 <code>TLSMinimumSupportedProtocol</code> 确定 session 是否支持 <a href="http://zh.wikipedia.org/wiki/安全套接层" target="_blank" rel="noopener">SSL 协议</a>。</li></ol><h5 id="缓存策略-1"><a href="#缓存策略-1" class="headerlink" title="缓存策略"></a>缓存策略</h5><ol><li><code>URLCache</code> : 是 session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的 <code>+sharedURLCache</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li><li><code>requestCachePolicy</code> : 指定了一个请求的缓存响应应该在什么时候返回。这相当于 <code>NSURLRequest</code> 的 <code>-cachePolicy</code> 方法。</li></ol><h5 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h5><ol><li><code>protocolClasses</code>: 用来配置特定某个 session 所使用的自定义协议（该协议是 <code>NSURLProtocol</code> 的子类）的数组。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 <code>NSURLConnection</code> 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。</p><p>尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 <code>NSURLSession</code> 仍然是实现更高级别网络功能的一个强大的基础框架。</p><hr>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支持OSX浏览PDF简单视图</title>
      <link href="/2017/09/09/macOS/%E6%94%AF%E6%8C%81OSX%E6%B5%8F%E8%A7%88PDF%E7%AE%80%E5%8D%95%E8%A7%86%E5%9B%BE/"/>
      <url>/2017/09/09/macOS/%E6%94%AF%E6%8C%81OSX%E6%B5%8F%E8%A7%88PDF%E7%AE%80%E5%8D%95%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>运行scheme： <code>PDFReaderForOSX</code> 即可</p><div id="badge-container-huos3203-PDFReader-737a7e" class="hexo-github" style="width: 100%"></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-PDFReader-737a7e", "huos3203", "PDFReader", "737a7e", false);</script><h2 id="支持iOS"><a href="#支持iOS" class="headerlink" title="支持iOS"></a>支持iOS</h2><p>pageViewController: pdf翻页效果视图控制器<br>startingViewController:DataViewController,翻页视图控制器的视图源<br>modelController:ModelController:NSObject,数据视图数据源的model模型。<br><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuSfFoafDBb5uEQFrnVhTJsUkW0aK9AQdXcMcbiFunVcbHScfC5vkVafg3fT3QbuAq0m0"></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ngrok使用</title>
      <link href="/2017/09/06/hexo/ngrok%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/09/06/hexo/ngrok%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>1.注册<a href="https://ngrok.com/signup" target="_blank" rel="noopener">https://ngrok.com/signup</a></p><ol><li>Start by <a href="https://ngrok.com/download" target="_blank" rel="noopener">downloading ngrok</a>.</li><li><p>Install your authtoken</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok authtoken 2tpoyojTzL5w55Y4na5DY_3shJgaMVzjJ*****</span><br></pre></td></tr></table></figure></li><li><p>Create your first secure tunnel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok http 80</span><br></pre></td></tr></table></figure></li><li><p>Open the web interface at <a href="http://localhost:4040" target="_blank" rel="noopener">http://localhost:4040</a> to inspect and replay requests</p></li><li>Read the documentation for instructions on advanced features like adding HTTP authentication, setting custom subdomains and more.<h3 id="开启TCP协议"><a href="#开启TCP协议" class="headerlink" title="开启TCP协议"></a>开启TCP协议</h3></li><li>开启TCP实现SSH远程访问. <a href="https://ngrok.com/docs#tcp" target="_blank" rel="noopener">详见</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok tcp 22</span><br></pre></td></tr></table></figure></li></ol><p>如图：</p><blockquote><p>每当执行开启命令，端口就会随机生成最新的。</p></blockquote><ol start="2"><li>配置SSH远程工具<br>自定义SSH名：ngrok<br>SSH域名地址：0.tcp.ngrok.io  (ngrok提供的免费域名，IP地址ping就变新)<br>SSH端口号：16335 （每次重新启动时需更新）<br>用户名称/密码: 电脑管理员账户/密码</li><li>手机热点访问远程内网电脑<br>连接前准备：<ol><li>使用“网络实用工具”扫描<code>0.tcp.ngrok.io</code>域名，确保当前网络16335端口开启</li><li>备选方案，使用手机热点分享，来访问内网电脑，进行连通测试。</li></ol></li><li>连接成功。<br>总结：可以使用ngrok客户端，开启tcp协议端口，实现SSH远程控制，在不要求过高的网速和安全，可以不搭建ngrok服务器。</li></ol><h3 id="强大的tunnel-隧道-工具部署原理"><a href="#强大的tunnel-隧道-工具部署原理" class="headerlink" title="强大的tunnel(隧道)工具部署原理"></a>强大的tunnel(隧道)工具部署原理</h3><p><a href="http://tonybai.com/2015/05/14/ngrok-source-intro/" target="_blank" rel="noopener">部署</a><br>ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost”，这个诠释有两层含义：<br>1、可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。<br>2、支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。<br>因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。</p><p>一、ngrok tunnel与ngrok部署</p><p>网络tunnel（隧道）对多数人都是很”神秘“的概念，tunnel种类很多，没有标准定义，我了解的也不多（日常工作较少涉及），这里也就不 深入了。在《HTTP权威指南》中有关于HTTP tunnel（http上承载非web流量）和SSL tunnel的说明，但ngrok中的tunnel又与这些有所不同。</p><p>ngrok实现了一个tcp之上的端到端的tunnel，两端的程序在ngrok实现的Tunnel内透明的进行数据交互。<br><img src="http://tonybai.com/wp-content/uploads/ngrok-tunnel.png" alt><br>ngrok分为client端(ngrok)和服务端(ngrokd)，实际使用中的部署如下：<br><img src="http://tonybai.com/wp-content/uploads/ngrok-deployment.png" alt><br>内网服务程序可以与ngrok client部署在同一主机，也可以部署在内网可达的其他主机上。ngrok和ngrokd会为建立与public client间的专用通道（tunnel）。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搞定III目录笔记</title>
      <link href="/2017/08/17/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9AIII%E7%9B%AE%E5%BD%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/17/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9AIII%E7%9B%AE%E5%BD%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>11个模型</p><h2 id="《搞定III》"><a href="#《搞定III》" class="headerlink" title="《搞定III》"></a>《搞定III》</h2><p>第1章 GTD现象<br>几类读者：似懂非懂型，止步于列举清单等<br>第二类：很难坚持<br>第三类：学以致用型<br>如何阅读本书：<br>手头备小本子，“假设的肯定”<br>自我培训：可信赖，可操作，长期追踪的步骤找到最终答案<br>相信自己的决定的钥匙</p><p>第2章 步骤<br>第3章 自我管理的基本内容</p><h3 id="获得掌控"><a href="#获得掌控" class="headerlink" title="获得掌控"></a>获得掌控</h3><pre><code>第4章 捕捉 :梦想家，发散思维搜集所有信息第5章 明确意义:执行者，处理原材料，有的放矢     1. 结果导向型思维的战术价值     2.第6章 组织整理第7章 深思第8章 参与第9章 把GTD运用到工作和生活中</code></pre><h3 id="六个高度-六层次法"><a href="#六个高度-六层次法" class="headerlink" title="六个高度:六层次法"></a>六个高度:六层次法</h3><pre><code>第10章 摆正视角第11章 紧急问题：下一步行动第12章 1万英尺：项目第13章 2万英尺：关注和责任范围第14章 3万英尺：长短期目标第15章 4万英尺：愿景第16章 5万英尺：宗旨和原则第17章 摆正视角：重访“格雷西的花园”</code></pre><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>第18章 实际运用<br>第19章 尾声</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在space-vim平台安装若干插件</title>
      <link href="/2017/08/17/shell/%E5%9C%A8space-vim%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E8%8B%A5%E5%B9%B2%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/08/17/shell/%E5%9C%A8space-vim%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E8%8B%A5%E5%B9%B2%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="space-vim"><a href="#space-vim" class="headerlink" title="space-vim"></a>space-vim</h2><p>首次启用一个 layer，需要执行 SPC f R, 或者 :so $MYVIMRC, 重新加载 .vimrc 并执行 :PlugInstall 安装所需的相关插件 。或者退出重新打开 vim, vim-plug 将会检测并自动安装缺失的插件。<br>基于vim-plug的插件管理平台<br><a href="https://github.com/junegunn/vim-plug#commands" target="_blank" rel="noopener">vim-plug命令工具</a></p><h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>PlugInstall [name ...] [#threads]</code></td><td>Install plugins</td></tr><tr><td><code>PlugUpdate [name ...] [#threads]</code></td><td>Install or update plugins</td></tr><tr><td><code>PlugClean[!]</code></td><td>Remove unused directories (bang version will clean without prompt)</td></tr><tr><td><code>PlugUpgrade</code></td><td>Upgrade vim-plug itself</td></tr><tr><td><code>PlugStatus</code></td><td>Check the status of plugins</td></tr><tr><td><code>PlugDiff</code></td><td>Examine changes from the previous update and the pending changes</td></tr><tr><td><code>PlugSnapshot[!] [output path]</code></td><td>Generate script for restoring the current snapshot of the plugins</td></tr></tbody></table><h3 id="Plug-options"><a href="#Plug-options" class="headerlink" title="Plug options"></a><code>Plug</code> options</h3><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>branch</code>/<code>tag</code>/<code>commit</code></td><td>Branch/tag/commit of the repository to use</td></tr><tr><td><code>rtp</code></td><td>Subdirectory that contains Vim plugin</td></tr><tr><td><code>dir</code></td><td>Custom directory for the plugin</td></tr><tr><td><code>as</code></td><td>Use different name for the plugin</td></tr><tr><td><code>do</code></td><td>Post-update hook (string or funcref)</td></tr><tr><td><code>on</code></td><td>On-demand loading: Commands or <code>&lt;Plug&gt;</code>-mappings</td></tr><tr><td><code>for</code></td><td>On-demand loading: File types</td></tr><tr><td><code>frozen</code></td><td>Do not update unless explicitly specified</td></tr></tbody></table><h2 id="安装objc-自动提示插件YouCompleteMe"><a href="#安装objc-自动提示插件YouCompleteMe" class="headerlink" title="安装objc 自动提示插件YouCompleteMe"></a>安装objc 自动提示插件YouCompleteMe</h2><p><a href="https://github.com/Valloric/YouCompleteMe#commands" target="_blank" rel="noopener">YouCompleteMe命令工具</a></p><ol><li><p>在spacevim添加<br>使用space-vim封装的layer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Layer &apos;ycmd&apos;         &quot;语法自动补齐</span><br></pre></td></tr></table></figure><p>YouCompleteMe 安装位置： <code>~/.vim/plugged/YouCompleteMe</code> 。</p></li><li><p>编译 YCM<br>在使用space-vim平台上，使用layer方式安装会执行如下编译操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!./install.py --clang-completer</span><br></pre></td></tr></table></figure></li></ol><p>详见脚本：space-vim/layers/+tools/ycmd/packages.vim</p><p>参考：<a href="http://www.cocoachina.com/ios/20170224/18751.html" target="_blank" rel="noopener">征服恐惧！用 Vim 写 iOS App</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br><span class="line">./install.py --clang-completer --system-libclang</span><br></pre></td></tr></table></figure></p><p><code>--clang-completer</code>: 告诉脚本需要 clang 的支持<br><code>--system-libclang</code>: 告诉编译脚本使用系统的 clang，因为之前 clang 升级 4.0 的时候，并没有已经编译好的包给我下载，所以这里不用系统 clang 的话，编译脚本会下载一个 clang 3.0，这样就无法支持 iOS 10.0 以后的 sdk 了，因为 iOS 10.0 以后的 sdk 为了支持 swift 引入了一些 clang 3.0 不支持的新语法，所以这里要加上 –system-libclang。</p><ol start="3"><li><p>FlagsForFile脚本获取编译参数<br>YCMD 是通过每个项目路径下的 <code>.ycm_extra_conf.py</code> 脚本文件，定义了<code>FlagsForFile</code> 的函数来获取某一个特定文件需要的编译参数，一般情况下大部分文件的编译参数是相同的。</p></li><li><p>安装vim插件<br>使用vim-plug安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;keith/sourcekittendaemon.vim&apos;</span><br></pre></td></tr></table></figure></li></ol><p>NOTE: This plugin doesn’t provide Swift runtime files. If you’d like those checkout swift.vim</p><h3 id="AsyncRun-shell-command"><a href="#AsyncRun-shell-command" class="headerlink" title="AsyncRun shell command"></a>AsyncRun shell command</h3><p>编辑器命令:AsyncRun + shell命令即可在后台执行shell命令，打开quickfix就可以实时查看执行结果了。也可以通过添加配置的方式来实现开始执行命令的时候自动打开quickfix窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:copen //打开脚本运行日志窗口 </span><br><span class="line">:AsyncRun git status  //异步执行shell脚本</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PBBReader项目重构模型</title>
      <link href="/2017/07/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/PBBReader%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/07/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/PBBReader%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://www.plantuml.com/plantuml/svg/ZLPRJnj757xVNp5ofQpKS7cib0SaY8L2KneBK2lLvM5j3_OgQw_hNNfHX0G2WxaOJA10I75Y2iLDmQP1nc07_6TsnhjF-GkTdTcRRqddnPvpllFDDpDdpbbLL2K80YCZ4r28m9HHk6s-BXahMPnVmiK2ogzpOPXGOGh4g9_x518c8XQAuxza0w0_B_71PhE-fDMlJTZHFWZByQIS8Ao3GMP7kUmqq6ukyFevsghYtJBUMFWnWRF7Uc43M4GyuUmdmo949oluglY8nJTh3JP7MsMjVchC7-gD5VtL8R7x1WPyUYEFDqzHvXAbhxNw7YhVwlyM21MX9AHVc0C0Hc0frEwopRlInm-74fnH1rDYDAOEgd9oC2IhgXm7WCRGS8v_G0UmbDINK2vZiR2Di0cgRA3JVS303tYEH-cBvbdMmh-jeWzRZxwL8x1l0ePL8H6LOD-eB96Zx1jD2N7OzrYIPoDzVa4LGe82UOvQWG_bocYjE1m8-5vmW8mW-Uk74emAAfm6WWA-4MOJuHYnSdCS8mG-yw2MDvWkEmwV7-kDJQDGcGRaZ8EelDnyku1Nxz7hl6di3ceSwALB1dL1xQ4CMjh0cHnRs0Dj8-WEdNCsk_P6NxmZUMU9jlU3CjVQtHyj-s7q9uVetKljRiUONyNhVpihwALxL3h4Hul6gvmZXaQqUvYWapsqjOqoorhjdrPukuV1g--9qPXVG9bzlL1q8kPQD1i7QRrSxwAv-fxaAjwzTlbk6sXxhMrXnqOX-EK5thtNpvQDu-t_0JJUN7qMMDdIpp81_sWF-MI7pStBAI7KefqQNU6rVMEdffV_melf7ZJQpJkjLYCl7pKMsyYyBiR7BEIAoDEqoUOu-qa0d_AJ9AhGF-83BpZgvbEq6E7VBt6sX6exrEZYdKfc1jZhsieOcTT3LKK4URhD4cepnCahbbpRd6VRl9oGn0JyXA1d5E1TDeZkqoGdtGrpj1G0NqnLamyLEVmSgjQvMOuM6wKmwPdLS-DXejCpbTKOJ7dcoTcG98ObCUIzD-yoJwQc0Yr2XoV7dX1D7gLcGGE-vlcvThEAzsud_K-TSfDVGEbLl5aaxyGg1fCn8GK9n9h6PvEHcMcN1QNFcxj5L3r5wQhDydXM8ULuxDdaLyCIJAdVYV0NAreLup2bM9FXoC_4AofY8keXPFrBkp_IAtiM8H-S_65S3eaIrM4cdLi-AHEveN7XEJcdJX_VuXpgKMM2Ory_7OSHKGX8mcyzU3eXGrsUkBCFlRA4Qpbh1pDM-ewDjBwbkXWG8fxR3P3JaHE29q-34p0gAcfB3YX98UpDaU-XH7etTC_PanNEod4X2fM1NyE2ea1LwIA38Rg8wN3OaZeSL5Y7rIFFwwEfo0yvW_Jwz5NpoYg-0BWUddFkWbL1fzzn7Mt9QWqT7QONqblNEJVPGR_vYM7US4URQSbRq4-_GYZGRGXZ8xOTj9qxnzB2eNTwf-Em-RnV0_Qttemianyk99C4PDtL_BPZrly0"></p><h3 id="使用属性结构与法"><a href="#使用属性结构与法" class="headerlink" title="使用属性结构与法"></a>使用属性结构与法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\`\`\`puml</span><br><span class="line">salt</span><br><span class="line">&#123;</span><br><span class="line">    &#123;T</span><br><span class="line">    + world</span><br><span class="line">    ++ America</span><br><span class="line">    ++ sss</span><br><span class="line">    +++ aaa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">\`\`\`puml</span><br></pre></td></tr></table></figure><p><img src="https://www.plantuml.com/plantuml/svg/AqxCAU6gvgeEuLBGLYZFByf90JAq5HnpKuioanF1xEBYOX2jhP2OcCXLorKB0000"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView控件和JS脚本传参及交互</title>
      <link href="/2017/07/07/iOS/UI/WKWebView%E6%8E%A7%E4%BB%B6%E5%92%8CJS%E8%84%9A%E6%9C%AC%E4%BC%A0%E5%8F%82%E5%8F%8A%E4%BA%A4%E4%BA%92/"/>
      <url>/2017/07/07/iOS/UI/WKWebView%E6%8E%A7%E4%BB%B6%E5%92%8CJS%E8%84%9A%E6%9C%AC%E4%BC%A0%E5%8F%82%E5%8F%8A%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="WebKit简介"><a href="#WebKit简介" class="headerlink" title="WebKit简介"></a>WebKit简介</h3><div id="badge-container-huos3203-WKWebView-JS-d03bc0e" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-WKWebView-JS-d03bc0e", "huos3203", "WKWebView-JS", "d03bc0e", false);</script><p>自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势:<br>1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道）<br>2、更多的支持 HTML5 的特性<br>3、官方宣称的高达60fps的滚动刷新率以及内置手势<br>4、Safari 相同的 JavaScript 引擎<br>5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。</p><p><img src="https://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0"></p><h4 id="添加监听代理和JS接口"><a href="#添加监听代理和JS接口" class="headerlink" title="添加监听代理和JS接口"></a>添加监听代理和JS接口</h4><p>在OC中添加监听的接口清单：以JS脚本的接口<code>showMobile</code>为例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebViewConfiguration</span> *config = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line"><span class="built_in">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class="line"><span class="comment">//MARK:在OC中添加监听的接口清单：JS脚本的接口名</span></span><br><span class="line">[userCC addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"showMobile"</span>];</span><br></pre></td></tr></table></figure></p><h4 id="设置WKUserContentController的代理"><a href="#设置WKUserContentController的代理" class="headerlink" title="设置WKUserContentController的代理"></a>设置WKUserContentController的代理</h4><ol><li><p>设置代理类遵守<code>WKScriptMessageHandler</code>协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">WKScriptMessageHandler</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注册对JS接口监听，注入代理类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[userCC addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"showMobile"</span>];</span><br></pre></td></tr></table></figure></li><li><p>实现<code>WKUserContentController</code>代理的回调方法,响应JS接口事件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JS脚本接口"><a href="#JS脚本接口" class="headerlink" title="JS脚本接口"></a>JS脚本接口</h4><p>js接口声明格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.接口名.postMessage(<span class="string">'参数'</span>)</span><br></pre></td></tr></table></figure></p><p>接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。</p><p>参数：object类型，多个参数时需要封装为集合类型来实现多参传递。</p><p>当OC拦截到该接口时，可以在<code>WKScriptMessageHandler</code>回调方法中的<code>WKScriptMessage</code>参数实例中获取该参数值: <code>message.body</code>。</p><p>三个例子：</p><ol><li><p>JS无参调用OC<br><br>当无参调用OC时，参数必须为<code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.showMobile.postMessage(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></li><li><p>JS传参调用OC<br><br>传递单个参数时，直接写入即可，例如：<code>xiao黄</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.showName.postMessage(<span class="string">'xiao黄'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>传递多个参数时，需要封装为集合类型实现多参传递。<br><br>例如:当传递一个电话，一条信息，需要封装为<code>[&#39;13300001111&#39;,&#39;Go Climbing This Weekend !!!&#39;]</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.showSendMsg.postMessage([<span class="string">'13300001111'</span>, <span class="string">'Go Climbing This Weekend !!!'</span>])</span><br></pre></td></tr></table></figure></p><h3 id="iOS原生API调用JS脚本"><a href="#iOS原生API调用JS脚本" class="headerlink" title="iOS原生API调用JS脚本"></a>iOS原生API调用JS脚本</h3><p>在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。<br><br>例如调用JS函数<code>alertMobile()</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.wkWebView evaluateJavaScript:<span class="string">@"alertMobile()"</span> completionHandler:^(<span class="keyword">id</span> _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,response,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h4 id="在OC中为JS定义属性-函数"><a href="#在OC中为JS定义属性-函数" class="headerlink" title="在OC中为JS定义属性/函数"></a>在OC中为JS定义属性/函数</h4><ul><li>当注入的类型字符串类型时，必须用<code>&#39;&#39;</code>括起来。<br></li><li>OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。<br></li></ul><p>通过NSString形式，编写JS脚本，通过以下两种方式注入网页</p><p>方式一：在初始化<code>WKWebView</code>时，通过配置<code>WKWebViewConfiguration&gt;userContentController</code>注入JS脚本  。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK:向网页中注入JS脚本例如，参数/函数等</span></span><br><span class="line"><span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:<span class="string">@"var number=0;"</span></span><br><span class="line">injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class="line">forMainFrameOnly:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class="line">[userCC addUserScript:script];</span><br></pre></td></tr></table></figure></p><p>方式二：使用WKWebView实例方法<code>evaluateJavaScript</code>动态注入JS脚本</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.wkWebView evaluateJavaScript:<span class="string">@"var number=0;"</span> completionHandler:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="iOS原生API调用JS函数"><a href="#iOS原生API调用JS函数" class="headerlink" title="iOS原生API调用JS函数"></a>iOS原生API调用JS函数</h4><p>使用WKWebView实例方法<code>evaluateJavaScript</code>动态调用JS函数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.wkWebView evaluateJavaScript:<span class="string">@"alertSendMsg('18870707070','下午好！')"</span> completionHandler:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 控件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器键盘映射命令map</title>
      <link href="/2017/07/04/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84%E5%91%BD%E4%BB%A4map/"/>
      <url>/2017/07/04/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84%E5%91%BD%E4%BB%A4map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用<code>:map</code>命令，可以将键盘上的某个按键与Vim的命令绑定起来。<br>例如使用以下命令，可以通过F5键将单词用花括号括起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:map &lt;F5&gt; i&#123;e&lt;Esc&gt;a&#125;&lt;Esc&gt;</span><br></pre></td></tr></table></figure></p><p>执行过程：<code>i{</code>将插入字符<code>{</code>，然后使用<code>Esc</code>退回到命令状态；接着用<code>e</code>移到单词结尾，<code>a}</code>增加字符<code>}</code>，最后退至命令状态。<br>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。</p><h2 id="不同模式下的键盘映射"><a href="#不同模式下的键盘映射" class="headerlink" title="不同模式下的键盘映射"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p><table><thead><tr><th style="text-align:center">Command 命令</th><th style="text-align:center">Normal 常规模式</th><th style="text-align:center">Visual可视化模式</th><th style="text-align:center">Operator Pending运算符模式</th><th style="text-align:center">Insert Only插入模式</th><th style="text-align:center">Command Line 命令行模式</th></tr></thead><tbody><tr><td style="text-align:center">:map</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:nmap</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">:vmap</td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:omap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:map!</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">:imap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:cmap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td></tr></tbody></table><h3 id="查看键盘映射"><a href="#查看键盘映射" class="headerlink" title="查看键盘映射"></a>查看键盘映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:map</span><br></pre></td></tr></table></figure><h3 id="取消键盘映射"><a href="#取消键盘映射" class="headerlink" title="取消键盘映射"></a>取消键盘映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:unmap &lt;F10&gt; #参数</span><br></pre></td></tr></table></figure><p>注意：必须为:unmap命令指定一个参数。如果未指定任何参数，那么系统将会报错，而不会取消所有的键盘映射。<br>针对不同模式下的键盘映射，需要使用与其相对应的unmap命令。例如：使用:iunmap命令，取消插入模式下的键盘映射；而取消常规模式下的键盘映射，则需要使用:nunmap命令。<br>如果想要取消所有映射，可以使用:mapclear命令。请注意，这个命令将会移除所有用户定义和系统默认的键盘映射。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://blog.csdn.net/daofengdeba/article/details/7605124" target="_blank" rel="noopener">VIM键盘映射 (Map)</a><br><a href="http://www.pythonclub.org/vim/map-basic" target="_blank" rel="noopener">Vim按键映射</a></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器的基本用法</title>
      <link href="/2017/07/04/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2017/07/04/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://github.com/huos3203/vim-galore-zh_cn" target="_blank" rel="noopener">参考</a></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>动作：是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:h navigation</span><br></pre></td></tr></table></figure></p><p>操作符：<br>对某个区域文本执行的操作。比如，d、~、gU 和 &gt; 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:h operator</span><br></pre></td></tr></table></figure></p><p>文本对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:h text-objects</span><br></pre></td></tr></table></figure></p><h3 id="缓冲区列表"><a href="#缓冲区列表" class="headerlink" title="缓冲区列表"></a>缓冲区列表</h3><p>缓冲区的几种状态：已激活，已载入，已列出，已命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:ls  #列出所有可以列出的缓冲区</span><br><span class="line">:ls! #命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区</span><br></pre></td></tr></table></figure></p><p>创建一个无名临时缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:enew</span><br></pre></td></tr></table></figure></p><p>激活一个缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e file2</span><br></pre></td></tr></table></figure></p><p>命名一个缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w /path/file #存储位置</span><br></pre></td></tr></table></figure></p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:h argument-list</span><br></pre></td></tr></table></figure><p>操作命令范围概念<br>关键字符：,|;|数字|\$|%</p><h3 id="跳转历史和变更历史"><a href="#跳转历史和变更历史" class="headerlink" title="跳转历史和变更历史"></a>跳转历史和变更历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:jumps</span><br><span class="line">:changes</span><br><span class="line">:h changelist</span><br><span class="line">:h jumplist</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><a href="http://vim.liuchengxu.org/docs/org/tutorial_cn.html#orgheadline26" target="_blank" rel="noopener">space-Vim使用文档</a><br><code>空格 f t</code>  打开/关闭树型栏<br><code>SPC f R</code> 刷新文件结构目录<br><code>, f c</code> unite命令集合快速查找命令集<br><code>SPC b h</code> 返回vim主页<br><code>SPC f r</code> 最近打开过的文件清单</p><h3 id="markdown插件命令"><a href="#markdown插件命令" class="headerlink" title="markdown插件命令"></a>markdown插件命令</h3><p><code>,1..3</code> 快速标题格式<code>###</code>生成章节<br><code>,ct</code> 在当前位置插入所有章节的清单<br><code>,cs</code> 新建窗口显示博客章节目录清单,支持编辑时跳转到指定的章节位置<br><code>,cp</code> 预览博客发布的效果</p><h3 id="git插件命令"><a href="#git插件命令" class="headerlink" title="git插件命令"></a>git插件命令</h3><p><code>SPC g s</code> git status<br><code>SPC g d</code> git diff<br><code>AsyncRun git add file</code> git add file<br><code>SPC g c</code> git commit<br><code>SPC g p</code> git push</p><h3 id="unite"><a href="#unite" class="headerlink" title="unite"></a>unite</h3><p><a href="http://www.cnblogs.com/pigzhu/p/3159161.html" target="_blank" rel="noopener">Vim插件：Unite新手指导(译)</a><br>Unite可以在一个项目中快速浏览文件。但是它不仅限于文件，其他任何可以列出的东西都可以很好的被显示和搜索。这个开放式的特性很可能是人们找到它的原因</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Unite命令采用的格式为:Unite source，其中”source”是buffer，file和file_rec其中之一。</p><p><code>buffer</code>: 浏览当前打开的buffer列表<br><code>file</code>: 浏览当前目录的文件列表<br><code>file_rec</code>: 递归的列出当前目录的文件<br>当一个命令被使用，一个新的水平分割窗口会被打开。<br>比如，命令:<code>Unite file</code>将会显示当前目录的文件列表。在这个窗口中，标准的Vim命令模式下的命令可以使用。可以使用“<code>j</code>”和“<code>k</code>”浏览该列表，可以使用“<code>/</code>”来查询。如果你在一个文件上按下<code>enter</code>键，Unite将会打开它。如果光标是在一个目录上，Unite将会进入该目录，并且更新该文件列表。<br>使用NERO Tree命令<br>查看帮助命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?</span><br></pre></td></tr></table></figure></p><p>将选中的目录变为根目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C  # change tree root to the selected dir</span><br></pre></td></tr></table></figure></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="插入搜索模式"><a href="#插入搜索模式" class="headerlink" title="插入搜索模式"></a>插入搜索模式</h4><p>如果你在Unite窗口进入插入模式，光标将会移到该窗口的最上方，并显示“&gt;”提示符。输入字符会搜索该列表–这里和FuzzyFinder相似。和常规vim一样，按<esc>键可以退出插入模式回到命令模式。</esc></p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>在命令模式下，当光标在一个文件上，按下a，Unite会显示一个可以操作该文件命令的列表。这个命令列表被称为actions，这个列表可以像Unite其他部分一样被搜索和调用。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>actions可以组合通配符。如果输入:Unite file, 然后按下*将会标记所有文件，再输入a将会列出所有actions，最后选择above，Unite将会打开所有被标记的文件。</p><h3 id="单行操作"><a href="#单行操作" class="headerlink" title="单行操作"></a>单行操作</h3><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p>hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</p><ol><li><p>单词移动：<br>1.一个单词由字母，数字和下划线组成，那么就用小写的e和w。即：程序变量移动。<br>2.单词是由blank字符分隔符，那么就用大写的E和W。 即：程序语句移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w → 到下一个单词的开头。</span><br><span class="line">e → 到下一个单词的结尾。</span><br><span class="line">b → 到前一个单词的开头。</span><br></pre></td></tr></table></figure></li><li><p>本行移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 → 数字零，到行头</span><br><span class="line">^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</span><br><span class="line">$ → 到本行行尾</span><br><span class="line">g_ → 到本行最后一个不是blank字符的位置。</span><br></pre></td></tr></table></figure></li><li><p>行间移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</span><br><span class="line">gg → 到第一行。（陈皓注：相当于1G，或 :1）</span><br><span class="line">G 到最后一行</span><br></pre></td></tr></table></figure></li></ol><h3 id="多行范围"><a href="#多行范围" class="headerlink" title="多行范围"></a>多行范围</h3><p>范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。</p><ul><li>很多命令都可以加一个数字，用于指明操作范围</li><li>范围可以是一个行号，用于指定某一行</li><li>范围也可以是一对通过 <code>,</code> 或 <code>;</code> 分割的行号</li><li>大部分命令，默认只作用于当前行</li><li>只有 <code>:write</code> 和 <code>:global</code> 是默认作用于所有行的</li></ul><p>范围的使用是十分直观的。以下为一些例子（其中，<code>:d</code> 为 <code>:delete</code> 的缩写）：</p><table><thead><tr><th>命令</th><th>操作的行</th></tr></thead><tbody><tr><td><code>:d</code></td><td>当前行</td></tr><tr><td><code>:.d</code></td><td>当前行</td></tr><tr><td><code>:1d</code></td><td>第一行</td></tr><tr><td><code>:$d</code></td><td>最后一行</td></tr><tr><td><code>:1,$d</code></td><td>所有行</td></tr><tr><td><code>:%d</code></td><td>所有行（这是 <code>1,$</code> 的语法糖）</td></tr><tr><td><code>:.,5d</code></td><td>当前行至第 5 行</td></tr><tr><td><code>:,5d</code></td><td>同样是当前行至第 5 行</td></tr><tr><td><code>:,+3d</code></td><td>当前行及接下来的 3 行</td></tr><tr><td><code>:1,+3d</code></td><td>第一行至当前行再加 3 行</td></tr><tr><td><code>:,-3d</code></td><td>当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围）</td></tr><tr><td><code>:3,&#39;xdelete</code></td><td>第三行至<a href="#标注">标注</a> 为 x 的那一行</td></tr><tr><td><code>:/^foo/,$delete</code></td><td>当前行以下，以字符 “foo” 开头的那一行至结尾</td></tr><tr><td><code>:/^foo/+1,$delete</code></td><td>当前行以下，以字符 “foo” 开头的那一行的下一行至结尾</td></tr></tbody></table><p>需要注意的是，<code>;</code> 也可以用于表示范围。区别在于，<code>a,b</code> 的 <code>b</code> 是以当前行作为参考的。而 <code>a;b</code> 的 <code>b</code> 是以 <code>a</code> 行作为参考的。举个例子，现在你的光标在第 5 行。这时 <code>:1,+1d</code> 会删除第 1 行至第 6 行，而 <code>:1;+1d</code> 会删除第 1 行和第 2 行。</p><h3 id="可视化区域选择并编辑文本"><a href="#可视化区域选择并编辑文本" class="headerlink" title="可视化区域选择并编辑文本"></a>可视化区域选择并编辑文本</h3><p>1.区域选择其命令格式：</p><pre><code>&lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;</code></pre><p>在visual 模式下，这些命令很强大。</p><p><code>action</code>可以是任何的命令，如 <code>d (删除)</code>, <code>y (拷贝)</code>,<code>v (可以视模式选择)</code>。<br><code>object</code> 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。</p><p>示例：<br>假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi&quot; → 会选择 foo.</span><br><span class="line">va&quot; → 会选择 &quot;foo&quot;.</span><br><span class="line">vi) → 会选择 &quot;foo&quot;.</span><br><span class="line">va) → 会选择(&quot;foo&quot;).</span><br><span class="line">v2i) → 会选择 map (+) (&quot;foo&quot;)</span><br><span class="line">v2a) → 会选择 (map (+) (&quot;foo&quot;))</span><br></pre></td></tr></table></figure></p><p>2.可视化选择： v,V,<c-v></c-v></p><p>前面，我们看到了 <c-v>的示例 （在Windows下应该是<c-q>），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">J → 把所有的行连接起来（变成一行）</span><br><span class="line">&lt; 或 &gt; → 左右缩进</span><br><span class="line">= → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</span><br></pre></td></tr></table></figure></c-q></c-v></p><p>3.在所有被选择的行后加上点东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……)</span><br><span class="line">$ 到行最后</span><br><span class="line">A, 输入字符串，按 ESC。</span><br></pre></td></tr></table></figure></p><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p>插入光标位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i → Insert 模式，按 ESC 回到 Normal 模式.</span><br><span class="line">a → 在光标后插入</span><br><span class="line">o → 在当前行后插入一个新行</span><br><span class="line">O → 在当前行前插入一个新行</span><br></pre></td></tr></table></figure></p><p>操作文本：</p><p>1.删除：字符，单词，行</p><pre><code>x → 删当前光标所在的一个字符。cw → 替换从光标所在位置后到一个单词结尾的字符【准确的说是删除从光标位置到一个单词结尾的字符并进入插入模式】dd → 删除当前行，并把删除的行存到剪贴板里</code></pre><p>通过行号确定你要删除的行；</p><pre><code>set nu → 显示行号；:32,65d → 32-65行就被删除了</code></pre><p>2.拷贝：单词，行，段</p><pre><code>ye → 当前位置拷贝到本单词的最后一个字符。yy → 拷贝当前行相当于 ddP（dd删除当前行，再粘贴）0y$ → 拷贝当前行，即：光标移动组合操作格式：&lt;start position&gt;&lt;command&gt;&lt;end position&gt;y2/foo → 拷贝2个 “foo” 之间的字符串。</code></pre><p>  还有很多时候并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p><pre><code>d (删除 )v (可视化的选择)gU (变大写)gu (变小写)等等</code></pre><blockquote><p>注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等</p></blockquote><p>3.粘帖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p/P → p是表示在当前位置之后，P表示在当前位置之前</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SourceKittenSwift语法自动补齐工具</title>
      <link href="/2017/06/29/shell/SourceKittenSwift%E8%AF%AD%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/06/29/shell/SourceKittenSwift%E8%AF%AD%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>vim插件工具：Vundle</p><p>主题色：<br>|组合键 |   Description|<br>空格 + T + n|  随机切换颜色主题。<br>SPC T s    |使用unite buffer方式切换一个主题</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Unite"><a href="#Unite" class="headerlink" title="Unite"></a><a href="https://github.com/Shougo/unite.vim" target="_blank" rel="noopener">Unite</a></h3><p>预定义操作命令<br>Unite或unite.vim插件可以搜索和显示信息，例如：任意源文件、缓冲区的，最近使用的文件或记录。可以直接运行在Unite窗口中显示的几个预设操作。</p><h3 id="neocomplete"><a href="#neocomplete" class="headerlink" title="neocomplete"></a>neocomplete</h3><p>一个自动补全的插件，使用TAB或ENTER键来选择。<br>同时，它又额外附带了补全代码段的特性（模版补全），要想使用这种特性，必须安装另外的插件neosnippet或者ultisnips。<br><img src="http://img.blog.csdn.net/20161026000011614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="NERD-Commenter"><a href="#NERD-Commenter" class="headerlink" title="NERD Commenter"></a><a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="noopener">NERD Commenter</a></h3><p>快速注释/解开注释</p><h3 id="Goyo-and-Limelight"><a href="#Goyo-and-Limelight" class="headerlink" title="Goyo and Limelight"></a>Goyo and Limelight</h3><p>干净模式和背景虚化。两者配合使用，效果非常好。vim 也可以很文艺</p><h3 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a><a href="http://blog.csdn.net/mdl13412/article/details/44081509" target="_blank" rel="noopener">Bookmarks</a></h3><p>插件旨在解决 Vim 自带书签无法高亮、无法持久化、难于记忆的问题，而且解决的非常漂亮. 下面列出其主要特性:</p><p>单行书签切换 ⚑<br>单行的注释(说明)书签 ☰<br>在 quickfix 窗口中访问所有书签<br>书签自动保存，下次开启自动加载<br>针对工作目录的独立书签(可选)<br>高度可定制<br>可以和 Unite 插件的 quickfix 结合<br>不依赖 Vim 自身的 marks</p><h3 id="Gita"><a href="#Gita" class="headerlink" title="Gita"></a>Gita</h3><p>git插件</p><h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>Key    Mode    Action</p><p><leader>+gu    Normal    Open undo tree</leader></p><p><leader>+i    Normal    Toggle indentation lines</leader></p><p><leader>+j    Normal    Start smalls</leader></p><p><leader>+r    Normal    Quickrun</leader></p><p><leader>+?    Normal    Dictionary</leader></p><p><leader>+W    Normal    Wiki</leader></p><p><leader>+K    Normal    Thesaurus</leader></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在slack上实现实时绘UML图</title>
      <link href="/2017/06/28/%E5%AF%BC%E5%9B%BE/%E5%9C%A8slack%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%BB%98UML%E5%9B%BE/"/>
      <url>/2017/06/28/%E5%AF%BC%E5%9B%BE/%E5%9C%A8slack%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%BB%98UML%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://github.com/huos3203/umlbot" target="_blank" rel="noopener">umlbot源码库</a><br><img src="https://www.plantuml.com/plantuml/svg/NLFFRjem6B_xAImuq2An1-3Gsqxh_cXQJz031KCYWYs5H5KrJGAj3EWWeBQC5T9kRCg4fecYReCj27WPx8Itc1C3exqvNpx__dsVDLbJ45o-xJlJkyMV0cqC9QIIhCvCcrxr5xOTn-pobjMArEpdbKGowtnlqyPNEhXXxP4p-KWh8psdqEuC917Ma0ebb4WX5V3Y4T7esAAbCK0ujIg3c0zo21Dvw9y0I2f4Jy70chPEptgSEV0Qn0I6tokE82Qw_99tND70I2nuWXI571_k-VNeoj761V2gNbj6HGZpBd4n2gdnoJtjCFC7U0Esq4HRP4-8Z4BXzE3fFl0BCBBcSMSNj6H9X6ITopwhZ5bhoEg3E7xr_CdZPolM_p0RFGSlzm48iP_zPVcCzNlqkXq2c6W8gd96qY19hmJ2ACp8cgGVCRlfV2vI-oAEFL0n4_7BwVvYXYKC2n05fNsC1vd2uB4aQuYBdZVTNaqmR0qQBYQ6BzGrnhJnWLCAD_T1HG115QLuogMwCnqGNSiG6MUW5qCSUv6KxQX6iWYBhv8LtNQ-az_rp1iMNwIr-PtT04-3lgi5_BosXqYhTTPeUXtYUxl37Sou017sVPaRE35B3cOMt6z5PpwXNwxYEF12GOayWac2qxAQWoT43wa8SWYOW2hXmJmAF9Z8Xbvu5zJXi4yU3Y-cNXHnl2nqt7bPvUkUGrpsOjPrEgUhRQnLb-UyXLrR_Fqunb10-461zVj94qwg0gSxy7p_Vk_UjkZV4RlhCRCgRebdk5v8ZivQ5NPZUgzCNFu7"></p>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PBBReader阅读器解析</title>
      <link href="/2017/06/27/iOS/PBBReader%E9%98%85%E8%AF%BB%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/06/27/iOS/PBBReader%E9%98%85%E8%AF%BB%E5%99%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="支持OS-X浏览PDF简单视图"><a href="#支持OS-X浏览PDF简单视图" class="headerlink" title="支持OS X浏览PDF简单视图"></a>支持OS X浏览PDF简单视图</h2><p>运行scheme： <code>PDFReaderForOSX</code> 即可</p><h2 id="支持iOS"><a href="#支持iOS" class="headerlink" title="支持iOS"></a>支持iOS</h2><p>pageViewController: pdf翻页效果视图控制器<br>startingViewController:DataViewController,翻页视图控制器的视图源<br>modelController:ModelController:NSObject,数据视图数据源的model模型。<br><img src="https://www.plantuml.com/plantuml/svg/ZLPRJnj757wVNp4A3zYWjPG-Rf0bBarbgG64I_iG8hIsnsRBiXlDZab95Oa4d3X02MeA936uGDh20w6G6uutc3-pisi_zI_qZ7TjVDbKzPDdvimvt_dcdEyiOYhJ2Awzo5N_jlZB8_VLCd-SgoqTkTPpfxZC2nMK93eZ5CyG9KKegXw-TeeRuoCttS89lzZyv_EQywBY_b66dTh-Xzhk0I9wohT5IKqnJNnJrSZtAhatREYC6ff6wC1ah7qZ-ZEI9CpFYixYeMijOqb2_R6XiInWOzWpndrtKsdnvmRgduoDAvaEdt3UjNS3IIPJA5FrJEV1z3JcJowSpLCHRdeQIJWK6nfCCjNGmsf26JACsJc5pffoQ38sb6NCq75Vs8JSwbxRZGLELIV_mpHE59gS6MAw759JJPi73QQ2yXfef1N4KOfe9ACm0foa5AR4ZInDYiKys4VIL9aJYmmnMPQI2P8qChfwdr2pE_r-LLTPA7m59PYtWQie0AUBmv3m4fvlkpB8Of3bJxB93BgGC1IQaaKUpiQE-_x0EThdkziY5IaqRm0b5B1w94qGCwknOKCpg1mQZSSP1JHrOiKfBEkyzVBSE_UTnSyUzQ9Wo3YYaJIBH0F9bUSCeB3wy1NVo4CUpYydJda31PPN91BjBcJPURhALoxjptkrnL-HRZ22uVMX66Pn3oKf6JihA-wb1PtXh1_o_4Ulm_nBvLNR-ZYbUvTTwsLh4uvxjMwNtY3K7HPVktuDzqctUn9QbjoHn388SmSWOGo8YikrnJr-KhGhgtQft0pgd5jyPSy3orT-hovTeFzaz7PFXYeBTu1OY1x0J7StYioR7BT34wvaR5ivzxSZkxpEyxlyS9MlRRd7ntPfqJdUzqH640Cwq-HfSmq41_IAdtmAf4cIebyePDalm8H2FVxvcstt-2-xz1P74VpgyAYQcM7OI7_11-wvDwCoeFHw10EJ_Zi_sx0hXMQUKph-AeATmdjdwzIB286Sam-rWvtgqxTU6C6cY1AGW2WYBEFMfEsIvGjjs-N0cfKnlBExVkf3symxnHtn2erQR3Gx-1zNg0dzpS__vBbpzymARkzKM7Ju3ogR4M17GL_QUZCDctfTTDfimVs8aPH3mzzu_x9pC58cI3gSCfB2T3G-IA40m466C30H6O25sQAC8B7VWiG63Gu1iocA07CqVYlBb8H6VAU6fyvVmnMLWC-kyxj47-kmQPaztmbJRm3vdfexmjTOuaUIP0Et5dmNxV16V7sEuhuhgNxGLAr2fHSrkQzNgv-dt1oppjOJP_zrTVsSFzloHgutcP5lYINem83smruX-bVgZOBQA-OgCBGV8Re_sc7AjiOHvR9NufTBNcNmjPmOy5XuwcYI1Y2lAqJjvGlSAhSYcDAzFkxuYF1SWzRnoZRFdpPr0ZM-FT86HAB8BZ-6cyBquZaOrVO_mNsV3W3bMVqB"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Perfect开发天气接口API</title>
      <link href="/2017/06/27/macOS/Perfect%E5%BC%80%E5%8F%91%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3API/"/>
      <url>/2017/06/27/macOS/Perfect%E5%BC%80%E5%8F%91%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3API/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Perfect介绍"><a href="#Perfect介绍" class="headerlink" title="Perfect介绍"></a>Perfect介绍</h2><p>Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。<br>所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。</p><h3 id="请求过滤器"><a href="#请求过滤器" class="headerlink" title="请求过滤器"></a>请求过滤器</h3><p>过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。</p><h3 id="HTTP请求-响应路由"><a href="#HTTP请求-响应路由" class="headerlink" title="HTTP请求/响应路由"></a>HTTP请求/响应路由</h3><p>HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。</p><ol><li><code>句柄</code>:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。</li><li><p><code>路由</code>:主要依据请求的方法<code>HTTP request method</code>和请求内容包括的<code>路径信息</code>来决定的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routes.add(method: .post, uris: [<span class="string">"HostMonitor/client/log/addLog"</span>])&#123;</span><br><span class="line">    (request,response) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//处理请求,并响应请求</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>URI路由变量<br>URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。<br>每个变量组件是通过一个<code>程序块{ }</code>声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号<code>}</code>之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。<br><code>变量值</code>:在匹配该模式下URL能够通过<code>HTTPRequest.urlVariables</code>字典查询变量值。该字典是[String:String]类型。</p></li></ol><h3 id="请求对象HTTPRequest"><a href="#请求对象HTTPRequest" class="headerlink" title="请求对象HTTPRequest"></a>请求对象HTTPRequest</h3><p>当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。<br>HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。</p><p>HTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。</p><p>以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> 终端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搞定2提升工作与生活效率的52项原则</title>
      <link href="/2017/06/26/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A2%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%95%88%E7%8E%87%E7%9A%8452%E9%A1%B9%E5%8E%9F%E5%88%99/"/>
      <url>/2017/06/26/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A2%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%95%88%E7%8E%87%E7%9A%8452%E9%A1%B9%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="《搞定II》"><a href="#《搞定II》" class="headerlink" title="《搞定II》"></a>《搞定II》</h2><h3 id="前言-轻松实现轻松做事"><a href="#前言-轻松实现轻松做事" class="headerlink" title="前言 轻松实现轻松做事"></a>前言 轻松实现轻松做事</h3><h3 id="第一部分-理清头绪，发挥创造力"><a href="#第一部分-理清头绪，发挥创造力" class="headerlink" title="第一部分 理清头绪，发挥创造力"></a>第一部分 理清头绪，发挥创造力</h3><pre><code>第1章 理清思路，确立新方向第2章 知道哪些事情自己尚未做，你才会为之心安第3章 理清承担的任务，可以更好地选择新任务第4章 要实现未来的目标，首先明确当前的位置第5章 以有限的可能，去利用无限的机遇第6章 一心二用带来压力与失败第7章 有意识地权衡轻重缓急第8章 完成未竟之事，释放自身能量第9章 如果你一直想着某件事，很可能是还没有搞定第10章 只要有空间，创造力就会展现第11章 渠深流畅第12章 担忧无益第13章 你不是你的工作</code></pre><h3 id="第二部分-高效关注"><a href="#第二部分-高效关注" class="headerlink" title="第二部分 高效关注"></a>第二部分 高效关注</h3><pre><code>第14章 想看得更清楚，请从更高处着眼第15章 只有身体力行，你才会知道如何去做第16章 工作足够努力是不可能的第17章 精力随心思而动第18章 目标越明确，实现目标的途径越多第19章 精益求精第20章 关注重心的变化等于结果的变化第21章 视角是地球上最贵重的商品第22章 多加思考第23章 思考有度第24章 效率是改善工作的唯一机会第25章 关注一件事才能“全神贯注”第26章 未来目标的价值，在于它当前培育的变化</code></pre><h3 id="第三部分-建立有效的制约机制"><a href="#第三部分-建立有效的制约机制" class="headerlink" title="第三部分 建立有效的制约机制"></a>第三部分 建立有效的制约机制</h3><pre><code>第27章 稳定带来创造力第28章 形式与功能必须符合效率最高的原则第29章 优化系统，放飞思想第30章 反应能力提升生存能力第31章 系统的强弱取决于最薄弱的环节第32章 系统的效率与你的感知度成反比第33章 功能取决于形式第34章 目标明确才能赢得胜利第35章 多人负责等于无人负责第36章 确定原则，而不是监管制度第37章 利用大脑来思考工作，而不是单纯关注工作第38章 思考的价值超乎想象第39章 资源越是有限，规划越有必要</code></pre><h3 id="第四部分-放松自我，开始工作"><a href="#第四部分-放松自我，开始工作" class="headerlink" title="第四部分 放松自我，开始工作"></a>第四部分 放松自我，开始工作</h3><pre><code>第40章 对自己做的事情承担起责任第41章 过度控制等于失去控制第42章 进展越好，状态越好第43章 相信自己的行动选择，需要多层面的自我管理第44章 你的力量取决于你的放松能力第45章 预料之内的意外算不上意外第46章 目光越长远，进展越顺畅第47章 放慢速度以提升速度第48章 你没有时间做任何项目第49章 坚持做好小事，就能产生重大影响第50章 亲力亲为才能了解事物第51章 动中求变更容易第52章 最伟大的成功源自最惨重的失败</code></pre><h3 id="第五部分-注意基本要素"><a href="#第五部分-注意基本要素" class="headerlink" title="第五部分 注意基本要素"></a>第五部分 注意基本要素</h3><pre><code>工作流程的5个阶段处理与组织整理流程图自然式计划模式每周回顾指南</code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><div class="pdf" target="/images/搞定2提升工作与生活效率的52项原则.pdf" height></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreML机器学习初级教程</title>
      <link href="/2017/06/25/iOS/CoreML%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
      <url>/2017/06/25/iOS/CoreML%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML开发文档</a><br><a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">ML模型资源页面</a><br>在Working with Models中包含有几个常用的模型模板，例如用于在图片中检测物体——树、动物、人等等。<br><a href="https://developer.apple.com/documentation/coreml/integrating_a_core_ml_model_into_your_app" target="_blank" rel="noopener">Integrating a Core ML Model into Your App</a></p><p><a href="https://docs-assets.developer.apple.com/published/51ff0c1668/IntegratingaCoreMLModelintoYourApp.zip" target="_blank" rel="noopener">官方Core ML文档示例 App</a><br>MarsHabitatPricePredictor 模型的输入只是数字，因此代码直接使用生成的 MarsHabitatPricer 方法和属性，而不是将模型包装在 Vision 模型中。每次都改一下参数，很容易看出模型只是一个线性回归：<br>137 <em> solarPanels + 653.50 </em> greenHouses + 5854 * acres</p><h3 id="配置-：将-Core-ML-模型集成到你的-App"><a href="#配置-：将-Core-ML-模型集成到你的-App" class="headerlink" title="配置 ：将 Core ML 模型集成到你的 App"></a>配置 ：将 Core ML 模型集成到你的 App</h3><p>本教程使用 Places205-GoogLeNet 模型，可以从苹果的<a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">ML</a>页面下载。往下滑找到 Working with Models，下载第一个。还在这个页面，注意一下其它三个模型，它们都用于在图片中检测物体——树、动物、人等等。</p><blockquote><p>注意：如果你有一个训练过的模型，并且是使用受支持的机器学习工具训练的，例如 Caffe、Keras 或 scikit-learn，Converting Trained Models to Core ML 介绍了如何将其转换为 Core ML 格式。</p></blockquote><ol><li>添加模型<br>下载 GoogLeNetPlaces.mlmodel 后，把它从 Finder 拖到项目导航器的 Resources 组里：<br><img src="http://upload-images.jianshu.io/upload_images/861914-5425960c41207b82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>生成模型类<br>选择该文件，然后等一会儿。Xcode 生成了模型类后会显示一个箭头：<br><img src="http://upload-images.jianshu.io/upload_images/861914-e00a802f64f0ae13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>查看模型类<br>点击箭头，查看生成的类：<br><img src="http://upload-images.jianshu.io/upload_images/861914-1268b5b918fccf07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>三个类：<br><code>GoogLeNetPlaces</code>: 主类，包含一个 model 属性和两个 prediction 方法<br><code>GoogLeNetPlacesInput</code>: 输入类,包含一个 CVPixelBuffer 类型的 sceneImage 属性，Vision 框架会负责把我们熟悉的图片格式转换成正确的输入类型。<br><code>GoogLeNetPlacesOutput</code>：输出属性,Vision 框架会将 <code>GoogLeNetPlacesOutput</code> 属性转换为自己的 <code>results</code> 类型.</li></ol><h3 id="实现Vision工作流程"><a href="#实现Vision工作流程" class="headerlink" title="实现Vision工作流程"></a>实现Vision工作流程</h3><p>标准的 Vision 工作流程是创建模型，创建一或多个请求，然后创建并运行请求处理程序。<br>并管理对 <code>prediction</code>方法的调用，所以在所有生成的代码中，我们只会使用 <code>model</code> 属性。</p><ol><li><p>创建模型：在 <code>Vision Model</code> 中包装 <code>Core ML Model</code><br>CoreML模型 是用于 Vision 请求的 Core ML 模型的容器<br>打开 ViewController.swift，并在 import UIKit 下面 import 两个框架：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreML</span><br><span class="line"><span class="keyword">import</span> Vision</span><br></pre></td></tr></table></figure></li><li><p>创建<code>VNCoreMLRequest</code>图像分析请求<br><code>VNCoreMLRequest</code> 是一个图像分析请求，它使用 Core ML 模型来完成工作。它的 completion handler 接收 request 和 error 对象。<br>Core ML 模型<code>GoogLeNetPlaces</code> 是一个分类器，因为它仅预测一个特征：图像的场景分类。这时request.results 是 <code>VNClassificationObservation</code> 对象数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个带有 completion handler 的 Vision 请求</span><br><span class="line">let request = VNCoreMLRequest(model: model) &#123; [weak self] request, error in</span><br><span class="line">    guard let results = request.results as? [VNClassificationObservation],</span><br><span class="line">    let topResult = results.first else &#123;</span><br><span class="line">    fatalError(&quot;unexpected result type from VNCoreMLRequest&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在主线程上更新 UI</span><br><span class="line">let article = (self?.vowels.contains(topResult.identifier.first!))! ? &quot;an&quot; : &quot;a&quot;</span><br><span class="line">    DispatchQueue.main.async &#123; [weak self] in</span><br><span class="line">        self?.answerLabel.text = &quot;\(Int(topResult.confidence * 100))% it&apos;s \(article) \(topResult.identifier)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>VNClassificationObservation 有两个属性：identifier - 一个 String，以及 confidence - 介于0和1之间的数字，这个数字是是分类正确的概率。使用对象检测模型时，你可能只会看到那些 confidence 大于某个阈值的对象，例如 30％ 的阈值。<br>然后取第一个结果，它会具有最高的 confidence 值，然后根据 identifier 的首字母把不定冠词设置为“a”或“an”。最后，dispatch 回到主线程来更新 label。你很快会明白分类工作为什么不在主线程，因为它会很慢。</p><h3 id="创建并运行VNImageRequestHandler请求处理程序"><a href="#创建并运行VNImageRequestHandler请求处理程序" class="headerlink" title="创建并运行VNImageRequestHandler请求处理程序"></a>创建并运行VNImageRequestHandler请求处理程序</h3><p><code>VNImageRequestHandler</code> 是标准的 Vision 框架请求处理程序；不特定于 Core ML 模型。给它 image 作为 detectScene(image:) 的参数。然后调用它的 perform 方法来运行处理程序，传入请求数组。在这个例子里，我们只有一个请求。<br>把下面几行添加到 <code>detectScene(image:)</code> 的末尾：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程上运行 Core ML GoogLeNetPlaces 分类器</span></span><br><span class="line"><span class="keyword">let</span> handler = <span class="type">VNImageRequestHandler</span>(ciImage: image)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInteractive).async &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> handler.perform([request])</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用模型来自动识别场景"><a href="#使用模型来自动识别场景" class="headerlink" title="使用模型来自动识别场景"></a>使用模型来自动识别场景</h3><p>在两个地方调用 <code>detectScene(image:)</code><br>把下面几行添加到 viewDidLoad() 的末端和 imagePickerController(_:didFinishPickingMediaWithInfo:) 的末端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">guard let ciImage = CIImage(image: image) else &#123;</span><br><span class="line">    fatalError(&quot;couldn&apos;t convert UIImage to CIImage&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">detectScene(image: ciImage)</span><br></pre></td></tr></table></figure></p><p>现在构建并运行。</p><ol><li>场景一:<br>机器识别出了50%的概率是摩天大厦<br><img src="http://upload-images.jianshu.io/upload_images/861914-bb5bec38118f91ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>场景二<br>机器人识别出了75%的概率是水族池<br><img src="http://upload-images.jianshu.io/upload_images/861914-e194482f995324a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ol><h3 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h3><p>自20世纪50年代以来，AI 研究人员开发了许多机器学习方法。苹果的 Core ML 框架支持神经网络、树组合、支持向量机、广义线性模型、特征工程和流水线模型。但是，神经网络最近已经取得了很多极为神奇的成功，开始于 2012 年谷歌使用 YouTube 视频训练 AI 来识别猫和人。仅仅五年后，谷歌正在赞助一场确定 5000 种植物和动物的比赛。像 Siri 和 Alexa 这样的 App 也存在它们自己的神经网络。<br>神经网络尝试用节点层来模拟人脑流程，并将节点层用不同的方式连接在一起。每增加一层都需要增加大量计算能力：Inception v3，一个对象识别模型，有48层以及大约2000万个参数。但计算基本上都是矩阵乘法，GPU 来处理会非常有效。GPU 成本的下降使我们能够创建多层深度神经网络，此为深度学习。<br>神经网络，circa 2016<br>神经网络需要大量的训练数据，这些训练数据理想化地代表了全部可能性。用户生成的数据爆炸性地产生也促成了机器学习的复兴。<br>训练模型意味着给神经网络提供训练数据，并让它计算公式，此公式组合输入参数以产生输出。训练是离线的，通常在具有多个 GPU 的机器上。<br>要使用这个模型，就给它新的输入，它就会计算输出：这叫做推论。推论仍然需要大量计算，以从新的输入计算输出。因为有了 Metal 这样的框架，现在可以在手持设备上进行这些计算。<br>在本教程的结尾你会发现，深度学习远非完美。真的很难建立具有代表性的训练数据，很容易就会过度训练模型，以至于它会过度重视一些古怪的特征。<br>苹果提供了什么？<br>苹果在 iOS 5 里引入了 NSLinguisticTagger 来分析自然语言。iOS 8 出了 Metal，提供了对设备 GPU 的底层访问。<br>去年，苹果在 Accelerate 框架添加了 Basic Neural Network Subroutines (BNNS)，使开发者可以构建用于推理（不是训练）的神经网络。<br>今年，苹果给了我们 Core ML 和 Vision！<br>Core ML 让我们更容易在 App 中使用训练过的模型。<br>Vision 让我们轻松访问苹果的模型，用于面部检测、面部特征点、文字、矩形、条形码和物体。<br>你还可以在 Vision 模型中包装任意的图像分析 Core ML 模型，我们在这篇教程中就干这个。由于这两个框架是基于 Metal 构建的，它们能在设备上高效运行，所以不需要把用户的数据发送到服务器。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS11ARKit初探</title>
      <link href="/2017/06/25/iOS/iOS11ARKit%E5%88%9D%E6%8E%A2/"/>
      <url>/2017/06/25/iOS/iOS11ARKit%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="iOS11新技术"><a href="#iOS11新技术" class="headerlink" title="iOS11新技术"></a>iOS11新技术</h2><h3 id="ARKit教程"><a href="#ARKit教程" class="headerlink" title="ARKit教程"></a>ARKit教程</h3><p>增强现实(AR)描述用户体验，将2D或3D元素从设备的摄像头中添加到实时视图中，从而使这些元素出现在真实世界中。ARKit结合了设备运动跟踪，摄像镜头捕捉，先进的场景处理，以及显示方便来简化建立AR体验的任务。<br><a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener">ARKit开发文档</a></p><h4 id="理解-Augmented-Reality"><a href="#理解-Augmented-Reality" class="headerlink" title="理解 Augmented Reality"></a>理解 Augmented Reality</h4><p>理解AR概念、特性和最佳实践来构建很好的AR体验，<br><code>ARSession</code>：一个共享对象，可以管理增强现实体验所需的设备摄像头和运动处理。</p><h4 id="AR相关配置"><a href="#AR相关配置" class="headerlink" title="AR相关配置"></a>AR相关配置</h4><p><code>ARSessionConfiguration</code>:只记录设备方向的轨迹的基本配置<br><code>ARWorldTrackingSessionConfiguration</code>:一种跟踪设备定位和位置的配置，它可以检测设备摄像头看到的真实表面。</p><h4 id="AR标准视图"><a href="#AR标准视图" class="headerlink" title="AR标准视图"></a>AR标准视图</h4><p><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience" target="_blank" rel="noopener">一个基本的AR体验DEMO</a><br>配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容</p><ol><li><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit" target="_blank" rel="noopener">Providing 3D Virtual Content with SceneKit</a><br> <code>ARSCNView</code>:一种显示AR体验的视图，它通过3D SceneKit内容增强了相机视图。</li><li><a href="https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit" target="_blank" rel="noopener">Providing 2D Virtual Content with SpriteKit</a><br> <code>ARSKView</code>:一种显示AR体验的视图，增加了2D SpriteKit内容的摄像头视图。</li></ol><p>借助 ARKit 和 Core ML，基于 iOS 11 进行开发。<br>iOS 11 为开发者带来了各种可能性。借助 ARKit，开发者可将生动逼真的增强现实带到 app 之中。而有了 Core ML，开发者可利用机器学习来创建各种更智能的 app。<br><a href="https://developer.apple.com/cn/ios/" target="_blank" rel="noopener">进一步了解基于 iOS 11 的开发</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>plantuml语法概览</title>
      <link href="/2017/06/25/%E5%AF%BC%E5%9B%BE/plantuml%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
      <url>/2017/06/25/%E5%AF%BC%E5%9B%BE/plantuml%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div class="pdf" target="http://p27uwfdhv.bkt.clouddn.com/static/pdf/PlantUML_Language_Reference_Guide_ZH.pdf" height></div>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列图sequence语法插件</title>
      <link href="/2017/06/25/%E5%AF%BC%E5%9B%BE/%E5%BA%8F%E5%88%97%E5%9B%BEsequencediagram%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/06/25/%E5%AF%BC%E5%9B%BE/%E5%BA%8F%E5%88%97%E5%9B%BEsequencediagram%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="MarkDown插件"><a href="#MarkDown插件" class="headerlink" title="MarkDown插件"></a>MarkDown插件</h2><div id="badge-container-bubkoo-hexo-filter-sequence-4ab9c15" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-bubkoo-hexo-filter-sequence-4ab9c15", "bubkoo", "hexo-filter-sequence", "4ab9c15", false);</script><p>这个插件在markdown暂时无法渲染出图像，不建议使用。</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p><a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图预览工具</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>序列图(sequence diagram)，又称时序图。</p><ol><li>通过描述对象之间发送消息的时间顺序</li><li>显示多个对象之间的动态协作<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2>=====</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="角色Actor"><a href="#角色Actor" class="headerlink" title="角色Actor"></a>角色Actor</h3><p>系统角色。<br><a href="http://blog.csdn.net/ethmery/article/details/50670284" target="_blank" rel="noopener">http://blog.csdn.net/ethmery/article/details/50670284</a></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>MarkDown语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Title:[标题]</span><br></pre></td></tr></table></figure></p><h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3><p>位于序列图顶部，代表参与交互行为的对象。常见的命名方式：</p><ol><li>类名+对象名</li><li>类名，无对象名（匿名对象）</li><li>对象名，无类名<br>对象(object)是对客观事物的抽象，类(class)是对对象的抽象。</li><li>一个对象可以通过发送消息来创建另一个对象</li><li>一个对象可以被删除/自我删除，此时以”×”表示<br>MarkDown语法：</li><li>声明一个或多个对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">participant [对象名1]</span><br><span class="line">participant [对象名2]</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">Note left of A: 这是对A的注释</span><br><span class="line">Note right of B: 这是对B的注释</span><br><span class="line">Note over A: 这是A上的注释</span><br><span class="line">Note over A,B: 这是A和B共有的注释</span><br></pre></td></tr></table></figure><ol start="2"><li>为对象添加注释<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note left/right to [对象名]: [注释]</span><br><span class="line">Note over [对象名]: [注释]</span><br><span class="line">Note over [多个对象，之间以,隔开]: [注释]</span><br></pre></td></tr></table></figure></li></ol><h3 id="生命线Lifeline"><a href="#生命线Lifeline" class="headerlink" title="生命线Lifeline"></a>生命线Lifeline</h3><ol><li>序列图中的对象在一段时间内的存在</li><li>以从对象底部中心延伸出的竖直虚线表示</li><li>对象之间的消息传递发生于生命线之间</li></ol><h3 id="激活期Activation"><a href="#激活期Activation" class="headerlink" title="激活期Activation"></a>激活期Activation</h3><ol><li>序列图中的对象执行一项操作的时期<ul><li>或执行其自身的代码</li><li>或等待另一个对象的返回信息</li></ul></li><li>以生命线上相应时间段内窄矩形表示</li></ol><h3 id="消息Message"><a href="#消息Message" class="headerlink" title="消息Message"></a>消息Message</h3><ol><li>用于对对象间通信内容进行建模的类</li><li>以垂直于生命线的单方向箭头表示</li><li>消息包含内容：<ul><li>消息名称</li><li>消息参数</li><li>可能带有条件表达式，以确定是否发送/发送分支<br>MarkDown语法：</li></ul></li><li>语法格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[发送对象][箭头符号][接收对象]: [消息]</span><br></pre></td></tr></table></figure></li></ol><h3 id="效果实现："><a href="#效果实现：" class="headerlink" title="效果实现："></a>效果实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B: -&gt;</span><br><span class="line">B--&gt;C: --&gt;</span><br><span class="line">B-&gt;&gt;A: -&gt;&gt;</span><br><span class="line">C--&gt;&gt;A: --&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义箭头语法：<br> -&gt; 实线黑色三角箭头<br> –-&gt; 虚线黑色三角箭头<br> -&gt;&gt; 实线开放箭头<br> –-&gt;&gt; 虚线开放箭头</li><li>消息显示顺序与代码中消息编写顺序一致</li></ol>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flowchart流程图语法</title>
      <link href="/2017/06/24/%E5%AF%BC%E5%9B%BE/flowchart%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/06/24/%E5%AF%BC%E5%9B%BE/flowchart%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p><a href="http://blog.csdn.net/KimBing/article/details/52934959?locationNum=2&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/KimBing/article/details/52934959?locationNum=2&amp;fps=1</a></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ol><li><p>六种对象：开始对象，结束对象，操作对象，条件对象，输入对象，子任务对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象变量=&gt;[start|end|operation|condition|inputoutput|subroutine]:[描述信息]</span><br></pre></td></tr></table></figure></li><li><p>流程控制语法<br>流程控制三要素：位置、方向，条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">条件对象(YES/NO/消息)-&gt; 其他对象</span><br><span class="line">操作对象(left/right/top)-&gt; 其他对象</span><br></pre></td></tr></table></figure></li></ol><p>样例<br>```<br>//结构模块<br>st=&gt;start: 开始<br>e=&gt;end: 结束<br>op=&gt;operation: 我的操作<br>cond=&gt;condition: 确认？</p><p>//流程控制模块<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br>```<br>效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//结构模块</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">//流程模块</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo功能插件</title>
      <link href="/2017/06/24/hexo/Hexo%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/06/24/hexo/Hexo%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>//保证格式正确：”插件名”: “^版本号”,</p><ol><li>方式一通过package.json 新增插件库<br>//保证格式正确：”插件名”: “^版本号”,</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;hexo-filter-plantuml&quot;: &quot;^1.0.1&quot;,</span><br><span class="line">&quot;hexo-filter-sequence&quot;: &quot;^1.0.3&quot;,</span><br><span class="line">&quot;hexo-tag-plantuml&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;hexo-pdf&quot;: &quot;^1.1.1&quot;</span><br></pre></td></tr></table></figure><blockquote><p>如何插件版本号：可以在插件的github库文件<code>package.json</code>中得到。</p></blockquote><p>执行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install</span><br></pre></td></tr></table></figure></p><ol start="2"><li>方式二: 安装单个插件<br>即下文的作图插件说明中使用的安装方式</li></ol><h2 id="举例：作图插件"><a href="#举例：作图插件" class="headerlink" title="举例：作图插件"></a>举例：作图插件</h2><ol><li>flowchart流程图</li><li>sequence队列图</li><li>plantuml类图<h3 id="plantuml"><a href="#plantuml" class="headerlink" title="plantuml"></a><a href="http://plantuml.com/use-case-diagram" target="_blank" rel="noopener">plantuml</a></h3><a href="https://github.com/wafer-li/hexo-filter-plantuml" target="_blank" rel="noopener">hexo-filter-plantuml</a><br>安装：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-plantuml</span><br></pre></td></tr></table></figure></li></ol><p>hexo使用语法：<br>```puml<br>    @startuml<br>    class A<br>    @enduml<br>```</p><p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKhEIImkLd3aSaZDIm7o0G00"><br>效果图：</p><h3 id="hexo-filter-sequence"><a href="#hexo-filter-sequence" class="headerlink" title="hexo-filter-sequence"></a>hexo-filter-sequence</h3><p><a href="https://github.com/bubkoo/hexo-filter-sequence" target="_blank" rel="noopener">sequence</a></p><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-sequence</span><br></pre></td></tr></table></figure></p><p>配置<br>_config.yml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequence:</span><br><span class="line"># webfont:     # optional, the source url of webfontloader.js</span><br><span class="line"># snap:        # optional, the source url of snap.svg.js</span><br><span class="line"># underscore:  # optional, the source url of underscore.js</span><br><span class="line"># sequence:    # optional, the source url of sequence-diagram.js</span><br><span class="line"># css: # optional, the url for css, such as hand drawn theme</span><br><span class="line">options:</span><br><span class="line">theme:</span><br><span class="line">css_class:</span><br></pre></td></tr></table></figure></p><p>hexo使用语法：<br>```sequence<br>    Alice-&gt;Bob: Hello Bob, how are you?<br>    Note right of Bob: Bob thinks<br>    Bob–&gt;Alice: I am good thanks!<br>```</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><p>效果图：</p><p><a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">hexo-filter-flowchart</a><br>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure></p><p>hexo使用语法：<br>```flow<br>st=&gt;start: Start|past:&gt;<a href="http://www.google.com[blank]" target="_blank" rel="noopener">http://www.google.com[blank]</a><br>e=&gt;end: End:&gt;<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br>op1=&gt;operation: My Operation|past<br>op2=&gt;operation: Stuff|current<br>sub1=&gt;subroutine: My Subroutine|invalid<br>cond=&gt;condition: Yes<br>or No?|approved:&gt;<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br>c2=&gt;condition: Good idea|rejected<br>io=&gt;inputoutput: catch something…|request</p><p>st-&gt;op1(right)-&gt;cond<br>cond(yes, right)-&gt;c2<br>cond(no)-&gt;sub1(left)-&gt;op1<br>c2(yes)-&gt;io-&gt;e<br>c2(no)-&gt;op2-&gt;e<br>```</p><p>效果图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end: End:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation|past</span><br><span class="line">op2=&gt;operation: Stuff|current</span><br><span class="line">sub1=&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;http://www.google.com</span><br><span class="line">c2=&gt;condition: Good idea|rejected</span><br><span class="line">io=&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure></p><h3 id="插件hexo-pdf"><a href="#插件hexo-pdf" class="headerlink" title="插件hexo-pdf"></a>插件hexo-pdf</h3><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></p><p>hexo使用语法：</p><ol><li><p>普通 PDF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure></li><li><p>相对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf ./bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持Google盘/Slideshare</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https://drive.google.com/file/d/0B6qSwdwPxPRdTEliX0dhQ2JfUEU/preview %&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Slideshare<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http://www.slideshare.net/slideshow/embed_code/key/8Jl0hUt2OKUOOE %&#125;</span><br></pre></td></tr></table></figure></p><p>预览：<br><img src="https://github.com/superalsrk/hexo-pdf/raw/master/screenshot/hexo-pdf-preview.png" alt></p><p>“hexo-tag-plantuml”</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell命令处理字符串</title>
      <link href="/2017/06/23/shell/shell%E5%91%BD%E4%BB%A4%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2017/06/23/shell/shell%E5%91%BD%E4%BB%A4%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><ol><li><code>%+字符+正则表达式</code> 删除字符及右边内容，从源字符串右边开始匹配<br><code>%</code>  单井号表示一旦匹配成功立即删除<br><code>%%</code> 双井号表示一直等相匹配到最后一个字符时再删除</li><li><code>#+正则表达式+字符</code> 删除字符及左边内容，从源字符串左边开始匹配<br><code>#</code>  单井号表示一旦匹配成功立即删除<br><code>##</code> 双井号表示一直等相匹配到最后一个字符时再删除</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>从line指定的路径中截取两个信息，类别和文件名称<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line=<span class="string">"shell/shell命令处理字符串.md"</span></span><br></pre></td></tr></table></figure></p><ol><li><p>截取文件类别：shell<br>删除最右边的“/shell命令处理字符串.md”</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories=<span class="string">"<span class="variable">$&#123;line%%/*&#125;</span>"</span>  <span class="comment"># %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符</span></span><br></pre></td></tr></table></figure></li><li><p>截取文件名称：shell命令处理字符串<br>先删除最左边的“shell/”,再删除最右边的“.md”</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titlemd=<span class="string">"<span class="variable">$&#123;line##*/&#125;</span>"</span>   <span class="comment"># ##*/: 删除"/"左边所有字段即"shell/"</span></span><br><span class="line">title=<span class="string">"<span class="variable">$&#123;titlemd%%\.*&#125;</span>"</span> <span class="comment"># 删除.md文件后缀</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人项目概览及环境搭建</title>
      <link href="/2017/06/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/06/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="环境搭建说明"><a href="#环境搭建说明" class="headerlink" title="环境搭建说明"></a>环境搭建说明</h3><ol><li><p>迁出项目<br>mupdf已合并到<code>PBBReader_Mac</code>项目中，迁出库即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.81.13/svn/PBBReader_Mac</span><br></pre></td></tr></table></figure></li><li><p>运行PBB Reader项目</p></li></ol><h3 id="发布pkg包"><a href="#发布pkg包" class="headerlink" title="发布pkg包"></a>发布pkg包</h3><p>运行target :<code>MakeInstaller</code>，它依赖<code>PBB Reader</code>项目,当运行时，如下过程：</p><ol><li>编译生成运行<code>PBB Reader.app</code>包</li><li>通过<code>Packages</code>打包工具生成pkg安装包，生成pkg目录在<code>Distribution/ImportSVN/${timeDir}/</code>。<br>例如：<code>Distribution/ImportSVN/20170118/PbbReader for OS 1.0.4.0037α.pkg</code></li><li>上传至SVN服务器<br>  方式一：可以在第二步中拿到pkg文件，手动上传。<br>  方式二：通过脚本来上传。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先判断svn目录是否存在,直接checkout目录导ImportSVN中</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$ImportSVN</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"导入SVN成功：<span class="variable">$SVNURL</span>/<span class="variable">$&#123;timeDir&#125;</span>/<span class="variable">$&#123;ProductName&#125;</span>.pkg"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><p>通过SVN脚本上传时，可以直接在<code>Distribution/releaseNote.md</code>文件中输入提交信息。</p><h3 id="脚本清单"><a href="#脚本清单" class="headerlink" title="脚本清单"></a>脚本清单</h3><p>发布脚本目录：<code>Distribution/Packages/Script</code></p><ol><li><code>PreInstall.sh</code>:发布脚本,Xcode运行<code>MakeInstaller</code>执行的脚本。</li><li><code>updateVersion.sh</code>:更新版本号脚本，读取<code>PBBReader-Info.plist</code>文件两个字段信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFBundleShortVersionString:版本号</span><br><span class="line">CFBundleVersion:build版本号</span><br></pre></td></tr></table></figure></li></ol><p>将两个版本号组合成发布内测版本号后，更新<code>Welcome.html</code>文件中的版本信息块中。具体呈现在双击pkg安装包安装过程中，显示的app版本信息的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mupdf使用说明</title>
      <link href="/2017/06/20/%E7%BC%96%E8%AF%91/mupdf%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/06/20/%E7%BC%96%E8%AF%91/mupdf%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>目前手机端使用mupdf，通过在底层添加加密方法实现定制pbb阅读器功能。<br>资源获取如下：<br><blockquote><p>Download packages of the latest release for your system:<br>Source code for all platforms.<br>Windows viewer and tools.<br>Android viewer on Google Play.<br>Android viewer APK installer files.<br>iPad and iPhone version on the App Store.<br>The latest development source is available directly from the git repository:<br>git clone –recursive git://git.ghostscript.com/mupdf.git</p></blockquote></p><p>总结：没有适配osx版本，放弃。</p><h3 id="使用apple-官方提供的demo，来分析pdf结构，显示pdf内容。"><a href="#使用apple-官方提供的demo，来分析pdf结构，显示pdf内容。" class="headerlink" title="使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。"></a>使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。</h3><p>猜想：这样以来，使用苹果提供相关API，将无法定制底层操作，即无法实现密文浏览功能，故先从明文阅读器开发开始。</p><h3 id="mupdf源码库集成加密"><a href="#mupdf源码库集成加密" class="headerlink" title="mupdf源码库集成加密"></a>mupdf源码库集成加密</h3><p>最新整合集成加密到源码库，并发布到git服务器上，便于协作维护:<a href="https://server.local/git/mupdf.git" target="_blank" rel="noopener">https://server.local/git/mupdf.git</a><br>协作过程：<br>在服务器端添加账号：test  test123<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/server.local/git</span><span class="regexp">/mupdf.git mupdf</span></span><br><span class="line"><span class="regexp">$ cd mupdf/thirdparty</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">$ git submodule init</span></span><br><span class="line"><span class="regexp">$ git submodule update</span></span><br><span class="line"><span class="regexp">$ open mupdf/platform</span><span class="regexp">/ios/</span>MuPDF.xcodeproj</span><br><span class="line">$ build &amp; run</span><br></pre></td></tr></table></figure></p><p>封装MuPDFFramework便于集成至PBBReader中：<br>初始化mupdf页面接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MuPDFViewController *bindingPhone = [[MuPDFViewController alloc] initWithNibName:<span class="literal">nil</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">bindingPhone.filename=filename;</span><br><span class="line">bindingPhone.openfilepath=select_files;</span><br><span class="line">[<span class="keyword">self</span>.view.window.contentViewController presentViewControllerAsSheet:bindingPhone];</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> PDF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>米粉卡的区别参考办理</title>
      <link href="/2017/06/18/%E5%85%B6%E4%BB%96/%E7%B1%B3%E7%B2%89%E5%8D%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%82%E8%80%83%E5%8A%9E%E7%90%86/"/>
      <url>/2017/06/18/%E5%85%B6%E4%BB%96/%E7%B1%B3%E7%B2%89%E5%8D%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%82%E8%80%83%E5%8A%9E%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="米粉卡：联通-电信"><a href="#米粉卡：联通-电信" class="headerlink" title="米粉卡：联通/电信"></a>米粉卡：联通/电信</h3><p>办卡需要实名制，可以根据情况办理：<br>米粉卡分为三种：</p><ol start="2"><li><p>日租无限流量卡，1元/天 3G流量套餐 ，3元/天无限流量卡<br> 如果平时在外不常使用流量，偶尔需求量大的话，天租比较合适。</p></li><li><p>10元/G 流量卡，两种套装：29元/月 2G流量。59元/月 4G流量<br> 如果对移动办公比较感冒，对流量需求量大，可以考虑10元/G，每月20元</p></li><li><p>0月租卡，任我行<br> 降预存，最节省套餐，不过也以为这没有流量福利</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Numbers做导图</title>
      <link href="/2017/06/17/%E5%AF%BC%E5%9B%BE/%E4%BD%BF%E7%94%A8Numbers%E5%81%9A%E5%AF%BC%E5%9B%BE/"/>
      <url>/2017/06/17/%E5%AF%BC%E5%9B%BE/%E4%BD%BF%E7%94%A8Numbers%E5%81%9A%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Pages文档、Numbers电子表格 和 Keynote演示文稿无不集思广益， 是创建精彩作品的理想工具。利用实时协作功能，你的团队成员可通过 Mac、iPad 或 iPhone 协作，共同编辑文档、电子表格或演示文稿，而 PC 用户也可通过 iCloud 版 iWork 一起参与。另外，你可以通过 Touch ID 瞬间解锁带有密码保护的文档。</p><h2 id="与其他人协作"><a href="#与其他人协作" class="headerlink" title="与其他人协作"></a>与其他人协作</h2><p>有了 iCloud 版 Pages、Numbers 和 Keynote，你和团队可通过 Mac 或 PC 上的网页浏览器，访问并编辑你的各种文件。只需登录 iCloud.com，打开网页上的 app，就可以开始工作。无论你的团队成员是近在咫尺，还是远在天边，合作起来都是如此高效。<br><a href="https://www.icloud.com/" target="_blank" rel="noopener">登录iCloud版APP</a></p><h2 id="图表使用法"><a href="#图表使用法" class="headerlink" title="图表使用法"></a>图表使用法</h2><h3 id="功能一：实用模版任君选择"><a href="#功能一：实用模版任君选择" class="headerlink" title="功能一：实用模版任君选择"></a>功能一：实用模版任君选择</h3><p>Numbers丰富的模板样式供用户选择，包括核对清单、贷款比较、预算、支出报告、员工日程表等，这些模版可广泛应用于企业员工日常的工作中，而且颜色、字体和图表质感均非常搭调，不仅实用还很美观。</p><ol><li><p>基础<br>空白，核对清单，核对清单总计，制图基础知识</p></li><li><p>个人财务<br>简单预算，个人预算，个人储蓄，净值，退休储蓄，贷款比较，抵押贷款计算器</p></li><li><p>个人<br>日历，日程表，跑步记录，家居装饰，球队组织，宝宝计划，旅游计划，聚会计划，膳食计划，食谱</p></li><li><p>商业<br>员工日程表，发票，投资回报，盈亏平衡分析</p></li><li><p>教育<br>出勤，成绩簿，概率实验，相关性项目，教育储蓄</p></li></ol><h3 id="功能二：演示效果佳-表格-形状-图片-视频便捷插入"><a href="#功能二：演示效果佳-表格-形状-图片-视频便捷插入" class="headerlink" title="功能二：演示效果佳 表格/形状/图片/视频便捷插入"></a>功能二：演示效果佳 表格/形状/图片/视频便捷插入</h3><p>（iPad中不存在画笔）</p><h3 id="功能三：空白模版很方便-格式随意修改"><a href="#功能三：空白模版很方便-格式随意修改" class="headerlink" title="功能三：空白模版很方便 格式随意修改"></a>功能三：空白模版很方便 格式随意修改</h3><h3 id="功能四：熟练使用250多个函数成为神算手"><a href="#功能四：熟练使用250多个函数成为神算手" class="headerlink" title="功能四：熟练使用250多个函数成为神算手"></a>功能四：熟练使用250多个函数成为神算手</h3><ol><li>菜单—插入—公式（Formula）— 基本公式算法</li></ol><h3 id="功能五：三维、交互式图表效果更出色"><a href="#功能五：三维、交互式图表效果更出色" class="headerlink" title="功能五：三维、交互式图表效果更出色"></a>功能五：三维、交互式图表效果更出色</h3><h3 id="功能六：可指定数据类型的单元格的技巧"><a href="#功能六：可指定数据类型的单元格的技巧" class="headerlink" title="功能六：可指定数据类型的单元格的技巧"></a>功能六：可指定数据类型的单元格的技巧</h3><h3 id="功能七：数据随时存-iCloud用处大"><a href="#功能七：数据随时存-iCloud用处大" class="headerlink" title="功能七：数据随时存 iCloud用处大"></a>功能七：数据随时存 iCloud用处大</h3>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode9新特性</title>
      <link href="/2017/06/16/xcode/Xcode9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2017/06/16/xcode/Xcode9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="无线调试"><a href="#无线调试" class="headerlink" title="无线调试"></a>无线调试</h2><h3 id="升级设备系统"><a href="#升级设备系统" class="headerlink" title="升级设备系统"></a>升级设备系统</h3><p>体验iOS11系统需要几步操作：</p><ol><li><a href="https://profile.apple.xsico.cn" target="_blank" rel="noopener">下载配置文件：iOS_11_beta_Configuration_Profile</a>，在手机端使用safari浏览器打开链接，自动安装到描述文件中。</li><li>设置中的“软件更新”会自动检测到iOS11 Developer beta版本，表明可以下载更新了。</li></ol><h3 id="配置设备信息"><a href="#配置设备信息" class="headerlink" title="配置设备信息"></a>配置设备信息</h3><ol><li>链接你的设备<br>选择Window -&gt; Device and Simulators，完成之后左侧Connected区域你的设备右侧会显示小地图的图标，表示你已经连接上，此时断开数据线，就可以开始无线调试了。如下图所示：</li><li>如果iphone和mac不在同一局域网，你可以按照下图进行设置：<br><img src="https://static.oschina.net/uploads/space/2017/0610/112915_7tCQ_2279344.png" alt></li></ol><h2 id="xcode-的新特性"><a href="#xcode-的新特性" class="headerlink" title="xcode 的新特性"></a>xcode 的新特性</h2><ol><li>集成github<ol><li>在偏好设置中，新增github账号<ol start="2"><li>在导航栏中，新增git版本库导航器<br>快速查看本地版本的Branches／Tags和commit时间轴，以及Remotes远程版本库信息。支持版本库基本操作：新建／合并／切换分支，打tag标签。还支持新建远程仓库，删除远程分支。<br>通过双击commit的时间轴的一个条目来查看某次提交中文件的更改详情</li><li>xcode欢迎页面，clone已有库的界面，可以直接查看readme.md</li></ol></li></ol></li></ol><h3 id="markdown的支持"><a href="#markdown的支持" class="headerlink" title="markdown的支持"></a>markdown的支持</h3><p>在Markdown文件中，您键入时，标题，粗体和斜体文本，链接和其他格式将立即在编辑器中呈现。Jump Bar甚至可以了解Markdown结构，因此您可以快速浏览README.md和文档文件。</p><h3 id="色彩管理"><a href="#色彩管理" class="headerlink" title="色彩管理"></a>色彩管理</h3><p>在Xcode中的xcassets中添加自定义的颜色，指定颜色名字:<code>MyColor</code>，这样就可以在代码和IB中方便的引用了。</p><ol><li>右键选择添加New Color Set</li><li>点击Any，在右侧区域中轻松设置你的颜色</li><li><p>使用<br> 代码中引用：UIColor(named:) 新方法引用你的颜色</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.backgroundColor = <span class="type">UIColor</span>(named:<span class="string">"MyColor"</span>)</span><br></pre></td></tr></table></figure><p> IB中引用你的颜色<br> <img src="https://static.oschina.net/uploads/space/2017/0610/113750_bVTy_2279344.png" alt></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode8中SB适配横竖屏按钮VaryforTraits</title>
      <link href="/2017/06/14/xcode/Xcode8%E4%B8%ADSB%E9%80%82%E9%85%8D%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%8C%89%E9%92%AEVaryforTraits/"/>
      <url>/2017/06/14/xcode/Xcode8%E4%B8%ADSB%E9%80%82%E9%85%8D%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%8C%89%E9%92%AEVaryforTraits/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代:<br>Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。</p><h3 id="添加竖屏约束"><a href="#添加竖屏约束" class="headerlink" title="添加竖屏约束"></a>添加竖屏约束</h3><p>xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器：</p><p>以前版本：</p><h4 id="Vary-for-Traits"><a href="#Vary-for-Traits" class="headerlink" title="Vary for Traits"></a>Vary for Traits</h4><p>对不同设备和方向上添加约束</p><ol><li>点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型<br>假如：选width，会发现约束会同时应用到iPhone的横竖屏：<br>选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了<br>接下来为竖屏状态的界面添加约束，</li><li>点击Done Varying按钮完成对约束的添加   </li></ol><h3 id="iPad适配时无法区分横竖屏"><a href="#iPad适配时无法区分横竖屏" class="headerlink" title="iPad适配时无法区分横竖屏"></a>iPad适配时无法区分横竖屏</h3><p>对比iPhone横竖屏：<br>竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。<br>但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。<br>所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> SB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞定1无压工作的艺术</title>
      <link href="/2017/06/13/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A1%E6%97%A0%E5%8E%8B%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2017/06/13/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A1%E6%97%A0%E5%8E%8B%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="第一部分-通向从容之道"><a href="#第一部分-通向从容之道" class="headerlink" title="第一部分 通向从容之道"></a>第一部分 通向从容之道</h2><h3 id="第1章-新情况，新做法"><a href="#第1章-新情况，新做法" class="headerlink" title="第1章 新情况，新做法"></a>第1章 新情况，新做法</h3><ol><li>如何回归“心如止水”的境界<br>在知识工作的环境下（信息大爆炸，事物繁杂的特点），传统时间管理法逐渐无法达到心如止水的境界，</li></ol><h3 id="第2章-掌控生活：横向管理工作流程的5个步骤"><a href="#第2章-掌控生活：横向管理工作流程的5个步骤" class="headerlink" title="第2章 掌控生活：横向管理工作流程的5个步骤"></a>第2章 掌控生活：横向管理工作流程的5个步骤</h3><p>横向管理的5个步骤</p><ol><li>收集：把一切会引起大脑注意的事务，不分轻重缓急（潜在的重要信息／任务／想法／行动／安排）一律从大脑中清空，作为原始材料放置工作篮中。</li><li>理清：它是什么？检查工作篮的材料，理清它们的意义，扔掉垃圾事件</li><li>整理：理清流程图和整理流程图一样，2分钟原则</li><li>回顾：思考回顾体现了GTD的最核心</li><li>执行：<br> 策划行动的三个方法：</li><li>四标准法：情境，时间，精力，重要性</li><li>每日工作三分类法：事先计划的事，突发事件，安排自己的事</li><li>检视工作的六层次法：<br> 当前行动，当前项目，关注及责任范围，目标，愿景，目的和原则<br>流程图如下：<br>衍生的清单：<br>项目清单<br>下一步行动<br>将要／也许清单<br>孵化清单</li></ol><h3 id="第3章-控制项目：纵向管理项目计划的5个阶段"><a href="#第3章-控制项目：纵向管理项目计划的5个阶段" class="headerlink" title="第3章 控制项目：纵向管理项目计划的5个阶段"></a>第3章 控制项目：纵向管理项目计划的5个阶段</h3><h2 id="第二部分-远离压力，提高效率"><a href="#第二部分-远离压力，提高效率" class="headerlink" title="第二部分 远离压力，提高效率"></a>第二部分 远离压力，提高效率</h2><h3 id="第4章-准备工作：确定时间、空间和工具"><a href="#第4章-准备工作：确定时间、空间和工具" class="headerlink" title="第4章 准备工作：确定时间、空间和工具"></a>第4章 准备工作：确定时间、空间和工具</h3><h3 id="第5章-收集阶段：归拢材料"><a href="#第5章-收集阶段：归拢材料" class="headerlink" title="第5章 收集阶段：归拢材料"></a>第5章 收集阶段：归拢材料</h3><h3 id="第6章-处理阶段：清空工作篮"><a href="#第6章-处理阶段：清空工作篮" class="headerlink" title="第6章 处理阶段：清空工作篮"></a>第6章 处理阶段：清空工作篮</h3><h3 id="第7章-组织整理：建立好清单"><a href="#第7章-组织整理：建立好清单" class="headerlink" title="第7章 组织整理：建立好清单"></a>第7章 组织整理：建立好清单</h3><h3 id="第8章-检查回顾：保障系统的有效运行"><a href="#第8章-检查回顾：保障系统的有效运行" class="headerlink" title="第8章 检查回顾：保障系统的有效运行"></a>第8章 检查回顾：保障系统的有效运行</h3><h3 id="第9章-执行阶段：选择最合适的行动"><a href="#第9章-执行阶段：选择最合适的行动" class="headerlink" title="第9章 执行阶段：选择最合适的行动"></a>第9章 执行阶段：选择最合适的行动</h3><h3 id="第10章-学会控制项目"><a href="#第10章-学会控制项目" class="headerlink" title="第10章 学会控制项目"></a>第10章 学会控制项目</h3><h2 id="第三部分-三个关键原则"><a href="#第三部分-三个关键原则" class="headerlink" title="第三部分 三个关键原则"></a>第三部分 三个关键原则</h2><h3 id="第11章-原则一：养成收集的习惯"><a href="#第11章-原则一：养成收集的习惯" class="headerlink" title="第11章 原则一：养成收集的习惯"></a>第11章 原则一：养成收集的习惯</h3><h3 id="第12章-原则二：确定“下一步行动”"><a href="#第12章-原则二：确定“下一步行动”" class="headerlink" title="第12章 原则二：确定“下一步行动”"></a>第12章 原则二：确定“下一步行动”</h3><h3 id="第13章-原则三：学会关注结果"><a href="#第13章-原则三：学会关注结果" class="headerlink" title="第13章 原则三：学会关注结果"></a>第13章 原则三：学会关注结果</h3><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><div class="pdf" target="/images/搞定1无压工作的艺术.pdf" height></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WacomSlate笔记本使用</title>
      <link href="/2017/06/04/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/WacomSlate%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/06/04/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/WacomSlate%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>梳理任务列表，整理阅读笔记和思维导图，来配合iPad完成每日工作任务</p><h3 id="使用效率"><a href="#使用效率" class="headerlink" title="使用效率"></a>使用效率</h3><p>按时出图，分解任务，规划职业</p><h3 id="带来的回报"><a href="#带来的回报" class="headerlink" title="带来的回报"></a>带来的回报</h3><p>### </p><h3 id="Starter-playgroundbook"><a href="#Starter-playgroundbook" class="headerlink" title="Starter.playgroundbook"></a>Starter.playgroundbook</h3><p>iPad学习开发swift<br>第一步：创建书本的结构（参考模版）<a href>Starter.playgroundbook</a><br>第二步：了解模版的结构<br>第三步：增删改模版，增加个人的书本内容<br>官方建议流程：<br>Make targeted changes to the book’s content and structure in Xcode.<br>Transfer the updated book into Swift Playgrounds using iCloud or AirDrop.<br>只能使用iCloud和AirDrop来同步swift书籍同步到iPad上。<br>Open the updated book and test the changes.<br>Note any additional changes that are needed, and return to step 1.</p><p>最终使用方法：<br>是在iPad上的一款应用，支持swift快速开发，只需要在appStore中下载Swift Playgrounds程序。<br>在这个这个程序中有精选栏，和我的Playgorund</p><ol><li>精选：就是内置了一些有趣的swift学习编程，从基础进阶再探索，简单易学的教学</li><li>我的Playground：有新建，分享，编辑三个按钮，和自己的程序书架。<br>有两种方式开始编程：</li><li>新建一个空白的playgroundbook</li><li>通过iCloud 云同步已有的playgroundbook，这也是和mac端共享代码的途径（airdrop暂时没有测通，Mac端开启airdrop却看不到ipad设备），也可以通过第三方来同步，比如sync<br>源码分享：</li><li>点击分享按钮，再点击要分享的playgroundbook文件，然后通过airdrop方式同 Mac共享文件。不过暂时没测通。如果使用微信，qq分享似乎发送到Mac端显示的是目录，无法通过打开方式来使用swift playground 程序<br>效果分享：</li><li>在playgroundbook编辑页面，点击”。。。”弹出下拉列表页，提供fenxiang四种方式<ul><li>拍照</li><li>创建PDF</li><li>录制影片</li><li>实时直播（需要第三方直播软件，暂时没测试）</li></ul></li></ol><h3 id="激活iPad拥有自己的工作空间"><a href="#激活iPad拥有自己的工作空间" class="headerlink" title="激活iPad拥有自己的工作空间"></a>激活iPad拥有自己的工作空间</h3><ol><li>激活iPad，安装自己喜欢的几款APP</li><li>测试电耗，连续使用8个小时，89%到30%，耗损50%，按工作场景应该能续航16小时左右</li><li>尝试键盘连接，使用外设键盘编辑文本还是比较舒服的，便捷，坐等移动键盘到手</li><li>摸索iPad使用场景 <ol><li>第一屏为咨询APP主页，在这里将发现更多新的东西，和未知的兴趣点，并同步至Pocker中，即搜集箱，充满期待</li><li>第二屏为下一步行动列表页，将第一屏搜集到的原材料，参考四象限法则，整理筛选排优先级，加工成可执行的下一步行动，过滤不能行动的事件</li><li>第三屏将行动导图梳理规范化，提高趣味性，增强行动动力，自我鼓励督促完成任务，培养自觉性和对承诺的责任心，逐步养成生活习惯　</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>麦步第一天体验</title>
      <link href="/2017/06/02/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E9%BA%A6%E6%AD%A5%E7%AC%AC%E4%B8%80%E5%A4%A9%E4%BD%93%E9%AA%8C/"/>
      <url>/2017/06/02/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E9%BA%A6%E6%AD%A5%E7%AC%AC%E4%B8%80%E5%A4%A9%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p><a href="http://dev.maibu.cc/sdk/watch" target="_blank" rel="noopener">开发文档</a><br><a href="https://github.com/maibu/Maibu" target="_blank" rel="noopener">gitHub源码库</a>   </p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><h4 id="可用功能"><a href="#可用功能" class="headerlink" title="可用功能"></a>可用功能</h4><p>滴答清单，同步神速，可以使用麦步来标记完成任务</p><p>表盘：纯黑背景比较适合，内置白底表盘无法卸载<br>工具：计步准确，睡眠监测还行，久坐提醒不错 </p><h4 id="思考功能"><a href="#思考功能" class="headerlink" title="思考功能"></a>思考功能</h4><p>怎样充分使用麦步，融入到现有的时间管理习惯中</p><ol><li>开发一款麦步trello清单APP<br>需求：麦步app获取到当天的trello清单，支持查看和完成操作<br>预研：麦步无须APP账号绑定等，仅凭蓝牙是如何获取到滴答清单的？<br>原理：<br>结果：开发一款trello清单是否可行<br>1.2 文档分析：<br>在第二步：编译及打包环境<ol><li>gcc-arm-none-eabi-4_7-2014q2-20140408-win32.exe 编译环境</li><li>IDE工具Visual MWatch.exe执行编译操作。<br>可见暂时仅支持win系统开发。</li></ol></li></ol><ol start="2"><li>借助IFTTT工具是否能将trello清单同步至麦步中<br>2.1 中间APP 选择系统提醒APP/(日历APP支持时间设置)<br>原理： 通过IFTTT工具将trello清单同步到提醒APP中，然后滴答清单读取提醒清单同步到麦步上。<br>缺点：trello开始与截止日期等属性无法同步至提醒app，由于麦步仅同步滴答清单的当天任务列表，中间必须认为设置起始时间等。</li></ol><p>日历属于一块圣地，不要轻易设置日程安排。他应该是第三象限不急重要的事情。当指定时间地点时，优先级立即为最高</p><ol start="3"><li>trello创建人物是否能讲日期同步到系统提醒APP中，不可行的话，就需要单独对任务指定开始和截止时间。</li></ol><h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>麦步获取信息的通道：蓝牙<br>平台区别：<br>Apple手机全局提醒，安卓可以过滤app</p><p>针对性个例：滴答清单<br>麦步是如何针对性滴答清单，获取APP内部信息的。</p><p>其中的原理，涉及到，如果开发一款trello清单是否可行。</p><h3 id="耗电："><a href="#耗电：" class="headerlink" title="耗电："></a>耗电：</h3><p>使用计步表盘，及时更新数据，相较普通时钟表盘，电耗是否一致，差距在哪？</p><h3 id="trello日历订阅源"><a href="#trello日历订阅源" class="headerlink" title="trello日历订阅源"></a>trello日历订阅源</h3><p>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p><h4 id="获取从trello看板中生成订阅源"><a href="#获取从trello看板中生成订阅源" class="headerlink" title="获取从trello看板中生成订阅源"></a>获取从trello看板中生成订阅源</h4><p>普通用户的看板限制的Power-Ups的一个数<br>两步设置：</p><ol><li>第一步：启动日历<br>看板的菜单项—Power-Ups—Calendar–点击启动—出现设置图标按钮，如图：</li><li>第二步：开启日历订阅功能（默认关闭）<br>点击设置按钮，并启动订阅功能，自动生成订阅路径    </li></ol><h4 id="添加日历订阅源"><a href="#添加日历订阅源" class="headerlink" title="添加日历订阅源"></a>添加日历订阅源</h4><p>iPhone日历订阅需要通过通过Mac实现 <a href="https://support.apple.com/zh-cn/HT202361" target="_blank" rel="noopener">使用 iCloud 日历订阅</a><br>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p><p>可以通过监听事件来同步trello看板中的所有信息</p>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift开发macOS系统的终端命令行应用</title>
      <link href="/2017/05/29/macOS/swift%E5%BC%80%E5%8F%91macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2017/05/29/macOS/swift%E5%BC%80%E5%8F%91macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p><a href="https://www.raywenderlich.com:443/128039/command-line-programs-macos-tutorial" target="_blank" rel="noopener">命令行程序MacOS的教程</a></p><p>使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。<br>选用SWIFT的理由：<br>Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。</p><h3 id="main-swift主体"><a href="#main-swift主体" class="headerlink" title="main.swift主体"></a>main.swift主体</h3><p>许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。<br>Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。</p><h3 id="终端调用程序"><a href="#终端调用程序" class="headerlink" title="终端调用程序"></a>终端调用程序</h3><p>命令行可分两种模式</p><ul><li>静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。</li><li>交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。</li></ul><ol><li><p>在同一个目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Panagram</span><br></pre></td></tr></table></figure></li><li><p>相对路径执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug/Panagram</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> 终端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一本书目录</title>
      <link href="/2017/05/28/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9B%AE%E5%BD%95/"/>
      <url>/2017/05/28/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><!--长宽测试没有效果--><iframe src="http://naotu.baidu.com/file/3cd277713d4ebb210443ffaf9c8f38e6?token=9200f134c9b8f825" width="700" height="300" frameborder="0" allowfullscreen></iframe><h2 id="第一篇-阅读的层次"><a href="#第一篇-阅读的层次" class="headerlink" title="第一篇 阅读的层次"></a>第一篇 阅读的层次</h2><pre><code>第一章 阅读的活力与艺术第二章 阅读的层次 第三章 阅读的第一个层次：基础阅读第四章 阅读的第二个层次：检视阅读第五章 如何做一个自我要求的读者第二篇 阅读的第三个层次：分析阅读第六章 一本书的分类第七章 透视一本书第八章 与作者找出共通的词义第九章 判断作者的主旨第十章 公正地评断一本书第十一章 赞同或反对作者第十二章 辅助阅读</code></pre><h2 id="第三篇-阅读不同读物的方法"><a href="#第三篇-阅读不同读物的方法" class="headerlink" title="第三篇 阅读不同读物的方法"></a>第三篇 阅读不同读物的方法</h2><pre><code>第十三章 如何阅读实用型的书第十四章 如何阅读想像文学第十五章 阅读故事、戏剧与诗的一些建议第十六章 如何阅读历史书第十七章 如何阅读科学与数学第十八章 如何阅读哲学书第十九章 如何阅读社会科学</code></pre><h2 id="第四篇-阅读的最终目标"><a href="#第四篇-阅读的最终目标" class="headerlink" title="第四篇 阅读的最终目标"></a>第四篇 阅读的最终目标</h2><pre><code>第二十章 阅读的第四个层次：主题阅读第二十一章 阅读与心智的成长附录一 建议阅读书目附录二 四种层次阅读的练习与测验</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搞定书籍目录</title>
      <link href="/2017/05/28/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/"/>
      <url>/2017/05/28/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="《搞定I》"><a href="#《搞定I》" class="headerlink" title="《搞定I》"></a>《搞定I》</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="第一部分-通向从容之道？"><a href="#第一部分-通向从容之道？" class="headerlink" title="第一部分 通向从容之道？"></a>第一部分 通向从容之道？</h3><pre><code>第1章 新情况，新做法？      收集存档清空大脑，万物皆于此，    2分钟法则整理可立刻执行的有效清单，不做材料清单第2章 掌控生活：横向管理工作流程的5个阶段第3章 控制项目：纵向管理项目计划的5个阶段</code></pre><h3 id="第二部分-远离压力，提高效率"><a href="#第二部分-远离压力，提高效率" class="headerlink" title="第二部分 远离压力，提高效率"></a>第二部分 远离压力，提高效率</h3><pre><code>第4章 准备工作：确定时间、空间和工具第5章 收集阶段：归拢材料第6章 处理阶段：清空工作篮第7章 组织整理：建立好清单第8章 检查回顾：保障系统的有效运行第9章 执行阶段：选择最合适的行动第10章 学会控制项目</code></pre><h3 id="第三部分-三个关键原则"><a href="#第三部分-三个关键原则" class="headerlink" title="第三部分 三个关键原则"></a>第三部分 三个关键原则</h3><pre><code>第11章 原则一：养成收集的习惯第12章 原则二：确定“下一步行动”第13章 原则三：学会关注结果</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>痛定思痛的项目管理弊病</title>
      <link href="/2017/05/27/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%97%9B%E5%AE%9A%E6%80%9D%E7%97%9B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%BC%8A%E7%97%85/"/>
      <url>/2017/05/27/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%97%9B%E5%AE%9A%E6%80%9D%E7%97%9B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%BC%8A%E7%97%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>现状：两个项目源码存在八成为同样的代码，管理在两个SVN库中。<br>背景：从一个SVN项目分裂成两个独立项目（PBB_2/Reader_v2）对应延伸出来SVN库，随后在两个库中开发不同的功能版本（PBB_7/Reader_v9）。<br>需求：现在准备将两项目中新增的功能重新合并起来，即将PBB_v7合并到Reader_v9中。<br>分析：需要把PBB_v3–PBB_v7的5个提交，合并到Reader_v9中</p><p>对PBB迭代的十几个版本中新增的功能涉及面太广，手动合并出错率高，协作难度大，纯劳力搬砖着实要命。<br>以下总结几条建议</p><h3 id="方案一：打补丁法合并源码"><a href="#方案一：打补丁法合并源码" class="headerlink" title="方案一：打补丁法合并源码"></a>方案一：打补丁法合并源码</h3><hr><p>注：仅适用于同一个库使用</p><p>实现步骤：</p><ol><li>git-svn命令把svn库转为git库</li><li>将5个提交重演到Reader_v9版中</li></ol><p>重演方案：</p><ol><li>打补丁法：通过压缩提交法把PBB_v7若干提交整合成一个提交，再创建一个补丁，重演到Reader_v9上<ol><li>交互变基压缩法，压缩成一个提交</li><li>reset压缩提交法，将提交压缩 git reset –soft 1bf27c6a33d87c2e36fa75431224124f91d8b482</li></ol></li></ol><p>案例：在大型项目中，贡献者常以使用补丁文件贡献代码<br>结论：打补丁法的前提打补丁的宿主库必须和将要应用补丁的库为同一库源。故使用版本库来合并两个独立不想关的svn库，无法通过打补丁法实现合并。</p><h3 id="方案二：项目模块化合并"><a href="#方案二：项目模块化合并" class="headerlink" title="方案二：项目模块化合并"></a>方案二：项目模块化合并</h3><hr><p>在PBB Reader中通过项目依赖整合IJK／mupdf／maker</p><ol><li>操作<ol><li>取消Maker原有IJK，mupdf的依赖</li><li>在PBB Reader中配置Maker依赖 ：隐私空间涉及到的阅读功能在Reader中实现</li><li>新需求开发</li></ol></li><li>好处 <ol><li>源码隔离，功能共享，对现有功能的源码无要做任何修改</li><li>项目之间相互独立，便于后续拆分或整合</li><li>更多精力专注代码优化</li></ol></li></ol><h4 id="否决方案二，采用手动合并"><a href="#否决方案二，采用手动合并" class="headerlink" title="否决方案二，采用手动合并"></a>否决方案二，采用手动合并</h4><p>Reader本属于一个播放器，是从PBB应用的lite版，主要业务都是在PBB中实现的，当前需求是让PBB集成到Reader中，如何使用PBB Framework集成，需要暴漏大量的接口，业务层的高耦合性已经违背了封装原则。故作罢。</p><p>突破了合并时遇到的棘手问题，加密崩溃，最终排查出socker传输结构体导致的异常，maker和Reader之间的差异导致合并过程更加困难，最终采用对讲maker中对加密实现文件的封装，在集成到Reader中，即隔离冲突，暴露功能，程序架构集成过程中更便捷合理化。</p><hr><p>相关知识：</p><p>引用日志：<br>git reflog<br>引用日志只存在本地仓库中，只记录第一次clone到之后，在本地仓库中的操作日志，服务器端不会同步这些引用记录，所以在本地无法查看别人的引用日志。</p><h3 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h3><p>几种表达式含义</p><ul><li><p>第一种：^/^^^(多个)<br>HEAD^:指向祖先提交<br>hash值^（^^^） :指向该引用的上一个提交，几个符号就是指向上几个提交<br>^数字:只适用于合并（merge）提交，有多个父提交。如：hash值^2表示第二父提交。第一父提交是指合并时所在的分支，第二父提交是指合并进来的分支。</p></li><li><p>第二种：~数字<br>HEAD~: 指向祖先提交<br>HEAD~数字:指向指向上几个提交<br>hash值^数字:指向该引用的上几个提交</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 命令 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升职必备的技能修炼二 以道御术</title>
      <link href="/2017/05/26/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD%E4%BA%8C/"/>
      <url>/2017/05/26/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>“老付”谈论的是目标，所有的方法都是为目标服务的，目标统率人的行为。    </p><ul><li>怎样规划自己的人生？</li><li>怎样树立自己的目标？</li><li>怎样把目标转化成实际的行动？</li><li>怎样提高自己实现目标的能力？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼升职必备的技能</title>
      <link href="/2017/05/26/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD/"/>
      <url>/2017/05/26/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>焦虑是由于缺乏控制力，以及组织管理、准备和行动不足所造成的。</p><h2 id="四象限"><a href="#四象限" class="headerlink" title="四象限"></a>四象限</h2><p>走出第三象限，将工作重心放进第二象限</p><ol><li>第二象限法则   </li><li>猴子法则：屏蔽干扰的伎俩   </li></ol><h3 id="项目与行动的区别"><a href="#项目与行动的区别" class="headerlink" title="项目与行动的区别"></a>项目与行动的区别</h3><p>项目需要分解为可执行的行动  </p><ol><li>以动词开头的行动  </li><li>添加行动的预期效果  </li></ol><p>下一步行动法，驱动项目的进行。</p><h2 id="时间投资"><a href="#时间投资" class="headerlink" title="时间投资"></a>时间投资</h2><h2 id="衣柜整理法"><a href="#衣柜整理法" class="headerlink" title="衣柜整理法"></a>衣柜整理法</h2><p>收集，处理，组织，回顾，行动<br>2分钟法则<br>无论在什么情况下，我们在工作时都将经历这五个阶段：   </p><h3 id="收集篮：收集一切引起我们注意的事情。"><a href="#收集篮：收集一切引起我们注意的事情。" class="headerlink" title="收集篮：收集一切引起我们注意的事情。"></a>收集篮：收集一切引起我们注意的事情。</h3><pre><code>收集的关键是将‘一切引起我们注意的东西’放在‘收集篮’里，在清空大脑的同时达到‘心如止水’的境界。</code></pre><p>工具军规</p><ol><li>收集工具越少越好</li><li>保证5秒钟内拿出工具</li><li>定期清空工具： 今日事今日毕 ，定期清空，比如每周五清空所有事件迎接周末</li></ol><h3 id="处理收集篮：加工处理后，确定它们的实质以及解决方法。"><a href="#处理收集篮：加工处理后，确定它们的实质以及解决方法。" class="headerlink" title="处理收集篮：加工处理后，确定它们的实质以及解决方法。"></a>处理收集篮：加工处理后，确定它们的实质以及解决方法。</h3><p>2分钟突击原则：指定任务可行性标签<br>不可行：  1. 垃圾事件 2. 将来某时／也许事件  3. 参考资料（处理方法就是分类归档）<br>可执行： 1. 2分钟事件（专治拖延症） 2. 项目事件 3. 委托事件  4. 预约事件  5.待办事件</p><p>原则：  </p><ol><li>从最上面一项开始处理   </li><li>一次只处理一件事情   </li><li>永远不要再放回收集篮（被迫中断的事情除外），争取一次做好   </li></ol><h3 id="组织：组织整理，得出结论"><a href="#组织：组织整理，得出结论" class="headerlink" title="组织：组织整理，得出结论"></a>组织：组织整理，得出结论</h3><p>‘3+1’组合的清单系统<br>材料，<br>收集篮清单（做到每日清理）<br>将某时／也许清单<br>待办事清单<br>项目清单（多任务集合，多个下一步行动）一般会放在待办清单中   </p><h3 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h3><p>解决盲目的问题，我们还需要做到对任务进行回顾。</p><ol><li>让灵感应运而生<br>周回顾的时候恰恰是这样一种状态，对所有的一切都了如指掌，对所有的一切都做了充足的准备。  </li><li>站在3万米的高度去看待问题<br>通过对自己一周工作的重新审视，向自己发问：到底哪些事有利于我更好地接近目标？今后遇到类似的事情应该如何取舍？当我们站在一个新的高度去看待现在的人和事，你会有前所未有的发现。</li><li><p>孵化和修剪你的任务及目标</p></li><li><p>把它们列为我们行动的选择方案。</p></li></ol><h2 id="行动：选择最佳方案"><a href="#行动：选择最佳方案" class="headerlink" title="行动：选择最佳方案"></a>行动：选择最佳方案</h2><p>利用一个月的时间去思考自己的未来发展，然后制定一个‘自上而下’的职业规划；当这个规划确定之后，我会‘自下而上’地搞定自己的工作，并且在工作的过程中随时修订自己的规划，这就是我的工作方式。</p><h3 id="‘自上而下’的目标系统"><a href="#‘自上而下’的目标系统" class="headerlink" title="‘自上而下’的目标系统"></a>‘自上而下’的目标系统</h3><p>大卫·艾伦的六个高度去进行检视和规划：  </p><ol><li>原则 （五万米）<br>你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。如果你以前没有思考过这些，建议你现在就开始思考。我可以和你分享一下我的原则：工作是谋求更好生活的途径，追求无压、流畅、高效的工作。</li><li>愿景（四万米）<br>这里面包含3—5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。在这个层面你需要问自己<br> ◎我的目标是什么？<br> ◎哪些人已经达到了我的这个目标？<br> ◎他们是如何达到目标的？<br> ◎达到这个目标之后我的工作和生活会是怎样的？</li><li><p>目标（三万米）<br>目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。比如说我现在的目标就是：</p><p> ◎每周通过参加商务聚会来扩展自己的人脉，主动给朋友们打电话来巩固自己的人脉；<br> ◎参加管理学的培训课程或者是参加MBA学习来提高自己的综合能力；<br> ◎每天坚持阅读40分钟，以扩充自己的知识面，并且更深层次地研究自己所在的专属领域。</p></li><li>责任范围（两万米）<br>工作上的角色：如销售、管理、产品开发等；<br>生活中的角色：如家庭、个人财务、精神层面等。<br>要把每一个角色扮演好，就需要执行一些任务，以拉近现实和期望的距离。比如在这个层面我会拿出我负责的项目和产品，看看在开发、销售、管理上是否还有提升的可能性，因为毕竟要把自己责任范围内的事情做得漂亮，才有可能升职或者有其他进一步的发展。</li><li>任务（一万米）<br>所有需要一步以上完成的事情都是一个任务，虽然我们已经有了一个‘自上而下’的目标系统，但是我们仍然要将注意力放在眼前的任务上，比如‘新产品的营销策略’等。</li><li>下一步行动（跑道）<br>这是最细枝末节的事件，我们要将它们全部放进我们的清单，然后逐一完成。谁更关注细节，谁就能获得更大的成功。刚开始我们都在同一个跑道里面绕圈，但是最终只有职业规划清晰的人才会驾车进入快车道，直奔目标而去。”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calibre一站式电子书解决方案</title>
      <link href="/2017/05/25/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/calibre%E4%B8%80%E7%AB%99%E5%BC%8F%E7%94%B5%E5%AD%90%E4%B9%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2017/05/25/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/calibre%E4%B8%80%E7%AB%99%E5%BC%8F%E7%94%B5%E5%AD%90%E4%B9%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Calibre，是一个免费的开源的“一站式”的电子书解决方案，它可以全面满足你的电子书需求。Calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。当然它也内置了一个 ePub 格式电子书编辑工具以满足修改电子书的需要。   </p><p>感兴趣的几个功能点：</p><ol><li><p>爬虫功能，即可以支持一键抓取新闻，根据指定的feed订阅源，来制作书籍。<br> 这样便可每天爬取最新消息，发到kindle上看新闻</p></li><li><p>支持kindle书籍，相比kindle应用，它能自由复制书本内容，便于笔记整理。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程操作mysql数据库</title>
      <link href="/2017/05/25/%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2017/05/25/%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="腾讯云服务器"><a href="#腾讯云服务器" class="headerlink" title="腾讯云服务器"></a>腾讯云服务器</h2><ol><li><p>申请账户，体验5天，搭建一个jira服务，还有微信小程序服务</p></li><li><p>需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统）</p></li><li>想使用daocloud加速器，就要更新docker版本<br>docker run –detach –publish 8080:8080 cptactionhank/atlassian-jira:latest<br>http://[dockerhost]:8080 and finish the configuration</li></ol><h3 id="远程服务器的基本操作"><a href="#远程服务器的基本操作" class="headerlink" title="远程服务器的基本操作"></a>远程服务器的基本操作</h3><ol><li>登录：<code>ssh -l username 服务ip／域名</code><br> ssh ubuntu@123.<strong><em>.</em>.*6   5<em>**</em></strong>RtH<br> sudo docker pull cptactionhank/atlassian-jira</li><li>服务器端拷贝文件目录<br> scp -i localDir serveruser@serverip:serverDir</li></ol><h3 id="docker下安装mysql数据库镜像"><a href="#docker下安装mysql数据库镜像" class="headerlink" title="docker下安装mysql数据库镜像"></a>docker下安装mysql数据库镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql </span><br><span class="line">sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest</span><br></pre></td></tr></table></figure><blockquote><p>-name : 容器名<br>MYSQL_ROOT_PASSWORD : 数据库密码<br>-d : 镜像名:tag 版本</p></blockquote><h4 id="终端：单行登录mysql"><a href="#终端：单行登录mysql" class="headerlink" title="终端：单行登录mysql"></a>终端：单行登录mysql</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it jiradb mysql -ujira -pjira</span><br></pre></td></tr></table></figure><h4 id="进入mysql终端-访问数据库"><a href="#进入mysql终端-访问数据库" class="headerlink" title="进入mysql终端,访问数据库"></a>进入mysql终端,访问数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it jiradb bash</span><br><span class="line">#登录数据库  默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码</span><br><span class="line">mysql -uroot -p   #登录本地数据库 可以 省略-h参数 -h 127.0.0.1</span><br><span class="line">回车</span><br><span class="line">输入密码：jiradb  #就是$MYSQL_ROOT_PASSWORD的值</span><br><span class="line">即登录</span><br></pre></td></tr></table></figure><h4 id="用户权限控制"><a href="#用户权限控制" class="headerlink" title="用户权限控制"></a>用户权限控制</h4><ol><li><p>查看sql服务器的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status;</span><br></pre></td></tr></table></figure></li><li><p>创建用户名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user jira identified by &apos;jira&apos;;</span><br></pre></td></tr></table></figure></li><li><p>赋予权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos; with grant option;</span><br><span class="line">grant all privileges on *.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure></li></ol><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ol><li><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database jiradb character set &apos;UTF8&apos;;</span><br></pre></td></tr></table></figure></li><li><p>查看当前数据库名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure></li><li><p>切换指定数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use jiradb;</span><br></pre></td></tr></table></figure></li><li><p>查看数据库表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></li></ol><p>创建表</p><h5 id="jira和数据库关联结果"><a href="#jira和数据库关联结果" class="headerlink" title="jira和数据库关联结果"></a>jira和数据库关联结果</h5><p>无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联：<br>从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connect to MySQL from an application in another Docker container</span><br><span class="line">sudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>最终采用在ubuntu系统中安装mysql：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get -y install mysql-server</span><br></pre></td></tr></table></figure></p><p>##问题：Could not reach any registry endpoint<br>安装Linux加速器：<br>curl -sSL <a href="https://get.daocloud.io/daotools/set_mirror.sh" target="_blank" rel="noopener">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href="http://142900b5.m.daocloud.io" target="_blank" rel="noopener">http://142900b5.m.daocloud.io</a><br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。<br>ubuntu 系统安装daocloud检测工具：<br>curl -sSL <a href="https://get.daocloud.io/daomonit/install.sh" target="_blank" rel="noopener">https://get.daocloud.io/daomonit/install.sh</a> | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c </p><h3 id="更新服务器上的docker"><a href="#更新服务器上的docker" class="headerlink" title="更新服务器上的docker"></a>更新服务器上的docker</h3><p><a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/#/prerequisites-by-ubuntu-version" target="_blank" rel="noopener">官网教程</a></p><h3 id="Update-your-apt-sources"><a href="#Update-your-apt-sources" class="headerlink" title="Update your apt sources"></a>Update your apt sources</h3><p>To set APT to use packages from the Docker repository:</p><ol><li>Log into your machine as a user with sudo or root privileges.</li><li>Open a terminal window.</li><li><p>Update package information, ensure that APT works with the https method, and that CA certificates are installed.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure></li><li><p>Docker资源库<br>|Ubuntu version|    Repository|<br>|—|—-|<br>|Precise 12.04 (LTS)|deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-precise main|<br>|Trusty 14.04 (LTS)    |deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-trusty main|<br>|Wily 15.10         |deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-wily main|<br>|Xenial 16.04 (LTS)    |deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-xenial main|</p><blockquote><p>Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from <a href="https://master.dockerproject.org" target="_blank" rel="noopener">https://master.dockerproject.org</a>. To install docker on a multi-architecture system, add an [arch=…] clause to the entry. Refer to Debian Multiarch wiki for details.</p></blockquote></li><li>导入库<br><repo> = deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-precise main<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"&lt;REPO&gt;"</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure></repo></li></ol><p>`<br>6.Update the APT package index.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>7.Verify that APT is pulling from the right repository.<br>When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL <a href="https://apt.dockerproject.org/repo/" target="_blank" rel="noopener">https://apt.dockerproject.org/repo/</a>. The version currently installed is marked with ***.The output below is truncated.</p><p>$ apt-cache policy docker-engine</p><p>docker-engine:<br>Installed: 1.12.2-0~trusty<br>Candidate: 1.12.2-0~trusty<br>Version table:<br>*** 1.12.2-0~trusty 0<br>500 <a href="https://apt.dockerproject.org/repo/" target="_blank" rel="noopener">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>100 /var/lib/dpkg/status<br>1.12.1-0~trusty 0<br>500 <a href="https://apt.dockerproject.org/repo/" target="_blank" rel="noopener">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>1.12.0-0~trusty 0<br>500 <a href="https://apt.dockerproject.org/repo/" target="_blank" rel="noopener">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages</p><p>From now on when you run apt-get upgrade, APT pulls from the new repository.</p><p>To upgrade your kernel and install the additional packages, do the following:</p><p>Open a terminal on your Ubuntu host.<br>Update your package manager.<br>$ sudo apt-get update<br>Install both the required and optional packages.<br>$ sudo apt-get install linux-image-generic-lts-trusty<br>Repeat this step for other packages you need to install.<br>Reboot your host to use the updated kernel.<br>$ sudo reboot<br>After your system reboots, go ahead and install Docker.</p><p>Install the latest version<br>Make sure you have satisfied all the prerequisites, then follow these steps.</p><p>Note: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully.<br>Log into your Ubuntu installation as a user with sudo privileges.<br>Update your APT package index.<br>$ sudo apt-get update<br>Install Docker.<br>$ sudo apt-get install docker-engine<br>Start the docker daemon.<br>$ sudo service docker start<br>Verify that docker is installed correctly by running the hello-world image.<br>$ sudo docker run hello-world<br>This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS和OSX集成gitAPI</title>
      <link href="/2017/05/18/%E5%BC%80%E6%BA%90%E5%BA%93/iOS%E5%92%8COSX%E9%9B%86%E6%88%90gitAPI/"/>
      <url>/2017/05/18/%E5%BC%80%E6%BA%90%E5%BA%93/iOS%E5%92%8COSX%E9%9B%86%E6%88%90gitAPI/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在项目中使用git submodule工具集成子项目ObjectiveGit</p><h4 id="在新项目中使用git-submodule集成gitAPI"><a href="#在新项目中使用git-submodule集成gitAPI" class="headerlink" title="在新项目中使用git submodule集成gitAPI"></a>在新项目中使用git submodule集成gitAPI</h4><p>参考官方提供的两个demo</p><ul><li><p>OS X: <a href="https://github.com/Abizern/CommitViewer" target="_blank" rel="noopener">CommitViewer</a>   </p></li><li><p>iOS: <a href="https://github.com/Raekye/ObjectiveGit-iOS-Example" target="_blank" rel="noopener">ObjectiveGit iOS Example</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br><span class="line">如果之前配置过，直接更新：</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><ol><li><code>cd External/ObjectiveGit</code>，然后执行<code>./script/bootstrap</code>安装相关依赖.</li><li>拖动 <code>ObjectiveGitFramework.xcodeproj</code> 文件 到iOS/OSX项目导航窗口 .</li><li>在build Phases中配置APP的依赖，根据平台添加<code>ObjectiveGit-Mac</code> or <code>ObjectiveGit-iOS</code>.</li><li>APP通过连接器链接 <code>ObjectiveGit.framework</code>.</li><li>在build setting中“Header Search Paths” (<code>HEADER_SEARCH_PATHS</code>)设置<code>libgit2</code>头文件在项目的路径，例如：<code>External/ObjectiveGit/External/libgit2/include</code>. </li><li>Add a new “Copy Files” build phase, set the destination to “Frameworks” and add <code>ObjectiveGit.framework</code> to the list. This will package the framework with your application as an embedded private framework.</li></ol><ul><li>It’s hard to tell the difference between the platforms, but the Mac framework is in <code>build/Debug</code> whereas the iOS framework is in <code>build/Debug-iphoneos</code></li></ul><ol><li>Don’t forget to <code>#import &lt;ObjectiveGit/ObjectiveGit.h&gt;</code> or <code>@import ObjectiveGit;</code> as you would with any other framework.</li></ol><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>类变量关联.xib控件text值    </li><li>字体样式菜单来改变字体样式    <h4 id="在OSX中设置控件的Bindings代替IBOutlet"><a href="#在OSX中设置控件的Bindings代替IBOutlet" class="headerlink" title="在OSX中设置控件的Bindings代替IBOutlet"></a>在OSX中设置控件的Bindings代替IBOutlet</h4></li></ul><p>先关联再使用属性依赖特性来同步数据</p><h5 id="类变量关联-xib控件text值"><a href="#类变量关联-xib控件text值" class="headerlink" title="类变量关联.xib控件text值"></a>类变量关联.xib控件text值</h5><p><a href="http://stackoverflow.com/questions/8161012/referencing-bindings-in-connections-inspector" target="_blank" rel="noopener">相关参考</a>      </p><ol><li>选中NSTextField的bindings检查器面板   </li><li>在<code>value</code>单元内设置bind to 的值，通过下拉框选中 <code>Delegate</code>      </li><li>Model key Path:输入类变量的名称。    </li><li>切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联：     </li></ol><h5 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h5><p>Foundation 框架提供的表示属性依赖的机制如下：<br>参考<a href="https://github.com/huos3203/BookObjc/blob/master/publish/issue7/issue-7-3-DJBen.md#依赖的属性" target="_blank" rel="noopener">属性的依赖</a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</span><br></pre></td></tr></table></figure></p><p>将属性关联起来，这样就可以将类变量的值同步至UI控件中了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keySet = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"commit"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"messageTitle"</span>] ||</span><br><span class="line">        [key isEqualToString:<span class="string">@"messageDetails"</span>] ||</span><br><span class="line">        [key isEqualToString:<span class="string">@"author"</span>] ||</span><br><span class="line">        [key isEqualToString:<span class="string">@"date"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现字体样式菜单来改变字体样式"><a href="#实现字体样式菜单来改变字体样式" class="headerlink" title="实现字体样式菜单来改变字体样式"></a>实现字体样式菜单来改变字体样式</h4><ol><li>在xib中拖一个Object并设置为NSFontManager.h类的实现。   </li><li>选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SubModule与SubTree的差异</title>
      <link href="/2017/05/17/git/SubModule%E4%B8%8ESubTree%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
      <url>/2017/05/17/git/SubModule%E4%B8%8ESubTree%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h2><p><code>git submodule</code>类似于引用，而<code>git subtree</code>类似于拷贝，比如你在一篇博客中想用到你另一篇博客的内容，<code>git submodule</code>是使用那篇博客的链接，而<code>git subtree</code>则是将内容完全copy过来。</p><h3 id="submodule命令"><a href="#submodule命令" class="headerlink" title="submodule命令"></a>submodule命令</h3><ol><li>添加submodule<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -b branchA http://github.com/../repoA.git pathA</span><br><span class="line">git submodule add http://github.com/../repoB.git pathB</span><br></pre></td></tr></table></figure></li></ol><p>执行以上命令后会生成<code>.gitmodule</code>的文件，文件存储子模块信息:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">"repoA"</span>]</span><br><span class="line">    path = pathA</span><br><span class="line">    url = http://github.com/../repoA.git</span><br><span class="line">    branch = branchA</span><br><span class="line">[submodule <span class="string">"ModuleB"</span>]</span><br><span class="line">    path = ModuleB</span><br><span class="line">    url = http://github.com/../repoB.git</span><br></pre></td></tr></table></figure></p><p>提交<code>.gitmodule</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;add submodule&apos;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>clone新库初始化submodule<br>clone之后各模块内容为空目录，需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br></pre></td></tr></table></figure></li><li><p>拉取所有子模块<br>需要在<code>.gitmodules</code>文件中指定<code>branch:分支名</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git pull</span><br><span class="line">或</span><br><span class="line">git submodule foreach git pull origin master</span><br></pre></td></tr></table></figure></li><li><p>更新所有模块<br>更新后每个子模块并非在指定分支上，而是关联最近一次commitID。<br>使用<code>git submodule foreach</code>为每一个子模块执行切换命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git checkout master</span><br></pre></td></tr></table></figure></li></ol><p>切换到所有master分支上（ModuleB为ResourceEvaluate，暂时需要单独执行）</p><ol start="5"><li>删除子模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached moduleA</span><br><span class="line">rm -rf moduleA</span><br><span class="line">vi .gitmodules //删除moduleA相关的内容</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;remove moduleA&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ol><h3 id="subtree命令"><a href="#subtree命令" class="headerlink" title="subtree命令"></a>subtree命令</h3><ol><li><p><code>subtree</code>添加子模块<br>通过<code>subtree</code>添加子模块,<code>–squash</code>可省略，其功能是只有最新的提交记录被引入，去掉后则是引入所有历史提交记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#增加远程仓库并设置引用名`ModuleA`，此步可省略，主要是为了简化后面的操作</span><br><span class="line">git remote add ModuleA http://github.com/../ModuleA.git master</span><br><span class="line">#`subtree`添加子模块</span><br><span class="line">git subtree add --prefix=ModuleA --squash  ModuleA master</span><br></pre></td></tr></table></figure></li><li><p><code>subtree</code>更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull -P ModuleA ModuleA master</span><br></pre></td></tr></table></figure></li><li><p><code>subtree</code>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=ModuleA ModuleA master</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">submodule</th><th style="text-align:center">subtree</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">远程仓库空间占用</td><td style="text-align:center">submodule只是引用，基本不占用额外空间</td><td style="text-align:center">子模块copy，会占用较大的额外空间</td><td style="text-align:center">submodule占用空间较小，略优</td></tr><tr><td style="text-align:center">本地空间占用</td><td style="text-align:center">可根据需要下载</td><td style="text-align:center">会下载整个项目</td><td style="text-align:center">所有模块基本都要下载，二者差异不大</td></tr><tr><td style="text-align:center">仓库克隆</td><td style="text-align:center">克降后所有子模块为空，需要注册及更新，同时更新后还需切换分支</td><td style="text-align:center">克隆之后即可使用</td><td style="text-align:center">submodule步骤略多，subtree占优</td></tr><tr><td style="text-align:center">更新本地仓库</td><td style="text-align:center">更新后所有子模块后指向最后一次提交，更新后需要重新切回分支，所有子模块只需一条更新语句即可</td><td style="text-align:center">所有子模块需要单独更新</td><td style="text-align:center">各有优劣，相对subtree更好用一些</td></tr><tr><td style="text-align:center">提交本地修改</td><td style="text-align:center">只需关心子模块即可，子模块的所有操作与普通git项目相同</td><td style="text-align:center">提交执行命令相对复杂一些</td><td style="text-align:center">submodule操作更简单，submodule占优</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开发思想模式总结</title>
      <link href="/2017/05/16/%E5%AF%BC%E5%9B%BE/%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2017/05/16/%E5%AF%BC%E5%9B%BE/%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>OOP面向对象编程：1. 封装，2，继承，3. 多态<br>五大原则：<br>SRP单一职责原则：一个类的功能要单一，表现突出的VIPER模式<br>OCP开放封闭原则:模块扩展性为开放的，模块更改性则为封闭的。<br>LSP替换原则，<br>DIP依赖原则，<br>ISP接口分离原则：模块间的功能通过抽象接口隔离</p><p>封装：将抽象事物的特征，行为，转化为代码中的类：属性和方法即为封装，体现2.对属性和方法的访问权限的控制 私有，公有不同级别的保护。<br>继承：广义上也是一种对代码的复用。继承有两种方式：实现继承和接口继承。</p><p>多态：一个类实例的同一个方法，在不同情形有不同的表现形式。类似多个构造器和便利构造器，实现的功能都是初始化类实例的作用</p><h2 id="子类场景"><a href="#子类场景" class="headerlink" title="子类场景"></a>子类场景</h2><p>优点：代码封装，重用组件</p><ol><li>自定义系统控件时： 如：对UITableViewCell等视图，自定义布局。</li><li>针对多平台，多版本来编写代码<br>实现：创建一个基类，创建iPhone子类／iPad子类来继承重写特性方法。</li><li>子类化模型对象，继承isEqual:,hash,copyWithZone:和description等方法，参考开源框架<a href="http://southpeak.github.io/2015/01/11/sourcecode-mantle/" target="_blank" rel="noopener">Mantle</a></li></ol><h2 id="子类的场景替代方案"><a href="#子类的场景替代方案" class="headerlink" title="子类的场景替代方案"></a>子类的场景替代方案</h2><p>深层次的集成的替代方案：</p><ol><li>子类使用相同的接口，协议替代，</li><li>当对象正常运行需要大量配置时，使用代理来完成配置 </li><li>对现有的类增加简单功能时，使用类别来扩展</li><li>重写一堆相同方法子类时，使用配置对象代替</li><li>当重用某些功能时，使用组合多个对象来代替，而不是扩展它们</li></ol><h2 id="简明架构：VIPER模式：单一职责，"><a href="#简明架构：VIPER模式：单一职责，" class="headerlink" title="简明架构：VIPER模式：单一职责，"></a>简明架构：VIPER模式：单一职责，</h2><p>将APP逻辑结构划分为不同的责任层：<br>View视图，Interactor交互器，Presenter展示器，Entity实体，Routing路由</p><ol><li>接口隔离原则：隔离依赖项，</li><li>单一职责原则：利于测试各层间边界处的交互。</li><li>轻量化VC，提高可读性，维护性。</li></ol><h2 id="基于用例的应用设计-待办事项清单示例"><a href="#基于用例的应用设计-待办事项清单示例" class="headerlink" title="基于用例的应用设计  待办事项清单示例"></a>基于用例的应用设计  待办事项清单示例</h2><p>用例别称为验收标准，或行为集，它们用来描述应用的用途。独立于用户界面，主要针对在应用程序中的负责业务逻辑层的测试操作。<br>举例：清单可以根据时间，类型以及名字排序，这就是一个用例。<br>特征：足够小，良好的定义。<br>作用：将复杂的应用分解成较小的用例。</p><p>单一职责原则：便于测试<br>测试用例：<br>模拟网络数据-&gt;拦截HTTP请求-&gt;模拟一个响应对象给请求方<br>目的：<br>模拟数据，激活iResearcher </p><ol><li>多线程下载</li><li>VIPER架构</li></ol><p>LLDB命令和断点的合用<br>变量，对象：p ，po，e 表达式，<br>流程控制：thread<br>断点管理：breakpoint<br>LLDB和Python<br>AppleScript</p><p>Instruments<br>自定义工具–DTrace语法 -&gt;自动化脚本<br>终端成员DTrace<br>使用IB工具来编写DTrace脚本，并可以方便的导出DTrace脚本，可用于脚本自动化时收集APP运行状态的数据，<br>探针 （断言，动作，提供者，全部变量 ，begin，end）<br>DTrace脚本是在内核中运行中的，需要IB工具做缓冲区，来封装内核数据达到ib工具识别</p><p>废除功能：<br>run Browser浏览器功能<br>UI automation功能</p><h1 id="view属性的自动布局"><a href="#view属性的自动布局" class="headerlink" title="view属性的自动布局"></a>view属性的自动布局</h1>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode8插件制作替代Alcatraz</title>
      <link href="/2017/05/15/xcode/Xcode8%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%9B%BF%E4%BB%A3Alcatraz/"/>
      <url>/2017/05/15/xcode/Xcode8%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%9B%BF%E4%BB%A3Alcatraz/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li>Xcode7插件工具Alcatraz<br>开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。<br>以往Xcode插件开发在没有官方支持的情况下，提供了<a href="https://github.com/kattrali/Xcode-Plugin-Template" target="_blank" rel="noopener">Xcode-Plugin-Template</a>和各种dump好的头文件，我们仍然需要在没有文档的情况下做各种猜测和hook。关于插件的开发，可以看看<a href="https://onevcat.com/2013/02/xcode-plugin/" target="_blank" rel="noopener">这篇文章</a>。</li><li>Xcode8编辑源码的插件Xcode source editor extensions<br>Xcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发<code>Xcode source editor extensions</code>来扩展以下三个功能:</li></ol><ul><li>Add commands to the source editor // 给Xcode的代码编辑器扩展一些命令（在Editor菜单下增加额外的菜单）</li><li>Edit text                 //通过这些命令对源代码进行编辑</li><li>Change selections //对选中文本的编辑功能</li></ul><h2 id="源码编辑器插件"><a href="#源码编辑器插件" class="headerlink" title="源码编辑器插件"></a>源码编辑器插件</h2><h2 id="添加命令菜单"><a href="#添加命令菜单" class="headerlink" title="添加命令菜单"></a>添加命令菜单</h2><h3 id="通过Info-plist中添加菜单"><a href="#通过Info-plist中添加菜单" class="headerlink" title="通过Info.plist中添加菜单"></a>通过Info.plist中添加菜单</h3><p>打开<code>Info.plist</code>，展开<code>NSExtension</code>至<code>XCSourceEditorCommandDefinitions</code>，命令菜单的定义如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSExtensionAttributes&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;XCSourceEditorCommandDefinitions&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;XCSourceEditorCommandClassName&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;$(PRODUCT_MODULE_NAME).SourceEditorCommand&lt;/string&gt;</span><br><span class="line">            &lt;key&gt;XCSourceEditorCommandIdentifier&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;com.xt.APPlugins.AutoComment.SourceEditorCommand&lt;/string&gt;</span><br><span class="line">            &lt;key&gt;XCSourceEditorCommandName&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;Source Editor Command&lt;/string&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">    &lt;key&gt;XCSourceEditorExtensionPrincipalClass&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;$(PRODUCT_MODULE_NAME).SourceEditorExtension&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>XCSourceEditorCommandClassName指向命令的处理类，该类实现XCSourceEditorCommand。</li><li>XCSourceEditorCommandIdentifier是命令的唯一标识，通常我们会对一组命令设置同一个XCSourceEditorCommand，在invocation中获取此标识做区分处理。</li><li>XCSourceEditorCommandName是命令在菜单栏展示的菜单名称。<h3 id="通过代码定制命令菜单"><a href="#通过代码定制命令菜单" class="headerlink" title="通过代码定制命令菜单"></a>通过代码定制命令菜单</h3>此外，菜单项是动态加载的，可以实现<code>SourceEditorExtension.swift</code>的<code>commandDefinitions:</code>实现<br><code>SourceEditorExtensio</code>n用来管理extension的生命周期相关,<code>SourceEditorCommand</code>则用来处理具体的命令。<br>这会覆盖掉Info.plist中的定义。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 启动extension被调用，自定义相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extensionDidFinishLaunching</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commandDefinitions: [[<span class="type">XCSourceEditorCommandDefinitionKey</span>: <span class="type">AnyObject</span>]] &#123;</span><br><span class="line">    <span class="comment">// If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter.</span></span><br><span class="line">    <span class="comment">////commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令</span></span><br><span class="line">    <span class="keyword">return</span> [[.classNameKey: <span class="string">"SourceEditorCommand"</span>,</span><br><span class="line">             .identifierKey: <span class="string">"CustomIdentifier"</span>,</span><br><span class="line">             .nameKey: <span class="string">"CustomeName"</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="命令插件功能实现"><a href="#命令插件功能实现" class="headerlink" title="命令插件功能实现"></a>命令插件功能实现</h2><p>打开<code>SourceEditorCommand.swift</code>，实现<code>perform(with:completionHandler:)</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceEditorCommand</span>: <span class="title">NSObject</span>, <span class="title">XCSourceEditorCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//当通过Xcode菜单键调用插件时调用，实现插件功能的主体</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(with invocation: XCSourceEditorCommandInvocation,</span></span></span><br><span class="line"><span class="function"><span class="params">               completionHandler: @escaping <span class="params">(Error?)</span></span></span> -&gt; <span class="type">Void</span> ) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">       <span class="comment">// 正则匹配含有 闭包 的文本</span></span><br><span class="line">       <span class="keyword">var</span> updatedLineIndexes = [<span class="type">Int</span>]()</span><br><span class="line">       <span class="keyword">for</span> lineIndex <span class="keyword">in</span> <span class="number">0</span> ..&lt; invocation.buffer.lines.<span class="built_in">count</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">let</span> line = invocation.buffer.lines[lineIndex] <span class="keyword">as</span>! <span class="type">NSString</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">let</span> results = <span class="keyword">try</span> findClosureSyntax(line: line)</span><br><span class="line">               <span class="comment">//简化所有闭包语法格式：移除闭包里面括号</span></span><br><span class="line">               <span class="number">_</span> = results.<span class="built_in">map</span> &#123; result <span class="keyword">in</span></span><br><span class="line">                   <span class="keyword">let</span> cleanLine = line.remove(characters: [<span class="string">"("</span>, <span class="string">")"</span>], <span class="keyword">in</span>: result.range)</span><br><span class="line">                   updatedLineIndexes.append(lineIndex)</span><br><span class="line">                   invocation.buffer.lines[lineIndex] = cleanLine</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">               completionHandler(error <span class="keyword">as</span> <span class="type">NSError</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       completionHandler(<span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用正则表达式去遍历每一行代码是否含有闭包</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">findClosureSyntax</span><span class="params">(line:NSString)</span></span> <span class="keyword">throws</span> -&gt;[<span class="type">NSTextCheckingResult</span>]</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">let</span> regex =  <span class="keyword">try</span> <span class="type">NSRegularExpression</span>(pattern: <span class="string">"\\&#123;.*\\(.+\\).+in"</span>, options: .caseInsensitive)</span><br><span class="line">       <span class="keyword">let</span> range = <span class="type">NSRange</span>(<span class="number">0</span> ..&lt; line.length)</span><br><span class="line">       <span class="keyword">return</span> regex.matches(<span class="keyword">in</span>: line <span class="keyword">as</span> <span class="type">String</span>, options: .reportProgress, range: range)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>XCSourceEditorCommandInvocation</code>的<code>buffer</code>提供了当前选中的文件源代码中的信息，包括文件的<code>lines</code>, <code>selections</code>, <code>indentationWidth</code>等等，具体作用可以查看WWDC视频或者苹果的文档查看，在此就不一一介绍了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>选择scheme后编译运行自定义的extensions插件</li><li>选择测试安装插件的Xcode</li><li>点击run按钮会单独启动一个全新的Xcode<br>在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。</li><li>然后执行<code>Editor &gt; Clean Closure &gt; Source Editor Command</code>，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！</li></ol><h2 id="命令快捷键"><a href="#命令快捷键" class="headerlink" title="命令快捷键"></a>命令快捷键</h2><p>设置快捷键去自动调用Clean Syntax命令</p><ol><li>打开Xcode的Preferences，选择Key Bindings ;</li><li>搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。</li></ol><p><a href="http://wuwen1030.github.io/2016/06/23/WWDC2016之初识Xcode-Source-Editor-Extension/" target="_blank" rel="noopener">WWDC2016之初识Xcode Source Editor Extension</a><br><a href="https://github.com/theswiftdev/awesome-xcode-extensions" target="_blank" rel="noopener">xcode常用的插件清单</a><br><a href="http://www.iseedog.com/2016/09/21/xcode-source-editor/#more" target="_blank" rel="noopener">使用 Xcode Source Editor Extension开发Xcode 8 插件</a><br><a href="https://www.jianshu.com/p/9c9d0fcc62cc?winzoom=1" target="_blank" rel="noopener">详解一步步实现Xcode 8 插件</a></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从UIKit到AppKit</title>
      <link href="/2017/03/04/macOS/%E4%BB%8EUIKit%E5%88%B0AppKit/"/>
      <url>/2017/03/04/macOS/%E4%BB%8EUIKit%E5%88%B0AppKit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="NSWindowController"><a href="#NSWindowController" class="headerlink" title="NSWindowController"></a>NSWindowController</h3><p>在<code>Mac</code>上应用都支持多窗口（<code>NSWindowController</code>），<code>AppKit</code> 中都有 <code>NSWindowController</code>担当着类似在<code>iOS</code>中的<code>view controller</code>处理的任务。</p><blockquote><p><code>window</code>在<code>iOS</code>占据整个屏幕，几乎不怎么不用。</p></blockquote><h3 id="NSViewController"><a href="#NSViewController" class="headerlink" title="NSViewController"></a>NSViewController</h3><p><code>AppKit</code> 中的 <code>NSViewController</code>默认不支持交互，缺少生命周期相关方法和<code>UIKit</code>中熟悉的特性。<br>但在OS X 10.10 Yosemite之后，<code>NSViewController</code>改进很多，默认支持交互中的响应链。</p><h3 id="NSWindow-和-UIWindow"><a href="#NSWindow-和-UIWindow" class="headerlink" title="NSWindow 和 UIWindow"></a>NSWindow 和 UIWindow</h3><p>在<code>UIKit</code>中<code>UIWindow</code>是一个 <code>view</code> 的子类.<br>在<code>AppKit</code>中<code>NSWindow</code>用 <code>contentView</code> 属性持有一个指向其顶层 <code>view</code> 的引用。</p><h2 id="响应者链（responder-chain）"><a href="#响应者链（responder-chain）" class="headerlink" title="响应者链（responder chain）"></a>响应者链（responder chain）</h2><p>如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下<code>view controller</code> 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 <code>window</code> 和 <code>window</code> <code>controller</code>。在这种情况下，如果你想在 <code>view controller</code> 处理事件，你需要手动把它添加到响应者链中。</p><h3 id="Target-Action消息传递方式"><a href="#Target-Action消息传递方式" class="headerlink" title="Target-Action消息传递方式"></a>Target-Action消息传递方式</h3><p><code>Target-Action</code> 是回应 <code>UI 事件</code>时典型的消息传递方式。<code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。<br><code>Target-Action</code> 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 <code>target</code> 是 <code>nil</code>，<code>action</code> 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。</p><h4 id="传递机制的局限"><a href="#传递机制的局限" class="headerlink" title="传递机制的局限"></a>传递机制的局限</h4><p>基于 <code>target-action</code> 传递机制的一个局限是，发送的消息不能携带自定义的信息：</p><ol><li>在<code>iOS</code> 中，可以选择性的把发送者和触发 <code>action</code> 的事件作为参数。</li><li>在 <code>Mac</code> 平台上 <code>action</code> 方法的第一个参数永远是发送者，否则将不视为无效方法。<br>在<code>AppKit</code>唯一有效的<code>action</code> 方法声明方式：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performAction:(<span class="keyword">id</span>)sender;</span><br></pre></td></tr></table></figure></li></ol><h4 id="控件关联Action事件的区别"><a href="#控件关联Action事件的区别" class="headerlink" title="控件关联Action事件的区别"></a>控件关联Action事件的区别</h4><p><code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。</p><ol><li>在 <code>iOS</code> 中，每个控件可以通过<code>addTarget:action:forControlEvents:</code>和多个 <code>target-action</code> 关联。</li><li>在<code>AppKit</code>中通常一个<code>控件</code>仅对应一个 <code>target-action</code>对。</li></ol><h2 id="View视图系统"><a href="#View视图系统" class="headerlink" title="View视图系统"></a>View视图系统</h2><p>因为历史遗留问题，<code>Mac</code> 的视图系统和 <code>iOS</code>的视图系统有很大区别。</p><ol><li>绘图处理器差异<br><code>iOS</code>由 <code>Core Animation layer</code> 驱动，使用<code>GPU</code>处理。<br><code>AppKit</code>视图系统相关的任务主要靠 <code>CPU</code> 处理，因为在<code>AppKit</code>设计之初，<code>GPU</code>还没有诞生。<br>Mac开发参考资料：<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978" target="_blank" rel="noopener">Introduction to View Programming Guide for Cocoa</a><br><a href="https://developer.apple.com/videos/wwdc/2012/#217" target="_blank" rel="noopener">WWDC session：Layer-Backed Views: AppKit + Core Animation</a><br><a href="https://developer.apple.com/videos/wwdc/2013/#215" target="_blank" rel="noopener">Optimizing Drawing and Scrolling</a></li></ol><h3 id="Layer-Backed-View-iOS反哺AppKit层支持视图"><a href="#Layer-Backed-View-iOS反哺AppKit层支持视图" class="headerlink" title="Layer-Backed View: iOS反哺AppKit层支持视图"></a>Layer-Backed View: iOS反哺AppKit层支持视图</h3><ol><li><code>iOS</code>反哺<code>AppKit</code><br>默认情况下，<code>AppKit</code> 的 <code>view</code> 不是由 <code>Core Animation layer</code> 驱动的；<code>AppKit</code> 整合 <code>layer-backing</code> 是 <code>iOS</code> 反哺的结果。</li></ol><h4 id="layer-backing启用／禁用-wantsLayer"><a href="#layer-backing启用／禁用-wantsLayer" class="headerlink" title="layer backing启用／禁用:wantsLayer"></a>layer backing启用／禁用:wantsLayer</h4><p><code>AppKit</code> 区分 <code>layer-backed view</code> 和 <code>layer-hosting view</code>，可以在每个视图树的根节点启用或者禁用 <code>layer backing</code>。<br>启用 <code>layer backing</code></p><ol><li>方法一：把窗口的 <code>contentView</code> 的 <code>wantsLayer</code> 属性设置为 <code>YES</code></li><li>方法二：在 <code>Interface Builder</code> 的 <code>View Effects Inspector</code> 面板完成<br>这会导致 <code>window</code> 的视图树中所有的 <code>view</code> 都启用 <code>layer backing</code>，这样就没必要反复设置每个 <code>view</code> 的 <code>wantsLayer</code> 属性了。</li></ol><h4 id="修改layer属性"><a href="#修改layer属性" class="headerlink" title="修改layer属性"></a>修改layer属性</h4><p>在<code>AppKit</code>上开启<code>layer backing</code>之后，<code>layer</code>的拥有者是<code>AppKit</code>，这就意味着不能直接编辑 <code>layer</code>的属性。<br>在 <code>iOS</code> 上可以直接编辑：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.layer.backgroundColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br></pre></td></tr></table></figure><br>在 <code>AppKit</code>编辑<code>layer</code>属性需要以下步骤：</p><ol><li>重写 <code>NSView</code> 的 <code>wantsUpdateLayer</code> 方法并返回 <code>YES</code>,这能让你可以改变 <code>layer</code> 的属性。<br>这样以来，在<code>view</code> 更新周期中，将不会再调用 <code>view</code> 的 <code>drawRect:</code> 方法。取而代之，调用<code>updateLayer</code>方法来更新<code>Layer</code>。<br>举个例子，用这方法去实现一个非常简单的有纯色背景的 <code>view</code>（没错，<code>NSView</code> 没有<code>backgroundColor</code> 属性）：<br>这个例子的前提是这个 <code>view</code> 的<code>父 view</code> 已经为其视图树启用了 <code>layer backing</code>。<br>另一种可行的实现则只需要重写 <code>drawRect:</code> 方法并在其中绘制背景颜色。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ColoredView</span>: <span class="title">NSView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSColor</span> *backgroundColor;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ColoredView</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)wantsUpdateLayer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateLayer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.layer.backgroundColor = <span class="keyword">self</span>.backgroundColor.CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBackgroundColor:(<span class="built_in">NSColor</span> *)backgroundColor</span><br><span class="line">&#123;</span><br><span class="line">    _backgroundColor = backgroundColor;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="合并-Layer"><a href="#合并-Layer" class="headerlink" title="合并 Layer"></a>合并 Layer</h4><p>当APP启动过多的<code>layer-backed view</code> 会带来巨大的内存消耗（每一个 <code>layer</code> 有其自己的 <code>backing store</code>，还有可能和其他 <code>view</code>的 <code>backing store</code> 重叠）而且会带来潜在的合成这些 <code>layer</code> 的消耗。</p><h5 id="canDrawSubviewsIntoLayer合并Layer"><a href="#canDrawSubviewsIntoLayer合并Layer" class="headerlink" title="canDrawSubviewsIntoLayer合并Layer"></a>canDrawSubviewsIntoLayer合并Layer</h5><p>从 OS X 10.9 开始，如果不单独对一个 <code>view</code> 中的子 <code>view</code> 做动画，可以通过设置 <code>canDrawSubviewsIntoLayer</code> 属性来让 <code>AppKit</code> 合并一个<code>视图树</code>中所有 <code>layer</code> 的内容到一个共有的 <code>layer</code>。</p><h5 id="隐式layer-backed合并Layer"><a href="#隐式layer-backed合并Layer" class="headerlink" title="隐式layer-backed合并Layer"></a>隐式layer-backed合并Layer</h5><p>所有隐式 <code>layer-backed</code> 的<code>子 view</code>（比如，没有显式地对这些<code>子 view</code> 设置 <code>wantsLayer = YES</code>）现在将会被绘制到同一个 <code>layer</code> 中。不过<code>wantsLayer</code> 设置为 <code>YES</code> 的<code>子 view</code> 仍然持有它们自己的 <code>backing layer</code>， 而且不管 <code>wantsUpdateLayer</code> 返回什么，它们的 <code>drawRect:</code> 方法仍然会被调用。</p><h4 id="Layer-重绘策略"><a href="#Layer-重绘策略" class="headerlink" title="Layer 重绘策略"></a>Layer 重绘策略</h4><h5 id="layer-backed-view-默认的自动重绘策略"><a href="#layer-backed-view-默认的自动重绘策略" class="headerlink" title="layer-backed view 默认的自动重绘策略"></a>layer-backed view 默认的自动重绘策略</h5><p><code>layer-backed view</code> 会默认设置重绘策略为 <code>NSViewLayerContentsRedrawDuringViewResize</code>。在行为上，这个非 <code>layer-backed view</code> 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。</p><h5 id="设置layer-backed-view手动重绘策略"><a href="#设置layer-backed-view手动重绘策略" class="headerlink" title="设置layer-backed view手动重绘策略"></a>设置layer-backed view手动重绘策略</h5><ol><li>设置手动重绘策略：把 <code>layerContentsRedrawPolicy</code> 属性设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> </li><li>实现手动重绘操作：调用 <code>-setNeedsDisplay:</code>方法来触发重绘操作<br>这样便由你来决定 <code>layer</code> 的内容何时需要重绘。帧的改变将不再自动触发重绘。</li></ol><h5 id="设置view的属性来重绘Layer"><a href="#设置view的属性来重绘Layer" class="headerlink" title="设置view的属性来重绘Layer"></a>设置view的属性来重绘Layer</h5><ol><li>view中<code>layerContentsPlacement</code>属性：等价<code>layer</code>中的 <code>contentGravity</code> 属性。<br>这个属性允许你指定在调整大小的时候当前的 <code>layer</code> 内容该怎么映射到 <code>layer</code> 上。</li></ol><h3 id="Layer-Hosting-View-使用-Core-Animation-layer"><a href="#Layer-Hosting-View-使用-Core-Animation-layer" class="headerlink" title="Layer-Hosting View:使用 Core Animation layer"></a>Layer-Hosting View:使用 Core Animation layer</h3><p><code>layer-hosting view</code> 是视图树中的叶子节点，使用这种模式可以对<code>layer</code> 及其<code>子 layer</code> 做任何操作，代价是你再也不能给该 <code>view</code> 添加任何<code>子 view</code>。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol><li>为 <code>view</code> 的 <code>layer</code> 属性分配一个 <code>layer 对象</code>，</li><li>设置<code>wantsLayer</code> 为 <code>YES</code><br>这些步骤的顺序是非常关键：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(<span class="type">NSRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.layer = [[<span class="type">CALayer</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="keyword">self</span>.wantsLayer = <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在你设置了自定义的 <code>layer</code> 之后，再设置 <code>wantsLayer</code> 是非常重要的。</li></ol><h3 id="其他与-View-相关的陷阱"><a href="#其他与-View-相关的陷阱" class="headerlink" title="其他与 View 相关的陷阱"></a>其他与 View 相关的陷阱</h3><h4 id="坐标系统原点设置左下／左上角"><a href="#坐标系统原点设置左下／左上角" class="headerlink" title="坐标系统原点设置左下／左上角"></a>坐标系统原点设置左下／左上角</h4><p>通过重写<code>isFlipped</code> 并返回 <code>YES</code> 来恢复到你熟悉的左上角。</p><h4 id="View背景颜色属性drawsBackground"><a href="#View背景颜色属性drawsBackground" class="headerlink" title="View背景颜色属性drawsBackground"></a>View背景颜色属性drawsBackground</h4><p>由于 <code>AppKit</code> 中的 <code>view</code> 没有背景颜色属性可以让你直接设置为 <code>[NSColor clearColor]</code> 来让其变得透明，许多 <code>NSView</code> 的子类比如 <code>NSTextView</code> 和 <code>NSScrollView</code> 开放了一个 <code>drawsBackground</code> 属性，如果你想让这一类 <code>view</code> 透明，你必须设置该属性为 <code>NO</code>。</p><h4 id="设置光标追踪区域"><a href="#设置光标追踪区域" class="headerlink" title="设置光标追踪区域"></a>设置光标追踪区域</h4><p>为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 <code>NSView</code> 中指定的 <code>updateTrackingAreas</code> 方法中来做这件事情。一个通用的写法看起来是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateTrackingAreas</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> removeTrackingArea:<span class="keyword">self</span>.trackingArea];</span><br><span class="line">    <span class="keyword">self</span>.trackingArea = [[<span class="type">NSTrackingArea</span> alloc] initWithRect:<span class="type">CGRectZero</span> </span><br><span class="line">                                                     options:<span class="type">NSTrackingMouseEnteredAndExited</span>|<span class="type">NSTrackingInVisibleRect</span>|<span class="type">NSTrackingActiveInActiveApp</span></span><br><span class="line">                                                       owner:<span class="keyword">self</span> </span><br><span class="line">                                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTrackingArea:<span class="keyword">self</span>.trackingArea];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NSCell困惑"><a href="#NSCell困惑" class="headerlink" title="NSCell困惑"></a>NSCell困惑</h4><p><code>AppKit</code> 的控件之前是由 <code>NSCell</code> 的子类驱动的，可以被所有同类型的控件重用。<br><code>AppKit</code> 最初区分 <code>view</code> 和 <code>cell</code> 是为了节省资源 - <code>view</code> 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 <code>view</code> 重用的 <code>cell</code> 对象。<br>不要混淆这些 <code>cell</code> 和 <code>UIKit</code> 里 <code>table view</code> 的 <code>cell</code> 及 <code>collection view</code> 的 <code>cell</code>。</p><h5 id="自定义一个按钮控件"><a href="#自定义一个按钮控件" class="headerlink" title="自定义一个按钮控件"></a>自定义一个按钮控件</h5><p>Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。<br>举个例子，如果你想创建一个自定义的按钮，</p><ol><li>首先要继承 <code>NSButton</code> 和 <code>NSButtonCell</code></li><li>然后在这个 <code>cell 子类</code>里面进行你自定义的绘制，</li><li>然后通过重写 <code>+[NSControl cellClass]</code>方法告诉自定义按钮使用你的 <code>cell 子类</code></li></ol><h4 id="获取-Core-Graphics-上下文"><a href="#获取-Core-Graphics-上下文" class="headerlink" title="获取 Core Graphics 上下文"></a>获取 Core Graphics 上下文</h4><p>最后，如果你想知道在你自己的 <code>drawRect:</code> 方法里怎么获取当前的 <code>Core Graphics</code> 上下文，答案是 <code>NSGraphicsContext</code> 的 <code>graphicsPort</code> 属性。详细内容请查看 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/" target="_blank" rel="noopener">Cocoa Drawing Guide</a>。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>如果你的 <code>view</code> 不是由 <code>layer</code> 驱动的，那你的动画自然是完全由 <code>CPU</code> 处理，这意味着动画的每一步都必须相应地绘制到 <code>window-backing store</code> 上。</p><h3 id="对-layer-backed-view做动画"><a href="#对-layer-backed-view做动画" class="headerlink" title="对 layer-backed view做动画"></a>对 layer-backed view做动画</h3><p>正如上面说的，在 <code>AppKit</code> 中,这些 <code>layer</code> 由 <code>AppKit</code> 管理，你不应该修改 <code>layer-backed view</code> 中的 <code>layer</code>。 </p><h4 id="几何属性"><a href="#几何属性" class="headerlink" title="几何属性"></a>几何属性</h4><p>与<code>iOS</code> 相反，<code>view</code> 的几何属性并不仅仅是对应的 <code>layer</code> 的几何属性的映射，但 <code>AppKit</code> 却会把 <code>view</code> 内部的几何属性同步到 <code>layer</code>。</p><h4 id="的animator-proxy动画"><a href="#的animator-proxy动画" class="headerlink" title="的animator proxy动画"></a>的animator proxy动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.animator.alphaValue = <span class="number">.5</span>;</span><br></pre></td></tr></table></figure><p>在幕后，这句代码会启用 <code>layer</code> 的隐式动画，设置其透明度，然后再次禁用 <code>layer</code> 的隐式动画。</p><h4 id="NSAnimationContext动画"><a href="#NSAnimationContext动画" class="headerlink" title="NSAnimationContext动画"></a>NSAnimationContext动画</h4><ol><li>结束回调<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSAnimationContext</span> runAnimationGroup:^(<span class="built_in">NSAnimationContext</span> *context)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//持续时间</span></span><br><span class="line">    context.duration = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//缓动类型</span></span><br><span class="line">    context.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line">    view.animator.alphaValue = <span class="number">.5</span>;</span><br><span class="line"></span><br><span class="line">&#125; completionHandler:^&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;]; </span><br></pre></td></tr></table></figure></li><li>无结束回调<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSAnimationContext</span> currentContext].duration = <span class="number">1</span>;</span><br><span class="line">view.animator.alphaValue = <span class="number">.5</span>; </span><br></pre></td></tr></table></figure></li></ol><h4 id="启用隐式动画"><a href="#启用隐式动画" class="headerlink" title="启用隐式动画"></a>启用隐式动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSAnimationContext</span> currentContext].allowsImplicitAnimations = <span class="literal">YES</span>;</span><br><span class="line">view.alphaValue = <span class="number">.5</span>;</span><br></pre></td></tr></table></figure><h4 id="CAAnimations控制动画"><a href="#CAAnimations控制动画" class="headerlink" title="CAAnimations控制动画"></a>CAAnimations控制动画</h4><p>使用 <code>CAAnimation</code> 实例更全面地控制动画。和 <code>iOS</code> 相反，你不能直接把它们加到 <code>layer</code> 上（因为 <code>layer</code> 不应该由你来修改），不过你可以使用 <code>NSAnimatablePropertyContainer</code> 协议中定义的 <code>API</code>，<code>NSView</code> 和 <code>NSWindow</code> 已经实现了该协议。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animation];</span><br><span class="line">animation.values = @[@<span class="number">1</span>, @<span class="number">.9</span>, @<span class="number">.8</span>, @<span class="number">.7</span>, @<span class="number">.6</span>];</span><br><span class="line">view.animations = @&#123;<span class="string">@"alphaValue"</span>: animation&#125;;</span><br><span class="line">view.animator.alphaValue = <span class="number">.5</span>;</span><br></pre></td></tr></table></figure></p><h5 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h5><p>对于帧动画来说，把 <code>view</code> 的 <code>layerContentsRedrawPolicy</code> 设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 是非常重要的，不然的话 <code>view</code> 的内容在每一帧都会被重绘。</p><p>很遗憾，<code>NSView</code> 没有开放 <code>Core Animation layer</code> 所有可以进行动画的属性，<code>transform</code> 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。</p><p>上面提到的所有东西都适用于 <code>layer-backed view</code>。对于 l<code>ayer-hosting view</code> 来说，你可以直接对 <code>view</code> 的 <code>layer</code> 或者<code>子 layer</code> 使用 <code>CAAnimations</code>，因为你拥有它们的控制权。</p><h3 id="文字系统"><a href="#文字系统" class="headerlink" title="文字系统"></a>文字系统</h3><p>有了 <code>TextKit</code>，<code>iOS 7</code> 终于有了和 <code>Mac</code> 上早就有了的 <code>Cocoa Text System</code> 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 <code>iOS</code>；相反，Apple 对其做了些显著的改变。<br>举个例子，<code>AppKit</code> 开放 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code>，你可以通过继承这两者来自定义它们的一些特性。<code>iOS</code> 并不开放这些类，但是你可以通过 <code>NSLayoutManagerDelegate</code> 协议达到定制的目的。<br>总体来说，两个平台的文字系统还是非常相似的，所有你在 <code>iOS</code> 上能做的在 <code>Mac</code> 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。</p><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>符合沙盒机制的 <code>Mac 应用</code>才能通过 <code>Mac App Store</code> 销售。然而，我们已经习惯了沙盒机制还没出现之前的 <code>Mac</code> 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。<br>管理Mac应用对沙盒支持：</p><h2 id="独有特性"><a href="#独有特性" class="headerlink" title="独有特性"></a>独有特性</h2><p>有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：<a href="http://objccn.io/issue-14-4/" target="_blank" rel="noopener">进程间通讯</a>，<a href="http://objccn.io/issue-14-1/" target="_blank" rel="noopener">使 Mac 应用脚本化</a>,<a href="http://objccn.io/issue-14-2/" target="_blank" rel="noopener">在沙盒中脚本化其他应用</a> , <a href="http://objccn.io/issue-14-3/" target="_blank" rel="noopener">为你的应用构建插件</a>。<br>当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> 视图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> UI </tag>
            
            <tag> 混编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift基本概念</title>
      <link href="/2017/03/03/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/03/03/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="FRP函数式反应型编程"><a href="#FRP函数式反应型编程" class="headerlink" title="FRP函数式反应型编程"></a>FRP函数式反应型编程</h2><p>Functional Reactive Programming ， 缩写为 FRP</p><h2 id="函数编程"><a href="#函数编程" class="headerlink" title="函数编程"></a>函数编程</h2><h3 id="函数是第一等公民"><a href="#函数是第一等公民" class="headerlink" title="函数是第一等公民"></a>函数是第一等公民</h3><p>所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。<br>将数组通过指定的函数映射成另一个数组，例如将<code>increment函数</code>作为参数传入数组的<code>map函数</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> increment = &#123; <span class="keyword">return</span> $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(increment)  <span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure></p><h3 id="函数式的函数"><a href="#函数式的函数" class="headerlink" title="函数式的函数"></a>函数式的函数</h3><h4 id="map-映射函数"><a href="#map-映射函数" class="headerlink" title="map 映射函数"></a>map 映射函数</h4><p><code>map</code> 可以把一个数组按照一定的规则转换成另一个数组，定义如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>[]</span><br><span class="line"><span class="comment">//效果</span></span><br><span class="line">[ x1, x2, ... , xn].<span class="built_in">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。</p><h4 id="filter-筛选函数"><a href="#filter-筛选函数" class="headerlink" title="filter 筛选函数"></a>filter 筛选函数</h4><p><code>filter</code>通过在闭包中对每个元素进行逻辑运算，来排除为<code>false</code>的元素<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(includeElement: <span class="params">(T)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">var</span> oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]</span><br><span class="line"><span class="keyword">var</span> filteredArray  = oldArray.<span class="built_in">filter</span>(&#123; <span class="keyword">return</span> $<span class="number">0</span> &gt; <span class="number">30</span> &#125;)</span><br><span class="line"><span class="built_in">println</span>(filteredArray) <span class="comment">// [45, 32]</span></span><br></pre></td></tr></table></figure></p><h4 id="reduce-迭代函数"><a href="#reduce-迭代函数" class="headerlink" title="reduce 迭代函数"></a>reduce 迭代函数</h4><p><code>reduce</code>函数把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br>定义如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;U&gt;<span class="params">(initial: U, combine: <span class="params">(U, T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span></span><br></pre></td></tr></table></figure><br>reduce 有两个参数，<code>initial</code>是初始值，<code>combine</code>定义规则闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，闭包返回的新值作为下一轮循环中的<code>initial</code>值。<br>写几个小例子试一下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">sum = oldArray.<span class="built_in">reduce</span>(<span class="number">0</span>,&#123;$<span class="number">0</span> + $<span class="number">1</span>&#125;) <span class="comment">// 0+10+20+45+32 = 107</span></span><br><span class="line">sum = oldArray.<span class="built_in">reduce</span>(<span class="number">1</span>,&#123;$<span class="number">0</span> + $<span class="number">1</span>&#125;) <span class="comment">// 1+10+20+45+32 = 108</span></span><br><span class="line">sum = oldArray.<span class="built_in">reduce</span>(<span class="number">5</span>,&#123;$<span class="number">0</span> * $<span class="number">1</span>&#125;) <span class="comment">// 5*10*20*45*32 = 1440000</span></span><br><span class="line">sum = oldArray.<span class="built_in">reduce</span>(<span class="number">0</span>,+) <span class="comment">// 0+10+20+45+32 = 107</span></span><br><span class="line"><span class="built_in">println</span>(sum)</span><br></pre></td></tr></table></figure></p><h3 id="函数式和指令式的比较"><a href="#函数式和指令式的比较" class="headerlink" title="函数式和指令式的比较"></a>函数式和指令式的比较</h3><h2 id="响应式编程-Reactive"><a href="#响应式编程-Reactive" class="headerlink" title="响应式编程 - Reactive"></a>响应式编程 - Reactive</h2><p>在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景：</p><ol><li>用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。</li><li>用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。<br>外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。</li></ol><p>那么什么是反应型编程呢？</p><pre><code>Reactive programming is programming with asynchronous data streams.反应型编程是异步数据流的编程。</code></pre><p>对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。<br>我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流：<br>    –a—b-c—d—X—|–&gt;<br>    a, b, c, d 是具体的值，代表了某个事件<br>    X 表示发生了一个错误<br>    | 是这个流已经结束了的标记<br>    ———-&gt; 是时间轴<br>比如我们要统计用户点击鼠标的次数，那么可以这样：<br>clickStream:    —c—-c–c—-c——c–&gt;<br>                vvvvv map(c becomes 1) vvvv<br>                —1—-1–1—-1——1–&gt;<br>                vvvvvvvvv scan(+) vvvvvvvvv<br>counterStream:  —1—-2–3—-4——5–&gt;<br>反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。</p><h2 id="swift-函数式编程"><a href="#swift-函数式编程" class="headerlink" title="swift 函数式编程"></a>swift 函数式编程</h2><p>Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。<br>Swift 本身并不是一门函数式语言，不过有一些函数式的方法和特性</p><ol><li>map reduce 等函数式函数</li><li>函数是一等公民</li><li>模式匹配<br>我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。</li></ol><h1 id="RxSwift-响应式编程"><a href="#RxSwift-响应式编程" class="headerlink" title="RxSwift 响应式编程"></a>RxSwift 响应式编程</h1><p><a href="https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground" target="_blank" rel="noopener">Rx.playground</a></p><h2 id="Observable观察者模式"><a href="#Observable观察者模式" class="headerlink" title="Observable观察者模式"></a>Observable观察者模式</h2><p>Rx 的基础：<code>Observable</code> ， <code>Observable&lt;Element&gt;</code> 是观察者模式中可观察的对象，相当于一个事件序列 (GeneratorType)。<br>支持订阅的事件序列，在下文简称为<code>订阅源</code>或<code>可观察者</code>。<br>订阅源的事件队列中包括三种事件类型：</p><ol><li><code>.Next(value)</code>: 表示新的事件数据。</li><li><code>.Completed</code>: 表示事件序列的完结。</li><li><code>.Error</code>: 同样表示完结，但是代表异常导致的完结。</li></ol><h3 id="新建订阅源几种快捷方法"><a href="#新建订阅源几种快捷方法" class="headerlink" title="新建订阅源几种快捷方法"></a>新建订阅源几种快捷方法</h3><ol><li><code>empty</code>是一个空的序列，它只发送 <code>.Completed</code> 消息。<figure class="highlight swift"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>&gt;</span><br><span class="line">example(<span class="string">"empty"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> emptySequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = empty()</span><br><span class="line">    <span class="keyword">let</span> subscription = emptySequence.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">                                                <span class="built_in">print</span>(event)</span><br><span class="line">                                            &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- empty example ---</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></li><li><code>never</code> 是没有任何元素、也不会发送任何事件的空序列。<figure class="highlight swift"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">- returns: An observable sequence whose observers will never get called.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">never</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>&gt;</span><br></pre></td></tr></table></figure></li><li><code>just</code> 是只包含一个元素的序列，它会先发送 <code>.Next(value)</code> ，然后发送 <code>.Completed</code><figure class="highlight swift"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns an observable sequence that contains a single element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">just</span><span class="params">(<span class="number">_</span> element: E)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Just</span>(element: element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>sequenceOf</code> 可以把一系列元素转换成订阅源<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sequenceOfElements<span class="comment">/* : Observable&lt;Int&gt; */</span> = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><code>asObservable方法</code> 将遵守<code>ObservableType</code>协议的对象转为可观察者序列<figure class="highlight swift"><figcaption><span>ObservableType.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ObservableType</span> : <span class="title">ObservableConvertibleType</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Default implementation of converting `ObservableType` to `Observable`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asObservable</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sequenceFromArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].asObservable()</span><br></pre></td></tr></table></figure></li><li><code>failWith</code>创建一个没有元素的序列，只会发送失败 (<code>.Error</code>) 事件。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> erroredSequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = failWith(error)</span><br><span class="line"><span class="keyword">let</span> subscription = erroredSequence.subscribe &#123; event <span class="keyword">in</span> <span class="built_in">print</span>(event)&#125;</span><br><span class="line">--- failWith example ---</span><br><span class="line"><span class="type">Error</span>(<span class="type">Error</span> <span class="type">Domain</span>=<span class="type">Test</span> <span class="type">Code</span>=-<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (Test error -1.)"</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="create自定义订阅源"><a href="#create自定义订阅源" class="headerlink" title="create自定义订阅源"></a>create自定义订阅源</h3><p><code>create</code> 可以通过闭包创建序列，通过 <code>.on(e: Event)</code> 添加可观察者事件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"create"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> myJust = &#123; (singleElement: <span class="type">Int</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> create &#123; observer <span class="keyword">in</span></span><br><span class="line">                observer.on(.<span class="type">Next</span>(singleElement))</span><br><span class="line">                observer.on(.<span class="type">Completed</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = myJust(<span class="number">5</span>).subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- create example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">5</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h3 id="deferred订阅源的懒加载"><a href="#deferred订阅源的懒加载" class="headerlink" title="deferred订阅源的懒加载"></a>deferred订阅源的懒加载</h3><p><code>deferred</code>表示当有有新增订阅者第一次订阅了该订阅源时，订阅源才会被创建，且每个订阅者订阅的对象都是内容相同而完全独立的序列。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"TestDeferred"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">var</span> subscription: <span class="type">Observable</span>&lt;<span class="type">String?</span>&gt; = deferred &#123;</span><br><span class="line">        <span class="keyword">return</span> just(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// got value</span></span><br><span class="line">    value = <span class="string">"Hello!"</span></span><br><span class="line">    subscription.subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="type">TestDeferred</span> example ---</span><br><span class="line"><span class="type">Next</span>(<span class="type">Optional</span>(<span class="string">"Hello!"</span>))</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h2 id="几种特殊类型的订阅源"><a href="#几种特殊类型的订阅源" class="headerlink" title="几种特殊类型的订阅源"></a>几种特殊类型的订阅源</h2><p><code>Subject</code> 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 <code>Observable 对象</code>，同时又可以对它的订阅者们发送事件。</p><h3 id="PublishSubject-向所有订阅者发送事件队列"><a href="#PublishSubject-向所有订阅者发送事件队列" class="headerlink" title="PublishSubject 向所有订阅者发送事件队列"></a>PublishSubject 向所有订阅者发送事件队列</h3><p>当<code>PublishSubject</code>类型订阅源事件队列中<code>.on()</code>新增事件时，会触发所有订阅者，一起响应该事件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"PublishSubject"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="type">PublishSubject</span> example ---</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(d)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(d)</span><br></pre></td></tr></table></figure></p><h3 id="基于PublishSubject的几种补发式订阅源"><a href="#基于PublishSubject的几种补发式订阅源" class="headerlink" title="基于PublishSubject的几种补发式订阅源"></a>基于PublishSubject的几种补发式订阅源</h3><p>以下几种类型的订阅源，相较第一种仅多了补发历史事件，姑且称为<code>补发式订阅源</code>。</p><h4 id="ReplaySubject先向最新订阅者补发所有已发生的事件"><a href="#ReplaySubject先向最新订阅者补发所有已发生的事件" class="headerlink" title="ReplaySubject先向最新订阅者补发所有已发生的事件"></a>ReplaySubject先向最新订阅者补发所有已发生的事件</h4><p>当<code>ReplaySubject</code>类型的订阅源，新增订阅者时，该类型的订阅源会把之前已发送过的所有事件队列重新补发给这个最新订阅者。这样就迫使订阅者会对从历史的事件队列逐一响应。<br><code>bufferSize</code> 是缓冲区的大小，决定了补发队列的最大值。如果 <code>bufferSize</code> 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"ReplaySubject"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="type">ReplaySubject</span> example ---</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b) <span class="comment">// 补了一个 b</span></span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(d)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(d)</span><br></pre></td></tr></table></figure></p><h4 id="BehaviorSubject-先向最新订阅者补发最近一次历史事件"><a href="#BehaviorSubject-先向最新订阅者补发最近一次历史事件" class="headerlink" title="BehaviorSubject 先向最新订阅者补发最近一次历史事件"></a>BehaviorSubject 先向最新订阅者补发最近一次历史事件</h4><p><code>BehaviorSubject</code>类型的订阅源会向最新订阅者发送最近一次的历史事件队列，如果没有则发送一个默认值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"BehaviorSubject"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"z"</span>)</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="type">BehaviorSubject</span> example ---</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(z)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Completed</span></span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Completed</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h4><p><code>Variable</code> 是基于 <code>BehaviorSubject</code> 的一层封装，它的优势是：不会被显式终结。<br>即：不会收到 <code>.Completed</code> 和 <code>.Error</code> 这类的终结事件，它会主动在析构的时候发送 <code>.Complete</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"Variable"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="string">"z"</span>)</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: variable)</span><br><span class="line">    variable.value = <span class="string">"a"</span></span><br><span class="line">    variable.value = <span class="string">"b"</span></span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: variable)</span><br><span class="line">    variable.value = <span class="string">"c"</span></span><br><span class="line">&#125;</span><br><span class="line">--- <span class="type">Variable</span> example ---</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(z)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(a)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(b)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Next</span>(<span class="built_in">c</span>)</span><br><span class="line"><span class="type">Subscription</span>: <span class="number">1</span>, event: <span class="type">Completed</span></span><br><span class="line"><span class="type">Subscription</span>: <span class="number">2</span>, event: <span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h2 id="支持订阅的嵌套函数"><a href="#支持订阅的嵌套函数" class="headerlink" title="支持订阅的嵌套函数"></a>支持订阅的嵌套函数</h2><h3 id="map-规则-遍历映射"><a href="#map-规则-遍历映射" class="headerlink" title="map{规则} 遍历映射"></a>map{规则} 遍历映射</h3><p>通过闭包中定义的规则将队列中的数据映射到新的队列中，支持订阅遍历事件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>[]</span><br><span class="line"><span class="comment">//效果</span></span><br><span class="line">[ x1, x2, ... , xn].<span class="built_in">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"map"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> originalSequence = sequenceOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    originalSequence.<span class="built_in">map</span>&#123; $<span class="number">0</span> * <span class="number">2</span> &#125;.subscribe&#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="built_in">map</span> example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">6</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h3 id="flatMap-嵌套式遍历映射"><a href="#flatMap-嵌套式遍历映射" class="headerlink" title="flatMap 嵌套式遍历映射"></a>flatMap 嵌套式遍历映射</h3><p>嵌套式遍历描述：在遍历当前队列的过程中，每次执行闭包时都会遍历另一个嵌套队列中的所有事件。<br>可以想象嵌套for 循环来理解。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"flatMap"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceInt = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> sequenceString = sequenceOf(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"--"</span>)</span><br><span class="line">    sequenceInt.flatMap&#123; int <span class="keyword">in</span> sequenceString &#125;.subscribe&#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- flatMap example ---</span><br><span class="line"><span class="type">Next</span>(<span class="type">A</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span>)</span><br><span class="line"><span class="type">Next</span>(--)</span><br><span class="line"><span class="type">Next</span>(<span class="type">A</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span>)</span><br><span class="line"><span class="type">Next</span>(--)</span><br><span class="line"><span class="type">Next</span>(<span class="type">A</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span>)</span><br><span class="line"><span class="type">Next</span>(--)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h3 id="scan-initial-U-combine-U-T-gt-U-迭代映射"><a href="#scan-initial-U-combine-U-T-gt-U-迭代映射" class="headerlink" title="scan(initial:U,combine:(U, T) -&gt; U)迭代映射"></a>scan(initial:U,combine:(U, T) -&gt; U)迭代映射</h3><p>scan 有点像 reduce ，把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"scan"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceToSum = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    sequenceToSum.scan(<span class="number">0</span>) &#123; acum, elem <span class="keyword">in</span> acum + elem &#125;</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- scan example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">0</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">6</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">10</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">15</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h2 id="Filtering-支持订阅的过滤器"><a href="#Filtering-支持订阅的过滤器" class="headerlink" title="Filtering 支持订阅的过滤器"></a>Filtering 支持订阅的过滤器</h2><h3 id="filter-布尔语句-条件过滤法"><a href="#filter-布尔语句-条件过滤法" class="headerlink" title="filter{布尔语句} 条件过滤法"></a>filter{布尔语句} 条件过滤法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"filter"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> subscription = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;.subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="built_in">filter</span> example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">0</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">6</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">8</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure><h3 id="distinctUntilChanged-去重过滤法（相邻且不重复）"><a href="#distinctUntilChanged-去重过滤法（相邻且不重复）" class="headerlink" title="distinctUntilChanged() 去重过滤法（相邻且不重复）"></a>distinctUntilChanged() 去重过滤法（相邻且不重复）</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"distinctUntilChanged"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .distinctUntilChanged().subscribe&#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- distinctUntilChanged example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure><h3 id="take-int-掐尖过滤法"><a href="#take-int-掐尖过滤法" class="headerlink" title="take(int) 掐尖过滤法"></a>take(int) 掐尖过滤法</h3><p><code>take</code>只获取队列中前 n 个事件，在满足数量之后会自动 <code>.Completed</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"take"</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">.take(<span class="number">3</span>).subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">--- take example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p><h2 id="Combining-订阅源聚合器"><a href="#Combining-订阅源聚合器" class="headerlink" title="Combining 订阅源聚合器"></a>Combining 订阅源聚合器</h2><p>订阅源聚合器将多个可观察者（订阅源）合并成一个可观察者（聚合订阅源），这样更便于订阅者同时监听多个订阅源。</p><h3 id="startWith-向可观察者队列中添加排头兵（新增的可观察者）"><a href="#startWith-向可观察者队列中添加排头兵（新增的可观察者）" class="headerlink" title="startWith 向可观察者队列中添加排头兵（新增的可观察者）"></a>startWith 向可观察者队列中添加排头兵（新增的可观察者）</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription = sequenceOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).startWith(<span class="number">3</span>).subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">--- startWith example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">5</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">6</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure><h3 id="combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件"><a href="#combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件" class="headerlink" title="combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件"></a>combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件</h3><p>便于订阅者监听聚合订阅源中每个订阅源的最后一次事件数据<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 1"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    combineLatest(intOb1, intOb2) &#123;<span class="string">"\($0) \($1)"</span>&#125;.subscribe &#123;  <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- combineLatest <span class="number">1</span> example ---</span><br><span class="line"><span class="type">Next</span>(<span class="type">A</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h3 id="zip-intOb1-intOb2-拉链式合并"><a href="#zip-intOb1-intOb2-拉链式合并" class="headerlink" title="zip(intOb1, intOb2) 拉链式合并"></a>zip(intOb1, intOb2) 拉链式合并</h3><p>仅在凑齐聚合源中所有订阅源的事件时，才会聚合一次，触发订阅者的响应。可以将多达8个订阅源<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"zip 1"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="built_in">zip</span>(intOb1, intOb2) &#123; <span class="string">"\($0) \($1)"</span> &#125;.subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>)&#125;</span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"C"</span>))</span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- <span class="built_in">zip</span> <span class="number">1</span> example ---</span><br><span class="line"><span class="type">Next</span>(<span class="type">A</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="type">B</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h3 id="merge-按可观察者的新的事件次序合并队列"><a href="#merge-按可观察者的新的事件次序合并队列" class="headerlink" title="merge() 按可观察者的新的事件次序合并队列"></a>merge() 按可观察者的新的事件次序合并队列</h3><p>订阅者会按次序来响应聚合订阅源的每一件事件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"merge 1"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    sequenceOf(subject1, subject2).merge().subscribeNext &#123; int <span class="keyword">in</span> <span class="built_in">print</span>(int)&#125;</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- merge <span class="number">1</span> example ---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><h3 id="switchLatest订阅源切换器：用于嵌套式订阅源"><a href="#switchLatest订阅源切换器：用于嵌套式订阅源" class="headerlink" title="switchLatest订阅源切换器：用于嵌套式订阅源"></a>switchLatest订阅源切换器：用于嵌套式订阅源</h3><p>通过切换（var3.value）嵌套的订阅源，来切换订阅者当前监听的订阅源，以响应当前订阅源中的可观察者的事件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"switchLatest"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> var1 = <span class="type">Variable</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> var2 = <span class="type">Variable</span>(<span class="number">200</span>)</span><br><span class="line">    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></span><br><span class="line">    <span class="keyword">let</span> var3 = <span class="type">Variable</span>(var1)</span><br><span class="line">    <span class="keyword">let</span> d = var3.switchLatest().subscribe&#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    var1.value = <span class="number">1</span></span><br><span class="line">    var1.value = <span class="number">2</span></span><br><span class="line">    var1.value = <span class="number">3</span></span><br><span class="line">    var1.value = <span class="number">4</span></span><br><span class="line">    var3.value = var2</span><br><span class="line">    var2.value = <span class="number">201</span></span><br><span class="line">    var1.value = <span class="number">5</span></span><br><span class="line">    var3.value = var1</span><br><span class="line">    var2.value = <span class="number">202</span></span><br><span class="line">    var1.value = <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">--- switchLatest example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">0</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">4</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">200</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">201</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">5</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><h2 id="订阅器"><a href="#订阅器" class="headerlink" title="订阅器"></a>订阅器</h2><ol><li>订阅器：<code>subscribe</code> 用来订阅可观察者的事件队列（即订阅源），并指定响应的相关操作</li><li>Next订阅器：<code>subscribeNext</code> 只订阅 <code>.Next</code> 事件</li><li>Completed订阅器：<code>subscribeCompleted</code> 只订阅<code>.Completed</code> 完成事件</li><li>Error订阅器：<code>subscribeError</code> 订阅 <code>.Error</code> 失败事件</li><li>订阅器观察者：<code>doOn</code> 在订阅器执行之前，获得执行代码的机会。可对比理解：<code>swift中的属性观察者</code></li></ol><h2 id="控制take掐尖过滤器"><a href="#控制take掐尖过滤器" class="headerlink" title="控制take掐尖过滤器"></a>控制take掐尖过滤器</h2><p>过滤器通过指定的事件和状态语句来判断是否停止take</p><h3 id="takeUntil-得到指定事件之后触发-Completed-事件"><a href="#takeUntil-得到指定事件之后触发-Completed-事件" class="headerlink" title="takeUntil 得到指定事件之后触发 .Completed 事件"></a>takeUntil 得到指定事件之后触发 .Completed 事件</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"takeUntil"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> originalSequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> whenThisSendsNextWorldStops = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    originalSequence.takeUntil(whenThisSendsNextWorldStops)</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    whenThisSendsNextWorldStops.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- takeUntil example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">2</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure><h3 id="takeWhile-判断语句"><a href="#takeWhile-判断语句" class="headerlink" title="takeWhile 判断语句"></a>takeWhile 判断语句</h3><p>takeWhile 则是可以通过状态语句判断是否继续 take 。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"takeWhile"</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    sequence.takeWhile &#123; int <span class="keyword">in</span> int &lt; <span class="number">2</span> &#125;.subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line">--- takeWhile example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Completed</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互动性的教学工具XCPlayground</title>
      <link href="/2017/03/02/swift/%E4%BA%92%E5%8A%A8%E6%80%A7%E7%9A%84%E6%95%99%E5%AD%A6%E5%B7%A5%E5%85%B7XCPlayground/"/>
      <url>/2017/03/02/swift/%E4%BA%92%E5%8A%A8%E6%80%A7%E7%9A%84%E6%95%99%E5%AD%A6%E5%B7%A5%E5%85%B7XCPlayground/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。</p><ol><li>演习框架API，了解框架结构<br><a href="https://github.com/objcio/PersonalSwiftPlaygrounds" target="_blank" rel="noopener">SceneKitMac.playground</a><br>是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。</li><li>测试驱动开发<br>我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。</li></ol><h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p><blockquote><p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p></blockquote><h2 id="导入Frameworks"><a href="#导入Frameworks" class="headerlink" title="导入Frameworks"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p><h3 id="手动配置cocoa-touch-Framework来桥接playground"><a href="#手动配置cocoa-touch-Framework来桥接playground" class="headerlink" title="手动配置cocoa touch Framework来桥接playground"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p><ol><li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li><li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li><li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li><li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li><li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li><li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li><li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li></ol><h3 id="导入cocopads管理的依赖库"><a href="#导入cocopads管理的依赖库" class="headerlink" title="导入cocopads管理的依赖库"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href="http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#" target="_blank" rel="noopener">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在写入磁盘之前，修改一些工程的配置:</span></span><br><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line">    installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        <span class="keyword">if</span> target.name != <span class="string">'CocoaAsyncSocket'</span></span><br><span class="line">            <span class="comment">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'CONFIGURATION_BUILD_DIR'</span>] = <span class="string">'$PODS_CONFIGURATION_BUILD_DIR'</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></span><br><span class="line">                <span class="comment">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></span><br><span class="line">                puts <span class="string">"SWIFT_VERSIION:"</span></span><br><span class="line">                config.build_settings[<span class="string">'SWIFT_VERSION'</span>] = <span class="string">"3.0.1"</span></span><br><span class="line">                puts config.build_settings[<span class="string">'SWIFT_VERSION'</span>]</span><br><span class="line">            end</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#输出操作</span></span><br><span class="line">            puts <span class="string">"以下不能在playground中使用的库名："</span></span><br><span class="line">            puts target.name</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h2 id="Playground沙盒Resources"><a href="#Playground沙盒Resources" class="headerlink" title="Playground沙盒Resources"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p><h2 id="本地-bundle访问本地资源"><a href="#本地-bundle访问本地资源" class="headerlink" title="本地 bundle访问本地资源"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonPath = <span class="type">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class="string">"weather.json"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span></span><br><span class="line">jsonData = <span class="type">NSData</span>(contentsOfFile: jsonPath),</span><br><span class="line">json = <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(jsonData, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="共享-访问Documents共享目录"><a href="#共享-访问Documents共享目录" class="headerlink" title="共享 访问Documents共享目录"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p><p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sharedImagePath = <span class="type">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class="string">"image.png"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlaygroundSupport"><a href="#PlaygroundSupport" class="headerlink" title="PlaygroundSupport"></a>PlaygroundSupport</h2><h3 id="liveView视图代理"><a href="#liveView视图代理" class="headerlink" title="liveView视图代理"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> liveView: <span class="type">XCPlaygroundLiveViewable?</span></span><br></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p><ol><li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li><li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li><li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = <span class="type">UIView</span>()／<span class="type">NSViewController</span>()</span><br></pre></td></tr></table></figure></li></ol><h3 id="捕获值（XCPCaptureValue在XCPlayground中过时）"><a href="#捕获值（XCPCaptureValue在XCPlayground中过时）" class="headerlink" title="捕获值（XCPCaptureValue在XCPlayground中过时）"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href="http://swifter.tips/playground-capture/" target="_blank" rel="noopener">冒泡排序可视化预览</a><br><figure class="highlight swift"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This function has been deprecated.</span></span><br><span class="line"><span class="meta">@available</span>(*, deprecated)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">XCPCaptureValue</span>&lt;T&gt;<span class="params">(identifier: String, value: T)</span></span></span><br></pre></td></tr></table></figure></p><p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p><ol><li>使用：导入框架<code>import XCPlayground</code></li><li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li></ol><p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p><p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCPlayground</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> forecast <span class="keyword">in</span> forecasts </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> tempString = forecast[<span class="string">"temp"</span>]?[<span class="string">"english"</span>] <span class="keyword">as</span>? <span class="type">String</span>, temperature = tempString.toInt()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">XCPCaptureValue</span>(<span class="string">"Temperature"</span>, temperature)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p><h3 id="异步执行（Asynchronous-Execution）"><a href="#异步执行（Asynchronous-Execution）" class="headerlink" title="异步执行（Asynchronous Execution）"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> needsIndefiniteExecution: <span class="type">Bool</span></span><br></pre></td></tr></table></figure></p><ol><li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li><li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://httpbin.org/image/png"</span>)!</span><br><span class="line"><span class="keyword">let</span> task = <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</span><br><span class="line">    data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//手动终止</span></span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.currentPage.finishExecution()</span><br><span class="line">&#125;</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure><h2 id="支持Markdown格式的文档"><a href="#支持Markdown格式的文档" class="headerlink" title="支持Markdown格式的文档"></a>支持Markdown格式的文档</h2><p><a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/" target="_blank" rel="noopener">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p><p>不同于<a href="http://nshipster.cn/swift-documentation/" target="_blank" rel="noopener">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p><p><code>xcode</code>切换备注以<code>Markdown</code>格式显示：</p><ol><li>选择<code>Editor → Show Rendered Markup</code> 菜单</li><li>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。<blockquote><p>在xcode8中打开之前版本时，菜单上的<code>Show Rendered Markup</code>会显示为<code>Upgrade playgound...</code>升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。</p></blockquote></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: This line will have **bold** and *italic* text.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*:</span></span><br><span class="line"><span class="comment">## Headers of All Sizes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Lists of Links</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- [NSHipster](http://nshipster.com)</span></span><br><span class="line"><span class="comment">- [ASCIIwwdc](http://asciiwwdc.com)</span></span><br><span class="line"><span class="comment">- [SwiftDoc](http://swiftdoc.org)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Images, Too</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</span></span><br><span class="line"><span class="comment">![Local Image](bomb.gif) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*Images in the Resources directory can be referenced locally*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> playground </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Cocoapods创建私有podspec</title>
      <link href="/2017/02/28/macOS/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89podspec/"/>
      <url>/2017/02/28/macOS/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89podspec/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="创建一个版本库来托管pod索引-pod-repo-add命令"><a href="#创建一个版本库来托管pod索引-pod-repo-add命令" class="headerlink" title="创建一个版本库来托管pod索引:pod repo add命令"></a>创建一个版本库来托管pod索引:pod repo add命令</h2><p>第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br>第二步：pod化版本库，使其专门用户管理个人的<code>*podspec</code>索引文件<br><figure class="highlight ruby"><figcaption><span>repo add命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></span><br><span class="line">$ pod repo add PodRepo <span class="symbol">https:</span>/<span class="regexp">/github.com/huos</span>3203/PodRepo.git</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">&gt; Cloning spec repo <span class="string">`PodRepo`</span> from <span class="string">`https://github.com/huos3203/PodRepo.git`</span></span><br></pre></td></tr></table></figure><br>此时在本地会生成<code>~/.cocoapods/repos/PodRepo</code>目录，这个目录就可以用来存储你所有的开源包。<br>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class="highlight ruby"><figcaption><span>lib create命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push PodRepo LogSwift.podspec  <span class="comment">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：</p><p>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p><p>下面详述<code>podspec文件</code>的配置，检测，使用的过程。</p><h2 id="使用模板命令创建Pod工程项目-lib-create"><a href="#使用模板命令创建Pod工程项目-lib-create" class="headerlink" title="使用模板命令创建Pod工程项目 lib create"></a>使用模板命令创建Pod工程项目 lib create</h2><p>初始化Pod模板项目：<br><figure class="highlight ruby"><figcaption><span>lib create命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create LogSwift</span><br></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class="highlight ruby"><figcaption><span>交互</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">What is your email?</span><br><span class="line">&gt; </span><br><span class="line">What language <span class="keyword">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class="line">&gt;Swift</span><br><span class="line">Would you like to <span class="keyword">include</span> a demo application with your library? [ Yes / No ]</span><br><span class="line">&gt;Yes</span><br><span class="line">Which testing frameworks will you use? [ Quick / None ]</span><br><span class="line">&gt;Quick</span><br><span class="line">Would you like to <span class="keyword">do</span> view based testing? [ Yes / No ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p><h3 id="添加库文件和资源"><a href="#添加库文件和资源" class="headerlink" title="添加库文件和资源"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p><h3 id="配置podspec文件及验证命令lib-lint"><a href="#配置podspec文件及验证命令lib-lint" class="headerlink" title="配置podspec文件及验证命令lib lint"></a>配置podspec文件及验证命令lib lint</h3><h4 id="打tag号作为podspec版本号"><a href="#打tag号作为podspec版本号" class="headerlink" title="打tag号作为podspec版本号"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class="highlight ruby"><figcaption><span>打标签</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -m <span class="string">"first release"</span> <span class="number">0</span>.<span class="number">1.0</span></span><br><span class="line">$ git push --tags     <span class="comment">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p><h4 id="编辑podspec文件"><a href="#编辑podspec文件" class="headerlink" title="编辑podspec文件"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class="highlight ruby"><figcaption><span>podspec文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">s.name             = <span class="string">"PodTestLibrary"</span>    <span class="comment">#名称</span></span><br><span class="line">s.version          = <span class="string">"0.1.0"</span>             <span class="comment">#版本号</span></span><br><span class="line">s.summary          = <span class="string">"Just Testing."</span>     <span class="comment">#简短介绍，下面是详细介绍</span></span><br><span class="line">s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">Testing Private Podspec.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* Markdown format.</span></span><br><span class="line"><span class="string">* Don't worry about the indent, we strip it!</span></span><br><span class="line"><span class="string">DESC</span></span><br><span class="line">s.homepage         = <span class="string">"https://coding.net/u/boyers/p/podTestLibrary"</span>                           <span class="comment">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class="line"><span class="comment"># s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"           #截图</span></span><br><span class="line">s.license          = <span class="string">'MIT'</span>              <span class="comment">#开源协议</span></span><br><span class="line">s.author           = &#123; <span class="string">"boyers"</span> =&gt; <span class="string">"boyers@foxmail.com"</span> &#125;  <span class="comment">#作者信息</span></span><br><span class="line">s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://coding.net/boyers/podTestLibrary.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"0.1.0"</span> &#125;      <span class="comment">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></span><br><span class="line"><span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></span><br><span class="line"></span><br><span class="line">s.platform     = <span class="symbol">:ios</span>, <span class="string">'7.0'</span>            <span class="comment">#支持的平台及版本</span></span><br><span class="line">s.requires_arc = <span class="literal">true</span>                   <span class="comment">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></span><br><span class="line"></span><br><span class="line">s.source_files = <span class="string">'Pod/Classes/**/*'</span>     <span class="comment">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line"><span class="string">'PodTestLibrary'</span> =&gt; [<span class="string">'Pod/Assets/*.png'</span>]</span><br><span class="line">&#125;                                       <span class="comment">#资源文件地址</span></span><br><span class="line"></span><br><span class="line">s.public_header_files = <span class="string">'Pod/Classes/**/*.h'</span>   <span class="comment">#公开头文件地址</span></span><br><span class="line">s.frameworks = <span class="string">'UIKit'</span>                  <span class="comment">#所需的framework，多个用逗号隔开</span></span><br><span class="line">s.dependency <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3'</span>   <span class="comment">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="验证podspec文件可用性"><a href="#验证podspec文件可用性" class="headerlink" title="验证podspec文件可用性"></a>验证podspec文件可用性</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-&gt; PodTestLibrary (<span class="number">0</span>.<span class="number">1.0</span>)</span><br><span class="line">PodTestLibrary passed validation.</span><br></pre></td></tr></table></figure><p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p><h3 id="将源码托管到远程仓库"><a href="#将源码托管到远程仓库" class="headerlink" title="将源码托管到远程仓库"></a>将源码托管到远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class="highlight ruby"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -s -m <span class="string">"Initial Commit of Library"</span></span><br><span class="line">$ git remote add origin <span class="symbol">https:</span>/<span class="regexp">/coding.net/git</span><span class="regexp">/LogSwift.git   #添加远端仓库</span></span><br><span class="line"><span class="regexp">$ git push origin master        #提交到远端仓库</span></span><br></pre></td></tr></table></figure></p><h2 id="手动配置Pod私库项目支持：spec-create"><a href="#手动配置Pod私库项目支持：spec-create" class="headerlink" title="手动配置Pod私库项目支持：spec create"></a>手动配置Pod私库项目支持：spec create</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create LogSwift git@coding.<span class="symbol">net:</span>boyers/LogSwift.git</span><br></pre></td></tr></table></figure><p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p><h2 id="path-gt-在新项目配置检测podspec文件"><a href="#path-gt-在新项目配置检测podspec文件" class="headerlink" title=":path =&gt; 在新项目配置检测podspec文件"></a>:path =&gt; 在新项目配置检测podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。</p><ol><li>指定本地依赖的两种方式:<figure class="highlight ruby"><figcaption><span>Podfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'LogSwift'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class="comment"># 指定路径</span></span><br><span class="line">pod <span class="string">'LogSwift'</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class="comment"># 指定podspec文件</span></span><br></pre></td></tr></table></figure></li><li>指定源码的远程仓库作为依赖<br>前提时索引文件中指定的tag版本的源码必须推送到远程仓库<figure class="highlight ruby"><figcaption><span>Podfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'MusicLrc'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/huos3203/MusicLrcTest.git'</span></span><br></pre></td></tr></table></figure></li></ol><p>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p><h2 id="万事具备，向私有索引库中提交podspec文件：repo-push"><a href="#万事具备，向私有索引库中提交podspec文件：repo-push" class="headerlink" title="万事具备，向私有索引库中提交podspec文件：repo push"></a>万事具备，向私有索引库中提交podspec文件：repo push</h2><p>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class="highlight ruby"><figcaption><span>lib create命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push PodRepo LogSwift.podspec  <span class="comment">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：</p><p>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p><h2 id="trunk-push-添加到Cocoapods的官方索引库"><a href="#trunk-push-添加到Cocoapods的官方索引库" class="headerlink" title="trunk push 添加到Cocoapods的官方索引库"></a>trunk push 添加到Cocoapods的官方索引库</h2><h3 id="注册trunk，邮箱验证"><a href="#注册trunk，邮箱验证" class="headerlink" title="注册trunk，邮箱验证"></a>注册trunk，邮箱验证</h3><p>在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:<br>sudo gem install cocoapods<br>开始注册trunk：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register boyer@163.com <span class="string">'boyers1250'</span>  --verbose</span><br></pre></td></tr></table></figure><br><code>-verbose</code>参数是为了便于输出注册过程中的调试信息。<br>执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。<br>使用下面的命令可以向trunk服务器查询自己的注册信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure></p><h3 id="通过trunk推送podspec文件"><a href="#通过trunk推送podspec文件" class="headerlink" title="通过trunk推送podspec文件"></a>通过trunk推送podspec文件</h3><p>现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：</p><ol><li>确保你的源码已经push到Github上。</li><li>确保你所push的代码已经打上”version tag”版本号标签：<br>只有确保了以上两点，CocoaPods才能更准确地找到你的repo。<br>现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push WZLBadge.podspec</span><br></pre></td></tr></table></figure>执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。</li></ol><h2 id="使用远程的私有Pod库"><a href="#使用远程的私有Pod库" class="headerlink" title="使用远程的私有Pod库"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p><ol><li>pod search 查找库<figure class="highlight ruby"><figcaption><span>查找库</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pod search PodTestLibrary</span><br><span class="line"></span><br><span class="line">-&gt; PodTestLibrary (<span class="number">0</span>.<span class="number">1.0</span>)</span><br><span class="line">Just Testing.</span><br><span class="line">pod <span class="string">'PodTestLibrary'</span>, <span class="string">'~&gt; 0.1.0'</span></span><br><span class="line">- <span class="symbol">Homepage:</span> <span class="symbol">https:</span>/<span class="regexp">/coding.net/u</span><span class="regexp">/boyers/p</span><span class="regexp">/podTestLibrary</span></span><br><span class="line"><span class="regexp">- Source:   https:/</span><span class="regexp">/coding.net/boyers</span><span class="regexp">/podTestLibrary.git</span></span><br><span class="line"><span class="regexp">- Versions: 0.1.0 [WTSpecs repo]</span></span><br></pre></td></tr></table></figure></li><li>在Podfile文件中配置库依赖<figure class="highlight ruby"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'PodTestLibrary'</span>, <span class="string">'~&gt; 0.1.0'</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="更新维护podspec文件配置，升级库版本"><a href="#更新维护podspec文件配置，升级库版本" class="headerlink" title="更新维护podspec文件配置，升级库版本"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p><h3 id="添加模块库文件和资源"><a href="#添加模块库文件和资源" class="headerlink" title="添加模块库文件和资源"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p><h3 id="打tag号作为podspec版本号-1"><a href="#打tag号作为podspec版本号-1" class="headerlink" title="打tag号作为podspec版本号"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class="highlight ruby"><figcaption><span>打标签</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -m <span class="string">"first release"</span> <span class="number">0</span>.<span class="number">1.0</span></span><br><span class="line">$ git push --tags     <span class="comment">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p><h3 id="更新podspec配置文件"><a href="#更新podspec配置文件" class="headerlink" title="更新podspec配置文件"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p><ol><li>源文件:<code>source_files</code></li><li>头文件:<code>public_header_files</code></li><li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class="highlight ruby"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">s.name             = <span class="string">"PodTestLibrary"</span></span><br><span class="line">s.version          = <span class="string">"1.0.0"</span></span><br><span class="line">s.summary          = <span class="string">"Just Testing."</span></span><br><span class="line">s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">                         Testing Private Podspec.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        * Markdown format.</span></span><br><span class="line"><span class="string">                        * Don't worry about the indent, we strip it!</span></span><br><span class="line"><span class="string">                    DESC</span></span><br><span class="line">s.homepage         = <span class="string">"https://coding.net/u/boyers/p/podTestLibrary"</span></span><br><span class="line"><span class="comment"># s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"</span></span><br><span class="line">s.license          = <span class="string">'MIT'</span></span><br><span class="line">s.author           = &#123; <span class="string">"boyers"</span> =&gt; <span class="string">"boyers@foxmail.com"</span> &#125;</span><br><span class="line">s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://coding.net/boyers/podTestLibrary.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"1.0.0"</span> &#125;</span><br><span class="line"><span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class="line"></span><br><span class="line">s.platform     = <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line">s.requires_arc = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#s.source_files = 'Pod/Classes/**/*'</span></span><br><span class="line"><span class="comment">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></span><br><span class="line"><span class="comment">#s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class="line"></span><br><span class="line">s.subspec <span class="string">'NetWorkEngine'</span> <span class="keyword">do</span> <span class="params">|networkEngine|</span></span><br><span class="line">    networkEngine.source_files = <span class="string">'Pod/Classes/NetworkEngine/**/*'</span></span><br><span class="line">    networkEngine.public_header_files = <span class="string">'Pod/Classes/NetworkEngine/**/*.h'</span></span><br><span class="line">    networkEngine.dependency <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s.subspec <span class="string">'DataModel'</span> <span class="keyword">do</span> <span class="params">|dataModel|</span></span><br><span class="line">    dataModel.source_files = <span class="string">'Pod/Classes/DataModel/**/*'</span></span><br><span class="line">    dataModel.public_header_files = <span class="string">'Pod/Classes/DataModel/**/*.h'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s.subspec <span class="string">'CommonTools'</span> <span class="keyword">do</span> <span class="params">|commonTools|</span></span><br><span class="line">    commonTools.source_files = <span class="string">'Pod/Classes/CommonTools/**/*'</span></span><br><span class="line">    commonTools.public_header_files = <span class="string">'Pod/Classes/CommonTools/**/*.h'</span></span><br><span class="line">    commonTools.dependency <span class="string">'OpenUDID'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s.subspec <span class="string">'UIKitAddition'</span> <span class="keyword">do</span> <span class="params">|ui|</span></span><br><span class="line">    ui.source_files = <span class="string">'Pod/Classes/UIKitAddition/**/*'</span></span><br><span class="line">    ui.public_header_files = <span class="string">'Pod/Classes/UIKitAddition/**/*.h'</span></span><br><span class="line">    ui.resource = <span class="string">"Pod/Assets/MLSUIKitResource.bundle"</span></span><br><span class="line">    ui.dependency <span class="string">'PodTestLibrary/CommonTools'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s.frameworks = <span class="string">'UIKit'</span></span><br><span class="line">    <span class="comment">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class="line">    <span class="comment">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。<blockquote><p>但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UIStackView教程了解StackView</title>
      <link href="/2017/02/25/iOS/UI/UIStackView%E6%95%99%E7%A8%8B%E4%BA%86%E8%A7%A3StackView/"/>
      <url>/2017/02/25/iOS/UI/UIStackView%E6%95%99%E7%A8%8B%E4%BA%86%E8%A7%A3StackView/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://blog.csdn.net/kmyhy/article/details/50456444" target="_blank" rel="noopener">原地址</a></p><h2 id="UIStackView简单介绍"><a href="#UIStackView简单介绍" class="headerlink" title="UIStackView简单介绍"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br>Leading:<br>Center:<br>Trailing:</p><p>布局方式对比</p><h3 id="添加一个新的Stack-View"><a href="#添加一个新的Stack-View" class="headerlink" title="添加一个新的Stack View"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br>另一种解散的方法是选中Stack View，然后点击<code>Editor\Emebed in\stack view</code>菜单。</p><h3 id="解散一个废弃的Stack-View"><a href="#解散一个废弃的Stack-View" class="headerlink" title="解散一个废弃的Stack View"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br>另一种解散的方法是选中Stack View，然后点击<code>Editor\Unemebed</code>菜单。</p><h2 id="使用场景描述"><a href="#使用场景描述" class="headerlink" title="使用场景描述"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p><ol><li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li><li>使用第三方库来实现</li><li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li></ol><p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p><h2 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h2><p>存在着这几方面的问题:</p><h3 id="问题一：自适应横竖屏"><a href="#问题一：自适应横竖屏" class="headerlink" title="问题一：自适应横竖屏"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。</p><h3 id="问题二：控件间留白不紧凑"><a href="#问题二：控件间留白不紧凑" class="headerlink" title="问题二：控件间留白不紧凑"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。</p><h3 id="Storyboard引入界面"><a href="#Storyboard引入界面" class="headerlink" title="Storyboard引入界面"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空标签和按钮的背景色</span></span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> backgroundColoredViews </span><br><span class="line">&#123;</span><br><span class="line">    view.backgroundColor = <span class="type">UIColor</span>.clearColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Size类便于使用storyboard"><a href="#Size类便于使用storyboard" class="headerlink" title="Size类便于使用storyboard"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。</p><h2 id="创建水平UIStackView"><a href="#创建水平UIStackView" class="headerlink" title="创建水平UIStackView"></a>创建水平<code>UIStackView</code></h2><h3 id="按钮模块"><a href="#按钮模块" class="headerlink" title="按钮模块"></a>按钮模块</h3><ol><li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：</li><li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li></ol><p>这些按钮被嵌到一个新的Stack View中：</p><h4 id="给新的Stack-View添加布局约束"><a href="#给新的Stack-View添加布局约束" class="headerlink" title="给新的Stack View添加布局约束"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p><p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p><ol start="4"><li>自动布局工具栏中的Pin按钮,添加一个约束</li></ol><p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Trailing</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：</p><h4 id="按钮等间距分布"><a href="#按钮等间距分布" class="headerlink" title="按钮等间距分布"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：</p><h5 id="使用等宽约束的Spacer-View实现"><a href="#使用等宽约束的Spacer-View实现" class="headerlink" title="使用等宽约束的Spacer View实现"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p><h5 id="Distribution属性：沿轴向水平分布"><a href="#Distribution属性：沿轴向水平分布" class="headerlink" title="Distribution属性：沿轴向水平分布"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！</p><h3 id="Rating版块"><a href="#Rating版块" class="headerlink" title="Rating版块"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br>然后点击Stack按钮将它们嵌到一个Stack View中：<br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">20</span></span><br></pre></td></tr></table></figure><br>打开属性面板，将间距设置为8：<br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br>编译运行，进行测试</p><h2 id="创建垂直的Stack-View"><a href="#创建垂直的Stack-View" class="headerlink" title="创建垂直的Stack View"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p><h3 id="WHY-VISIT模块"><a href="#WHY-VISIT模块" class="headerlink" title="WHY VISIT模块"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br>点击Stack 按钮将二者嵌到一个Stack View：</p><h4 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br>最后点击Add 4 Constraints按钮。显示结果如下图所示：</p><h4 id="alignment属性：轴向的垂直方向"><a href="#alignment属性：轴向的垂直方向" class="headerlink" title="alignment属性：轴向的垂直方向"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p><p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p><p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p><p>我们将用另外一个Stack View来说明这个问题。</p><h2 id="垂直／水平Stack-View嵌套使用"><a href="#垂直／水平Stack-View嵌套使用" class="headerlink" title="垂直／水平Stack View嵌套使用"></a>垂直／水平Stack View嵌套使用</h2><h3 id="Weather版块"><a href="#Weather版块" class="headerlink" title="Weather版块"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。</p><h4 id="垂直stackView"><a href="#垂直stackView" class="headerlink" title="垂直stackView"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：</p><h4 id="水平StackView中出现按钮拉伸标签的问题"><a href="#水平StackView中出现按钮拉伸标签的问题" class="headerlink" title="水平StackView中出现按钮拉伸标签的问题"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p><h4 id="垂直stack-View1-嵌套WEATHER标签和标签"><a href="#垂直stack-View1-嵌套WEATHER标签和标签" class="headerlink" title="垂直stack View1:嵌套WEATHER标签和标签"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br>点击 Stack 按钮：<br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Top</span>: <span class="number">20</span>, <span class="type">Leading</span>: <span class="number">0</span>, <span class="type">Trailing</span>: <span class="number">0</span>, <span class="type">Bottom</span>: <span class="number">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p><p>当然，底下的标签宽度还是需要100%占满的。</p><p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p><h4 id="垂直stack-View2-仅嵌套WEATHER标签"><a href="#垂直stack-View2-仅嵌套WEATHER标签" class="headerlink" title="垂直stack View2: 仅嵌套WEATHER标签"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br>然后点击Stack 按钮：<br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：</p><h4 id="按钮和WEATHER标签两个约束"><a href="#按钮和WEATHER标签两个约束" class="headerlink" title="按钮和WEATHER标签两个约束"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。</p><h2 id="顶级-Stack-View"><a href="#顶级-Stack-View" class="headerlink" title="顶级 Stack View"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br>然后点击 Stack 按钮：<br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br>编译运行：<br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p><p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：</p><h2 id="重新调整视图位置"><a href="#重新调整视图位置" class="headerlink" title="重新调整视图位置"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p><p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：</p><p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p><p>点击 Hide 按钮，选中它：</p><p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br>现在 Hide 按钮将回到正确的位置：</p><h2 id="基于配置的-Size-类"><a href="#基于配置的-Size-类" class="headerlink" title="基于配置的 Size 类"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p><p>选择顶层 Stack View，点击 Spacing 前面的+按钮：</p><p>选择 Any Width &gt; Compact Height：</p><p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p><p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p><p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p><p>将方法的最后一行：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> animated </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p><p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip" target="_blank" rel="noopener">开始项目源码</a><br><a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip" target="_blank" rel="noopener">完整项目源码</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 控件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改设备屏幕上显示的应用程序图标下方的名称</title>
      <link href="/2017/02/24/iOS/UI/%E6%9B%B4%E6%94%B9%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E4%B8%8B%E6%96%B9%E7%9A%84%E5%90%8D%E7%A7%B0/"/>
      <url>/2017/02/24/iOS/UI/%E6%9B%B4%E6%94%B9%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E4%B8%8B%E6%96%B9%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>修改APP启动图标上的名称，需配置<code>Info.plist</code>文件，增加<code>CFBundleDisplayName</code>属性键值对。<br>进入到如下界面：<br><!--长宽设置百分比大小无效果--></p><p>在<code>Info.plist</code>文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。<br>如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。<br><!--长宽设置百分比大小无效果--></p><h2 id="agvtool自动增加版本号命令行工具"><a href="#agvtool自动增加版本号命令行工具" class="headerlink" title="agvtool自动增加版本号命令行工具"></a>agvtool自动增加版本号命令行工具</h2><p>版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。</p><p>注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。</p><p>注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。</p><h3 id="设置-Current-Project-Version-为选定的值"><a href="#设置-Current-Project-Version-为选定的值" class="headerlink" title="设置 Current Project Version 为选定的值"></a>设置 Current Project Version 为选定的值</h3><p>Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。<br>agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。</p><h3 id="设置-Versioning-System-为-Apple-Generic"><a href="#设置-Versioning-System-为-Apple-Generic" class="headerlink" title="设置 Versioning System 为 Apple Generic"></a>设置 Versioning System 为 Apple Generic</h3><p>默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。</p><p>注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。</p><h3 id="设置版本和编译号"><a href="#设置版本和编译号" class="headerlink" title="设置版本和编译号"></a>设置版本和编译号</h3><p>agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。<br>确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。</p><h3 id="版本号命令"><a href="#版本号命令" class="headerlink" title="版本号命令"></a>版本号命令</h3><p>退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。</p><ol><li><p>查看版本号：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agvtool what-marketing-version</span><br></pre></td></tr></table></figure></li><li><p>更新版本号</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agvtool new-marketing-version &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure><h3 id="编译号命令"><a href="#编译号命令" class="headerlink" title="编译号命令"></a>编译号命令</h3><ol><li><p>将编译号设置为指定版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agvtool new-version -all &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure></li><li><p>更新编译号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agvtool next-version -all</span><br></pre></td></tr></table></figure></li><li><p>查看当前编译号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agvtool what-version</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 经历 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高期望实现异步单元测试</title>
      <link href="/2017/02/21/%E6%B5%8B%E8%AF%95/%E9%AB%98%E6%9C%9F%E6%9C%9B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/02/21/%E6%B5%8B%E8%AF%95/%E9%AB%98%E6%9C%9F%E6%9C%9B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="异步单元测试"><a href="#异步单元测试" class="headerlink" title="异步单元测试"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p><h3 id="常规实现方式"><a href="#常规实现方式" class="headerlink" title="常规实现方式"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAsyncTheOldWay</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutDate = <span class="type">Date</span>.<span class="keyword">init</span>(timeIntervalSinceNow: <span class="number">5.0</span>)</span><br><span class="line">    <span class="keyword">var</span> responseHasArrived = <span class="literal">false</span></span><br><span class="line">    <span class="type">Alamofire</span>.request(<span class="string">"https://www.baidu.com"</span>).responseData&#123;response <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取到的数据长度：\(String(data: response.data!, </span></span><br><span class="line"><span class="string">                                   encoding:String.Encoding.utf8)!)"</span>)</span><br><span class="line">        responseHasArrived = <span class="literal">true</span></span><br><span class="line">        <span class="type">XCTAssert</span>((response.data?.<span class="built_in">count</span>)! &gt; <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (responseHasArrived == <span class="literal">false</span> </span><br><span class="line">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class="number">0</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">CFRunLoopRunInMode</span>(<span class="type">CFRunLoopMode</span>.defaultMode, <span class="number">0.01</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseHasArrived == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">XCTFail</span>(<span class="string">"Test timed out"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XCTest相关API"><a href="#XCTest相关API" class="headerlink" title="XCTest相关API"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p><h3 id="XCTestExpection-高期望-High-Expectations-的实现和使用"><a href="#XCTestExpection-高期望-High-Expectations-的实现和使用" class="headerlink" title="XCTestExpection:高期望(High Expectations)的实现和使用"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p><h4 id="expectation-description-为XCTest测试单元设置期望"><a href="#expectation-description-为XCTest测试单元设置期望" class="headerlink" title="expectation(description:):为XCTest测试单元设置期望"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class="line"><span class="keyword">let</span> expection = expectation(description: <span class="string">"失败时显示原因"</span>)</span><br></pre></td></tr></table></figure></p><h5 id="fulfill-调用它表示测试达到期望值"><a href="#fulfill-调用它表示测试达到期望值" class="headerlink" title="fulfill():调用它表示测试达到期望值"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- (void)fulfill;</span></span><br><span class="line">expection.fulfill()</span><br></pre></td></tr></table></figure></p><h4 id="waitForExpectations-timeout-handler-在方法底部设置测试期望的时效"><a href="#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效" class="headerlink" title="waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class="line">waitForExpectations(timeout: <span class="number">5</span>) &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"错误信息:\(error?.localizedDescription)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p><h4 id="expectation-forNotification-object-handler-通知期望"><a href="#expectation-forNotification-object-handler-通知期望" class="headerlink" title="expectation(forNotification:object:handler:):通知期望"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class="line"><span class="comment">//设置一个测试通知期望</span></span><br><span class="line">expectation(forNotification: <span class="string">"BLDownloadImageNotification"</span>, </span><br><span class="line">                     object: <span class="literal">nil</span>) </span><br><span class="line">&#123;(notification) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> userInfo = notification.userInfo <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">let</span> name = userInfo[<span class="string">"name"</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name:\(name)"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">来定义一个通知并发送通知，来测试：</span><br><span class="line"><span class="keyword">let</span> notif =  <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="keyword">self</span>, userInfo: [<span class="string">"name"</span>:<span class="string">"iTBoyer"</span>,<span class="string">"sex"</span>:<span class="string">"man"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class="line">waitForExpectations(timeout: <span class="number">3</span>, handler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><h5 id="使用expectation-description-实现"><a href="#使用expectation-description-实现" class="headerlink" title="使用expectation(description:)实现"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAsynForNotificationWithExpectation</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line">    <span class="keyword">let</span> notif = <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line">    <span class="keyword">let</span> sub = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: notif, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; (notification) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        expectation.fulfill()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送一个通知</span></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//waitForExpectations</span></span><br><span class="line">    waitForExpectations(timeout: <span class="number">1</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除通知</span></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="expectation-for-evaluatedWith-handler-谓词计算测试法"><a href="#expectation-for-evaluatedWith-handler-谓词计算测试法" class="headerlink" title="expectation(for:evaluatedWith:handler:):谓词计算测试法"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testThatBackgroundImageChanges</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> viewController = <span class="type">OnclickLikeViewController</span>()</span><br><span class="line">    <span class="comment">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = viewController.view</span><br><span class="line">    <span class="keyword">let</span> button = viewController.button</span><br><span class="line">    <span class="keyword">let</span> img = button.backgroundImage(<span class="keyword">for</span>: .normal)</span><br><span class="line">    <span class="type">XCTAssertNil</span>(img,<span class="string">"此时img不为nil,中止执行"</span>)  <span class="comment">//当img不是nil时，执行断言</span></span><br><span class="line">    <span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>.<span class="keyword">init</span> &#123; (anyobject, bindings) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">let</span> button = anyobject <span class="keyword">as</span>! <span class="type">UIButton</span></span><br><span class="line">        <span class="keyword">return</span> button.backgroundImage(<span class="keyword">for</span>: <span class="type">UIControlState</span>()) != <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    expectation(<span class="keyword">for</span>: predicate, evaluatedWith: button, handler: <span class="literal">nil</span>)</span><br><span class="line">    waitForExpectations(timeout: <span class="number">20</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用expectation-description-实现-1"><a href="#使用expectation-description-实现-1" class="headerlink" title="使用expectation(description:)实现"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testThatBackgroundImageChanges</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置期望</span></span><br><span class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"backgroundImageForState"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> viewController = <span class="type">OnclickLikeViewController</span>()</span><br><span class="line">    <span class="comment">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = viewController.view</span><br><span class="line">    <span class="keyword">let</span> button = viewController.button</span><br><span class="line">    <span class="keyword">let</span> img = button.backgroundImage(<span class="keyword">for</span>: .normal)</span><br><span class="line">    <span class="type">XCTAssertNil</span>(img,<span class="string">"此时img不为nil,中止执行"</span>)  <span class="comment">//当img不是nil时，执行断言</span></span><br><span class="line">    <span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>.<span class="keyword">init</span> &#123; (anyobject, bindings) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">let</span> button = anyobject <span class="keyword">as</span>! <span class="type">UIButton</span></span><br><span class="line">        <span class="keyword">return</span> button.backgroundImage(<span class="keyword">for</span>: <span class="type">UIControlState</span>()) != <span class="literal">nil</span></span><br><span class="line">        <span class="comment">//实现测试期望</span></span><br><span class="line">        expectation.fulfill()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待期望实现</span></span><br><span class="line">    waitForExpectations(timeout: <span class="number">20</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="传递expectation在目的方法中再fulfill-实现期望"><a href="#传递expectation在目的方法中再fulfill-实现期望" class="headerlink" title="传递expectation在目的方法中再fulfill()实现期望"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAsynForNotificationWithExpectation2</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.expectation(description: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> notif = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"BLDownloadImageNotification"</span>)</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(<span class="type">AsyncTheOldWayTest</span>.downLoadImage(<span class="number">_</span>:)), name: notif, object: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将期望封装在字典中传递</span></span><br><span class="line">        <span class="keyword">let</span> userInf = [<span class="string">"name"</span>:<span class="string">"iTBoyer"</span>,<span class="string">"sex"</span>:<span class="string">"man"</span>,<span class="string">"expectation"</span>:expectation]</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notif, object: <span class="keyword">self</span>, userInfo: userInf)</span><br><span class="line">        <span class="comment">//等待期望实现</span></span><br><span class="line">        waitForExpectations(timeout: <span class="number">1</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downLoadImage</span><span class="params">(<span class="number">_</span> notification:Notification)</span></span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">let</span> userInfo = notification.userInfo <span class="keyword">as</span>! [<span class="type">String</span>:<span class="type">AnyObject</span>]</span><br><span class="line">        <span class="keyword">let</span> name = userInfo[<span class="string">"name"</span>]</span><br><span class="line">        <span class="keyword">let</span> sex = userInfo[<span class="string">"sex"</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"name:\(name), sex = \(sex)"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> expectation = userInfo[<span class="string">"expectation"</span>] <span class="keyword">as</span>! <span class="type">XCTestExpectation</span></span><br><span class="line">        expectation.fulfill()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> UI </tag>
            
            <tag> 测试 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI自动测试学习</title>
      <link href="/2017/02/21/%E6%B5%8B%E8%AF%95/UI%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/02/21/%E6%B5%8B%E8%AF%95/UI%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="UI-Testing-和-Accessibility"><a href="#UI-Testing-和-Accessibility" class="headerlink" title="UI Testing 和 Accessibility"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p><p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p><h2 id="UI-Testing-API"><a href="#UI-Testing-API" class="headerlink" title="UI Testing API"></a>UI Testing API</h2><h3 id="XCUIApplication-获取APP实例"><a href="#XCUIApplication-获取APP实例" class="headerlink" title="XCUIApplication()获取APP实例"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p><h3 id="获取XCUIElementQuery对象的四种方式"><a href="#获取XCUIElementQuery对象的四种方式" class="headerlink" title="获取XCUIElementQuery对象的四种方式"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id="第一种简写形式：buttons-gt-XCUIElementQuery"><a href="#第一种简写形式：buttons-gt-XCUIElementQuery" class="headerlink" title="第一种简写形式：buttons-&gt;XCUIElementQuery"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().buttons</span><br><span class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure><h4 id="三种通过XCUIElementType的枚举值"><a href="#三种通过XCUIElementType的枚举值" class="headerlink" title="三种通过XCUIElementType的枚举值"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XCUIElementType</span> : <span class="title">UInt</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> button</span><br><span class="line">    <span class="keyword">case</span> radioButton</span><br><span class="line">    <span class="keyword">case</span> textField</span><br><span class="line">    <span class="keyword">case</span> comboBox</span><br><span class="line">    <span class="keyword">case</span> menuButton</span><br><span class="line">    <span class="keyword">case</span> toolbarButton</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery"><a href="#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery" class="headerlink" title="第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().descendantsMatchingType(.<span class="type">Button</span>)</span><br><span class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p><h5 id="第三种仅获取当前层级子元素：childrenMatchingType"><a href="#第三种仅获取当前层级子元素：childrenMatchingType" class="headerlink" title="第三种仅获取当前层级子元素：childrenMatchingType"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().childrenMatchingType(.<span class="type">Button</span>)</span><br><span class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p><h5 id="第四种所有包含的元素：containingType"><a href="#第四种所有包含的元素：containingType" class="headerlink" title="第四种所有包含的元素：containingType"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buttons:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().containingType(.<span class="type">Button</span>)</span><br><span class="line"><span class="keyword">let</span> textFields:<span class="type">XCUIElementQuery</span> = <span class="type">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure><h3 id="XCUIElement表示系统的各种UI控件"><a href="#XCUIElement表示系统的各种UI控件" class="headerlink" title="XCUIElement表示系统的各种UI控件"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p><ol><li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性</li><li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合</li></ol><h4 id="访问UI控件"><a href="#访问UI控件" class="headerlink" title="访问UI控件"></a>访问UI控件</h4><ol><li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li><li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields.element(boundBy: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields[<span class="string">"username"</span>]</span><br></pre></td></tr></table></figure>对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li></ol><h4 id="设置UI控件触发事件和属性值"><a href="#设置UI控件触发事件和属性值" class="headerlink" title="设置UI控件触发事件和属性值"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userNameTextField:<span class="type">XCUIElement</span> = app.textFields.element(boundBy: <span class="number">0</span>)</span><br><span class="line">userNameTextField.tap()</span><br><span class="line">userNameTextField.typeText(<span class="string">"文本内容"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="XCUIElementAttributes协议"><a href="#XCUIElementAttributes协议" class="headerlink" title="XCUIElementAttributes协议"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p><ol><li>使用: 可使用这些属性来获取UI元素对象。<figure class="highlight swift"><figcaption><span>title获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">"hsg"</span></span><br><span class="line">userNameTextField.typeText(username)</span><br><span class="line">app.textFields[username].tap()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>identifier获取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier = <span class="string">"hsg"</span></span><br><span class="line">userNameTextField.typeText(username)</span><br><span class="line">app.textFields[username].tap()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> UI </tag>
            
            <tag> 测试 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义展示型控制器</title>
      <link href="/2017/02/17/iOS/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%95%E7%A4%BA%E5%9E%8B%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2017/02/17/iOS/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%95%E7%A4%BA%E5%9E%8B%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div id="badge-container-huos3203-PresentationsDemo-2cce4c908" class="hexo-github" style="width: ="></div><script src="/hexo-github/badge.js"></script><script type="text/javascript">  loadStyle("/hexo-github/style.css");  loadStyle("/hexo-github/octicons/octicons.css");  new Badge("#badge-container-huos3203-PresentationsDemo-2cce4c908", "huos3203", "PresentationsDemo", "2cce4c908", false);</script><h2 id="触发转场的方式"><a href="#触发转场的方式" class="headerlink" title="触发转场的方式"></a>触发转场的方式</h2><h3 id="官方支持的自定义转场"><a href="#官方支持的自定义转场" class="headerlink" title="官方支持的自定义转场"></a>官方支持的自定义转场</h3><ul><li>在 <code>UINavigationController</code> 中 <code>push</code> 和 <code>pop</code>;</li><li>在 <code>UITabBarController</code> 中切换 <code>Tab</code>;</li><li>Modal 转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;<br><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。<br>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。<h3 id="相关触发转场的动作"><a href="#相关触发转场的动作" class="headerlink" title="相关触发转场的动作"></a>相关触发转场的动作</h3><h4 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h4><code>UINavigationController</code> 中所有修改其<code>viewControllers</code>栈中 <code>VC</code> 的方法都可以自定义转场动画：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们使用的最广泛的 push 和 pop 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pushViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated animated: Bool)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; <span class="type">UIViewController?</span></span><br><span class="line"><span class="comment">//不怎么常用的 pop 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToRootViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]?</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popToRootViewControllerAnimated</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]?</span><br><span class="line"><span class="comment">//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setViewControllers</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController], animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure><h4 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h4><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意传递的参数必须是其下的子 VC</span></span><br><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">var</span> selectedViewController: <span class="type">UIViewController?</span></span><br><span class="line"><span class="keyword">var</span> selectedIndex: <span class="type">Int</span></span><br><span class="line"><span class="comment">//和上面类似的整体更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setViewControllers</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController]?, animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure><h4 id="Modal-转场："><a href="#Modal-转场：" class="headerlink" title="Modal 转场："></a>Modal 转场：</h4><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Presentation 转场</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentViewController</span><span class="params">(<span class="number">_</span> viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?)</span><br><span class="line"><span class="comment">// Dismissal 转场</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissViewControllerAnimated</span><span class="params">(<span class="number">_</span> flag: Bool, completion completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?)</span><br></pre></td></tr></table></figure><h4 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h4>在 <code>storyboard</code> 里设置 <code>segue</code>有两种方式：<code>Button to VC</code>，这种在点击 <code>Button</code> 的时候触发转场；<code>VC to VC</code>，这种需要在代码中调用<code>performSegueWithIdentifier:sender:</code>。<code>prepareForSegue:sender:</code>方法是在转场发生前修改转场参数的最后机会。这点对于 <code>Modal</code> 转场比较重要，因为在 <code>storyboard</code>里 <code>Modal</code> 转场的 <code>Segue</code> 类型不支持选择 <code>Custom</code> 模式，使用 <code>segue</code> 方式触发时必须在<code>prepareForSegue:sender:</code>里修改模式。</li></ul><h4 id="iOS-8-的变化"><a href="#iOS-8-的变化" class="headerlink" title="iOS 8 的变化"></a>iOS 8 的变化</h4><p>iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：<br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showViewController</span><span class="params">(<span class="number">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showDetailViewController</span><span class="params">(<span class="number">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br></pre></td></tr></table></figure><br>这两个方法咋看上去是给 <code>UISplitViewController</code> 用的，在 <code>storyboard</code> 里 <code>segue</code> 的候选模式里，直接给出了<code>Show(e.g. Push)</code>和<code>Show Detail(e.g. Replace)</code>这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。<br>这两个方法在 <code>UISplitViewController</code> 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：<br>|  |ViewController|NavigationController|TabBarController|<br>|:——-|:——-|:——–|:——–|<br>|showViewController:sender: |Presentation| Push | Presentation(by self) |<br>|showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|<br><code>UINavigationController</code> 重写了<code>showViewController:sender:</code>而执行 <code>push</code> 操作，上面的<code>by self</code>意思是用容器 <code>VC</code> 本身而非其下子 <code>VC</code> 去执行 <code>presentation</code>。这两个方法的行为可以通过重写来改变。<br>当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：<br>||VC in NavigationController|VC in TabBarController|<br>|:——-|:——-|:——–|<br>|showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) |<br>|showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) |</p><h3 id="转场五大工具"><a href="#转场五大工具" class="headerlink" title="转场五大工具"></a>转场五大工具</h3><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p><h4 id="转场代理-Transition-Delegate-："><a href="#转场代理-Transition-Delegate-：" class="headerlink" title="转场代理(Transition Delegate)："></a>转场代理(Transition Delegate)：</h4><p>有如下三种容器转场代理，对应上面三种类型的转场：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">UINavigationControllerDelegate</span>&gt; <span class="comment">//UINavigationController 的 delegate 属性遵守该协议。</span></span><br><span class="line">&lt;<span class="type">UITabBarControllerDelegate</span>&gt; <span class="comment">//UITabBarController 的 delegate 属性遵守该协议。</span></span><br><span class="line">&lt;<span class="type">UIViewControllerTransitioningDelegate</span>&gt; <span class="comment">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span></span><br></pre></td></tr></table></figure><br>这里除了<uiviewcontrollertransitioningdelegate>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</uiviewcontrollertransitioningdelegate></p><h4 id="动画控制器-Animation-Controller-："><a href="#动画控制器-Animation-Controller-：" class="headerlink" title="动画控制器(Animation Controller)："></a>动画控制器(Animation Controller)：</h4><p>最重要的部分，负责添加视图以及执行动画；遵守<uiviewcontrolleranimatedtransitioning>协议；由我们实现。</uiviewcontrolleranimatedtransitioning></p><h4 id="交互控制器-Interaction-Controller-："><a href="#交互控制器-Interaction-Controller-：" class="headerlink" title="交互控制器(Interaction Controller)："></a>交互控制器(Interaction Controller)：</h4><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<uiviewcontrollerinteractivetransitioning>协议；系统已经打包好现成的类供我们使用。</uiviewcontrollerinteractivetransitioning></p><h4 id="转场环境-Transition-Context"><a href="#转场环境-Transition-Context" class="headerlink" title="转场环境(Transition Context):"></a>转场环境(Transition Context):</h4><p>提供转场中需要的数据；遵守<uiviewcontrollercontexttransitioning>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</uiviewcontrollercontexttransitioning></p><h4 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h4><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<uiviewcontrollertransitioncoordinator>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</uiviewcontrollertransitioncoordinator></p><p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p><h2 id="特殊的-Modal-转场"><a href="#特殊的-Modal-转场" class="headerlink" title="特殊的 Modal 转场"></a>特殊的 Modal 转场</h2><p>容器类 VC 的转场里 <code>fromView</code> 和 <code>toView</code> 是 <code>containerView</code> 的子层次的视图，而 Modal 转场里 <code>presentingView</code> 与 <code>containerView</code> 是同层次的视图，只有 <code>presentedView</code> 是 <code>containerView</code> 的子层次视图。</p><h3 id="iOS-8引入的UIPresentationController"><a href="#iOS-8引入的UIPresentationController" class="headerlink" title="iOS 8引入的UIPresentationController"></a>iOS 8引入的UIPresentationController</h3><p><code>UIPresentationController</code>类，该类接管了 <code>UIViewController</code> 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 <code>presentation</code> 转场结束后打印视图控制器的结构，会发现 <code>presentedVC</code> 是由一个<code>UIPresentationController</code>对象来显示的，查看视图结构也能看到 <code>presentedView</code> 是 <code>UIView</code> 私有子类的<code>UITtansitionView</code>的子视图，这就是前面 <code>containerView</code> 的真面目.<br>当<code>UIViewController</code>的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 <code>Modal 转场</code>进行进一步的定制。实际上该类也可以在<code>.FullScreen</code>模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在<code>.Custom</code>模式下使用该类。<br><code>UIPresentationController</code>类赋予 Modal 转场以下特性：</p><ol><li>定制 <code>presentedView</code> 的外观，尺寸以及在 <code>containerView</code> 中添加自定义视图并为这些视图添加动画；</li><li>可以选择是否移除 <code>presentingView</code></li><li>可以在不需要动画控制器的情况下单独工作</li><li>iOS 8 中的自适应适应性布局<br><code>UIPresentationController</code>类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionDidEnd</span><span class="params">(<span class="number">_</span> completed: Bool)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionDidEnd</span><span class="params">(<span class="number">_</span> completed: Bool)</span></span></span><br></pre></td></tr></table></figure>除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：<figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定初始化方法。</span></span><br><span class="line"><span class="keyword">init</span>(presentedViewController presentedViewController: <span class="type">UIViewController</span>, presentingViewController presentingViewController: <span class="type">UIViewController</span>)</span><br><span class="line"><span class="keyword">var</span> presentingViewController: <span class="type">UIViewController</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> presentedViewController: <span class="type">UIViewController</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> containerView: <span class="type">UIView?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="comment">//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentedView</span><span class="params">()</span></span> -&gt; <span class="type">UIView?</span>    </span><br></pre></td></tr></table></figure>没有 <code>presentingView</code> 是因为 <code>Custom</code> 模式下 <code>presentingView</code> 不受 <code>containerView</code> 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 <code>Modal</code> 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 <code>presentedView</code> 包装在其他视图后重写该方法返回包装后的视图当做 <code>presentedView</code> 在动画控制器中使用。</li></ol><h3 id="定制presentedView"><a href="#定制presentedView" class="headerlink" title="定制presentedView"></a>定制presentedView</h3><h4 id="外观：重载size方法和frameOfPresentedViewInContainerView属性"><a href="#外观：重载size方法和frameOfPresentedViewInContainerView属性" class="headerlink" title="外观：重载size方法和frameOfPresentedViewInContainerView属性"></a>外观：重载size方法和frameOfPresentedViewInContainerView属性</h4><p>重载存储属性：get方法返回登场页面的位置和大小<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> frameOfPresentedViewInContainerView: <span class="type">CGRect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> presentViewFrame = <span class="type">CGRect</span>.zero</span><br><span class="line">    <span class="keyword">let</span> containerBounds = containerView?.bounds</span><br><span class="line">    <span class="comment">//登场控制器内容页面的大小</span></span><br><span class="line">    presentViewFrame.size = size(forChildContentContainer: presentedViewController, </span><br><span class="line">                                  withParentContainerSize: (containerBounds?.size)!)</span><br><span class="line">    presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width</span><br><span class="line">    <span class="keyword">return</span> presentViewFrame</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(forChildContentContainer container: UIContentContainer, </span></span></span><br><span class="line"><span class="function"><span class="params">                   withParentContainerSize parentSize: CGSize)</span></span> -&gt; <span class="type">CGSize</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>.<span class="keyword">init</span>(width:<span class="type">CGFloat</span>(floorf(<span class="type">Float</span>(parentSize.width/<span class="number">3.0</span>))), height: parentSize.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="过渡动画，转场协调器-Transition-Coordinator"><a href="#过渡动画，转场协调器-Transition-Coordinator" class="headerlink" title="过渡动画，转场协调器(Transition Coordinator)"></a>过渡动画，转场协调器(Transition Coordinator)</h4><p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 <code>UIViewController</code> 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 <code>nil</code>。</p><h5 id="转场开始"><a href="#转场开始" class="headerlink" title="转场开始"></a>转场开始</h5><ol><li>在<code>containerView</code>中插入过渡视图<code>chromeView</code></li><li>为转场中<code>chromeView</code>过渡视图添加转场动画</li><li><code>presentedViewController.transitionCoordinator</code>转场协调器，添加转场的登场和退场动画<figure class="highlight swift"><figcaption><span>presentationTransitionWillBegin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">presentationTransitionWillBegin</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    chromeView.frame = (<span class="keyword">self</span>.containerView?.bounds)!</span><br><span class="line">    chromeView.alpha = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">//在`containerView`中插入视图`chromeView`    </span></span><br><span class="line">    containerView?.insertSubview(chromeView, at:<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//coordinator转场协调器负责转场动画的呈现和dismissal</span></span><br><span class="line">    <span class="keyword">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//添加登场动画</span></span><br><span class="line">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class="line">        (context:<span class="type">UIViewControllerTransitionCoordinatorContext!</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//animate the alpha to 1.0.</span></span><br><span class="line">            <span class="keyword">self</span>.chromeView.alpha = <span class="number">1.0</span></span><br><span class="line">        &#125;, completion:<span class="literal">nil</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        chromeView.alpha = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="转场结束"><a href="#转场结束" class="headerlink" title="转场结束"></a>转场结束</h5><p>在<code>presentedViewController.transitionCoordinator</code>转场协调器中添加转场的退场动画<br><figure class="highlight swift"><figcaption><span>dismissalTransitionWillBegin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">dismissalTransitionWillBegin</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">nil</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加退场动画</span></span><br><span class="line">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class="line">        (context:<span class="type">UIViewControllerTransitionCoordinatorContext!</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.chromeView.alpha = <span class="number">0.0</span></span><br><span class="line">        &#125;, completion:<span class="literal">nil</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        chromeView.alpha = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="适配屏幕旋转"><a href="#适配屏幕旋转" class="headerlink" title="适配屏幕旋转"></a>适配屏幕旋转</h4><p>在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">containerViewWillLayoutSubviews</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    chromeView.frame = (containerView?.bounds)!</span><br><span class="line">    presentedView?.frame = frameOfPresentedViewInContainerView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Modal的两种PresentationStyle"><a href="#Modal的两种PresentationStyle" class="headerlink" title="Modal的两种PresentationStyle"></a>Modal的两种PresentationStyle</h4><ol><li>设置整个转场动画是否将覆盖全屏幕<br> <code>.OverFullScreen</code>: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡<br> <code>.FullScreen</code>  : 全覆盖全屏 即：占据全屏来显示登场视图<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置整个转场动画是否将覆盖全屏幕</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> shouldPresentInFullscreen: <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> adaptivePresentationStyle: <span class="type">UIModalPresentationStyle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.fullScreen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="交互式转场"><a href="#交互式转场" class="headerlink" title="交互式转场"></a>交互式转场</h2><h3 id="实现交互化"><a href="#实现交互化" class="headerlink" title="实现交互化"></a>实现交互化</h3><p>在非交互转场的基础上将之交互化需要两个条件：<br>由转场代理提供交互控制器，这是一个遵守<uiviewcontrollerinteractivetransitioning>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。<br>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</uiviewcontrollerinteractivetransitioning></p><h3 id="使用一个变量来标记交互状态配合转场交互"><a href="#使用一个变量来标记交互状态配合转场交互" class="headerlink" title="使用一个变量来标记交互状态配合转场交互"></a>使用一个变量来标记交互状态配合转场交互</h3><p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。<br>在两个容器控制器<code>NavigationController</code>和<code>TabBarController</code>转场为例：</p><ol><li>在 <code>NavigationController</code> 中点击 <code>NavigationBar</code> 也能实现 <code>pop</code> 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li><li>在 <code>TabBarController</code> 的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</li></ol><h3 id="转场动画控制器：向转场中添加视图，执行转场动画"><a href="#转场动画控制器：向转场中添加视图，执行转场动画" class="headerlink" title="转场动画控制器：向转场中添加视图，执行转场动画"></a>转场动画控制器：向转场中添加视图，执行转场动画</h3><p>转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。<br>但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。<br><code>UIViewControllerAnimatedTransitioning</code>代理协议方法，提供了转场所需要的重要数据：</p><ol><li><code>containerView()</code>：运行转场动画的容器视图</li><li>转场视图控制器<ul><li>方法一：<code>viewController(forKey:)</code>：<code>UITransitionContextViewControllerKey</code>枚举值：<code>from</code>，<code>to</code></li><li>方法二：<code>viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)</code>:iOS 8新增 API 用于方便获取参与转场的视图.两个键值：<code>UITransitionContextFromViewKey</code>,<code>UITransitionContextToViewKey</code>.</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleAnimatedTransitioning</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//used to determine if the presentation animation is presenting (as opposed to dismissing).</span></span><br><span class="line">    <span class="keyword">var</span> isPresentation : <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//returns the duration in seconds of the transition animation.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回动画时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the respective views of these view controllers. </span></span><br><span class="line">    <span class="comment">//Next we get the container view and if the presentation animation is presenting, we add the to view to the container view.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get the from and to view controllers from the UIViewControllerContextTransitioning object.</span></span><br><span class="line">        <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.from)</span><br><span class="line">        <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.to)</span><br><span class="line">        <span class="comment">//determine the start and end positions of the view.</span></span><br><span class="line">        <span class="keyword">let</span> fromView = fromVC?.view</span><br><span class="line">        <span class="keyword">let</span> toView = toVC?.view</span><br><span class="line">        <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isPresentation </span><br><span class="line">        &#123;</span><br><span class="line">            containerView.addSubview(toView!)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//decide on which view controller to animate based on whether the transition is a presentation or dismissal</span></span><br><span class="line">        <span class="keyword">let</span> animatingVC = isPresentation ? toVC : fromVC</span><br><span class="line">        <span class="keyword">let</span> animatingView = animatingVC?.view</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> finalFrameForVC = transitionContext.finalFrame(<span class="keyword">for</span>: animatingVC!)</span><br><span class="line">        <span class="keyword">var</span> initialFrameForVC = finalFrameForVC</span><br><span class="line">        <span class="comment">//This will animate the view from right to left during a presentation and vice versa during dismissal.</span></span><br><span class="line">        initialFrameForVC.origin.x += initialFrameForVC.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC</span><br><span class="line">        <span class="keyword">let</span> finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC</span><br><span class="line"></span><br><span class="line">        animatingView?.frame = initialFrame</span><br><span class="line">        <span class="comment">//根据协议中的方法获取动画的时间。</span></span><br><span class="line">        <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, delay:<span class="number">0</span>, usingSpringWithDamping:<span class="number">300.0</span>, initialSpringVelocity:<span class="number">5.0</span>, options:<span class="type">UIViewAnimationOptions</span>.allowUserInteraction, animations:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//we move the view to the final position.</span></span><br><span class="line">            animatingView?.frame = finalFrame</span><br><span class="line"></span><br><span class="line">        &#125;, completion:&#123; (value: <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>.isPresentation &#123;</span><br><span class="line">                <span class="comment">//If the transition is a dismissal, we remove the view.</span></span><br><span class="line">                fromView?.removeFromSuperview()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//we complete the transition by calling transitionContext.completeTransition()</span></span><br><span class="line">            transitionContext.completeTransition(<span class="literal">true</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in</span></span><br><span class="line">    <span class="comment">//    let isCancelled = transitionContext.transitionWasCancelled()</span></span><br><span class="line">    <span class="comment">//    transitionContext.completeTransition(!isCancelled)</span></span><br><span class="line">    <span class="comment">//    &#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationEnded</span><span class="params">(<span class="number">_</span> transitionCompleted: Bool)</span></span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转场代理协议-Transition-Delegate"><a href="#转场代理协议-Transition-Delegate" class="headerlink" title="转场代理协议(Transition Delegate)"></a>转场代理协议(Transition Delegate)</h2><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。</p><h3 id="实现转场代理协议方法，整合动画控制器和自定义展示控制器"><a href="#实现转场代理协议方法，整合动画控制器和自定义展示控制器" class="headerlink" title="实现转场代理协议方法，整合动画控制器和自定义展示控制器"></a>实现转场代理协议方法，整合动画控制器和自定义展示控制器</h3><ol><li>返回管理用户信息视图控制器如何展示的控制器。前面实现的<code>ExamplePresentationViewController</code>类可同时处理 <code>presentation</code>转场 和 <code>dismissal</code> 转场。</li><li>动画控制器为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<blockquote><p><code>UIPresentationController</code>只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。</p></blockquote></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleTransitioningDelegate</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerTransitioningDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//returns a presentation controller that manages the presentation of a view controller.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentationController</span><span class="params">(forPresented presented: UIViewController, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            presenting: UIViewController?, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                source: UIViewController)</span></span> -&gt; <span class="type">UIPresentationController?</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//presentation动画控制器</span></span><br><span class="line">        <span class="keyword">let</span> presentationController = <span class="type">ExamplePresentationViewController</span>(presentedViewController:presented, </span><br><span class="line">                                                                                    presenting:presenting)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> presentationController</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为presentation转场提供登场转场动画控制器</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         presenting: UIViewController, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//登场转场动画控制器</span></span><br><span class="line">        <span class="keyword">let</span> animator = <span class="type">ExampleAnimatedTransitioning</span>()</span><br><span class="line">        animator.isPresentation = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> animator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为dismissal 转场提供退场转场动画控制器</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//退场转场动画控制器</span></span><br><span class="line">        <span class="keyword">let</span> animator = <span class="type">ExampleAnimatedTransitioning</span>()</span><br><span class="line">        animator.isPresentation = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> animator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用自定义的转场的代理"><a href="#使用自定义的转场的代理" class="headerlink" title="使用自定义的转场的代理"></a>使用自定义的转场的代理</h3><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。<br>UIViewControllerTransitioningDelegate转场代理：</p><ol><li>强引用代理变量:强引用的变量来维护该代理</li><li>Modal转场代理的特性：由presentedVC自身来遵循转场代理<code>presentedVC.modalPresentationStyle</code>，和前两个容器控制器转场代理不同。</li><li>两种支持自定义转场模式：<code>.Custom</code>或<code>.FullScreen</code>,默认值为<code>.FullScreen</code><figure class="highlight swift"><figcaption><span>fromVC.class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强引用的变量来维护该代理</span></span><br><span class="line"><span class="keyword">let</span> exampleTransitionDelegate = <span class="type">ExampleTransitioningDelegate</span>()</span><br><span class="line"><span class="comment">//create an instance of ExampleViewController which will provide the content to display.</span></span><br><span class="line"><span class="keyword">let</span> presentedVC = <span class="type">ExampleViewController</span>()</span><br><span class="line">presentedVC.modalPresentationStyle = .custom</span><br><span class="line">presentedVC.transitioningDelegate = exampleTransitionDelegate</span><br><span class="line"></span><br><span class="line"><span class="comment">//present this view controller.</span></span><br><span class="line">present(toVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="两种常规的转场方式"><a href="#两种常规的转场方式" class="headerlink" title="两种常规的转场方式"></a>两种常规的转场方式</h2><h3 id="UIView方式-transitionFromView"><a href="#UIView方式-transitionFromView" class="headerlink" title="UIView方式:transitionFromView"></a>UIView方式:transitionFromView</h3><p>不需要获取 <code>containerView</code> 以及手动添加 <code>toView</code> 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIView</span>.transitionFromView(fromView, toView: toView, duration: durantion, options: .<span class="type">TransitionCurlDown</span>, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> isCancelled = transitionContext.transitionWasCancelled()</span><br><span class="line">transitionContext.completeTransition(!isCancelled)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="UIViewController方式：在子-VC-间转换的方法"><a href="#UIViewController方式：在子-VC-间转换的方法" class="headerlink" title="UIViewController方式：在子 VC 间转换的方法"></a>UIViewController方式：在子 VC 间转换的方法</h3><p>该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行<code>animations闭包</code>里的动画。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transitionFromViewController:toViewController:duration:options:animations:completion:</span><br></pre></td></tr></table></figure><br>该方法仅限于在自定义容器控制器里使用，如果直接使用 <code>UINavigationController</code> 和 <code>UITabBarController</code> 调用该方法执行子VC间转换会抛出异常。</p><blockquote><p>不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。</p></blockquote><p><a href="http://www.appcoda.com/presentation-controllers-tutorial/" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 转场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
            <tag> 转场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理iOS中几种常用的展示型视图控制器</title>
      <link href="/2017/02/17/iOS/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%95%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/02/17/iOS/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%95%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0" target="_blank" rel="noopener">开始项目</a><br><a href="https://github.com/appcoda/Presentation-Controllers-Demo" target="_blank" rel="noopener">完整项目</a></p><h2 id="UIAlertController"><a href="#UIAlertController" class="headerlink" title="UIAlertController"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li><li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li><li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li><li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li><li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li></ol><h3 id="创建使用UIAlertController"><a href="#创建使用UIAlertController" class="headerlink" title="创建使用UIAlertController"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class="highlight swift"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showAlertWasTapped</span><span class="params">(sender: UIButton)</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Appcoda"</span>, message: <span class="string">"Message in alert dialog"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deleteAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Delete"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Destructive</span>, handler: &#123;(alert :<span class="type">UIAlertAction!</span>) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Delete button tapped"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    alertController.addAction(deleteAction)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>, handler: &#123;(alert :<span class="type">UIAlertAction!</span>) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"OK button tapped"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    alertController.addAction(okAction)</span><br><span class="line"></span><br><span class="line">    presentViewController(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行效果：</p><h3 id="UIAlertControllerStyle枚举：Alert切换ActionSheet"><a href="#UIAlertControllerStyle枚举：Alert切换ActionSheet" class="headerlink" title="UIAlertControllerStyle枚举：Alert切换ActionSheet"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class="highlight swift"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Appcoda"</span>, message: <span class="string">"Message in alert dialog"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">ActionSheet</span>)</span><br></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p><h3 id="popoverPresentationController锚点：sourceView-sourceRect"><a href="#popoverPresentationController锚点：sourceView-sourceRect" class="headerlink" title="popoverPresentationController锚点：sourceView/sourceRect"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alertController.popoverPresentationController?.sourceView = view</span><br><span class="line">alertController.popoverPresentationController?.sourceRect = sender.frame</span><br></pre></td></tr></table></figure></p><h2 id="UIPopoverPresentationController"><a href="#UIPopoverPresentationController" class="headerlink" title="UIPopoverPresentationController"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p><h3 id="在compact和regular两种屏幕中显示模态视图"><a href="#在compact和regular两种屏幕中显示模态视图" class="headerlink" title="在compact和regular两种屏幕中显示模态视图"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class="highlight swift"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">actionWasTapped</span><span class="params">(sender: UIBarButtonItem)</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> storyboard : <span class="type">UIStoryboard</span> = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class="string">"PopoverViewController"</span>) <span class="keyword">as</span>! <span class="type">UIViewController</span></span><br><span class="line">    vc.modalPresentationStyle = <span class="type">UIModalPresentationStyle</span>.<span class="type">Popover</span></span><br><span class="line">    <span class="keyword">let</span> popover: <span class="type">UIPopoverPresentationController</span> = vc.popoverPresentationController!</span><br><span class="line">    popover.barButtonItem = sender  <span class="comment">//`popover箭头`锚的位置</span></span><br><span class="line">    presentViewController(vc, animated: <span class="literal">true</span>, completion:<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="设置锚点四种方式"><a href="#设置锚点四种方式" class="headerlink" title="设置锚点四种方式"></a>设置锚点四种方式</h4><ol><li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li><li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li><li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li><li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li></ol><p>在iPhone上以模态显示：</p><h3 id="在iPhone设备上dissmiss模态视图"><a href="#在iPhone设备上dissmiss模态视图" class="headerlink" title="在iPhone设备上dissmiss模态视图"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p><h4 id="实现UIPopoverPresentationController协议"><a href="#实现UIPopoverPresentationController协议" class="headerlink" title="实现UIPopoverPresentationController协议"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol><li><code>PopoverViewController</code>类定义修改如下:<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopoverViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popover.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure><h4 id="方法一：返回自适应设备的视图展示样式"><a href="#方法一：返回自适应设备的视图展示样式" class="headerlink" title="方法一：返回自适应设备的视图展示样式"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class="highlight swift"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adaptivePresentationStyleForPresentationController</span><span class="params">(controller: UIPresentationController)</span></span> -&gt; <span class="type">UIModalPresentationStyle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.<span class="type">FullScreen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：返回自定义的视图控制器"><a href="#方法二：返回自定义的视图控制器" class="headerlink" title="方法二：返回自定义的视图控制器"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class="highlight swift"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">presentationController</span><span class="params">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class="type">UIViewController?</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> navigationController = <span class="type">UINavigationController</span>(rootViewController: controller.presentedViewController)</span><br><span class="line">    <span class="keyword">let</span> btnDone = <span class="type">UIBarButtonItem</span>(title: <span class="string">"Done"</span>, style: .<span class="type">Done</span>, target: <span class="keyword">self</span>, action: <span class="string">"dismiss"</span>)</span><br><span class="line">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</span><br><span class="line">    <span class="keyword">return</span> navigationController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Done按钮的dismiss事件"><a href="#Done按钮的dismiss事件" class="headerlink" title="Done按钮的dismiss事件"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class="highlight swift"><figcaption><span>dismiss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">UIModalPresentationStyle</span>.<span class="type">None</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 转场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
            <tag> 转场 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript自动化组件OC桥接</title>
      <link href="/2017/02/16/macOS/JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6OC%E6%A1%A5%E6%8E%A5/"/>
      <url>/2017/02/16/macOS/JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6OC%E6%A1%A5%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8" target="_blank" rel="noopener">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p><h2 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjC.import(<span class="string">'Cocoa'</span>)</span><br><span class="line">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjC.import(<span class="string">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p><p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p><blockquote><p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p></blockquote><h2 id="实例化的类和调用方法"><a href="#实例化的类和调用方法" class="headerlink" title="实例化的类和调用方法"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = $.NSString.alloc.initWithUTF8String(<span class="string">'foo'</span>)</span><br><span class="line">str.writeToFileAtomically(<span class="string">'/tmp/foo'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.NSNumber.numberWithInt(<span class="number">99</span>).intValue</span><br></pre></td></tr></table></figure></p><h3 id="访问-ObjC-Properties"><a href="#访问-ObjC-Properties" class="headerlink" title="访问 ObjC Properties"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task = $.NSTask.alloc.init</span><br><span class="line">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task.launchPath = <span class="string">'/bin/sleep'</span></span><br><span class="line">task.setLaunchPath(<span class="string">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 搭建 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 混编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS支持JavaScript自动化组件基础</title>
      <link href="/2017/02/16/macOS/macOS%E6%94%AF%E6%8C%81JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/02/16/macOS/macOS%E6%94%AF%E6%8C%81JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href="https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508" target="_blank" rel="noopener">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href="https://github.com/tylergaw/js-osx-app-examples" target="_blank" rel="noopener">JavaScript OS X App Examples</a><br><a href="https://github.com/dtinth/JXA-Cookbook" target="_blank" rel="noopener">JavaScript for Automation Cookbook</a></p><h2 id="OSA框架-Open-Scripting-Architecture"><a href="#OSA框架-Open-Scripting-Architecture" class="headerlink" title="OSA框架:Open Scripting Architecture"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p><h2 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p><h3 id="打开脚本字典"><a href="#打开脚本字典" class="headerlink" title="打开脚本字典"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p><h2 id="object-specifier"><a href="#object-specifier" class="headerlink" title="object specifier"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p><blockquote><p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p></blockquote><h2 id="访问APP"><a href="#访问APP" class="headerlink" title="访问APP"></a>访问APP</h2><p>六种方式:<br><figure class="highlight js"><figcaption><span>By name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application(<span class="string">'Mail'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application(<span class="string">'com.apple.mail'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>By path</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application(<span class="string">'/Applications/Mail.app'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>By process ID</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application(<span class="number">763</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application(<span class="string">'eppc://127.0.0.1/Mail'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>currentApplication</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.currentApplication()</span><br></pre></td></tr></table></figure><h2 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h2><figure class="highlight js"><figcaption><span>Access properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.name</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Access elements</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.outgoingMessages[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Call commands</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.open(...)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Create new objects</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.OutgoingMessage(...)</span><br></pre></td></tr></table></figure><h3 id="属性的get-set方法"><a href="#属性的get-set方法" class="headerlink" title="属性的get/set方法"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subject = Mail.inbox.messages[<span class="number">0</span>].subject()</span><br></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.outgoingMessages[<span class="number">0</span>].subject = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subjects = Mail.inbox.messages.subject()</span><br></pre></td></tr></table></figure></p><h3 id="元素数组"><a href="#元素数组" class="headerlink" title="元素数组"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class="highlight js"><figcaption><span>索引</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> = Mail.windows.at(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">window</span> = Mail.windows[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight js"><figcaption><span>name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> = Mail.windows.byName(<span class="string">'New Message'</span>)</span><br><span class="line"><span class="built_in">window</span> = Mail.windows[<span class="string">'New Message'</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight js"><figcaption><span>ID</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> = Mail.windows.byId(<span class="number">412</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>Note: 使用ID来访问不是方括号[]而是().</p></blockquote><h3 id="调用命令"><a href="#调用命令" class="headerlink" title="调用命令"></a>调用命令</h3><p>命令被称为函数。</p><ol start="2"><li>直接参数的函数，该参数作为命令的第一个参数传递。</li><li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li><li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li><li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li><li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class="highlight js"><figcaption><span>无参数命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.open()</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mail.open(message)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response = message.reply(&#123;</span><br><span class="line">replayAll: <span class="literal">true</span>,</span><br><span class="line">openingWindow: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Safari.doJavaScript(<span class="string">'alert("Hello world")'</span>, &#123;</span><br><span class="line"><span class="keyword">in</span>: Safari.windows[<span class="number">0</span>].tabs[<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Creating-Objects"><a href="#Creating-Objects" class="headerlink" title="Creating Objects"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p><ol><li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li><li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li></ol><h3 id="Create-a-new-object"><a href="#Create-a-new-object" class="headerlink" title="Create a new object."></a>Create a new object.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = Mail.OutgoingMessage().make()</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-object-with-properties"><a href="#Create-a-new-object-with-properties" class="headerlink" title="Create a new object with properties."></a>Create a new object with properties.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = Mail.OutgoingMessage(&#123;</span><br><span class="line">subject: <span class="string">'Hello world'</span>,</span><br><span class="line">visible: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">Mail.outgoingMessages.push(message)</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-object-with-data"><a href="#Create-a-new-object-with-data" class="headerlink" title="Create a new object with data."></a>Create a new object with data.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">para = TextEdit.Paragraph(&#123;&#125;, <span class="string">'Some text'</span>)</span><br><span class="line">TextEdit.documents[<span class="number">0</span>].paragraphs.push(para)</span><br></pre></td></tr></table></figure><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = Mail.OutgoingMessage().make()</span><br><span class="line">message.subject = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure></p><h3 id="Scripting-Additions"><a href="#Scripting-Additions" class="headerlink" title="Scripting Additions"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app = Application.currentApplication()</span><br><span class="line">app.includeStandardAdditions = <span class="literal">true</span></span><br><span class="line">app.say(<span class="string">'Hello world'</span>)</span><br><span class="line">app.displayDialog(<span class="string">'Please enter your email address'</span>, &#123;</span><br><span class="line">withTitle: <span class="string">'Email'</span>,</span><br><span class="line">defaultAnswer: <span class="string">'your_email@site.com'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Applets"><a href="#Applets" class="headerlink" title="Applets"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDocuments</span>(<span class="params">docs</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href="https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8" target="_blank" rel="noopener">更多样例</a></p><h2 id="UI-Automation"><a href="#UI-Automation" class="headerlink" title="UI Automation"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Notes = Application(<span class="string">'Notes'</span>)</span><br><span class="line">Notes.activate()</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1</span>)</span><br><span class="line">SystemEvents = Application(<span class="string">'System Events'</span>)</span><br><span class="line">Notes = SystemEvents.processes[<span class="string">'Notes'</span>]</span><br><span class="line"></span><br><span class="line">Notes.windows[<span class="number">0</span>].splitterGroups[<span class="number">0</span>].groups[<span class="number">1</span>].groups[<span class="number">0</span>].buttons[<span class="number">0</span>].click()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 混编 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过沙盒中JS脚本访问其他APP</title>
      <link href="/2017/02/15/macOS/%E9%80%9A%E8%BF%87%E6%B2%99%E7%9B%92%E4%B8%ADJS%E8%84%9A%E6%9C%AC%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96APP/"/>
      <url>/2017/02/15/macOS/%E9%80%9A%E8%BF%87%E6%B2%99%E7%9B%92%E4%B8%ADJS%E8%84%9A%E6%9C%AC%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96APP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>如何使用脚本字典里的命令和对象来与其他的应用进行通讯?<br>这个教程将向您展示现在使用 <code>AppleScript</code> 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 <code>AppleScript</code>。</p><h2 id="在自己的APP中编写"><a href="#在自己的APP中编写" class="headerlink" title="在自己的APP中编写"></a>在自己的APP中编写</h2><h3 id="编写AppleScript代码"><a href="#编写AppleScript代码" class="headerlink" title="编写AppleScript代码"></a>编写AppleScript代码</h3><p><a href="https://developer.apple.com/library/mac/documentation/applescript/conceptual/applescriptlangguide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1" target="_blank" rel="noopener">AppleScript 脚本指南</a><br>与其他应用进行通讯的脚本一般来说都很短，也容易理解。<code>AppleScript</code> 可以被想做一种传送的机制，而不是一种处理环境。<br>典型脚本:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">on chockify(inputString)</span><br><span class="line">    <span class="keyword">set</span> resultString to ""</span><br><span class="line"></span><br><span class="line">        repeat with inputStringCharacter in inputString</span><br><span class="line">            <span class="keyword">set</span> asciiValue to (ASCII number inputStringCharacter)</span><br><span class="line">            if (asciiValue &gt; 96 and asciiValue &lt; 123) then</span><br><span class="line">                <span class="keyword">set</span> resultString to resultString &amp; (ASCII character (asciiValue - 32))</span><br><span class="line">            else</span><br><span class="line">                if ((asciiValue &gt; 64 and asciiValue &lt; 91) or (asciiValue = 32)) then</span><br><span class="line">                    <span class="keyword">set</span> resultString to resultString &amp; inputStringCharacter</span><br><span class="line">                else</span><br><span class="line">                    if (asciiValue &gt; 47 and asciiValue &lt; 58) then</span><br><span class="line">                        <span class="keyword">set</span> numberStrings to &#123;<span class="string">"ZERO"</span>, <span class="string">"ONE"</span>, <span class="string">"TWO"</span>, <span class="string">"THREE"</span>, <span class="string">"FOR"</span>, <span class="string">"FIVE"</span>, <span class="string">"SIX"</span>, <span class="string">"SEVEN"</span>, <span class="string">"EIGHT"</span>, <span class="string">"NINE"</span>&#125;</span><br><span class="line">                        <span class="keyword">set</span> itemIndex to asciiValue - 47</span><br><span class="line">                        <span class="keyword">set</span> numberString to item itemIndex of numberStrings</span><br><span class="line">                        <span class="keyword">set</span> resultString to resultString &amp; numberString &amp; " "</span><br><span class="line">                    else</span><br><span class="line">                        if (asciiValue = 33) then</span><br><span class="line">                            <span class="keyword">set</span> resultString to resultString &amp; " DUH"</span><br><span class="line">                        else</span><br><span class="line">                            if (asciiValue = 63) then</span><br><span class="line">                                <span class="keyword">set</span> resultString to resultString &amp; " IF YOU KNOW WHAT I MEAN"</span><br><span class="line">                            end if</span><br><span class="line">                        end if</span><br><span class="line">                    end if</span><br><span class="line">                end if</span><br><span class="line">            end if</span><br><span class="line">        end repeat</span><br><span class="line">        resultString</span><br><span class="line">end chockify</span><br></pre></td></tr></table></figure></p><h3 id="创建事件描述符-event-descriptor"><a href="#创建事件描述符-event-descriptor" class="headerlink" title="创建事件描述符 (event descriptor)"></a>创建事件描述符 (event descriptor)</h3><ol><li>导入Carbon.h<br>它有关于所有的 AppleEvent 的定义。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Carbon/Carbon.h&gt;</span> // for AppleScript definitions</span></span><br></pre></td></tr></table></figure></li><li>OC中创建<code>chockify</code>事件描述符<br>这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 <code>NSString</code> 作为参数，创建<code>chockify</code>事件描述符：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSAppleEventDescriptor</span> *)chockifyEventDescriptorWithString:(<span class="built_in">NSString</span> *)inputString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// parameter</span></span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *parameter = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithString:inputString];</span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *parameters = [<span class="built_in">NSAppleEventDescriptor</span> listDescriptor];</span><br><span class="line">    [parameters insertDescriptor:parameter atIndex:<span class="number">1</span>]; <span class="comment">// you have to love a language with indices that start at 1 instead of 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// target</span></span><br><span class="line">    ProcessSerialNumber psn = &#123;<span class="number">0</span>, kCurrentProcess&#125;;</span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *target = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:<span class="keyword">sizeof</span>(ProcessSerialNumber)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *function = [<span class="built_in">NSAppleEventDescriptor</span> descriptorWithString:<span class="string">@"chockify"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// event</span></span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="built_in">NSAppleEventDescriptor</span> appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID];</span><br><span class="line">    [event setParamDescriptor:function forKeyword:keyASSubroutineName];</span><br><span class="line">    [event setParamDescriptor:parameters forKeyword:keyDirectObject];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="OC中加载-AppleScript"><a href="#OC中加载-AppleScript" class="headerlink" title="OC中加载 AppleScript"></a>OC中加载 AppleScript</h3><p>通过应用包(Application bundle)的一个 <code>URL</code> 可以创建 <code>NSAppleScript</code>的实例。而反过来，脚本也要和上面创建的 <code>chockify 事件描述符</code>一起使用。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Automation"</span> withExtension:<span class="string">@"scpt"</span>];</span><br><span class="line"><span class="keyword">if</span> (URL) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAppleScript</span> *appleScript = [[<span class="built_in">NSAppleScript</span> alloc] initWithContentsOfURL:URL error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> chockifyEventDescriptorWithString:[<span class="keyword">self</span>.chockifyInputTextField stringValue]];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (! resultEventDescriptor) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript run error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *string = [<span class="keyword">self</span> stringForResultEventDescriptor:resultEventDescriptor];</span><br><span class="line">        [<span class="keyword">self</span> updateChockifyTextFieldWithString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 <code>Foundation 类</code>很相似，但是返回的错误并不是一个 <code>NSError</code> 的实例。</p><h3 id="调用事件描述符"><a href="#调用事件描述符" class="headerlink" title="调用事件描述符"></a>调用事件描述符</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringForResultEventDescriptor:(<span class="built_in">NSAppleEventDescriptor</span> *)resultEventDescriptor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultEventDescriptor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ([resultEventDescriptor descriptorType] != kAENullEvent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) </span><br><span class="line">            &#123;</span><br><span class="line">                result = [resultEventDescriptor stringValue];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法</p><h2 id="调用沙盒中脚本代码与访问其他应用"><a href="#调用沙盒中脚本代码与访问其他应用" class="headerlink" title="调用沙盒中脚本代码与访问其他应用"></a>调用沙盒中脚本代码与访问其他应用</h2><h3 id="了解APP沙盒限制"><a href="#了解APP沙盒限制" class="headerlink" title="了解APP沙盒限制"></a>了解APP沙盒限制</h3><p>如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行<code>JavaScript</code>。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。</p><p>对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。<code>NSUserScriptTask</code>使这一切变得可能。<br>由此：Apple 引入了一个新的抽象类 <code>NSUserScriptTask</code>,有三个具体的子类实现:</p><ol><li><code>NSUserUnixTask</code>: 执行 Unix shell 命令</li><li><code>NSUserAutomatorTask</code>: Automator 工作流</li><li><code>NSUserAppleScriptTask</code>:执行<code>AppleScript脚本</code>,脚本是异步执行的,所以脚本不能对用户界面做更新操作。</li></ol><h3 id="开始安装运行脚本"><a href="#开始安装运行脚本" class="headerlink" title="开始安装运行脚本"></a>开始安装运行脚本</h3><p>怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？<br>两种策略:</p><ol><li>帮助用户来存放运行脚本的位置</li><li>获取行脚本目录可读写</li></ol><h4 id="帮用户存放运行脚本的位置"><a href="#帮用户存放运行脚本的位置" class="headerlink" title="帮用户存放运行脚本的位置"></a>帮用户存放运行脚本的位置</h4><p>只能把把这些脚本放到用户的脚本文件夹(<code>User &gt; Library &gt; Application Scripts/bundle identifier/</code>)中，以只读的方式来运行你的脚本。<br>脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者<code>Library 文件夹</code>在 OS X 里默认还是隐藏的。这样对用户都很不友好。<br>让代码来帮助用户打开这个隐藏文件夹：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</span><br><span class="line">[[<span class="built_in">NSWorkspace</span> sharedWorkspace] openURL:directoryURL];</span><br></pre></td></tr></table></figure><br>通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。</p><h4 id="设置运行脚本目录的读写权限"><a href="#设置运行脚本目录的读写权限" class="headerlink" title="设置运行脚本目录的读写权限"></a>设置运行脚本目录的读写权限</h4><ol><li>在 Xcode 里，你需要更新 <code>Capabilities</code>，让其包括 <code>User Selected File to Read/Write</code>。在 <code>App Sandbox &gt; File Access</code>里找到相关选项。</li><li>用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSOpenPanel</span> *openPanel = [<span class="built_in">NSOpenPanel</span> openPanel];</span><br><span class="line">[openPanel setDirectoryURL:directoryURL];</span><br><span class="line">[openPanel setCanChooseDirectories:<span class="literal">YES</span>];</span><br><span class="line">[openPanel setCanChooseFiles:<span class="literal">NO</span>];</span><br><span class="line">[openPanel setPrompt:<span class="string">@"Select Script Folder"</span>];</span><br><span class="line">[openPanel setMessage:<span class="string">@"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder"</span>];</span><br><span class="line"></span><br><span class="line">[openPanel beginWithCompletionHandler:^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="built_in">NSFileHandlingPanelOKButton</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *selectedURL = [openPanel URL];</span><br><span class="line">    <span class="keyword">if</span> ([selectedURL isEqual:directoryURL])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *destinationURL = [selectedURL URLByAppendingPathComponent:<span class="string">@"Automation.scpt"</span>];</span><br><span class="line">        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        <span class="built_in">NSURL</span> *sourceURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Automation"</span> withExtension:<span class="string">@"scpt"</span>];</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">BOOL</span> success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSAlert</span> *alert = [<span class="built_in">NSAlert</span> alertWithMessageText:<span class="string">@"Script Installed"</span> defaultButton:<span class="string">@"OK"</span> alternateButton:<span class="literal">nil</span> otherButton:<span class="literal">nil</span> informativeTextWithFormat:<span class="string">@"The Automation script was installed succcessfully."</span>];</span><br><span class="line">            [alert runModal];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">            <span class="keyword">if</span> ([error code] == <span class="built_in">NSFileWriteFileExistsError</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// this is where you could update the script, by removing the old one and copying in a new one</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// the item couldn't be copied, try again</span></span><br><span class="line">                [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(installAutomationScript:) withObject:<span class="keyword">self</span> afterDelay:<span class="number">0.0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// try again because the user changed the folder path</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(installAutomationScript:) withObject:<span class="keyword">self</span> afterDelay:<span class="number">0.0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>这么一来，应用包中的 <code>Automation.scpt</code> 文件现在暴露在常规的文件系统中了。</li></ol><h3 id="执行脚本任务"><a href="#执行脚本任务" class="headerlink" title="执行脚本任务"></a>执行脚本任务</h3><p>使用 <code>NSUserAppleScriptTask</code> 来替代 <code>NSAppleScript</code>，来运行上面创建的<code>事件描述符</code>。<br>你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， <code>NSUserAppleScriptTask</code> 不应该被执行多次。所以写一个<code>工厂函数</code>来在需要的时候创建任务：<br><figure class="highlight objc"><figcaption><span>工厂函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUserAppleScriptTask</span> *)automationScriptTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUserAppleScriptTask</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSURL</span> *directoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSApplicationScriptsDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">YES</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (directoryURL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *scriptURL = [directoryURL URLByAppendingPathComponent:<span class="string">@"Automation.scpt"</span>];</span><br><span class="line">        result = [[<span class="built_in">NSUserAppleScriptTask</span> alloc] initWithURL:scriptURL error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (! result) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s no AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> if you're not running in a sandbox, the directory URL will always be nil</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s no Application Scripts folder error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 <code>directoryURL</code> 时你需要特别小心。<code>NSApplicationScriptsDirectory</code>只在沙盒中有效。</p></blockquote><p>在创建脚本任务后，你需要使用 <code>AppleEvent</code> 并提供一个结束处理来执行它：<br><figure class="highlight objc"><figcaption><span>AppleEvent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserAppleScriptTask</span> *automationScriptTask = [<span class="keyword">self</span> automationScriptTask];</span><br><span class="line"><span class="keyword">if</span> (automationScriptTask) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> safariURLEventDescriptor];</span><br><span class="line">    [automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! resultEventDescriptor) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *URL = [<span class="keyword">self</span> URLForResultEventDescriptor:resultEventDescriptor];</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get</span></span><br><span class="line">            <span class="comment">// on that thread by using libdispatch or performing a selector.</span></span><br><span class="line">            [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 <code>event</code> 传递一个 <code>nil</code>，脚本就会像用户在 <code>Finder</code> 中双击那样的行为进行执行。<br><code>NSUserAppleScriptTask</code>脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。</p><h2 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h2><p><code>NSAppleScript</code> 和 <code>NSUserAppleScriptTask</code> 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。<br>然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 <code>NSAppleScript</code> 的同步特性了。<br>要获得传统方式的行为，一种简单的方法是使用一个<code>信号量(semaphore)</code> 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 <code>libdispatch</code> 创建一个信号量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.appleScriptTaskSemaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">self</span>.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// run the script task</span></span><br><span class="line"><span class="built_in">NSAppleEventDescriptor</span> *event = [<span class="keyword">self</span> openNetworkPreferencesEventDescriptor];</span><br><span class="line">[automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class="built_in">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! resultEventDescriptor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s AppleScript task error = %@"</span>, __PRETTY_FUNCTION__, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(showNetworkAlert) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the task has completed, so let any pending tasks proceed</span></span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.appleScriptTaskSemaphore);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><br>再强调一下，除非确实有所需要，否则最好别这么做。</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>macOS之PDFKit基础</title>
      <link href="/2017/02/14/macOS/macOS%E4%B9%8BPDFKit%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/02/14/macOS/macOS%E4%B9%8BPDFKit%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p><ul><li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li><li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li></ul><h2 id="PDF页面"><a href="#PDF页面" class="headerlink" title="PDF页面"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p><h3 id="view-VS-page空间坐标"><a href="#view-VS-page空间坐标" class="headerlink" title="view VS page空间坐标"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较</p><p><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p><h2 id="PDF-Kit-Classes"><a href="#PDF-Kit-Classes" class="headerlink" title="PDF Kit Classes"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。</p><h3 id="PDFView-Class"><a href="#PDFView-Class" class="headerlink" title="PDFView Class"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView</p><h3 id="PDF-Kit-Utility-Classes"><a href="#PDF-Kit-Utility-Classes" class="headerlink" title="PDF Kit Utility Classes"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code></p><h4 id="PDF-Document"><a href="#PDF-Document" class="headerlink" title="PDF Document"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p><h4 id="PDFPage"><a href="#PDFPage" class="headerlink" title="PDFPage"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p><h4 id="PDFOutline"><a href="#PDFOutline" class="headerlink" title="PDFOutline"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p><h4 id="PDFSelection"><a href="#PDFSelection" class="headerlink" title="PDFSelection"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p><h4 id="PDFAnnotation"><a href="#PDFAnnotation" class="headerlink" title="PDFAnnotation"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。</p><h4 id="PDFBorder"><a href="#PDFBorder" class="headerlink" title="PDFBorder"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p><p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p><footer><strong>老文档</strong><cite><a href="http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html" target="_blank" rel="noopener">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> PDF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> UI </tag>
            
            <tag> PDF </tag>
            
            <tag> 阅读器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric对macOS系统的支持</title>
      <link href="/2017/02/14/macOS/Fabric%E5%AF%B9macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%AF%E6%8C%81%E8%B0%83%E7%A0%94/"/>
      <url>/2017/02/14/macOS/Fabric%E5%AF%B9macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%AF%E6%8C%81%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href="https://try.crashlytics.com/" target="_blank" rel="noopener">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href="https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support" target="_blank" rel="noopener">浏览官方文档</a></p><h3 id="crashlytics支持macOS"><a href="#crashlytics支持macOS" class="headerlink" title="crashlytics支持macOS"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class="string">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure><p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p><footer><strong>官方文档</strong><cite><a href="https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support" target="_blank" rel="noopener">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p><h3 id="Cause-a-Test-Crash教程"><a href="#Cause-a-Test-Crash教程" class="headerlink" title="Cause a Test Crash教程"></a><a href="https://docs.fabric.io/apple/crashlytics/test-crash.html" target="_blank" rel="noopener">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p><ol><li><code>run</code>在模拟器上安装运行APP</li><li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li><li>在模拟器上启动APP，并执行崩溃操作</li><li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li></ol><blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href="https://fabric.io/settings/apps/some_app_id/mappings" target="_blank" rel="noopener">https://fabric.io/settings/apps/some_app_id/mappings</a></p><footer><strong>官方文档</strong><cite><a href="https://docs.fabric.io/apple/crashlytics/test-crash.html" target="_blank" rel="noopener">Cause a Test Crash教程</a></cite></footer></blockquote>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 搭建 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 测试 </tag>
            
            <tag> SDK </tag>
            
            <tag> 发布 </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维导图之开发实践篇</title>
      <link href="/2017/02/14/%E5%AF%BC%E5%9B%BE/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
      <url>/2017/02/14/%E5%AF%BC%E5%9B%BE/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h2><ul><li>5种图表解决工作中的12大难题</li><li>你的第一本思维导图操作书</li><li>5分钟手绘彩色圆珠笔涂鸦集</li><li>如果阅读一本书</li></ul><p>使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。 </p><p>目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。<br>从产品、设计等方面谈谈我是如何运用思维导图的。</p><h2 id="需求分析——完善最初的想法"><a href="#需求分析——完善最初的想法" class="headerlink" title="需求分析——完善最初的想法"></a>需求分析——完善最初的想法</h2><p>一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。</p><h3 id="需求速记法"><a href="#需求速记法" class="headerlink" title="需求速记法"></a>需求速记法</h3><p>先用纸笔速记的方式，把临时能想到的点记录下来<br>在纸上列得差不多了，再新建一个 <code>XMind</code> 文档，把之前列的一些点一一转到电脑上，然后整理分类。</p><h3 id="功能结构图案例"><a href="#功能结构图案例" class="headerlink" title="功能结构图案例"></a>功能结构图案例</h3><ol><li>码市逻辑图<br>通过思维导图能够一目了然的看到码市的功能</li><li>网站功能逻辑图<br>通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。<h2 id="产品设计——通过画原型来完善功能结构"><a href="#产品设计——通过画原型来完善功能结构" class="headerlink" title="产品设计——通过画原型来完善功能结构"></a>产品设计——通过画原型来完善功能结构</h2><code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<h3 id="悬赏功能结构图"><a href="#悬赏功能结构图" class="headerlink" title="悬赏功能结构图"></a>悬赏功能结构图</h3>为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。<br>下面这个图是码市功能结构中的发布悬赏功能部分：<br>有了功能结构图，就可以一一对照来做原型了。<h3 id="原型图"><a href="#原型图" class="headerlink" title="原型图"></a>原型图</h3>正如前面所说：<code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<br>然后得到下面的原型：</li></ol><h2 id="写文章时用到的思维导图"><a href="#写文章时用到的思维导图" class="headerlink" title="写文章时用到的思维导图"></a>写文章时用到的思维导图</h2><p><a href="https://blog.coding.net/blog/coding-mindmap" target="_blank" rel="noopener">原文</a><br>把想到的先列出来，慢慢整理调整，梳理出写作思路。<br>演变过程：</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="微信推出应用号的处境："><a href="#微信推出应用号的处境：" class="headerlink" title="微信推出应用号的处境："></a>微信推出应用号的处境：</h3>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JavaScript把JSON数据定义对象</title>
      <link href="/2017/02/12/swift/%E4%BD%BF%E7%94%A8JavaScript%E6%8A%8AJSON%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/02/12/swift/%E4%BD%BF%E7%94%A8JavaScript%E6%8A%8AJSON%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="将JSON数据序列化为代码实例"><a href="#将JSON数据序列化为代码实例" class="headerlink" title="将JSON数据序列化为代码实例"></a>将JSON数据序列化为代码实例</h2><ol><li>定义一个继承自 <code>JSExport</code> 子协议 <code>PersonJSExports</code></li><li>定义一个遵守<code>PersonJSExports</code>协议的<code>Person</code>数据模</li><li>使用 <code>JavaScript</code> 把<code>JSON</code>转为<code>类</code>并实例化<code>对象</code><br>都有一个完整的 <code>JVM</code> 在那儿了，谁还需要 <code>NSJSONSerialization</code>？</li></ol><h2 id="JSExport语言互通协议"><a href="#JSExport语言互通协议" class="headerlink" title="JSExport语言互通协议"></a>JSExport语言互通协议</h2><p><code>JavaScript</code>可以脱离<code>prototype继承</code>完全用<code>JSON</code>来定义对象，但是<code>Objective-C</code>编程不能脱离<code>类</code>和<code>继承</code>。所以<code>JavaScriptCore</code>就提供了<code>JSExport</code>作为两种语言的互通协议。<br><code>JSExport</code>中没有预定义任何方法，但是所有继承<code>JSExport</code>的协议中定义的方法即协议方法，都可以在<code>JSContext</code>中被调用。</p><h2 id="JSExportAs-宏-指定方法在JS中调用的名称"><a href="#JSExportAs-宏-指定方法在JS中调用的名称" class="headerlink" title="JSExportAs 宏: 指定方法在JS中调用的名称"></a>JSExportAs 宏: 指定方法在JS中调用的名称</h2><p>对于多参数的方法，<code>JavaScriptCore</code>的转换方式将<code>Objective-C</code>的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MultiArgs</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)doFoo:(<span class="keyword">id</span>)foo withBar:(<span class="keyword">id</span>)bar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br>如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏：<br><figure class="highlight objc"><figcaption><span>JSExport.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSExportAs(PropertyName, Selector)</span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><figcaption><span>JSExportAs的官方宏定义 xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define JSExportAs(PropertyName, Selector) \</span></span><br><span class="line"><span class="keyword">@optional</span> Selector __JS_EXPORT_AS__<span class="meta">##PropertyName:(id)argument; @required Selector</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>如 <code>setX:Y:Z</code>方法，我们可以给他重命名，让 JS 中通过 <code>set3D(x,y,z)</code> 来调用<br><figure class="highlight objc"><figcaption><span>使用方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSExportAs(set3D,</span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="keyword">id</span>)x Y:(<span class="keyword">id</span>)y Z:(<span class="keyword">id</span>)z</span><br><span class="line">);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">set3D(x,y,z)</span><br></pre></td></tr></table></figure></p><h3 id="定义PersonJSExports协议和create协议方法（类方法）"><a href="#定义PersonJSExports协议和create协议方法（类方法）" class="headerlink" title="定义PersonJSExports协议和create协议方法（类方法）"></a>定义PersonJSExports协议和create协议方法（类方法）</h3><p><code>Person 类</code>实现了<code>PersonJSExports 协议</code>，该协议规定哪些属性可以在 <code>JavaScript</code>中可用。<br>在<code>JavaScript</code>语境中，不能像：<code>var person = new Person()</code>来初始化实例，可以在定义<code>PersonJSExports</code>协议方法时，添加一个协议方法来弥补这一点。见下例<code>create...</code>类方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom protocol must be declared with `@objc`</span></span><br><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PersonJSExports</span> : <span class="title">JSExport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> birthYear: <span class="type">NSNumber?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getFullName</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在JavaScript中调用这个类方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createWithFirstName</span>(<span class="title">firstName</span>: <span class="title">String</span>, <span class="title">lastName</span>: <span class="title">String</span>) -&gt; <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">### 定义<span class="title">Person</span>模型</span></span><br><span class="line"><span class="class">定义一个遵守`<span class="title">PersonJSExports</span>`协议的`<span class="title">Person</span>`数据模</span></span><br><span class="line"><span class="class">// <span class="title">Custom</span> <span class="title">class</span> <span class="title">must</span> <span class="title">inherit</span> <span class="title">from</span> `<span class="title">NSObject</span>`</span></span><br><span class="line"><span class="class">@<span class="title">objc</span> <span class="title">class</span> <span class="title">Person</span> : <span class="title">NSObject</span>, <span class="title">PersonJSExports</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JS协议属性必须声明为`dynamic`</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> birthYear: <span class="type">NSNumber?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">        <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//JS协议类方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createWithFirstName</span>(<span class="title">firstName</span>: <span class="title">String</span>, <span class="title">lastName</span>: <span class="title">String</span>) -&gt; <span class="title">Person</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Person</span>(firstName: firstName, lastName: lastName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//JS协议方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getFullName</span><span class="params">()</span></span> -&gt; <span class="type">String</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(firstName) \(lastName)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JSContext-配置"><a href="#JSContext-配置" class="headerlink" title="JSContext 配置"></a>JSContext 配置</h3><p>之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 <code>JavaScript</code> 环境。我们也将借此导入<a href="http://mustache.github.io" target="_blank" rel="noopener">Mustache JS library</a>，我们将应用模板到我们的 Person 对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export Person class，JS中以该`Person标示符`作为类名使用</span></span><br><span class="line">context.setObject(<span class="type">Person</span>.<span class="keyword">self</span>, forKeyedSubscript: <span class="string">"Person"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// load Mustache.js</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> mustacheJSString = <span class="type">String</span>(contentsOfFile:..., encoding:<span class="type">NSUTF8StringEncoding</span>, error:<span class="literal">nil</span>) </span><br><span class="line">&#123;</span><br><span class="line">    context.evaluateScript(mustacheJSString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JavaScript-数据和进程"><a href="#JavaScript-数据和进程" class="headerlink" title="JavaScript 数据和进程"></a>JavaScript 数据和进程</h3><p>下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。<br>数据：<br><figure class="highlight json"><figcaption><span>Persons.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Grace"</span>,     <span class="attr">"last"</span>: <span class="string">"Hopper"</span>,   <span class="attr">"year"</span>: <span class="number">1906</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Ada"</span>,       <span class="attr">"last"</span>: <span class="string">"Lovelace"</span>, <span class="attr">"year"</span>: <span class="number">1815</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"first"</span>: <span class="string">"Margaret"</span>,  <span class="attr">"last"</span>: <span class="string">"Hamilton"</span>, <span class="attr">"year"</span>: <span class="number">1936</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>创建新的 Person 实例：<br><figure class="highlight js"><figcaption><span>loadPeople.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadPeopleFromJSON = <span class="function"><span class="keyword">function</span>(<span class="params">jsonString</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonString);</span><br><span class="line">    <span class="keyword">var</span> people = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data.length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在swift中的js协议方法：`createWithFirstName:lastName:`</span></span><br><span class="line">        <span class="keyword">var</span> person = Person.createWithFirstNameLastName(data[i].first, data[i].last);</span><br><span class="line">        person.birthYear = data[i].year;</span><br><span class="line">        <span class="comment">//`push:`添加到数组中</span></span><br><span class="line">        people.push(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回该对象</span></span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>JSContext</code>加载装换<code>loadPeople.js</code>脚本<br>加载js脚本之后，<code>loadPeopleFromJSON</code>即可作为下标被<code>context</code>调用该方法:<br><figure class="highlight swift"><figcaption><span>加载loadPeople.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load loadPeople.js</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> loadPeople = <span class="type">String</span>(contentsOfFile:..., encoding:<span class="type">NSUTF8StringEncoding</span>, error:<span class="literal">nil</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载js脚本之后，`loadPeopleFromJSON`即可作为下标被context调用该方法</span></span><br><span class="line">    context.evaluateScript(loadPeople)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。</p></blockquote><h3 id="使用Mustache-模板-渲染"><a href="#使用Mustache-模板-渲染" class="headerlink" title="使用Mustache 模板 渲染"></a>使用Mustache 模板 渲染</h3><p>Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。<br><a href="http://blog.csdn.net/kevin_luan/article/details/46485561" target="_blank" rel="noopener">mustache模板引擎</a><br><a href="https://github.com/BjornRuud/Swiftache" target="_blank" rel="noopener">Mustache 的 Swift 语言实现版本</a><br>mustache的特点就是很语法很简单，主要语法如下:</p><pre><code>1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ &name }}，这个和分隔符无关2. {{#person}}…{{/person}} 区块，4种方式    person 是真假值，决定是否输出    person 是list of array，会循环展开 for x in person:section.render(&apos;xxx)    person 是匿名函数/object, 区块包裹的html 会作为参数传递进去    person 是dict，直接打印 dict[key]3. {{^person}}…{{/person}，反向区块    4. {{！name }} 注释5. {{> box }} 载入子模块</code></pre><p>加载 <code>JSON 数据</code>，调用 <code>JSContext</code> 将数据解析成 <code>Person 对象</code>的数组，并用 <code>Mustache 模板</code>呈现每个<code>Person</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件`Persons.json`中加载json数据</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> peopleJSON = <span class="type">NSString</span>(contentsOfFile:..., encoding: <span class="type">NSUTF8StringEncoding</span>, error: <span class="literal">nil</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取js中定义的`loadPeopleFromJSON`的方法</span></span><br><span class="line">    <span class="keyword">let</span> load = context.objectForKeyedSubscript(<span class="string">"loadPeopleFromJSON"</span>)</span><br><span class="line">    <span class="comment">// 通过调用load方法将`JSON 数据`解析成`Person 对象`的数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> people = load.callWithArguments([peopleJSON]).toArray() <span class="keyword">as</span>? [<span class="type">Person</span>] </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get rendering function and create template</span></span><br><span class="line">        <span class="keyword">let</span> mustacheRender = context.objectForKeyedSubscript(<span class="string">"Mustache"</span>).objectForKeyedSubscript(<span class="string">"render"</span>)</span><br><span class="line">        <span class="keyword">let</span> template = <span class="string">", born "</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through people and render Person object as string</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">println</span>(mustacheRender.callWithArguments([template, person]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Grace Hopper, born 1906</span></span><br><span class="line"><span class="comment">// Ada Lovelace, born 1815</span></span><br><span class="line"><span class="comment">// Margaret Hamilton, born 1936</span></span><br></pre></td></tr></table></figure><br>JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java​Script​Core实现swift混编</title>
      <link href="/2017/02/12/swift/Java%E2%80%8BScript%E2%80%8BCore%E5%AE%9E%E7%8E%B0swift%E6%B7%B7%E7%BC%96/"/>
      <url>/2017/02/12/swift/Java%E2%80%8BScript%E2%80%8BCore%E5%AE%9E%E7%8E%B0swift%E6%B7%B7%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>OS X Mavericks 和 iOS 7 引入了 <code>JavaScriptCore</code> 库，它把 <code>WebKit 的 JavaScript</code> 引擎用 <code>Objective-C</code> 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，<code>JavaScript</code> 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。</p><ol><li>如何从 <code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</li><li>那么反向呢？怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？</li></ol><h2 id="swift通过JSContext调用JavaScript"><a href="#swift通过JSContext调用JavaScript" class="headerlink" title="swift通过JSContext调用JavaScript"></a>swift通过JSContext调用JavaScript</h2><p>如何从<code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</p><h3 id="全局实例JSContext：运行JavaScript代码的环境"><a href="#全局实例JSContext：运行JavaScript代码的环境" class="headerlink" title="全局实例JSContext：运行JavaScript代码的环境"></a>全局实例JSContext：运行JavaScript代码的环境</h3><p>全局实例<code>JSContext</code>作用就像在浏览器内运行的一个<code>JavaScript</code>脚本，<code>JSContext</code> 类似于 <code>window</code>。<br>通过<code>JSContext</code>实例运行<code>JavaScript</code>代码<code>创建变量</code>，<code>做计算</code>，<code>定义方法</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="type">JSContext</span>()    <span class="comment">//创建全局环境</span></span><br><span class="line">context.evaluateScript(<span class="string">"var num = 5 + 5"</span>) <span class="comment">//计算</span></span><br><span class="line">context.evaluateScript(<span class="string">"var names = ['Grace', 'Ada', 'Margaret']"</span>) <span class="comment">//定义变量</span></span><br><span class="line">context.evaluateScript(<span class="string">"var triple = function(value) &#123; return value * 3 &#125;"</span>) <span class="comment">//定义方法</span></span><br><span class="line"><span class="keyword">let</span> tripleNum: <span class="type">JSValue</span> = context.evaluateScript(<span class="string">"triple(num)"</span>)  </span><br></pre></td></tr></table></figure></p><h3 id="动态类型JSValue-包裹JSContext环境下每一个可能的JS值"><a href="#动态类型JSValue-包裹JSContext环境下每一个可能的JS值" class="headerlink" title="动态类型JSValue:包裹JSContext环境下每一个可能的JS值"></a>动态类型JSValue:包裹JSContext环境下每一个可能的JS值</h3><p><code>JavaScript</code> 是动态语言，所以动态类型<code>JSValue</code>包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 <code>null</code> 和 <code>undefined</code>。<br>获取<code>tripleNum</code>值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Tripled: \(tripleNum.toInt32())"</span>)</span><br></pre></td></tr></table></figure><br><code>JSValue</code> 包括一系列方法用于访问其可能的值以保证有正确的 <code>Foundation 基本类型</code><br>包括：</p><h3 id="下标取值：访问JSContext环境下的任何值"><a href="#下标取值：访问JSContext环境下的任何值" class="headerlink" title="下标取值：访问JSContext环境下的任何值"></a>下标取值：访问JSContext环境下的任何值</h3><p><code>JSContext</code> 和 <code>JSValue</code> 实例可以使用下标的方式访问之前创建的 <code>context</code> 的任何值。</p><ul><li><code>JSContext</code>：需要一个字符串下标</li><li><code>JSValue</code>：允许使用<code>字符串</code>或<code>整数</code>标来得到里面的对象和数组</li></ul><h4 id="JSContext下标取值"><a href="#JSContext下标取值" class="headerlink" title="JSContext下标取值"></a>JSContext下标取值</h4><ol><li><code>swift</code>语法<figure class="highlight swift"><figcaption><span>未映射成[]的原始方法</span><a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="noopener">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = context.objectForKeyedSubscript(<span class="string">"names"</span>)  <span class="comment">//JSContext字符串下标原始方法</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="JSValue整数下标原始方法"><a href="#JSValue整数下标原始方法" class="headerlink" title="JSValue整数下标原始方法"></a>JSValue整数下标原始方法</h4><figure class="highlight swift"><figcaption><span>未映射成[]的原始方法</span><a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="noopener">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialName = names.objectAtIndexedSubscript(<span class="number">0</span>)   <span class="comment">//JSValue整数下标原始方法</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The first name: \(initialName.toString())"</span>)  <span class="comment">//JSValue method</span></span><br><span class="line"><span class="comment">// The first name: Grace</span></span><br></pre></td></tr></table></figure><blockquote><p>在这里，Objective-C 代码可以利用下标表示法，如下例：context[@”names”]，names[0]，[initialName toString]，Swift 目前只公开<a href="http://nshipster.cn/object-subscripting/" target="_blank" rel="noopener">原始方法</a>:<code>objectAtKeyedSubscript()</code> 和 <code>objectAtIndexedSubscript()</code>来让下标成为可能。</p></blockquote><h3 id="callWithArguments调用JS方法：只需传入Foundation基本类型参数"><a href="#callWithArguments调用JS方法：只需传入Foundation基本类型参数" class="headerlink" title="callWithArguments调用JS方法：只需传入Foundation基本类型参数"></a>callWithArguments调用JS方法：只需传入Foundation基本类型参数</h3><p>上述<code>JavaScript</code>代码中，<code>JSValue</code>包装了一个<code>triple函数</code>，在<code>Objective-C / Swift</code> 代码中可以使用 <code>Foundation基本类型</code>作为参数来直接调用该函数。再次，<code>JavaScriptCore</code> 很轻松的处理了这个桥接：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">let</span> tripleFunction = context.objectForKeyedSubscript(<span class="string">"triple"</span>) <span class="comment">//下标取值</span></span><br><span class="line"><span class="keyword">let</span> result = tripleFunction.callWithArguments([<span class="number">5</span>]) <span class="comment">//传入基本类型参数直接调用</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Five tripled: \(result.toInt32())"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="exceptionHandler错误处理"><a href="#exceptionHandler错误处理" class="headerlink" title="exceptionHandler错误处理"></a><code>exceptionHandler</code>错误处理</h3><p><code>exceptionHandler</code> 是一个接收<code>JSContext 引用</code>和<code>异常本身</code>的回调处理的闭包。<br>通过设置上下文的 <code>exceptionHandler</code> 属性，可以观察和记录<code>语法</code>，<code>类型</code>以及<code>运行时错误</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.exceptionHandler = &#123; context, exception <span class="keyword">in</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"JS Error: \(exception)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.evaluateScript(<span class="string">"function multiply(value1, value2) &#123; return value1 * value2 "</span>)</span><br><span class="line"><span class="comment">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"JS Error: %@"</span>, exception);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[context evaluateScript:<span class="string">@"function multiply(value1, value2) &#123; return value1 * value2 "</span>];</span><br><span class="line"><span class="comment">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure></p><h2 id="JavaScript-通过JSContext调用-swift／OC"><a href="#JavaScript-通过JSContext调用-swift／OC" class="headerlink" title="JavaScript 通过JSContext调用 swift／OC"></a>JavaScript 通过JSContext调用 swift／OC</h2><p>怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？<br>让 <code>JSContext</code> 访问我们的本地客户端代码的方式主要有两种：</p><ol><li><code>block块</code>键值对：把OC中的<code>block块</code>赋值给<code>JSContext</code>的一个标示键，该标识键的<code>JSValue</code>可以通过<code>callWithArguments</code>调用.</li><li><code>JSExport 协议</code>。</li></ol><h3 id="block块-键值对-该block键的JSValue通过callWithArguments调用"><a href="#block块-键值对-该block键的JSValue通过callWithArguments调用" class="headerlink" title="block块 键值对:该block键的JSValue通过callWithArguments调用"></a>block块 键值对:该block键的<code>JSValue</code>通过<code>callWithArguments</code>调用</h3><p>当一个 <code>Objective-C block</code> 被赋给 <code>JSContext</code> 里的一个标识符，<code>JavaScriptCore</code> 会自动的把 <code>block</code> 封装在 <code>JavaScript 函数</code>里，并以该标示符作为函数名来调用该block的实现。这使得在 <code>JavaScript</code> 中可以简单的使用 <code>Foundation</code> 和 <code>Cocoa</code>类，所有的桥接都为你做好了。<br><a href="http://nshipster.cn/cfstringtransform/" target="_blank" rel="noopener">CFStringTransform</a>处理语言的强大威力</p><p>在 <code>JSContext</code> 中使用 <code>Swift 闭包</code>需要注意两点:</p><ol><li>与 <code>@objc_block</code> 属性一起声明</li><li>使用Swift中的<code>unsafeBitCast()</code>函数，把对象转换为<code>AnyObject</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simplifyString: <span class="meta">@objc</span>_block <span class="type">String</span> -&gt; <span class="type">String</span> = &#123; input <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> mutableString = <span class="type">NSMutableString</span>(string: input) <span class="keyword">as</span> <span class="type">CFMutableStringRef</span></span><br><span class="line">    <span class="type">CFStringTransform</span>(mutableString, <span class="literal">nil</span>, kCFStringTransformToLatin, <span class="type">Boolean</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="type">CFStringTransform</span>(mutableString, <span class="literal">nil</span>, kCFStringTransformStripCombiningMarks, <span class="type">Boolean</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> mutableString</span><br><span class="line">&#125;</span><br><span class="line">context.setObject(<span class="built_in">unsafeBitCast</span>(simplifyString, <span class="type">AnyObject</span>.<span class="keyword">self</span>), forKeyedSubscript: <span class="string">"simplifyString"</span>)</span><br><span class="line"><span class="comment">//通过simplifyString标示符来调用block的实现</span></span><br><span class="line"><span class="built_in">println</span>(context.evaluateScript(<span class="string">"simplifyString('안녕하새요!')"</span>))</span><br><span class="line"><span class="comment">// annyeonghasaeyo!</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数</span></span><br><span class="line">context[<span class="string">@"simplifyString"</span>] = ^(<span class="built_in">NSString</span> *input) &#123;</span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableString = [input mutableCopy];</span><br><span class="line"><span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformToLatin, <span class="literal">NO</span>);</span><br><span class="line"><span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformStripCombiningMarks, <span class="literal">NO</span>);</span><br><span class="line"><span class="keyword">return</span> mutableString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过simplifyString标示符来调用block的实现</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [context evaluateScript:<span class="string">@"simplifyString('안녕하새요!')"</span>]);</span><br></pre></td></tr></table></figure><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>由于 <code>block</code> 可以保有变量引用，而且 <code>JSContext</code> 也强引用它所有的变量，为了避免强引用循环需要特别小心。<br>避免保有<code>JSContext</code> 或<code>一个 block</code> 里的任何 <code>JSValue</code>。相反，使用 <code>[JSContext currentContext]</code> 得到当前上下文，并把你需要的任何值用参数传递。</p><h3 id="JSExport-协议"><a href="#JSExport-协议" class="headerlink" title="JSExport 协议"></a>JSExport 协议</h3><p>在继承<code>JSExport 协议</code>的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给<code>JavaScript</code>代码来调用。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> JS混编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> macOS </tag>
            
            <tag> 混编 </tag>
            
            <tag> iOS </tag>
            
            <tag> Java​Script​Core </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Git将代码恢复到一个历史的版本</title>
      <link href="/2017/02/11/git/%E7%94%A8Git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2017/02/11/git/%E7%94%A8Git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：<br>目的：在当前分支上，将代码恢复到一个历史的提交版本上。</p><h2 id="暴力的方式"><a href="#暴力的方式" class="headerlink" title="暴力的方式"></a>暴力的方式</h2><p>如果仓库是自己在用（不影响别人），那么可以使用<code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p><ol><li>第一步：查看本地的索引的提交日志：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog </span></span><br><span class="line">a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to master</span><br><span class="line">a1d09fd HEAD@&#123;1&#125;: checkout: moving from master to all</span><br><span class="line">a1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to master</span><br><span class="line">a1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD</span><br></pre></td></tr></table></figure></li><li>第二步：根据上面的sh2值，回滚：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset  —hard  a1d09fd</span><br></pre></td></tr></table></figure>这样就可以找回代码.</li></ol><h2 id="温柔的方式"><a href="#温柔的方式" class="headerlink" title="温柔的方式"></a>温柔的方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">回滚</span></span><br><span class="line">git reset  —hard  a1d09fd</span><br><span class="line"><span class="meta">#</span><span class="bash">将当前代码切换回最新的提交</span></span><br><span class="line">git reset --soft origin/source</span><br></pre></td></tr></table></figure><p>此时工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可.</p><h3 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h3><ul><li>舍弃上一次工作区的更改<br><code>git checkout .</code></li><li>舍弃暂存区的更改<br><code>git reset --hard</code></li><li>恢复上一次提交的内容到工作区<br><code>git reset -- .</code><br><code>git reset filename</code></li><li>先提交后再恢复到上一次提交的状态<br><code>git revert id</code><br><code>git revert HEAD</code></li><li>修改提交的日志分两步<br><code>git commit -am &quot;日志信息&quot;</code><br><code>git commit -amend</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> 恢复 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bilibiliForMac版之mpv依赖编译</title>
      <link href="/2017/02/10/%E7%BC%96%E8%AF%91/bilibili%E4%B9%8BMac%E7%89%88ffmpeg%E4%BE%9D%E8%B5%96%E7%BC%96%E8%AF%91/"/>
      <url>/2017/02/10/%E7%BC%96%E8%AF%91/bilibili%E4%B9%8BMac%E7%89%88ffmpeg%E4%BE%9D%E8%B5%96%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Bilibili-Mac-Client"><a href="#Bilibili-Mac-Client" class="headerlink" title="Bilibili Mac Client"></a><a href="https://github.com/typcn/bilibili-mac-client" target="_blank" rel="noopener">Bilibili Mac Client</a></h2><p>一款基于mpv和ffmpeg底层库实现的播放器.</p><h2 id="项目依赖库"><a href="#项目依赖库" class="headerlink" title="项目依赖库"></a>项目依赖库</h2><p>编译在项目中所需的相关依赖库</p><h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><ol><li><p>下载mpv-build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mpv-player/mpv-build.git</span><br></pre></td></tr></table></figure></li><li><p>执行下载<code>ffmpeg</code>, <code>libass</code> 和<code>mpv资源</code>，同时完成编译的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mpv-build/ </span><br><span class="line">./rebuild -j4  </span><br></pre></td></tr></table></figure></li><li><p>使用参数 “–enable-shared ” 可以开启 ffmpeg 的动态版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffmpeg/</span><br><span class="line">./configure --<span class="built_in">enable</span>-shared    </span><br></pre></td></tr></table></figure></li><li><p>安装ffmpeg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在ffmpeg目录下执行：</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h3 id="开始编译mpv动态依赖库："><a href="#开始编译mpv动态依赖库：" class="headerlink" title="开始编译mpv动态依赖库："></a>开始编译mpv动态依赖库：</h3><ol><li>开启libmpv动态库的支持：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../mpv/</span><br><span class="line">./waf configure --<span class="built_in">enable</span>-libmpv-shared  --<span class="built_in">disable</span>-libass</span><br><span class="line">./waf build</span><br></pre></td></tr></table></figure><blockquote><p>变更去除static参数：./waf configure –enable-static-build –enable-libmpv-shared  –disable-libass</p></blockquote></li></ol><h2 id="集成到项目中"><a href="#集成到项目中" class="headerlink" title="集成到项目中"></a>集成到项目中</h2><h3 id="指定libmpv-dylib相对路径"><a href="#指定libmpv-dylib相对路径" class="headerlink" title="指定libmpv.dylib相对路径"></a>指定libmpv.dylib相对路径</h3><p>直接编译出来的库会是绝对路径，需要先通过install_name_tool 修改 相对路径：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build/</span><br><span class="line">install_name_tool -id "@executable_path/lib/libmpv.dylib" libmpv.dylib</span><br></pre></td></tr></table></figure></p><h3 id="聚合ffmpeg相关依赖包"><a href="#聚合ffmpeg相关依赖包" class="headerlink" title="聚合ffmpeg相关依赖包"></a>聚合ffmpeg相关依赖包</h3><p>执行 mpv<code>tools/dylib-unhell</code> ，目标是 <code>libmpv.dylib</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOOLS/dylib-unhell.py libmpv.dylib</span><br></pre></td></tr></table></figure><br>这样会多出一个 <code>lib文件夹</code>，里面会出现变为相对路径的文件，复制导入到项目即可。</p><h2 id="相对路径脚本学习"><a href="#相对路径脚本学习" class="headerlink" title="相对路径脚本学习"></a>相对路径脚本学习</h2><p>使用otool -L 和install_name_tool完成了一系列操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change</span><br><span class="line">install_name_tool -id </span><br></pre></td></tr></table></figure><br><img src="https://cloud.githubusercontent.com/assets/4022953/16513398/fba07b2a-3f96-11e6-8358-b93275ed0a09.png" alt="编译后的资源目录位置"></p><h3 id="扩展一："><a href="#扩展一：" class="headerlink" title="扩展一："></a>扩展一：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/sh</span></span><br><span class="line">mkdir "$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib"</span><br><span class="line">cp -f /your/path/to/xcode_project_name/dylib/*.dylib "$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib/"</span><br><span class="line"></span><br><span class="line">echo "--------$(pwd)----------------"</span><br><span class="line">cur_dir="$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib"</span><br><span class="line">cd $&#123;cur_dir&#125;</span><br><span class="line">echo "--进入$(pwd)--"</span><br><span class="line"></span><br><span class="line">for dirlist in $(ls $&#123;cur_dir&#125;)</span><br><span class="line">    #查看它们的 rpath</span><br><span class="line">    otool -L $&#123;dirlist&#125;</span><br><span class="line">    #制作相对路径</span><br><span class="line">    #方法一</span><br><span class="line">    install_name_tool -change /usr/local/lib/$&#123;dirlist&#125; @executable_path/lib/$&#123;dirlist&#125; "$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME"</span><br><span class="line">    #方法二</span><br><span class="line">    install_name_tool -id "@executable_path/lib/$&#123;dirlist&#125;" $&#123;dirlist&#125;</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展二"><a href="#扩展二" class="headerlink" title="扩展二"></a>扩展二</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo "--------$(pwd)----------------"</span><br><span class="line">cur_dir="$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib"</span><br><span class="line">cd $&#123;cur_dir&#125;</span><br><span class="line">echo "--进入$(pwd)--"</span><br><span class="line">lib="libmediainfo.0.dylib"</span><br><span class="line"><span class="meta">#</span><span class="bash">-f 参数判断 <span class="variable">$file</span> 是否存在</span></span><br><span class="line">if [ -f "$lib" ]; then</span><br><span class="line">    otool -L $&#123;lib&#125;</span><br><span class="line">    install_name_tool -id "@executable_path/lib/$&#123;lib&#125;" $&#123;lib&#125;</span><br><span class="line">    otool -L $&#123;lib&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
          <category> 视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> mpv </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发Mac上的App插件</title>
      <link href="/2017/02/07/macOS/%E5%BC%80%E5%8F%91Mac%E4%B8%8A%E7%9A%84App%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/02/07/macOS/%E5%BC%80%E5%8F%91Mac%E4%B8%8A%E7%9A%84App%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过<code>NSBundle</code>和 <code>plug-ins</code>插件,可以很方便的向原有APP中添加新功能点。</p><p>目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能</p><h2 id="包-Bundles-和接口-Interfaces"><a href="#包-Bundles-和接口-Interfaces" class="headerlink" title="包 (Bundles) 和接口 (Interfaces)"></a>包 (Bundles) 和接口 (Interfaces)</h2><p>如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： <code>Screen Savers</code> 到 <code>Image Units</code>等。<br>在<code>Framework &amp; Library</code>中的 <code>Bundle</code> 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。<br><code>bundle 模版</code>项目与APP项目比较：</p><ol><li>一个 <code>Contents</code> 目录，里面包含了 <code>Info.plist</code> 和 <code>Resource</code> 目录。</li><li>如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 <code>MacOS</code> 目录。</li><li><code>Bundle</code> 工程里缺少的一个东西是 <code>main()</code> 函数。它是被宿主<code>App</code> 调用执行的。</li></ol><h2 id="为-TextEdit-加入-Plugin-支持"><a href="#为-TextEdit-加入-Plugin-支持" class="headerlink" title="为 TextEdit 加入 Plugin 支持"></a>为 TextEdit 加入 Plugin 支持</h2><p>两种插件的方式:<br>    第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。<br>    第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。<br>本文章的项目文件仍然会放在 <a href="https://github.com/objcio/issue-14-plugins" target="_blank" rel="noopener">GitHub</a> 供大家参考。</p><h3 id="在-TextEdit-中扫描-Bundle"><a href="#在-TextEdit-中扫描-Bundle" class="headerlink" title="在 TextEdit 中扫描 Bundle"></a>在 TextEdit 中扫描 Bundle</h3><p>请打开 “01 TextEdit” 目录下面的 <code>TextEdit.xcodeproj</code> 工程，同时浏览它里面包含的代码。<br><code>TextEdit</code> 里面有三个简单的组成部分：扫描 <code>bundle</code>，加载 <code>bundle</code>，调用 <code>bundle 的 UI</code><br><code>loadPlugins</code> 方法：<br>打开 <code>Controller.m</code>，你可以看见 <code>-(void)loadPlugins</code> 方法 (它在 <code>applicationDidFinishLaunching:</code> 中被调用)。</p><ol><li>扩展插件菜单：在界面菜单右侧加入了一个新的 <code>NSMenuItem</code>，为调用插件提供一个入口（通常你会在 <code>MainMenu.xib</code> 做这件事情并且链接 <code>outlets</code>，但是我们这次偷下懒）。</li><li>扫描插件目录：获得插件目录（在 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> ）下，并且扫描这个目录。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *pluginsFolder = [<span class="keyword">self</span> pluginsFolder];</span><br><span class="line"><span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line"><span class="built_in">NSError</span> *outErr;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *item <span class="keyword">in</span> [fm contentsOfDirectoryAtPath:pluginsFolder error:&amp;outErr]) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![item hasSuffix:<span class="string">@".bundle"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *bundlePath = [pluginsFolder stringByAppendingPathComponent:item];</span><br><span class="line">    <span class="built_in">NSBundle</span> *b = [<span class="built_in">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class="line">    <span class="keyword">if</span> (!b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Could not make a bundle from %@"</span>, bundlePath);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取实现插件代理协议方法的类</span></span><br><span class="line">    <span class="keyword">id</span> &lt;TextEditPlugin&gt; plugin = [[b principalClass] new];</span><br><span class="line">    <span class="built_in">NSMenuItem</span> *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:<span class="keyword">@selector</span>(pluginMenuItemCalledAction:) keyEquivalent:<span class="string">@""</span>];</span><br><span class="line">    [item setRepresentedObject:plugin];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：扫描插件目录，确保得到的是一个 <code>.bundle</code> 文件，然后用 <code>NSBundle</code> 载入你找到的 <code>bundle</code> 并且实例化里面的类。</p></blockquote></li></ol><h3 id="插件代理"><a href="#插件代理" class="headerlink" title="插件代理"></a>插件代理</h3><p>你会注意到一个 <code>TextEditPlugin</code> 的 <code>protocol</code> 的引用。在 <code>TextEditMisc.h</code> 能找它的定义:<br><figure class="highlight objc"><figcaption><span>声明代理协议</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TextEditPlugin</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span>*)menuItemTitle;</span><br><span class="line">- (<span class="keyword">void</span>)actionCalledWithTextView:(<span class="built_in">NSTextView</span>*)textView inDocument:(<span class="keyword">id</span>)document;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br>这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。</p><h3 id="NSPrincipalClass键-值–实现插件代理协议方法的类名称"><a href="#NSPrincipalClass键-值–实现插件代理协议方法的类名称" class="headerlink" title="NSPrincipalClass键:值–实现插件代理协议方法的类名称"></a>NSPrincipalClass键:值–实现插件代理协议方法的类名称</h3><p>在 <code>bundle</code> 里面调用的 <code>principalClass</code> 方法是什么呢？<br>当你创建一个 <code>Bundle</code> 的时候，你可以在里面创建一个或者多个类，同时你需要让 <code>TextEdit</code> 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 <code>Info.plist</code> 文件加入一个 <code>NSPrincipalClass</code> 的键，同时设置它的值为实现插件方法的类的名字。你可以用 <code>[NSBundle principalClass]</code> 方便地从 <code>NSPrincipalClass</code> 的值里面寻找并创建这个类。</p><h3 id="添加扩展插件菜单的响应事件"><a href="#添加扩展插件菜单的响应事件" class="headerlink" title="添加扩展插件菜单的响应事件"></a>添加扩展插件菜单的响应事件</h3><p>在 <code>Plug-Ins</code> 菜单加入一个新的按钮，设置 <code>action</code> 为 <code>pluginMenuItemCalledAction:</code>，并且设置它表示你已经实例化的对象。</p><blockquote><p>如果在 <code>menu item</code> 里面没有设置一个<code>target</code>，即目标是<code>nil</code>，那么它会寻找响应链，来寻找第一个实现 <code>pluginMenuItemCalledAction:</code> 方法的对象。如果它找不到，那么这个菜单选项将会不能用。<br>举一个例子，实现 <code>pluginMenuItemCalledAction</code> 的最好的地方是在 <code>Document</code> 的 <code>window controller</code> 类中。打开 <code>DocumentWindowController.m</code>，然后定位到<code>pluginMenuItemCalledAction</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pluginMenuItemCalledAction:(<span class="keyword">id</span>)sender </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> &lt;TextEditPlugin&gt;plugin = [sender representedObject];</span><br><span class="line">    [plugin actionCalledWithTextView:[<span class="keyword">self</span> firstTextView] inDocument:[<span class="keyword">self</span> document]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>代码本身很清晰，搜集插件实例，调用 <code>actionCalledWithTextView:inDocument:</code> 方法（被定义在 <code>protocol</code> 里面的），运行你插件里面的代码。</p><h2 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h2><ol><li>新建模版项目<br>打开 “01 MarkYellow” 工程看一下。这是一个 Xcode (通过<code>OS X ▸ Framework &amp; Library ▸ Bundle template</code> 建立) 的标准工程，里面只添加了一个类：<code>TEMarkYellow</code>。</li><li>设置NSPrincipalClass键值<br>如果你打开<code>MarkYellow-Info.plist</code>，你可以看到 <code>NSPrincipalClass</code> 的值设置成了上面提到的 <code>TEMarkYellow</code>。</li><li>实现协议代理<br>接着，打开 <code>TEMarkYellow.m</code>，你将会看见定义在协议里面的方法。<ul><li>第一个方法（<code>menuItemTitle</code>）返回插件的名字，最为入口名显示在 <code>menu</code> 里面。</li><li>第二个方法 (<code>actionCalledWithTextView:inDocument:</code>)，把所有选中的文字变成黄色的背景。<figure class="highlight objc"><figcaption><span>改变字体颜色</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)actionCalledWithTextView:(<span class="built_in">NSTextView</span>*)textView inDocument:(<span class="keyword">id</span>)document </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([textView selectedRange].length) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMutableAttributedString</span> *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy];</span><br><span class="line">        [ats addAttribute:<span class="built_in">NSBackgroundColorAttributeName</span> value:[<span class="built_in">NSColor</span> yellowColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [ats length])];</span><br><span class="line">        <span class="comment">//  先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。</span></span><br><span class="line">        By asking the text view <span class="keyword">if</span> you can change the text first, it will automatically <span class="keyword">do</span> the right thing to enable undoing of attribute changes</span><br><span class="line">        <span class="keyword">if</span> ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]])</span><br><span class="line">        &#123;</span><br><span class="line">            [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats];</span><br><span class="line">            [textView didChangeText];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="集成插件"><a href="#集成插件" class="headerlink" title="集成插件"></a>集成插件</h2><p>运行 <code>TextEdit</code> （它会创建<code>Plug-Ins</code>目录），然后构建 <code>MarkYellow</code> 工程。把 <code>MarkYellow.bundle</code> 丢到你的 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> 目录下面，重启你的 <code>TextEdit</code> 应用。<br>一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 <code>Plug-Ins ▸ Mark Selected Text Yellow</code>，选择的文字的背景颜色就变成黄色的了。</p><h2 id="XCode8版本问题"><a href="#XCode8版本问题" class="headerlink" title="XCode8版本问题"></a>XCode8版本问题</h2><p>Xcode8 不再支持<code>Application Plug-in</code>插件<br><a href="http://www.jianshu.com/p/39443429f71d" target="_blank" rel="noopener">XCode8.2.1继续使用xcode插件</a><br>这个是因为苹果解决xcode ghost，把插件屏蔽了。<br>解决方法<br><code>sudo /usr/libexec/xpccachectl</code><br>然后必须重启电脑后生效.</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Crash文件分析方法</title>
      <link href="/2017/02/07/%E8%B0%83%E8%AF%95/Crash%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
      <url>/2017/02/07/%E8%B0%83%E8%AF%95/Crash%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>第一步：在任意目录创建调试crash的目录</p><p>第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM</p><p>第三步：将symbolicatecrash工具copy到crash目录<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></p><p>2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起<br>拷贝到crash目录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash</span><br></pre></td></tr></table></figure></p><p>第四步：执行symbolicatecrash<br>1.打开终端用命令切换到桌面的crash目录下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/你的电脑名称/Desktop/crash</span><br></pre></td></tr></table></figure></p><p>2.执行命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash</span><br></pre></td></tr></table></figure></p><p>这时候终端有可能会出现：<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60.</code></p><p>3.输入命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DEVELOPER_DIR=<span class="string">"/Applications/XCode.app/Contents/Developer"</span></span><br></pre></td></tr></table></figure></p><p>4.再执行 2.的命令行</p><p>5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsupported crash <span class="built_in">log</span> version: 12 at ./symbolicatecrash line 614.</span><br></pre></td></tr></table></figure></p><p>第五步：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo标签插件</title>
      <link href="/2017/01/23/hexo/Hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/01/23/hexo/Hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p><h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><hr><p>在文章中插入引言，可包含作者、来源和标题。</p><h3 id="别号：-quote"><a href="#别号：-quote" class="headerlink" title="别号： quote"></a>别号： quote</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><hr><h5 id="无参普通blockquote"><a href="#无参普通blockquote" class="headerlink" title="无参普通blockquote"></a>无参普通blockquote</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><a id="more"></a><h5 id="引用书上的句子"><a href="#引用书上的句子" class="headerlink" title="引用书上的句子"></a>引用书上的句子</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness <span class="keyword">for</span> yourself. Seek happiness <span class="keyword">for</span> all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>boyer huo </strong><cite>Wide Awake</cite></footer></blockquote><h5 id="引用-Twitter"><a href="#引用-Twitter" class="headerlink" title="引用 Twitter"></a>引用 Twitter</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https:<span class="comment">//twitter.com/devdocs/status/356095192085962752 %&#125;</span></span><br><span class="line">NEW: DevDocs now comes <span class="keyword">with</span> syntax highlighting. http:<span class="comment">//devdocs.io</span></span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="noopener">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="noopener">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h5 id="引用网络上的文章"><a href="#引用网络上的文章" class="headerlink" title="引用网络上的文章"></a>引用网络上的文章</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http:<span class="comment">//sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span></span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><hr><p>在文章中插入代码。</p><h3 id="别名-code"><a href="#别名-code" class="headerlink" title="别名:code"></a>别名:code</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><hr><h5 id="普通的代码块"><a href="#普通的代码块" class="headerlink" title="普通的代码块"></a>普通的代码块</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock %&#125;</span><br><span class="line">alert(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><h5 id="指定语言"><a href="#指定语言" class="headerlink" title="指定语言"></a>指定语言</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;</span><br><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br></pre></td></tr></table></figure><h5 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock <span class="built_in">Array</span>.map %&#125;</span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.map</span><br><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><h5 id="附加说明和网址"><a href="#附加说明和网址" class="headerlink" title="附加说明和网址"></a>附加说明和网址</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock _.compact http:<span class="comment">//underscorejs.org/#compact Underscore.js %&#125;</span></span><br><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.compactUnderscore.js</span><br><span class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="反引号代码块-MD语法"><a href="#反引号代码块-MD语法" class="headerlink" title="反引号代码块 (MD语法)"></a>反引号代码块 (MD语法)</h2><hr><h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><hr><h4 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内 <span class="code">`code 块 `</span></span><br></pre></td></tr></table></figure><h4 id="缩进代码块"><a href="#缩进代码块" class="headerlink" title="缩进代码块"></a>缩进代码块</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Some comments</span><br><span class="line">line 1 of code</span><br><span class="line">line 2 of code</span><br><span class="line">line 3 of code</span><br></pre></td></tr></table></figure><h4 id="多行代码块"><a href="#多行代码块" class="headerlink" title="多行代码块"></a>多行代码块</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">``` [language] [title] [url] [link text] </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    代码块</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> `` `</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><hr><h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h3><hr><h4 id="默认左对齐"><a href="#默认左对齐" class="headerlink" title="默认左对齐"></a>默认左对齐</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|参数|描述|默认值|</span><br><span class="line">|-------|-------|----------|</span><br><span class="line">|文本内容 |文本内容| 文本内容  |</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td></td></tr><tr><td>title</td><td>标题</td><td></td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td></tr></tbody></table><h4 id="向右对齐"><a href="#向右对齐" class="headerlink" title="向右对齐"></a>向右对齐</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|参数|描述|默认值|</span><br><span class="line">|-------:|-------:|-------:|</span><br><span class="line">| 文本内容 | 文本内容 | 文本内容|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:right">三种布局</th><th style="text-align:right">路径:(储存到路径文件夹)</th></tr></thead><tbody><tr><td style="text-align:right">post</td><td style="text-align:right">source/_posts</td></tr><tr><td style="text-align:right">page</td><td style="text-align:right">source</td></tr><tr><td style="text-align:right">draft</td><td style="text-align:right">source/_drafts</td></tr></tbody></table><h4 id="向左对齐"><a href="#向左对齐" class="headerlink" title="向左对齐"></a>向左对齐</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|参数|描述|默认值|</span><br><span class="line">|:------|:------|:------|</span><br><span class="line">| 文本内容 | 文本内容 | 文本内容|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">日期变量</th><th style="text-align:left">描述:（可以通过日期来管理文章）</th></tr></thead><tbody><tr><td style="text-align:left">:title</td><td style="text-align:left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td style="text-align:left">:year</td><td style="text-align:left">建立的年份，比如， 2015</td></tr><tr><td style="text-align:left">:month</td><td style="text-align:left">建立的月份（有前导零），比如， 04</td></tr><tr><td style="text-align:left">:i_month</td><td style="text-align:left">建立的月份（无前导零），比如， 4</td></tr><tr><td style="text-align:left">:day</td><td style="text-align:left">建立的日期（有前导零），比如， 07</td></tr><tr><td style="text-align:left">:i_day</td><td style="text-align:left">建立的日期（无前导零），比如， 7</td></tr></tbody></table><h4 id="居中对齐"><a href="#居中对齐" class="headerlink" title="居中对齐"></a>居中对齐</h4><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|参数|描述|默认值|</span><br><span class="line">|:------:|:------:|:------:|</span><br><span class="line">| 文本内容 | 文本内容 | 文本内容|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">layout</td><td style="text-align:center">布局当:false不加任何布局样式</td></tr><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">文件建立日期</td></tr></tbody></table><h2 id="Pull-Quote"><a href="#Pull-Quote" class="headerlink" title="Pull Quote"></a>Pull Quote</h2><hr><p>在文章中插入 Pull quote。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h2><hr><p><a href="https://jsfiddle.net" target="_blank" rel="noopener">官网</a><br>在文章中嵌入 <code>jsFiddle</code> 在线的shell编辑器,可以供我们在线测试html、js、和css代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h2><hr><p>在文章中嵌入 Gist<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gist gist_id [filename] %&#125;</span><br></pre></td></tr></table></figure></p><p><code>filename</code>: 可选，当不指定文件名时，嵌入显示<code>gist_id</code>下所有文件。</p><p>一个gist可能存在多个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gist.github.com/dergachev/4627207#file-gif-screencast-osx-md</span><br></pre></td></tr></table></figure></p><p><code>4627207</code>：表示gist_id ，<code>#file-</code>后边内容：表示Gist中某个文件名</p><p>如下:指定文章中嵌入<code>ecba275d5e4404678354</code>中的<code>NSAttributeString相关方法.m</code>内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gist ecba275d5e4404678354 NSAttributeString相关方法.m %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><hr><p>在文章中插入 iframe。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><hr><h3 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h3><hr><h4 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h4><hr><p>在文章中插入指定大小的图片。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="MD语法"><a href="#MD语法" class="headerlink" title="MD语法"></a>MD语法</h4><hr><h5 id="原图-toolTip"><a href="#原图-toolTip" class="headerlink" title="原图+toolTip"></a>原图+toolTip</h5><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![boyer logo](http://boyers.coding.me/img/logo.png &quot;这是我的logo图片&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://boyers.coding.me/img/logo.png" alt="boyer logo" title="这是我的logo图片"></p><h5 id="注脚语法"><a href="#注脚语法" class="headerlink" title="注脚语法"></a>注脚语法</h5><hr><p>可以在稍後的文件中再定义图片地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![boyer logo][logo]</span><br><span class="line">[logo]: http://boyers.coding.me/img/logo.png  &quot;这是我的logo图片&quot;</span><br></pre></td></tr></table></figure></p><p>![boyer logo][logo]<br>[logo]: <a href="http://boyers.coding.me/img/logo.png" target="_blank" rel="noopener">http://boyers.coding.me/img/logo.png</a>  “这是我的logo图片”</p><h5 id="指定图片大小"><a href="#指定图片大小" class="headerlink" title="指定图片大小"></a>指定图片大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![boyer logo](http://boyers.coding.me/img/logo.png [200] [200] &quot;这是我的logo图片&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://boyers.coding.me/img/logo.png [200] [200]" alt="boyer logo" title="这是我的logo图片"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><hr><h3 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h3><hr><h4 id="Hexo语法-1"><a href="#Hexo语法-1" class="headerlink" title="Hexo语法"></a>Hexo语法</h4><hr><p>在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="MD语法-1"><a href="#MD语法-1" class="headerlink" title="MD语法"></a>MD语法</h4><hr><h5 id="智能识别超链接"><a href="#智能识别超链接" class="headerlink" title="智能识别超链接"></a>智能识别超链接</h5><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://boyers.coding.me</span><br></pre></td></tr></table></figure><p><a href="http://boyers.coding.me" target="_blank" rel="noopener">http://boyers.coding.me</a></p><h5 id="文本式"><a href="#文本式" class="headerlink" title="文本式"></a>文本式</h5><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">boyer Blog</span>](<span class="link">http://boyers.coding.me</span>)</span><br></pre></td></tr></table></figure><p><a href="http://boyers.coding.me" target="_blank" rel="noopener">boyer Blog</a></p><h5 id="toolTip式"><a href="#toolTip式" class="headerlink" title="toolTip式"></a>toolTip式</h5><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">boyer Blog</span>](<span class="link">http://boyers.coding.me "这是我的博客首页"</span>)</span><br></pre></td></tr></table></figure><p><a href="http://boyers.coding.me" title="这是我的博客首页" target="_blank" rel="noopener">boyer Blog</a></p><h2 id="Include-Code"><a href="#Include-Code" class="headerlink" title="Include Code"></a>Include Code</h2><hr><p>插入 source 文件夹内的代码文件(.m/json/xml等)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include_code [title] [lang:language] path/to/file %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h2><hr><p>在文章中插入 Youtube 视频。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Vimeo"><a href="#Vimeo" class="headerlink" title="Vimeo"></a>Vimeo</h2><hr><p>在文章中插入 Vimeo 视频。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% vimeo video_id %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><hr><p>根据服务器根目录分为两种方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_path slug %&#125;</span><br><span class="line">&#123;% post_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></p><p>以<code>Docker使用</code>博客为例</p><ol><li><p>相对路径</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_path Docker使用 %&#125;</span><br></pre></td></tr></table></figure><p> 相对于服务器根目录的位置：</p> </li><li><p>绝对路径</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link Docker使用 Docker使用 %&#125;</span><br></pre></td></tr></table></figure><p> 本博中其他文章的超链接：</p> </li></ol><h2 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h2><hr><p>引用文章的资源。<br>Assets指的是那些不在source目录下的资源，比如图片、CSS文件或者Javascript文件。Hexo提供一种更方便的方法来管理这些资源（Assets）。想使其生效，首先修改 post_asset_folder 字段的设置，将其值改为 true 。<br>当生效后，在你创建文章的时候，Hexo会创建一个同名目录，你可以将该文章关联的资源全部放到该目录下。这样就可以更加方便的使用它们了。<br>使用方法就是上面介绍过的标签插件。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h2><hr><p>一些内容不想被主题渲染，可以使用该插件呈现原始状态。<br>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kindle114 资源集[转]</title>
      <link href="/2017/01/23/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E8%B5%84%E6%BA%90/"/>
      <url>/2017/01/23/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul><li><a href="http://www.hi-pda.com/forum/viewthread.php?tid=1815180" target="_blank" rel="noopener">hi-pda dtgc</a></li><li><a href="http://kindle115.com" target="_blank" rel="noopener">Kindle115</a></li></ul><h2 id="综合类"><a href="#综合类" class="headerlink" title="综合类"></a>综合类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2050031688#category/type=0" target="_blank" rel="noopener">青风乘翼 最近出版的译著</a> 更新中</li><li><a href="http://pan.baidu.com/s/1qWRYl1i" target="_blank" rel="noopener">周旋久 按字母排列的书籍</a> 提取码：djhp</li></ol><ul><li><a href="http://f92a01.l45.yunpan.cn/lk/cxvBQv5ymqCMY" target="_blank" rel="noopener">F、H、J、R字母</a> 提取码 39bd  </li><li><a href="http://f93be8.l45.yunpan.cn/lk/cxvB6neaCmfGL" target="_blank" rel="noopener">S、T、Y字母</a> 提取码 42b1</li></ul><ol start="3"><li><a href="http://pan.baidu.com/share/home?uk=1848670581&amp;view=share#category/type=0" target="_blank" rel="noopener">烫伤关东煮</a> 约1t以上 20160302更新</li><li><a href="http://pan.baidu.com/share/home?uk=2724752809#category/type=0" target="_blank" rel="noopener">18810815415 精排版书籍</a> （可能是豆瓣读书编辑）</li><li><a href="http://pan.baidu.com/share/link?uk=1194297961&amp;shareid=256546" target="_blank" rel="noopener">liantingv70657</a></li><li><a href="http://pan.baidu.com/share/home?uk=3728907970&amp;view=share#category/type=0" target="_blank" rel="noopener">炜博happy</a> 更新中</li><li><a href="http://pan.baidu.com/share/home?uk=1365179281&amp;view=share#category/type=0" target="_blank" rel="noopener">guyuemuziye6@gmail.com 旅游原版书</a> （微博号逼影共享，解压密码bygx）</li><li><a href="http://pan.baidu.com/share/link?uk=4029256032&amp;shareid=139939577" target="_blank" rel="noopener">枫729882492</a></li><li><a href="http://pan.baidu.com/share/home?uk=439872812&amp;view=share#category/type=0" target="_blank" rel="noopener">电子书资源外链发布站</a></li><li><a href="http://yun.baidu.com/share/home?uk=1293124599#category/type=0" target="_blank" rel="noopener">赤霓</a></li><li><a href="http://yun.baidu.com/share/home?uk=4278581020#category/type=0" target="_blank" rel="noopener">nnuuij11111</a></li><li><a href="http://pan.baidu.com/share/home?uk=1282872761&amp;view=share#category/type=0" target="_blank" rel="noopener">风扒皮1503</a></li><li><a href="http://pan.baidu.com/share/home?uk=4211477728&amp;view=share#category/type=0" target="_blank" rel="noopener">zphstar</a></li><li><a href="http://pan.baidu.com/share/home?uk=1261210236#category/type=0" target="_blank" rel="noopener">skmjtptwr</a></li><li><a href="http://pan.baidu.com/share/home?uk=1093619523&amp;view=share#category/type=0" target="_blank" rel="noopener">327995970ou</a></li><li><a href="http://pan.baidu.com/share/home?uk=1057298937&amp;view=share#category/type=0" target="_blank" rel="noopener">xunys</a></li><li><a href="http://yun.baidu.com/share/home?uk=1946547680#category/type=0" target="_blank" rel="noopener">ohhe</a></li><li><a href="http://yun.baidu.com/share/home?uk=490155926#category/type=0" target="_blank" rel="noopener">没我找不到的电子书</a> （此人吹牛居多，书籍不全）</li><li><a href="http://yun.baidu.com/share/home?uk=1426398717&amp;view=share#category/type=0" target="_blank" rel="noopener">搜珍玉鏡</a></li><li><a href="http://yun.baidu.com/share/home?uk=959117889&amp;view=share#category/type=0" target="_blank" rel="noopener">菜是菜菜</a></li><li><a href="http://yun.baidu.com/share/home?uk=775816440&amp;view=share#category/type=0" target="_blank" rel="noopener">13805758171</a></li><li><a href="http://yun.baidu.com/share/home?uk=842217715&amp;view=share#category/type=0" target="_blank" rel="noopener">yun360419811</a></li><li><a href="http://yun.baidu.com/share/home?uk=1512823434&amp;view=share#category/type=0" target="_blank" rel="noopener">虚昧斋</a> 分享新书 可私信求书</li><li><a href="http://pan.baidu.com/share/home?uk=3324179911#category/type=0" target="_blank" rel="noopener">唯我君行 中医、VB</a></li><li><a href="https://pan.baidu.com/share/home?uk=2603616653" target="_blank" rel="noopener">haoyou43 mobi epub 格式书籍 350+</a> 更新中</li><li><a href="http://pan.baidu.com/share/home?uk=2063855134#category/type=0" target="_blank" rel="noopener">liguobing55 txt合集</a></li><li><a href="http://yun.baidu.com/share/home?uk=4097060373&amp;view=share#category/type=0" target="_blank" rel="noopener">青辰VOW  部分全站打包等</a></li><li>苏菇莨百度盘书（BTSync） 约56G 至20160222关闭前 感谢：maldiniymx</li></ol><ul><li>B3EWLQK7C6O6RK3CU5CG3PZUYDUJLMYCP</li><li>B25G263OSC7ZAXPLCZESSL3DFJOHK6UQ3</li></ul><ol start="9"><li><a href="https://mega.nz/#F!nJ8GFJAQ!K5Nw2HF1cMXMGNbYQ7RggQ" target="_blank" rel="noopener">wizardforcel 杂项书籍</a></li><li><a href="http://pan.baidu.com/s/1lKIiq" target="_blank" rel="noopener">豆瓣图书top250</a></li><li><a href="http://pan.baidu.com/share/link?uk=1459936824&amp;shareid=3702424259" target="_blank" rel="noopener">当当epub7000本</a></li><li><a href="http://pan.baidu.com/share/link?shareid=1080906058&amp;uk=1412470983" target="_blank" rel="noopener">卡夫卡全集和哈佛管理</a></li><li><a href="http://pan.baidu.com/s/1sjLkZ97" target="_blank" rel="noopener">知乎话题、专栏、收藏</a></li><li><a href="http://pan.baidu.com/s/1kT85Zp1" target="_blank" rel="noopener">知日系列</a></li><li><a href="http://pan.baidu.com/s/1eQAereE" target="_blank" rel="noopener">知乎盐系列</a></li><li><a href="http://pan.baidu.com/s/1pJDjOJx" target="_blank" rel="noopener">图说天下系列</a></li><li><a href="http://pan.baidu.com/share/link?uk=754986678&amp;shareid=237392098" target="_blank" rel="noopener">kindle人资源打包</a> 精品区11G+自购区31G+自制区10G+66G</li><li><a href="https://onedrive.live.com/?id=F5B0090663FEEADA%21828&amp;cid=F5B0090663FEEADA" target="_blank" rel="noopener">programthink</a></li></ol><h2 id="文学历史类、社科类"><a href="#文学历史类、社科类" class="headerlink" title="文学历史类、社科类"></a>文学历史类、社科类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=1259438467&amp;view=share#category/type=0" target="_blank" rel="noopener">零度小然 稀有现代书历史籍</a></li><li><a href="http://pan.baidu.com/share/home?uk=2704770694&amp;view=share#category/type=0" target="_blank" rel="noopener">youngharrylg 中华人民共和国前三十年历史</a></li><li><a href="http://pan.baidu.com/share/home?uk=1460307841&amp;view=share#category/type=0" target="_blank" rel="noopener">南阳高卧 近现代大家</a></li><li><a href="http://pan.baidu.com/share/home?uk=3946745677&amp;view=share#category/type=0" target="_blank" rel="noopener">doppel88 各国文学</a></li><li><a href="http://yun.baidu.com/share/home?uk=152128425&amp;view=share#category/type=0" target="_blank" rel="noopener">坊書流元 语言学</a></li><li><a href="http://yun.baidu.com/share/home?uk=1728233671&amp;view=share#category/type=0" target="_blank" rel="noopener">高贵的容克领主 历史</a></li><li><a href="http://yun.baidu.com/share/home?uk=3943501741&amp;view=share#category/type=0" target="_blank" rel="noopener">dfdean 文学 名家文集</a></li><li><a href="http://pan.baidu.com/share/home?uk=2905885322#category/type=0" target="_blank" rel="noopener">rainthounder 文史高清pdg版图书</a></li><li><a href="http://pan.baidu.com/s/1eQqW062" target="_blank" rel="noopener">翟子昂 中国古文字学</a></li><li><a href="http://pan.baidu.com/share/home?uk=2987157500&amp;view=share#category/type=0" target="_blank" rel="noopener">longhuarenn 历史</a></li><li><a href="http://pan.baidu.com/share/home?uk=4111094503#category/type=0" target="_blank" rel="noopener">Lyra1900</a></li><li><a href="http://pan.baidu.com/share/home?uk=805574156&amp;third=0#category/type=0" target="_blank" rel="noopener">iilikes</a></li></ol><h2 id="古籍类"><a href="#古籍类" class="headerlink" title="古籍类"></a>古籍类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2670973685&amp;view=share" target="_blank" rel="noopener">Ac_heron 古典文学</a></li><li><a href="http://pan.baidu.com/share/home?uk=4029740943&amp;view=share" target="_blank" rel="noopener">dadssfree 大批量文史书籍</a> (约1.3t)</li><li><a href="http://pan.baidu.com/share/home?uk=1896826771&amp;view=share#category/type=0" target="_blank" rel="noopener">qq312145694 古文史资料</a> （大约1t以上）</li><li><a href="http://pan.baidu.com/share/home?uk=272017959&amp;view=share#category/type=0" target="_blank" rel="noopener">洋风汉魂 日本文史资料原版</a> （大约1t以上）</li><li><a href="http://yun.baidu.com/share/home?uk=2533729796#category/type=0" target="_blank" rel="noopener">久舞而凄 精选精美古籍</a> （大约500G以上,更新中）</li><li><a href="http://yun.baidu.com/share/home?uk=3405888410&amp;view=share#category/type=0" target="_blank" rel="noopener">逍遥449824194 古籍</a></li><li><a href="http://yun.baidu.com/share/home?uk=2118390434&amp;view=share#category/type=0" target="_blank" rel="noopener">事无所成只因懒 古籍</a></li><li><a href="http://yun.baidu.com/share/home?uk=4211484048&amp;view=share#category/type=0" target="_blank" rel="noopener">钱建文 古籍</a></li><li><a href="http://yun.baidu.com/share/home?uk=4066113708#category/type=0" target="_blank" rel="noopener">风家纪录片3</a></li><li><a href="http://pan.baidu.com/s/1os4MQ" target="_blank" rel="noopener">子乌书简全站打包 20130507</a> 密码：qjq8</li></ol><h2 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h2><ol><li><a href="https://mega.nz/#F!jVsinZIT!1Oiz9bkHwNBABc7NU5sSAg" target="_blank" rel="noopener">wizardforcel 小说</a></li><li><a href="http://pan.baidu.com/s/1sjNSRtr" target="_blank" rel="noopener">莫迪亚诺作品集</a></li><li><a href="http://pan.baidu.com/s/1i3uzhbB" target="_blank" rel="noopener">王小波全集</a></li><li><a href="http://pan.baidu.com/s/1qW0q3Kg" target="_blank" rel="noopener">阿加莎·克里斯蒂作品集</a></li><li><a href="http://pan.baidu.com/s/1sjqLbzB" target="_blank" rel="noopener">周浩晖作品集</a></li></ol><h2 id="医学类、心理学类"><a href="#医学类、心理学类" class="headerlink" title="医学类、心理学类"></a>医学类、心理学类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=3711822837&amp;view=share" target="_blank" rel="noopener">于柏清二 中医</a></li><li><a href="http://pan.baidu.com/share/home?uk=3527489425&amp;view=share#category/type=0" target="_blank" rel="noopener">bdywuxinghua 中医丛书</a></li><li><a href="http://pan.baidu.com/share/home?uk=2818809037&amp;view=share" target="_blank" rel="noopener">yyzsm99 心理学</a></li><li><a href="http://pan.baidu.com/share/home?uk=1225533335&amp;view=share#category/type=0" target="_blank" rel="noopener">异硫氰酸烯丙酯 医学</a></li><li><a href="http://pan.baidu.com/s/1pJju6dd#path=%252F%25E4%25BC%259F%25E5%25BA%25B7" target="_blank" rel="noopener">一蹀盐 呼吸医学</a></li><li><a href="http://pan.baidu.com/share/home?uk=1630489195&amp;view=share#category/type=0" target="_blank" rel="noopener">cnchenlian 康复医学</a></li><li><a href="http://pan.baidu.com/s/1gdFHavh#path=%252F%25E4%25B9%25A6" target="_blank" rel="noopener">Zita 解剖学 图谱</a></li><li><a href="http://pan.baidu.com/share/home?uk=3221391314#category/type=0" target="_blank" rel="noopener">LV终结者 制药技术</a> （物化资料夹里）</li><li><a href="http://yun.baidu.com/share/home?uk=405421905&amp;view=share#category/type=0" target="_blank" rel="noopener">136603yin 性科学为特色 偏综合</a></li><li><a href="http://pan.baidu.com/s/17mp8P" target="_blank" rel="noopener">心理学交际学电子书合集13本</a></li><li><a href="http://vdisk.weibo.com/u/1778220897" target="_blank" rel="noopener">hhhzihao 心理学</a></li></ol><h2 id="佛学类"><a href="#佛学类" class="headerlink" title="佛学类"></a>佛学类</h2><ol><li><a href="http://yun.baidu.com/share/home?uk=289392363&amp;third=1&amp;view=share#category/type=0" target="_blank" rel="noopener">CBETA_TW 中華電子佛典協會分享佛教书籍</a></li><li><a href="http://yun.baidu.com/share/home?uk=1913113259&amp;view=share#category/type=0" target="_blank" rel="noopener">dufojing 佛教书籍</a></li><li><a href="http://yun.baidu.com/share/home?uk=925845574&amp;view=share#category/type=0" target="_blank" rel="noopener">senmy08 佛教书籍</a></li></ol><h2 id="数理学科类"><a href="#数理学科类" class="headerlink" title="数理学科类"></a>数理学科类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=1244439600&amp;;view=share" target="_blank" rel="noopener">小兆一凡 数学</a></li><li><a href="http://pan.baidu.com/share/home?uk=3409070258&amp;view=share#category/type=0" target="_blank" rel="noopener">我就叫混沌</a></li><li><a href="http://pan.baidu.com/share/link?uk=1766755481&amp;shareid=2684679400" target="_blank" rel="noopener">华章数学译丛 百度云</a></li><li><a href="http://vdisk.weibo.com/s/B-1mTXGOXIRvY?category_id=0&amp;parents_ref=B-1mTXGOXIRaF" target="_blank" rel="noopener">华章数学译丛 微盘</a></li><li><a href="http://pan.baidu.com/share/link?uk=3191333230&amp;shareid=870418565" target="_blank" rel="noopener">图灵数学·统计学丛书 百度云</a></li><li><a href="http://vdisk.weibo.com/s/B-1mTXGOXIQZJ?category_id=0&amp;parents_ref=B-1mTXGOXIRaF" target="_blank" rel="noopener">图灵数学·统计学丛书 微盘</a></li></ol><h2 id="生物学类（动物、植物、野外生存等）"><a href="#生物学类（动物、植物、野外生存等）" class="headerlink" title="生物学类（动物、植物、野外生存等）"></a>生物学类（动物、植物、野外生存等）</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2855048701&amp;view=share#category/type=0" target="_blank" rel="noopener">ChentaoTony1 昆虫学</a></li><li><a href="http://pan.baidu.com/share/home?uk=3959509661&amp;view=share#category/type=0" target="_blank" rel="noopener">jkdpgh 野外生存 动物志</a></li><li><a href="http://pan.baidu.com/share/home?uk=2734991257&amp;third=0#category/type=0" target="_blank" rel="noopener">麦子 生物学 动物学</a></li><li><a href="http://pan.baidu.com/share/home?uk=3020331843&amp;view=share#category/type=0" target="_blank" rel="noopener">xiayang405 精神病学、细胞生物学</a></li><li><a href="http://pan.baidu.com/share/home?uk=86518920&amp;view=share#category/type=0" target="_blank" rel="noopener">li__cheng__ 中国植物志、各地区植物志</a></li><li><a href="http://yun.baidu.com/share/home?uk=420129823#category/type=0" target="_blank" rel="noopener">山刺玫 植物学</a></li><li><a href="http://pan.baidu.com/share/home?uk=523517449&amp;view=share#category/type=0" target="_blank" rel="noopener">绿色营上海小组 植物学</a></li></ol><h2 id="计算机技术类"><a href="#计算机技术类" class="headerlink" title="计算机技术类"></a>计算机技术类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=3339153721&amp;view=share" target="_blank" rel="noopener">lxghost IT</a> （xiaoshuwu.net）</li><li><a href="http://pan.baidu.com/share/home?uk=1074173238&amp;view=share#category/type=0" target="_blank" rel="noopener">wintelsui IT</a></li><li><a href="http://pan.baidu.com/share/home?uk=3809969834&amp;view=share#category/type=0" target="_blank" rel="noopener">明月无风</a></li><li><a href="http://pan.baidu.com/share/home?uk=1832385835#category/type=0" target="_blank" rel="noopener">耍大刀xyz PS书籍</a></li><li><a href="http://pan.baidu.com/share/home?uk=1176304088#category/type=0" target="_blank" rel="noopener">hcbbt IT</a></li><li><a href="http://pan.baidu.com/share/link?shareid=2981703177&amp;uk=2214641459" target="_blank" rel="noopener">salttiger IT</a></li><li><a href="https://mega.nz/#F!qQUwUTKR!okYrzPOauVIaFj4GNSRZfA" target="_blank" rel="noopener">wizardforcel IT</a></li></ol><h2 id="非IT工业技术类"><a href="#非IT工业技术类" class="headerlink" title="非IT工业技术类"></a>非IT工业技术类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2437672157#category/type=0" target="_blank" rel="noopener">南航飞动研学群 航空航天</a></li><li><a href="http://pan.baidu.com/share/home?uk=2702990868&amp;view=share#category/type=0" target="_blank" rel="noopener">星河舰队司令 武器</a></li><li><a href="http://pan.baidu.com/share/home?uk=35826880&amp;view=share#category/type=0" target="_blank" rel="noopener">wxjoldgoat 武器</a></li><li><a href="http://pan.baidu.com/share/home?uk=2349638677#category/type=0" target="_blank" rel="noopener">cfhcjg 军事资料</a></li><li><a href="http://pan.baidu.com/share/home?uk=1611109307#category/type=0" target="_blank" rel="noopener">以逸待劳hk 航天资料</a></li></ol><h2 id="语言学习类"><a href="#语言学习类" class="headerlink" title="语言学习类"></a>语言学习类</h2><ol><li><a href="https://pan.baidu.com/share/home?uk=3394258028&amp;view=share#category/type=0" target="_blank" rel="noopener">学派英语团队 英语学习</a></li><li><a href="http://pan.baidu.com/s/1sjugDQ1" target="_blank" rel="noopener">英语学习资料</a></li></ol><h2 id="经管"><a href="#经管" class="headerlink" title="经管"></a>经管</h2><ol><li><a href="http://vdisk.weibo.com/u/5340187825" target="_blank" rel="noopener">商业类电子书</a></li></ol><h2 id="艺术类-（摄影、音乐、绘画等）"><a href="#艺术类-（摄影、音乐、绘画等）" class="headerlink" title="艺术类 （摄影、音乐、绘画等）"></a>艺术类 （摄影、音乐、绘画等）</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2755480552&amp;view=share#category/type=0" target="_blank" rel="noopener">吸血鬼123牛仔 音乐</a></li><li><a href="http://pan.baidu.com/share/home?uk=674298946#category/type=0" target="_blank" rel="noopener">xslp2004 摄影</a></li><li><a href="http://yun.baidu.com/share/home?uk=2738239597&amp;view=share#category/type=0" target="_blank" rel="noopener">yu鈥唋ei 中国绘画</a> 新浪微博@于双子鱼 分享私密文件</li></ol><h2 id="杂志类"><a href="#杂志类" class="headerlink" title="杂志类"></a>杂志类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=2332146839&amp;view=share" target="_blank" rel="noopener">qingge16 杂志</a> （含部分最新书）</li><li><a href="http://yun.baidu.com/share/home?uk=2737417622#category/type=0" target="_blank" rel="noopener">yanxishe 杂志</a></li><li><a href="http://yun.baidu.com/share/home?uk=3156696063&amp;;view=share#category/type=0" target="_blank" rel="noopener">liuafenliu 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊）</a> 更新中</li><li><a href="http://yun.baidu.com/share/home?uk=3859261705&amp;;view=share#category/type=0" target="_blank" rel="noopener">foodservice 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊）</a> 似乎是台湾地区人 更新到201410</li></ol><h2 id="原版书类"><a href="#原版书类" class="headerlink" title="原版书类"></a>原版书类</h2><ol><li><a href="http://pan.baidu.com/share/home?uk=1563658231&amp;view=share" target="_blank" rel="noopener">好想一次过 原版外文书</a></li><li><a href="http://pan.baidu.com/s/1i39TawH" target="_blank" rel="noopener">12879本Kindle英文原版电子书</a></li><li><a href="http://pan.baidu.com/s/1gdELWgN" target="_blank" rel="noopener">经典、畅销英文原著100本</a></li></ol><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol start="8"><li><a href="http://bestcbooks.com/" target="_blank" rel="noopener">计算机书籍控</a></li><li><a href="http://www.jb51.net/books/" target="_blank" rel="noopener">脚本之家电子书</a></li><li><a href="http://www.xiaoshuwu.net/" target="_blank" rel="noopener">小书屋</a></li><li><a href="http://www.ckook.com/" target="_blank" rel="noopener">稀酷客</a></li><li><a href="http://readcolor.com/books?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">读远</a></li><li><a href="http://www.salttiger.com/" target="_blank" rel="noopener">SaltTiger</a></li><li><a href="http://it-ebooks.cn/" target="_blank" rel="noopener">it-ebooks.cn</a></li><li><a href="http://it-ebooks.info/" target="_blank" rel="noopener">it-ebooks.info</a></li><li><a href="http://it-ebooks.org/" target="_blank" rel="noopener">it-ebooks.org</a></li><li><a href="http://it-ebooks.com/" target="_blank" rel="noopener">it-ebooks.com</a></li><li><a href="http://ebooks-it.net/" target="_blank" rel="noopener">ebooks-it.net</a></li><li><a href="http://wowebook.org/" target="_blank" rel="noopener">wowebook.org</a></li><li><a href="http://bookdl.com/" target="_blank" rel="noopener">bookdl.com</a></li><li><a href="http://bookzz.org/" target="_blank" rel="noopener">bookzz.org</a></li><li><a href="http://www.allitebooks.com/" target="_blank" rel="noopener">allitebooks.com</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> kindle </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kindle之ResilioSync索引</title>
      <link href="/2017/01/23/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E4%B9%8BResilioSync%E7%B4%A2%E5%BC%95/"/>
      <url>/2017/01/23/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E4%B9%8BResilioSync%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Kindle伴侣精品书库"><a href="#Kindle伴侣精品书库" class="headerlink" title="Kindle伴侣精品书库"></a>Kindle伴侣精品书库</h2><p><a href="https://kindlefere.com/share" target="_blank" rel="noopener">Kindle伴原文</a><br>Resilio Sync同步密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOC3NIGPF2DOKETOF2FAHXJXE2HF24QWC</span><br></pre></td></tr></table></figure></p><h3 id="精品书库"><a href="#精品书库" class="headerlink" title="精品书库"></a>精品书库</h3><p><a href="https://kindlefere.github.io/share/ebook/" target="_blank" rel="noopener">精品库</a><br><iframe src="https://kindlefere.github.io/share/ebook/" width="800" height="400" frameborder="0" allowfullscreen></iframe></p><h3 id="每周一书"><a href="#每周一书" class="headerlink" title="每周一书"></a>每周一书</h3><p><a href="https://kindlefere.github.io/share/weekly/index.html" target="_blank" rel="noopener">每周一书</a><br><iframe src="https://kindlefere.github.io/share/weekly/index.html" width="800" height="400" frameborder="0" allowfullscreen></iframe></p><h3 id="国外书籍"><a href="#国外书籍" class="headerlink" title="国外书籍"></a>国外书籍</h3><p><a href="https://kindlefere.github.io/share/ebook-en/index.html" target="_blank" rel="noopener">国外精选</a><br><iframe src="https://kindlefere.github.io/share/ebook-en/index.html" width="800" height="400" frameborder="0" allowfullscreen></iframe></p><h2 id="Resilio-Sync"><a href="#Resilio-Sync" class="headerlink" title="Resilio Sync"></a>Resilio Sync</h2><p><a href="https://kindlefere.com/post/347.html" target="_blank" rel="noopener">原地址详解</a></p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Resilio Sync 这款软件的优点上面已经说了一些，就是不依赖中心服务器，所有的文件都分布在用密钥连接在一起的电脑上。这里重点说一下小伙伴们关心的缺点。</p><p>缺点一：免费版只能强制同步所有文件，比如书库的大小有 5G，只能将这 5G 的电子书全部同步到你的电脑上，这需要你有一块足够大的硬盘。除非你升级到收费版（每年 100 元）实现选择性同步。</p><p>缺点二：因为没有中心服务器，所以下载的速度依赖于每个电脑的上传速度，和中心服务器的分享方式相反，人越多同步的速度就越快，反之，人越少同步的速度就越慢。</p><h3 id="在IgnoreList文件中忽略不想同步的文件"><a href="#在IgnoreList文件中忽略不想同步的文件" class="headerlink" title="在IgnoreList文件中忽略不想同步的文件"></a>在IgnoreList文件中忽略不想同步的文件</h3><p>BitTorrent Sync还支持文件过滤，如果你有一些文件不想被同步，你可以通过配置<code>IgnoreList</code>实现。<br><code>IgnoreList</code>是一个UTF-8编码的txt文件，里面你可以定义单个文件，路径，以及规则，他支持简单的“？”和“*”匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 同步目录/.sync／</span><br><span class="line">cat IgnoreList</span><br></pre></td></tr></table></figure></p><pre><code>&gt;# IgnoreList is a UTF-8 encoded .txt file that helps you specify single files, paths and rules &gt;# for ignoring during the synchronization job. It supports &quot;?&quot; and &quot;*&quot; wildcard symbols.### OS generated files #.DS_Store.Spotlight-V100.Trashesehthumbs.dbdesktop.iniThumbs.db# Temporary files #~**~.~lock.**.part*.crdownload@eaDir@SynoResource.@__thumb</code></pre><h3 id="高级设置相关说明"><a href="#高级设置相关说明" class="headerlink" title="高级设置相关说明"></a>高级设置相关说明</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">disk_low_priority：<span class="literal">true</span>  设置在磁盘上操作文件的优先级，如果设置为<span class="literal">false</span>，在同步文件时读写文件将会采用最高速度和优先级，不过这样会影响其他应用的性能。</span><br><span class="line"></span><br><span class="line">folder_rescan_interval：<span class="number">600</span>  设置扫描目录的时间间隔，单位为秒</span><br><span class="line"></span><br><span class="line">lan_encrypt_data：<span class="literal">true</span>  如果设置为ture，则在本地网络传输时会采用加密传输。</span><br><span class="line"></span><br><span class="line">lan_use_tcp：<span class="literal">false</span>  如果设置为ture，在本地网络同步会采用tcp传输，而不是采用udp传输。注意：在LAN中禁止加密并采用tcp传输，会增加传输速度。</span><br><span class="line"></span><br><span class="line">rate_limit_local_peers：<span class="literal">false</span>  申请在本地网络的peers直接限速传输，默认没有在LAN里面限速</span><br><span class="line"></span><br><span class="line">send_buf_size：<span class="number">5</span>  在发送文件时可以使用的发送缓存，可以设置<span class="number">1</span>~<span class="number">100</span>M</span><br><span class="line"></span><br><span class="line">recv_buf_size：<span class="number">5</span>  在接收文件时可以使用的接收缓存，可以设置<span class="number">1</span>~<span class="number">100</span>M</span><br><span class="line"></span><br><span class="line">sync_max_time_diff：<span class="number">600</span>  同步的设备之间的时间差别</span><br><span class="line"></span><br><span class="line">sync_trash_ttl：<span class="number">30</span>  设置多少天之后自动删除.SyncArchive目录中的文件</span><br><span class="line"></span><br><span class="line">max_file_size_diff_for_patching：<span class="number">1000</span></span><br><span class="line"></span><br><span class="line">max_file_size_for_versioning：<span class="number">1000</span>  版本控制的一个参数，不了解...</span><br></pre></td></tr></table></figure><h3 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h3><h4 id="添加同步链接后为什么找不到节点？"><a href="#添加同步链接后为什么找不到节点？" class="headerlink" title="添加同步链接后为什么找不到节点？"></a>添加同步链接后为什么找不到节点？</h4><p>如果是刚添加同步密钥或链接，请稍等片刻。如果很长时间仍然找不到节点无法同步，请尝试：把已经添加的同步目录删除，在 Sync 界面上谭家的同步断开，然后重新添加同步密钥或同步链接。</p><h4 id="提示“与-x-个用户的时间差”怎么办？"><a href="#提示“与-x-个用户的时间差”怎么办？" class="headerlink" title="提示“与 x 个用户的时间差”怎么办？"></a>提示“与 x 个用户的时间差”怎么办？</h4><p>如果系统的时间严重不准会导致 BT Sync 无法正常工作。如果 Sync 软件提示的事您的电脑有时间差，请确保开启自动时间同步，如果时间同步没问题，请先退出 Sync 软件重新开启。如果提醒其他人有时间差，请忽略。</p><h4 id="为什么同步的电子书比目录标示的大？"><a href="#为什么同步的电子书比目录标示的大？" class="headerlink" title="为什么同步的电子书比目录标示的大？"></a>为什么同步的电子书比目录标示的大？</h4><p>书库在维护的过程中会删除一些质量较差和重复的电子书，如果被删除的电子书已经同步到你的电脑上，就会被 Sync 自动备份下来。备份位置在同步目录下的隐藏文件夹 .sync/Archive 中，在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“打开存档文件”即可打开。</p><p>默认情况下，此目录中的文件 30 天后会自动删除。书库中删除的文件没有保留的必要，为了避免备份文件占用空间，可以禁用此功能。先把 Archive 文件夹删除，然后在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“首选项”，取消“在文件夹存档中存储已删除的文件”前面的勾选即可。</p><h4 id="开启-Sync-后电脑变得很卡怎么办？"><a href="#开启-Sync-后电脑变得很卡怎么办？" class="headerlink" title="开启 Sync 后电脑变得很卡怎么办？"></a>开启 Sync 后电脑变得很卡怎么办？</h4><p>因为 Sync 传输数据时需要读写硬盘，这可能会导致电脑其它的数据读取变慢，解决方法就是设置限速，让同步细水长流。打开 Sync 的软件的“首选项”，在“高级”选项卡中找到“限制接收速率”和“限制发送速率”，输入一个合适的值即可。另外，如果正在做其他工作，建议暂停或暂时退出 Sync 软件。</p><p>另外，在“高级”界面里，点击底部的“打开高级用户偏好设置”，把“disk_low_priority”这项设置为 true 也可以缓解卡顿的现象。其中“rate_limit_local_peers”是设置在磁盘上操作文件的优先级，默认为 false，在同步文件时读写文件将会采用最高速度和优先级，所以会影响其他应用的性能。</p><h4 id="重新添加能继续用之前的同步目录吗？"><a href="#重新添加能继续用之前的同步目录吗？" class="headerlink" title="重新添加能继续用之前的同步目录吗？"></a>重新添加能继续用之前的同步目录吗？</h4><p>有时因为某种原因，导致添加到 Resilio Sync 的同步丢失，需要重新添加密钥，这种情况下，是可以继续使用之前的同步目录的，只需要在重新添加密钥选择同步目录的时候，选择原来的目录即可。</p>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> kindle </tag>
            
            <tag> 书籍 </tag>
            
            <tag> ResilioSync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AR 开发资料汇[转]</title>
      <link href="/2017/01/23/swift/AR%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99%E6%B1%87/"/>
      <url>/2017/01/23/swift/AR%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>总结了AR开发的平台汇总，AR视频经典教程，AR主流资讯网站，Vuforia，EasyAR一些实例教程以及AR精选应用。</p><hr><h1 id="AR-平台"><a href="#AR-平台" class="headerlink" title="AR 平台"></a>AR 平台</h1><p><a href="https://developer.vuforia.com/" target="_blank" rel="noopener">Vuforia</a>–不用多说，最流行的AR应用开发引擎。<br><a href="http://www.easyar.cn/" target="_blank" rel="noopener">EasyAR</a>－－EasyAR是国内最专业的AR引擎,是国内首款投入应用的AR SDK。EasyAR是好用且免费的增强现实(Augmented Reality)开发者引擎。<br><a href="http://www.hiar.com.cn/" target="_blank" rel="noopener">HiAR</a>–HiAR 增强现实开发平台 HiAR 是亮风台信息科技打造的新一代移动增强现实(AR)开发平台,提供一整套世界领先的增强现实(AR)技术服务。<br><a href="http://www.voidar.net/" target="_blank" rel="noopener">太虚AR</a>－－成都米有网络科技有限公司自主研发集成于Unity3d实现增强现实的SDK开发包,虚拟现实SDK太虚官方网站。<br><a href="http://www.wikitude.com/" target="_blank" rel="noopener">Wikitude</a>–Wikitude是一家专门从事智能手机增强现实的应用，分别出品了两款应用Wikitude drive与Wikitude World Browser。<br><a href="http://www.intel.com/content/www/us/en/architecture-and-technology/realsense-overview.html" target="_blank" rel="noopener">Inter RealSense</a>–RealSense 3D是一套感知计算解决方案,包括世界上最小的3D摄像头,模块比两个硬币摞起来还薄,除了硬件外,英特尔还将提供驱动及软件等全套开发工具<br><a href="https://www.icreator.cn/" target="_blank" rel="noopener">ICreator</a>–依托于iCreator 3D, VR引擎,模型师可以快速创建交互式3D, VR内容,并支持微信平台传播,也为模型师提供可视化3D模型交易功能。<br><a href="http://www.tianyanar.com/" target="_blank" rel="noopener">天眼</a>－－天眼AR包括天眼云平台和天眼AR浏览器,用户需在天眼云平台完成“AR内容”制作,然后在天眼AR浏览器查看效果。<br><a href="https://developers.google.com/tango/" target="_blank" rel="noopener">Google Tango</a>–小编重点推荐。运动追踪(Motion Tracking)，深度感知(Depth Perception)和区域学习(Area Learning)。</p><hr><h1 id="AR-视频教程"><a href="#AR-视频教程" class="headerlink" title="AR 视频教程"></a>AR 视频教程</h1><p><a href="http://edu.manew.com/course/204" target="_blank" rel="noopener">Hololens 开发教程</a><br><a href="http://edu.manew.com/course/154" target="_blank" rel="noopener">增强现实技术分享</a><br><a href="http://edu.manew.com/course/172" target="_blank" rel="noopener">AR房地产</a><br><a href="http://edu.manew.com/course/175" target="_blank" rel="noopener">AR - 双卡互动</a><br><a href="http://edu.manew.com/course/162" target="_blank" rel="noopener">AR涂涂乐</a><br><a href="http://www.taikr.com/course/378" target="_blank" rel="noopener">Hololens 开发</a><br><a href="http://www.arinchina.com/video/list/149/" target="_blank" rel="noopener">Vuforia 公开课</a><br><a href="http://www.arinchina.com/video/show-1946.html" target="_blank" rel="noopener">Intel realSense制作面部捕捉小游戏</a><br><a href="http://www.arinchina.com/video/show-1972.html" target="_blank" rel="noopener">HiAR 视频播放</a><br><a href="http://www.arinchina.com/video/show-1965.html" target="_blank" rel="noopener">HiAR 水晶球</a><br><a href="http://www.arinchina.com/video/show-1982.html" target="_blank" rel="noopener">HiAR 瞬间拥有Apple Watch</a><br><a href="http://www.arvrschool.com/read.php?tid=325&amp;fid=21" target="_blank" rel="noopener">Vuforia 入门－基础－进阶</a></p><hr><h1 id="AR-网站"><a href="#AR-网站" class="headerlink" title="AR 网站"></a>AR 网站</h1><p><a href="http://arjiang.com/" target="_blank" rel="noopener">AR酱</a>–发现闪闪发光的AR从业者|增强现实|混合现实|虚拟现实<br><a href="http://www.arinchina.com/" target="_blank" rel="noopener">增强现实</a>－－增强现实中国ARinChina 是中国最大的专注于AR增强现实技术行业的门户网站。<br><a href="http://www.arvrschool.com/" target="_blank" rel="noopener">AR 学院</a>－－增强现实|虚拟现实技术交流社区、综合门户<br><a href="http://www.arcun.cn/" target="_blank" rel="noopener">AR 村</a>－－提供最新最快的AR增强现实信息,最权威的AR增强现实解读与产品发布.<br><a href="http://www.youziar.com/" target="_blank" rel="noopener">柚子AR</a>－－柚子AR打造专业的增强现实技术领域门户网站,提供AR资讯、AR技术、AR视频、AR游戏、AR设备等相关知识教程,柚子AR,打造增强现实行业交流聚集地。<br><a href="http://www.chinaar.com/" target="_blank" rel="noopener">ChinaAR</a>－－中国AR网,是国内第一家打造增强现实技术交流的一个自媒体平台!意在打造中国AR爱好者对AR技术的交流与学习的一个平台<br><a href="http://www.archina.org/" target="_blank" rel="noopener">AR 中国</a>－－AR中国是专注于增强现实技术的新闻门户网站<br><a href="http://www.arjishu.com/" target="_blank" rel="noopener">AR 技术网</a><br><a href="http://www.arcompetition.com/Default.aspx" target="_blank" rel="noopener">Realseer</a></p><hr><h1 id="增强现实视频合辑"><a href="#增强现实视频合辑" class="headerlink" title="增强现实视频合辑"></a>增强现实视频合辑</h1><p><a href="http://www.arcun.cn/thread-2111-1-1.html" target="_blank" rel="noopener">增强现实技术1-31篇技术视频教程合集</a></p><hr><h1 id="Vuforai-教程精选"><a href="#Vuforai-教程精选" class="headerlink" title="Vuforai 教程精选"></a>Vuforai 教程精选</h1><p><a href="http://www.arinchina.com/video/list/149/" target="_blank" rel="noopener">Vuforia 公开课</a>－－包括Vuforia 环境搭建，多图识别，单页翻页效果，模型自动旋转…<br><a href="http://www.arvrschool.com/read.php?tid=325&amp;fid=21" target="_blank" rel="noopener">VUforia 视频合辑</a><br><a href="http://www.chinaar.com/Vuforia/" target="_blank" rel="noopener">Vuforia 官方教程</a><br><a href="http://www.arvrschool.com/index.php?c=thread&amp;fid=36" target="_blank" rel="noopener">Vuforia 论坛</a><br><a href="http://dev.arinchina.com/qualcomm/1" target="_blank" rel="noopener">Vuforia 论坛</a><br><a href="http://www.manew.com/thread-92723-1-1.html?_dsign=51711fb9" target="_blank" rel="noopener">Vufoira 涂涂乐文章教程</a>－－讲解详细<br><a href="http://mec0825.net/blog/?p=126" target="_blank" rel="noopener">Vuforia 实现物体阴影特效</a><br><a href="http://www.th7.cn/Program/Android/201502/394666.shtml" target="_blank" rel="noopener">Vuforia 多图识别</a><br><a href="http://www.arinchina.com/video/show-1956.html" target="_blank" rel="noopener">Vuforia 脱卡</a><br><a href="http://lib.csdn.net/article/vr/20346" target="_blank" rel="noopener">Vuforia SDK—- AR开发vuforia实现拍照截屏功能</a></p><hr><h1 id="EasyAR教程精选"><a href="#EasyAR教程精选" class="headerlink" title="EasyAR教程精选"></a>EasyAR教程精选</h1><p><a href="http://www.manew.com/thread-98569-1-1.html" target="_blank" rel="noopener">Leap Motion+EasyAR AR手势开发教程</a><br><a href="http://www.manew.com/thread-98708-1-1.html" target="_blank" rel="noopener">AR从入门到精通开发系列教程(1)—搭建开发环境</a><br><a href="http://www.manew.com/thread-98992-1-1.html" target="_blank" rel="noopener">AR从入门到精通开发系列教程(2)–创建模型并互动</a><br><a href="http://www.arinchina.com/video/list/151/" target="_blank" rel="noopener">EasyAR 公开课</a><br><a href="http://www.easyar.cn/view/documentapi.html" target="_blank" rel="noopener">EasyAR 文档</a><br><a href="http://bbs.sightp.com/thread-249-1-1.html" target="_blank" rel="noopener">EasyAR官方Sample之涂涂乐</a><br><a href="http://www.arvrschool.com/index.php?c=thread&amp;fid=86" target="_blank" rel="noopener">EasyAR 论坛</a><br><a href="http://www.taidous.com/bbs/thread-42793-1-1.html" target="_blank" rel="noopener">带你开发类似Pokemon Go的AR游戏(1)</a><br><a href="http://www.taidous.com/bbs/thread-42825-1-1.html" target="_blank" rel="noopener">带你开发类似Pokemon Go的AR游戏(2)</a></p><hr><h1 id="HiAR-教程"><a href="#HiAR-教程" class="headerlink" title="HiAR 教程"></a>HiAR 教程</h1><p><a href="http://www.hiar.com.cn/doc-v1/main/home/" target="_blank" rel="noopener">HiAR 官方文档</a>－－看完之后就掌握的大概了，官方文档很详细了。<br><a href="http://www.arvrschool.com/index.php?c=thread&amp;fid=98" target="_blank" rel="noopener">HiAR 论坛</a><br><a href="http://dev.arinchina.com/hiar/1" target="_blank" rel="noopener">HiAR 论坛</a><br><a href="http://edu.51cto.com/course/course_id-5565.html" target="_blank" rel="noopener">HiAR SDK 教学视频</a></p><hr><h1 id="其他平台教程"><a href="#其他平台教程" class="headerlink" title="其他平台教程"></a>其他平台教程</h1><p><a href="http://www.arvrschool.com/index.php?c=thread&amp;fid=87" target="_blank" rel="noopener">太虚AR教程</a><br><a href="http://dev.arinchina.com/143/1" target="_blank" rel="noopener">太虚AR学习</a><br><a href="http://dev.arinchina.com/metaio/1" target="_blank" rel="noopener">Metaio 学习</a><br><a href="http://www.arinchina.com/video/list/150/" target="_blank" rel="noopener">Wikitude 公开课</a><br><a href="http://www.arinchina.com/video/list/154/" target="_blank" rel="noopener">太虚AR公开课</a></p><hr><h1 id="Google-tango教程"><a href="#Google-tango教程" class="headerlink" title="Google tango教程"></a>Google tango教程</h1><p><a href="https://pan.baidu.com/s/1i44Fpat" target="_blank" rel="noopener">Tango SDK 下载</a>（提取码：sh18）<br><a href="http://www.aiweibang.com/yuedu/147339646.html" target="_blank" rel="noopener">跟着Shrek Team学tango</a><br><a href="https://www.zhihu.com/question/37920173" target="_blank" rel="noopener">Project Tango 知识原理</a><br><a href="http://www.arjiang.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=11&amp;id=308" target="_blank" rel="noopener">Google Tango 项目</a></p><hr><h1 id="AR-技术文章"><a href="#AR-技术文章" class="headerlink" title="AR 技术文章"></a>AR 技术文章</h1><p><a href="http://www.arjiang.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=11&amp;id=344" target="_blank" rel="noopener">两家AR专利大厂在AR硬件方面的探索</a><br><a href="http://www.doc88.com/p-5661286681360.html" target="_blank" rel="noopener">增强现实技术及其应用</a><br><a href="http://www.vrguancha.net/a/start/baogaoku/2016/1102/2026.html" target="_blank" rel="noopener">全球首份VR/AR医疗健康产业应用创新报告</a></p><hr><h1 id="AR-精选论文"><a href="#AR-精选论文" class="headerlink" title="AR 精选论文"></a>AR 精选论文</h1><p><a href="http://www.docin.com/p-62167994.html" target="_blank" rel="noopener">基于ARM和OpenCV的增强现实平台研究</a><br><a href="http://www.docin.com/p-890798256.html" target="_blank" rel="noopener">基于Android的增强现实技术研究与实现</a><br><a href="http://www.docin.com/p-123294670.html" target="_blank" rel="noopener">增强现实应用技术研究</a><br><a href="http://www.docin.com/p-220443601.html" target="_blank" rel="noopener">基于ARTOOLKIT的增强现实技术在恐龙博物馆中的应用研究</a><br><a href="http://www.docin.com/p-983104432.html" target="_blank" rel="noopener">基于增强现实技术的虚拟留言墙系统的设计与实现</a><br><a href="http://www.docin.com/p-880664177.html" target="_blank" rel="noopener">基于智能移动终端的移动增强现实应用研究与实现 </a><br><a href="http://www.docin.com/p-1404596806.html" target="_blank" rel="noopener">基于unity3d的移动增强现实技术与应用研究分析</a><br><a href="http://www.docin.com/p-129257030.html" target="_blank" rel="noopener">增强现实中标记设计与识别方法研究</a><br><a href="http://www.docin.com/p-1124496600.html" target="_blank" rel="noopener">户外增强现实gis的应用研究</a><br><a href="http://www.docin.com/p-1701043105.html" target="_blank" rel="noopener">手持式增强现实神经导航关键技术研究及其系统建立</a><br><a href="http://www.docin.com/p-118637060.html" target="_blank" rel="noopener">基于ARToolKit平台的增强现实人机交互系统的若干问题研究</a><br><a href="http://www.docin.com/p-427198314.html" target="_blank" rel="noopener">基于ARToolkit的汉字识别系统的设计与实现</a><br><a href="http://www.docin.com/p-1609057674.html" target="_blank" rel="noopener">基于ARToolKit的增强现实技术在恐龙博物馆中的应用研究</a></p><hr><h1 id="AR应用精选"><a href="#AR应用精选" class="headerlink" title="AR应用精选"></a>AR应用精选</h1><p><a href="http://www.anzhi.com/soft_2519240.html" target="_blank" rel="noopener">视+AR</a>－－搭载独立开发的EasyAR引擎，全新视+2.0强势来袭！包罗丰富ar内容的增强现实浏览器，等你来体验！<br><a href="http://www.anzhi.com/soft_2699705.html" target="_blank" rel="noopener">AR</a>–这是一款增强现实AR的应用，主要分为三部分：LOL人物展示（带有经典音效），太空大战，手势交互（可以旋转与缩放）。突破现在AR格局，给玩家带来更多的乐趣。你只需一张个人身份证的反面，便会通过AR得到一个精彩的世界！<br><a href="http://neobear.com/index.php/home/product/product/" target="_blank" rel="noopener">小熊尼奥产品</a><br><a href="http://mec0825.net/blog/?p=107" target="_blank" rel="noopener">增强现实优秀应用</a>－－大部分是国外的。<br><a href="http://www.arjiang.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=11&amp;id=298" target="_blank" rel="noopener">十一用12个案例SoLoMo，AR+LBS</a><br><a href="http://digi.163.com/15/0312/14/AKGVTR86001668IL.html" target="_blank" rel="noopener">让你脑洞大开的AR技术应用</a><br><a href="http://www.leiphone.com/news/201406/the-best-augmented-reality-apps.html" target="_blank" rel="noopener">13款最叫绝的增强现实应用</a><br><a href="http://www.arinchina.com/news/show-2573.html" target="_blank" rel="noopener">9款超赞的AR教育APP</a><br><a href="https://github.com/GeekLiB/AR-Source" target="_blank" rel="noopener">参考原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
            <tag> LBS+AR </tag>
            
            <tag> QQ红包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Awsome Apple Develop Guide[转]</title>
      <link href="/2017/01/23/swift/AwsomeAppleDevelopGuide/"/>
      <url>/2017/01/23/swift/AwsomeAppleDevelopGuide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>此文档是Apple平台开发所使用语言的主流学习资源</p><h1 id="iOS开发者博客"><a href="#iOS开发者博客" class="headerlink" title="iOS开发者博客"></a>iOS开发者博客</h1><ul><li>使用 <a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="noopener">iOSBlogCN</a>添加或者订阅</li></ul><h1 id="从社区学习知识"><a href="#从社区学习知识" class="headerlink" title="从社区学习知识"></a>从社区学习知识</h1><ul><li><a href="http://weekly.ios-wiki.com/" target="_blank" rel="noopener">iOS技术周报</a></li><li><a href="http://objccn.io/" target="_blank" rel="noopener">objc中国</a></li><li><a href="http://www.cocoachina.com/" target="_blank" rel="noopener">cocoachina</a></li><li><a href="http://swiftist.org/" target="_blank" rel="noopener">Swift社区</a></li></ul><h1 id="从iOS面试题总结"><a href="#从iOS面试题总结" class="headerlink" title="从iOS面试题总结"></a>从iOS面试题总结</h1><p><a href="iOS-usefulInterviewquestions-zh_CN">iOS有用的面试题</a></p><h1 id="建议－学习iOS之前快速预览一下"><a href="#建议－学习iOS之前快速预览一下" class="headerlink" title="建议－学习iOS之前快速预览一下"></a>建议－学习iOS之前快速预览一下</h1><p><a href="http://aaaaaashu.gitbooks.io/mac-dev-setup/content/" target="_blank" rel="noopener">MAC开发环境配置</a></p><p><a href="http://www.zhihu.com/question/24002984" target="_blank" rel="noopener">什么是Swift，如何评价 Swift 语言？</a></p><p><a href="http://zh.wikipedia.org/zh-cn/Objective-C" target="_blank" rel="noopener">了解一下Objective-C是什么</a></p><p><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="noopener">iOS开发60分钟入门</a></p><p><a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/index.html#//apple_ref/doc/uid/TP40012668-CH2-SW1" target="_blank" rel="noopener">Start Developing iOS Apps Today</a></p><p><a href="http://www.jianshu.com/p/8472ba0f2bb6" target="_blank" rel="noopener">从零开始学iOS开发的15条建议</a></p><p><a href="http://limboy.me/ios/2014/12/31/learning-ios.html" target="_blank" rel="noopener">自学iOS开发的一些经验</a></p><p><a href="http://www.cocoachina.com/special/fornew.html" target="_blank" rel="noopener">学习路线</a></p><h2 id="语言学习"><a href="#语言学习" class="headerlink" title="语言学习"></a>语言学习</h2><p>这里包括了Swift，Objective-C，C，C++</p><p><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="noopener">中文版 Apple 官方 Swift 教程《The Swift Programming Language》1.2</a></p><p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="noopener">中文版 Apple 官方 Swift 教程《The Swift Programming Language》2.0</a></p><p><a href="https://github.com/raywenderlich/swift-style-guide" target="_blank" rel="noopener">The Official raywenderlich.com Swift Style Guide</a></p><p><a href="http://swift.gg/2015/08/11/raywenderlich-swift-style-guide/" target="_blank" rel="noopener">The Official raywenderlich.com Swift Style Guide 中文版</a></p><p><a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md" target="_blank" rel="noopener">Using Swift with Cocoa and Objective-C中文手册</a></p><p><a href="http://c-faq-chn.sourceforge.net/ccfaq/index.html" target="_blank" rel="noopener">C 语言常见问题集</a></p><p><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google Objective-C Style Guide 中文版</a></p><p><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">Google C++ Style Guide 中文版</a></p><p><a href="https://github.com/oa414/objc-zen-book-cn" target="_blank" rel="noopener">禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译</a></p><h2 id="免费视频资源"><a href="#免费视频资源" class="headerlink" title="免费视频资源"></a>免费视频资源</h2><p><a href="http://www.imooc.com/learn/127" target="_blank" rel="noopener">玩儿转Swift</a></p><p><a href="http://www.imooc.com/learn/218" target="_blank" rel="noopener">征战Objective-C</a></p><p><a href="http://v.163.com/special/opencourse/ios7.html" target="_blank" rel="noopener">斯坦福大学公开课：iOS 7应用开发</a></p><p><a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift" target="_blank" rel="noopener">斯坦福大学公开课：Swift开发iOS 8应用－中文字幕</a></p><p><a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099" target="_blank" rel="noopener">斯坦福大学公开课：Swift开发iOS 8应用</a></p><p><a href="https://github.com/qiaoxueshi/WWDC_2015_Video_Subtitle" target="_blank" rel="noopener">WWDC 2015 Video 英文字幕 (共104个)</a></p><p><a href="https://github.com/6david9/WWDC2015" target="_blank" rel="noopener">WWDC2015下载链接</a></p><h2 id="精粹"><a href="#精粹" class="headerlink" title="精粹"></a>精粹</h2><p><a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">一些 iOS / Web 开发相关的翻译或原创博客文章</a></p><p><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">iOS-Core-Animation-Advanced-Techniques</a></p><p><a href="https://github.com/objccn/articles" target="_blank" rel="noopener">objc.io中文翻译版本</a></p><p><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="noopener">这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排</a></p><p><a href="https://github.com/cjwirth/awesome-ios-ui" target="_blank" rel="noopener">A curated list of awesome iOS UI/UX libraries</a></p><p><a href="https://github.com/shinobicontrols/iOS8-day-by-day" target="_blank" rel="noopener">iOS8-Day-by-Day blog series</a></p><p><a href="https://github.com/ShinobiControls/iOS9-day-by-day/" target="_blank" rel="noopener">iOS9 Day-by-Day blog series</a></p><p><a href="https://github.com/matteocrippa/awesome-swift" target="_blank" rel="noopener">matteocrippa/awesome-swift</a></p><p><a href="https://github.com/Wolg/awesome-swift" target="_blank" rel="noopener">Wolg/awesome-swift</a></p><p><a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="noopener">awesome-ios</a></p><h2 id="Swift-Objective-C-C-C-设计-资源集合"><a href="#Swift-Objective-C-C-C-设计-资源集合" class="headerlink" title="Swift | Objective-C | C/C++ | 设计 资源集合"></a>Swift | Objective-C | C/C++ | 设计 资源集合</h2><p><a href="http://www.jianshu.com/p/f1208b5e42d9" target="_blank" rel="noopener">Alamofire网络库基础教程</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;mid=204340894&amp;idx=1&amp;sn=cf7d5b0a9e3a198a39111fb07b0685e5#rd" target="_blank" rel="noopener">C 语言中的指针和内存泄漏</a></p><p><a href="http://www.ideawu.net/blog/archives/878.html" target="_blank" rel="noopener">C/C++编程的现代习惯</a></p><p><a href="http://onevcat.com/2015/01/swift-pointer/" target="_blank" rel="noopener">Swift指针的使用</a></p><p><a href="http://swifter.tips/" target="_blank" rel="noopener">Swift tips</a></p><p><a href="https://github.com/ming1016/study" target="_blank" rel="noopener">Study</a></p><p><a href="https://github.com/100mango/zen" target="_blank" rel="noopener">iOS心得</a></p><p><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="noopener">A curated list of delightful iOS resources.</a></p><p><a href="https://github.com/CocoaChinaTranslationTeam/Excellent-Articles-Translations" target="_blank" rel="noopener">优秀外文翻译资源集合</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=207789673&amp;idx=1&amp;sn=15683e2b9c939f9e21084b4e65df9b92#rd" target="_blank" rel="noopener">详解Swift中的iOS设计模式</a></p><p><a href="http://www.yming9.com/?p=579" target="_blank" rel="noopener">在iOS8 下用Swift 创建自定义的键盘</a></p><p><a href="http://www.devtf.cn/?p=462" target="_blank" rel="noopener">Swift和自动引用计数(ARC)整理之强，弱和无主引用</a></p><p><a href="http://lvwenhan.com/ios/454.html" target="_blank" rel="noopener">自己动手写一个 iOS 网络请求库（一）—— NSURLSession 初探</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=209907200&amp;idx=1&amp;sn=4c3d467cc76980209ed55ae8d08694f5#rd" target="_blank" rel="noopener">ReactiveCocoa 3.0 初窥</a></p><p><a href="http://www.jianshu.com/p/2dc639b2675a" target="_blank" rel="noopener">Swift 2 有哪些新特性</a></p><p><a href="http://www.cocoachina.com/cms/wap.php?action=article&amp;id=12237" target="_blank" rel="noopener">如何使用Instruments诊断App（Swift版）：起步</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=209755668&amp;idx=1&amp;sn=383f306a3cc8cf2463a0a2c951ce17f6#rd" target="_blank" rel="noopener">理解 ARC 下的循环引用</a></p><p><a href="http://www.devtalking.com/articles/what-is-new-in-swift/" target="_blank" rel="noopener">Swift 2.0初探</a></p><p><a href="http://www.cocoachina.com/industry/20140103/7651.html?utm_campaign=ios_wiki_dev_issue_1&amp;utm_source=ios_wiki_com&amp;utm_medium=website" target="_blank" rel="noopener">2013 CocoaChina微信精选之技术汇</a></p><p><a href="http://www.imooc.com/wenda/detail/238393" target="_blank" rel="noopener">理解 Objective-C 的 ARC</a></p><p><a href="http://www.jianshu.com/p/50b63a221f09" target="_blank" rel="noopener">iOS开发的一些奇巧淫技</a></p><p><a href="http://www.jianshu.com/p/2fa080673842" target="_blank" rel="noopener">我推荐的一些iOS开发书单 叶孤城___</a></p><p><a href="http://www.jianshu.com/p/9e1f0b44935c" target="_blank" rel="noopener">iOS性能优化</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=206525720&amp;idx=1&amp;sn=61ad896414bd492f5dee7a46c1753b50#rd" target="_blank" rel="noopener">iOS 调试核对清单</a></p><p><a href="http://www.jianshu.com/p/e28e8f5c7578?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">iOS APP 测试点摘要</a></p><p><a href="http://toutiao.io/r/z71jv" target="_blank" rel="noopener">GCD使用经验与技巧浅谈</a></p><p><a href="http://xuexuefeng.com/autolayout/" target="_blank" rel="noopener">iOS 开发实践之 Auto Layout</a></p><p><a href="http://www.jianshu.com/p/9c35432ec7a4?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">I Found You! 正则表达式!</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=206617040&amp;idx=1&amp;sn=35c497c91047130c96490b1e7b9a3fa5#rd" target="_blank" rel="noopener">iOS 开发中的消息传递机制</a></p><p><a href="http://www.jianshu.com/p/6b7d54b3f88b?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">iOS扫一扫功能开发</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=206668083&amp;idx=1&amp;sn=1661f83ff6d5e1f1b75eba9176e1b640#rd" target="_blank" rel="noopener">给游戏开发者们的 7 个制作建议</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=206705810&amp;idx=1&amp;sn=32beff0e768d167f9a76a2be003d0886#rd" target="_blank" rel="noopener">iOS另类的内存管理</a></p><p><a href="http://www.jianshu.com/p/613916eea37f?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">iOS runloop</a></p><p><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">正确使用Block避免Cycle Retain和Crash</a></p><p><a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/" target="_blank" rel="noopener">为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=207272218&amp;idx=1&amp;sn=fe72df0ae11997be7e0dac8cc06115aa#rd" target="_blank" rel="noopener">iOS事件分发机制（一） hit-Testing</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=207315755&amp;idx=1&amp;sn=3e48dbd35674882b46796ac9bd02ad10#rd" target="_blank" rel="noopener">iOS事件分发机制（二）：The Responder Chain</a></p><p><a href="http://blog.cnbang.net/tech/2729/" target="_blank" rel="noopener">iOS富文本组件的实现—DTCoreText源码解析 渲染篇</a></p><p><a href="http://blog.cnbang.net/tech/2630/" target="_blank" rel="noopener">iOS富文本组件的实现—DTCoreText源码解析 数据篇</a></p><p><a href="https://github.com/bboyfeiyu/iOS-tech-frontier/blob/master/issue-2/GCD%E6%A6%82%E8%BF%B0%E3%80%81%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%A5%BD%E7%9A%84%E7%A4%BA%E4%BE%8B.md" target="_blank" rel="noopener">GCD概述、语法以及好的示例</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=208119666&amp;idx=1&amp;sn=b85d6532b7804cdeb2accb5e8aea3c38#rd" target="_blank" rel="noopener">通过减少动态派送提升性能</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206285714&amp;idx=5&amp;sn=2048f89ee84149bac671ce8e204ec277#rd" target="_blank" rel="noopener">NSString属性什么时候用copy，什么时候用strong?</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206321222&amp;idx=8&amp;sn=71171f2298c2ed6d72015b942733f607#rd" target="_blank" rel="noopener">NSRecursiveLock递归锁的使用</a></p><p><a href="http://cubernet.cn/blog/rootdaemon/" target="_blank" rel="noopener">在iOS上以root身份运行守护进程</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206483177&amp;idx=2&amp;sn=0431f8a7673bf6633643c23e1776fcdd#rd" target="_blank" rel="noopener">iOS开发中两个常见问题的处理</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206448996&amp;idx=3&amp;sn=895663ec96a8469820b54b6536975340#rd" target="_blank" rel="noopener">iOS 8增强的自动布局功能</a></p><p><a href="http://cubernet.cn/blog/theos1/" target="_blank" rel="noopener">Theos介绍</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206637839&amp;idx=7&amp;sn=d5719f4c59753143c288de6d6206832b#rd" target="_blank" rel="noopener">iOS中几种定时器 - 控制了时间，就控制了一切</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=208071791&amp;idx=5&amp;sn=8fd1f5ae65611a4de7ce3885db28dc6f#rd" target="_blank" rel="noopener">iOS view的frame和bounds之区别（位置和大小）</a></p><p><a href="http://www.jianshu.com/p/aa50e5350852?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="noopener">iOS应用程序的生命周期</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=207857740&amp;idx=2&amp;sn=95d11ae018381f7b711320f406f800ab#rd" target="_blank" rel="noopener">2015 Objective-C 三大新特性 | 干货</a></p><p><a href="http://www.olinone.com/?p=232" target="_blank" rel="noopener">“自释放”在iOS开发中的应用</a></p><p><a href="http://nshipster.cn/" target="_blank" rel="noopener">关注被忽略的 Objective-C、Swift 和 Cocoa 特性</a></p><p><a href="https://www.bloc.io/tutorials/swiftris-build-your-first-ios-game-with-swift#!/chapters/675" target="_blank" rel="noopener">Swift开发游戏步骤</a></p><p><a href="http://www.jianshu.com/p/d46fb9d72ddb?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">关于iOS编码规范</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206155008&amp;idx=1&amp;sn=360b4f02a9f9aea2cdd21f9253140276#rd" target="_blank" rel="noopener">Objective-C开发编码规范（一）</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=208035695&amp;idx=2&amp;sn=b5069f3429308204dec4dd459bc4652f#rd" target="_blank" rel="noopener">Objective-C开发编码规范（二）</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206573834&amp;idx=5&amp;sn=b18dc313960fada8e84b76efabd3175c#rd" target="_blank" rel="noopener">Swift扩展的三个微妙细节</a></p><p><a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="noopener">Objective-C类成员变量深度剖析</a></p><p><a href="http://cubernet.cn/blog/swift-1/" target="_blank" rel="noopener">Swift基础(一)</a></p><p><a href="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html" target="_blank" rel="noopener">iOS7人机界面指南</a></p><p><a href="http://wileam.com/iphone-6-screen-cn/" target="_blank" rel="noopener">iphone6 屏幕设计揭秘</a></p><p><a href="http://www.mobile-patterns.com/" target="_blank" rel="noopener">mobile设计</a></p><p><a href="http://www.jianshu.com/p/e7fc525f342d?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">iOS常用框架</a></p><p><a href="http://www.jianshu.com/p/47201e57d21a?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">iOS面试基础知识36题</a></p><p><a href="http://www.jianshu.com/p/ca75fa02cf1e" target="_blank" rel="noopener">GitHub 上排名前 50 的 Objective-C 项目简介</a></p><p><a href="http://www.jianshu.com/p/c5b0eb58b878" target="_blank" rel="noopener">一些知名App用到的第三方库汇总</a></p><p><a href="http://foggry.com/blog/2014/04/25/githubyou-xiu-xiang-mu-ios/" target="_blank" rel="noopener">Github优秀开源项目大全-iOS</a></p><p><a href="http://zixun.github.io/blog/2015/04/11/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-kuang-jia-xuan-xing/" target="_blank" rel="noopener">[iOS单元测试系列]单元测试框架选型</a></p><p><a href="https://github.com/linqiang/Demo" target="_blank" rel="noopener">购物商城的Demo</a></p><p><a href="https://github.com/jkyin/Subtitle" target="_blank" rel="noopener">斯坦福大学公开课：iOS 7 应用开发 Demo</a></p><p><a href="https://github.com/Lax/iOS-Swift-Demos" target="_blank" rel="noopener">iOS-Swift-Demos</a></p><p><a href="https://github.com/numbbbbb/Accessibility-Programming-Guide-for-iOS" target="_blank" rel="noopener">iOS 无障碍开发指导</a></p><p><a href="https://github.com/CocoaChinaTranslationTeam/TestingWithXcodeDocsCN" target="_blank" rel="noopener">TestingWithXcode中文文档</a></p><p><a href="http://ourcoders.com/thread/show/117/" target="_blank" rel="noopener">苹果Xcode帮助文档阅读指南</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=209849033&amp;idx=2&amp;sn=59b5aa163d0be134afbbe951e55ea708#rd" target="_blank" rel="noopener">iOS项目的持续集成与管理</a></p><p><a href="http://www.coderyi.com/archives/751" target="_blank" rel="noopener">（译）WebViewJavascriptBridge－Obj-C和JavaScript互通消息的桥梁</a></p><p><a href="http://www.jianshu.com/p/6376149a2c4c?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">截获导航控制器系统返回按钮的点击pop及右滑pop事件</a></p><p><a href="http://beauty-soft.net/blog/ceiba/Ios/20140102/680.html" target="_blank" rel="noopener">UITableView常用属性和方法</a></p><p><a href="http://www.devtalking.com/articles/swift-access-control/" target="_blank" rel="noopener">Swift新特性 – 访问控制（Access Control）</a></p><p><a href="http://chengway.in/post/ji-zhu/viewcontroller-programming-guide/presenting-a-view-controller" target="_blank" rel="noopener">ViewController Programming Guide 笔记（一）</a></p><p><a href="http://www.cnblogs.com/haibindev/archive/2013/01/30/2880764.html" target="_blank" rel="noopener">HTTP Live Streaming直播(iOS直播)技术分析与实现</a></p><p><a href="http://ourui.github.io/blog/2014/01/22/mantle-use/" target="_blank" rel="noopener">Mantle 初步使用</a></p><p><a href="http://www.jianshu.com/p/76c588893b19?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">使用CAReplicatorLayer创建动画</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206678143&amp;idx=" target="_blank" rel="noopener">iOS动画——ViewAnimations</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=206718165&amp;idx=6&amp;sn=17c3a363f49df7a90a4e973b9c6d9af6#rd" target="_blank" rel="noopener">iOS动画——Layer Animations</a></p><p><a href="https://github.com/sxyx2008/awesome-ios-animation" target="_blank" rel="noopener">收集整理了下iOS平台下比较主流炫酷的几款动画框架</a></p><p><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="noopener">Masonry介绍与使用实践(快速上手Autolayout)</a></p><p><a href="http://vit0.com/blog/2013/12/07/iosxue-xi-zhi-autolayout/" target="_blank" rel="noopener">iOS学习之Autolayout</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=208000068&amp;idx=2&amp;sn=a4fdbf1858302470cab8b0d4bf3484cd#rd" target="_blank" rel="noopener">如何实现一个不规则排列的图片布局算法 | 干货</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=209655681&amp;idx=2&amp;sn=9f89d8d1ecb393db58c3e064d713b9b5#rd" target="_blank" rel="noopener">响应式视图</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=208550104&amp;idx=1&amp;sn=83eca61921efd512c42ec9e68ca6b492#rd" target="_blank" rel="noopener">微软前员工：开发Apple Watch应用的27个技巧</a></p><p><a href="http://nilsun.github.io/apple-watch/" target="_blank" rel="noopener">Apple Watch开发初探</a></p><p><a href="http://www.cocoachina.com/applewatch/" target="_blank" rel="noopener">Apple Watch开发专题</a></p><p><a href="http://tech.meituan.com/DiveIntoMethodCache.html" target="_blank" rel="noopener">深入理解Objective-C：方法缓存</a></p><p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a></p><p><a href="http://objccn.io/issue-4-2/" target="_blank" rel="noopener">一个完整的Core Data应用</a></p><p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">iOS安全系列之一：HTTPS</a></p><p><a href="http://www.90159.com/2015/08/10/ios-block-basic-article/" target="_blank" rel="noopener">block基础篇</a></p><p><a href="http://www.90159.com/2015/08/04/ios-block-ultimate/" target="_blank" rel="noopener">block终极篇</a></p><p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="noopener">关于iOS多线程，你看我就够了</a></p><h2 id="Objective-C-Run-time"><a href="#Objective-C-Run-time" class="headerlink" title="Objective-C Run time"></a>Objective-C Run time</h2><p><a href="http://www.jianshu.com/p/425a39d43d16?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="noopener">轻松学习之三——IMP指针的作用</a></p><p><a href="http://www.jianshu.com/p/d39f7d22db6c?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;mid=206641670&amp;idx=1&amp;sn=3fbc0070451d33b4c87d0da616ead22d#rd" target="_blank" rel="noopener">Cocoa Runtime系统知识整理</a></p><p><a href="http://blog.cocoabit.com/2014-10-06-yi-li-jie-objctive-c-runtime/" target="_blank" rel="noopener">理解 Objective-C Runtime</a></p><p><a href="http://www.jianshu.com/p/41735c66dccb" target="_blank" rel="noopener">Objective-C isa 指针 与 runtime 机制</a></p><p><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></p><p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></p><p><a href="http://www.jianshu.com/p/25a319aee33d" target="_blank" rel="noopener">Objective-C特性：Runtime</a></p><h2 id="项目结构经验"><a href="#项目结构经验" class="headerlink" title="项目结构经验"></a>项目结构经验</h2><p><a href="http://www.jianshu.com/p/77a948bcbc38" target="_blank" rel="noopener">iOS 项目的目录结构能看出你的开发经验</a></p><p><a href="https://github.com/makeLaugh/TWAPP" target="_blank" rel="noopener">iOS项目架构探索</a></p><p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">iOS应用架构谈系列</a></p><h2 id="学习UI"><a href="#学习UI" class="headerlink" title="学习UI"></a>学习UI</h2><p><a href="http://segmentfault.com/a/1190000002412930" target="_blank" rel="noopener">iOS组件之UIScrollView详解</a></p><p><a href="http://tech.glowing.com/cn/practice-in-uiscrollview/" target="_blank" rel="noopener">UIScrollView 实践经验</a></p><p><a href="https://github.com/icepy/Awsome-Apple-Develop-Guide" target="_blank" rel="noopener">参考原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 汇总 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题大集合[转]</title>
      <link href="/2017/01/23/swift/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/"/>
      <url>/2017/01/23/swift/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 align="center">iOS有用的面试题大集合</h1><h2 id="面试题从何处得来"><a href="#面试题从何处得来" class="headerlink" title="面试题从何处得来"></a>面试题从何处得来</h2><ul><li><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="noopener">招聘一个靠谱的 iOS</a></li><li><a href="http://www.zhihu.com/question/19604641" target="_blank" rel="noopener">知乎－如何面试 iOS 工程师？</a></li></ul><h2 id="阅读面试题之前"><a href="#阅读面试题之前" class="headerlink" title="阅读面试题之前"></a>阅读面试题之前</h2><p>在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。</p><p>Now！！请使用ARC</p><h3 id="什么是iOS开发"><a href="#什么是iOS开发" class="headerlink" title="什么是iOS开发"></a>什么是iOS开发</h3><p>iOS是iPhone iPad等手持设备的操作系统，所谓的iOS开发就是开发运行在iOS系统上的应用或者游戏，比如支付宝，微信，微博等，当然这也包括了iPad版的应用，iOS开发可以归纳到<strong>移动开发</strong>领域。</p><p><strong>有时候面试官是那种’脑残粉’，了解一下Apple的发展历史，可能比较聊的开。</strong></p><p><a href="http://digi.tech.qq.com/a/20150127/021898.htm" target="_blank" rel="noopener">苹果Mac计算机31年发展历程回顾</a></p><p><a href="http://baike.baidu.com/link?url=68F4Bl4llkNvdFJ1Md0fkZDDudN-NS46JeZoLrgPeqEbZmm8oBKG92Ocyd983yNQU6FVuDTFZOnjjPjfUHnuoePdfh6zJJ973pXFKYcbIKp5bCnQy_WvUVNJ6P84s8HE1xAlRaGdLVuoCb2p_8uaMa" target="_blank" rel="noopener">苹果公司</a></p><p><a href="http://www.zhihu.com/topic/19551762" target="_blank" rel="noopener">苹果公司在知乎上的话题</a></p><p><a href="http://www.amazon.cn/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0-%E6%B2%83%E5%B0%94%E7%89%B9%C2%B7%E8%89%BE%E8%90%A8%E5%85%8B%E6%A3%AE/dp/B00IM4IFL2/ref=sr_1_1?ie=UTF8&amp;qid=1436592631&amp;sr=8-1&amp;keywords=%E4%B9%94%E5%B8%83%E6%96%AF" target="_blank" rel="noopener">乔布斯个人传记</a></p><h3 id="拼写正确的重要性"><a href="#拼写正确的重要性" class="headerlink" title="拼写正确的重要性"></a>拼写正确的重要性</h3><p>有些面试官可能更注重细节，所以，拼写的单词一定要对，比如iOS，Xcode，iPhone，Objective-C，JSON等，良好的拼写习惯，会让面试官觉得你细心靠谱。</p><h3 id="Swift和Objective-C的比较"><a href="#Swift和Objective-C的比较" class="headerlink" title="Swift和Objective-C的比较"></a>Swift和Objective-C的比较</h3><p>仁者见仁智者见智，从个人的使用角度上来看，Swift在某些情况上比Objective-C更加的严谨了，入门非常简单，但是想开发应用，还是需要学习cocoa框架，这玩意路子还是Objective-C的，所以有基础可能更好的理解Swift在iOS/Mac OS X 中的开发和应用。</p><p><a href="http://www.zhihu.com/question/24002984" target="_blank" rel="noopener">知乎原文</a></p><h3 id="了解Watch-OS"><a href="#了解Watch-OS" class="headerlink" title="了解Watch OS"></a>了解Watch OS</h3><p><code>Watch OS</code>是苹果公司推出的应用在手表上的一个操作系统，<code>Watch OS 1.0</code>需要跟iPhone相结合才能工作。</p><p><a href="https://stratechery.com/2014/apple-watch-asking-saying/" target="_blank" rel="noopener">Apple Watch</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c#rd" target="_blank" rel="noopener">Watch OS 2.0 开发概述</a></p><hr><h2 id="iOS面试"><a href="#iOS面试" class="headerlink" title="iOS面试"></a>iOS面试</h2><h5>property 后面可以有哪些修饰符</h5><ol><li><p>读写修饰符 <code>readwrite</code> | <code>readonly</code></p><p> <code>readwrite</code> Xcode会帮助我们创建<code>setter</code>，<code>getter</code>方法，<code>readonly</code> Xcode只会帮助我们创建<code>getter</code>方法，不会创建<code>setter</code>方法。</p></li><li><p><code>setter</code>相关的修饰符 <code>assign</code> | <code>retain</code> | <code>copy</code></p><p> 2.1 <code>setter</code>相关的修饰符表明了<code>setter</code>方法该如何实现，<code>assign</code>用于基本数据类型<code>NSInteger</code>，<code>CGFloat</code>，C数据类型<code>int</code>，<code>float</code>，<code>id</code>类型等，这个符号不会涉及内存管理，但是如果是对象类使用了它，可能会导致内存泄漏或者<code>EXC_BAD_ACCESS</code>错误。</p><p> 2.2 <code>retain</code>用于对象类的内存管理，如果基本数据类型使用它，<code>Xcode</code>会直接报错。当对象类使用此修饰符时，<code>setter</code>方法的实现是先<code>release</code>一次，然后再对新的对象做一次<code>retain</code>操作。</p><p> 2.3 <code>copy</code>主要用于<code>NSString</code>，用于内容复制。</p></li><li><p>原子性修饰符 <code>atomic</code> | <code>nonatomic</code></p><p> <code>atomic</code> 表示线程安全</p><p> <code>nonatomic</code> 表示非线程安全，使用此修饰符会提高性能</p></li><li><p><code>getter</code>，<code>setter</code>修饰符</p><p> 这两个修饰符用于设置生成的getter，setter的方法名</p></li><li><p><code>strong</code>，<code>weak</code>修饰符（ARC）<br>在ARC中内存管理都只需要使用这两个修饰符，而且<code>strong</code>是默认全局的，只要你写了<code>Objective-C</code>的对象，不自己添加<code>weak</code>的话，默认就是<code>strong</code>。<br> 5.1 <code>strong</code>表示这个对象的拥有者<br> 一个对象可以有多个拥有者，<code>strong</code>就是用来表示对这个对象的拥有。比如在往<code>NSMutableArray</code>中添加<code>Objective-C</code>对象，当你从数组中删除时，这个对象并不会释放。需要你手动设置为<code>nil</code>，或者在控制器的生命周期内，由系统来释放。<br> 5.2 <code>weak</code>指针变量仍然可以指向一个对象，但不是这个对象的拥有者<br> <code>weak</code>修饰的指针变量也可以指向对象，但不是这个对象的实际拥有者，也就是说<code>weak</code>修饰的指针变量如果想要释放，需要<code>strong</code>修饰的指针变量设置为<code>nil</code>，<code>weak</code>修饰的指针变量也会是一个<code>nil</code>，它指向的对象已经没有了，还需要设置<code>weak</code>修饰的指针变量为<code>nil</code>。</p></li><li><code>nonnull</code> <code>nullable</code> <code>null_resettable</code></li></ol><p>Xcode 6.3推出的<code>nullability annotations</code>，主要是为了更好的Swift与Objective-C混编，在Swift中有可选型的概念<code>!</code>,<code>?</code>，但是Objective-C中木有这玩意，于是Xcode 6.3中才有了这个，<br>从字面可以看出:<br>    <code>nonnull</code> 表示对象不应该为空，如果是这个修饰符对应的就是Swift中已经解包的对象或者<code>!</code><br>    <code>nullable</code>表示可以为<code>nil</code>或者<code>NULL</code>,对应是Swift中的可选<code>?</code><br>    <code>null_resettable</code>则是表达属性的空属性，该属性<code>setter</code>访问器允许将其设置为<code>nil</code>（设置该属性为默认值），但是它的<code>getter</code>访问器不会提供一个<code>nil</code>值（因为它提供了默认值），有一个这样的属性如UIView’s tintColor，如果没有tint颜色指定时它会提供一个默认的tint颜色值，对应的Swift使用是var tintColor:UIColor!</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ol><li>使用 <code>weak</code> 关键字，相比 <code>assign</code> 有什么不同<br> 一般情况下使用<code>weak</code>是避免循环引用，因为它不是对象的拥有者。而<code>assign</code>则是用于基本数据类型，或者C类型，而且<code>assign</code>是直接赋值，可能会导致一个问题。比如我想a和b共用一块内存，a是用<code>assign</code>修饰的，<code>a = b</code>，现在a使用的目的已经完成，我想释放这个内存，但是a并不知道b到底用没用完，如果此时a释放内存，而b还在使用，那么会导致应用程序crash，使用<code>weak</code>就能避免这样的问题。</li><li>怎么用 copy 关键字<br> <code>copy</code>拷贝的是内容,<code>retain</code>是拷贝的指针<pre><code>* 以`string`为例,如果`string`的属性为`copy`的话,那么传入参数为`NSString`的话,即为不可变`string`,`retain`,`copy`效果一样.* 如果传入参数是`mutable`的话,那么`copy`拷贝内容,源随意变化不影响该属性的值.`retain`拷贝指针,源变化则属性值着变化,因为属性和源指向如何使用呢,通常在需要拷贝内容,但是副本和源不要互相影响的情况下使用.`*` 同一内存地址.* 例如`array/dictionary`中,可能会需要一个副本来做一些操作(筛选,排序等),但是并不希望影响原始值,则可以使用`copy`</code></pre></li><li>@property (copy) NSMutableArray *array; 这样写有什么问题吗<br> 因为用了<code>copy</code>, 内部会深拷贝一次, 指针实际指向的是<code>NSArray</code>, 所以如果调用<code>removeObject</code>和<code>addObject</code>方法的话, 会<code>unRecognized selector</code></li><li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？<br> 当一个对象发生改变时不影响另外一个对象，这里就需要使用<code>copy</code>关键字了，实现<code>NSCopying</code>协议，重写- <code>(id)copyWithZone:(NSZone *)zone</code>方法。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_name != name)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = [name <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>@protocol 和 category 中如何使用 @property<br> <code>@protocol</code>可以通过关键字:<code>@synthesize</code>或者在继承的类里面重新定义一次该属性(<code>extension</code>里面定义是不行的)<br> <code>category</code>通过关联:<code>objc_setAssociatedObject</code>/<code>objc_getAssociatedObject</code></li><li><code>@property</code> 的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code> 是如何生成并添加到这个类中的<br> <code>@property</code>本质是定义一个<code>objc_property</code>结构体<br><strong>如何生成目前不清楚</strong></li><li><code>weak</code>属性需要在<code>dealloc</code>中置<code>nil</code>么<br> 不需要，因为weak会自动设置nil</li><li><code>@synthesize</code>和@<code>dynamic</code>分别有什么作用<br> 关于@synthesize（现在已经不需要在写这个属性了，它是用来生成getter和setter方法）<br> <code>@dynamic</code> 就是要告诉编译器<code>getter</code>和<code>setter</code>方法会在程序运行或者用到动态绑定的方式，以便让编译器通过编译，这个主要要在<code>NSManagerObject</code>上。</li><li><code>ARC</code>下，不显式指定任何属性关键字时，默认的关键字都有哪些<br> 在默认情况下，所有的实例变量和局部变量都是<code>strong</code>类型的。</li><li>用<code>@property</code>声明的<code>NSString</code>（或<code>NSArray</code>，<code>NSDictionary</code>）经常使用<code>copy</code>关键字，为什么？如果改用strong关键字，可能造成什么问题<br>因为不想改变了其中的值后把原来的值也跟着改变了，用了<code>strong</code>后会出现这样的状况。</li><li>什么是ARC<br>请阅读，然后随便谈谈你的理解即可。<br>ARC是为了解决下面几个问题<ul><li>当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被<code>release</code>了。（避免提前释放）</li><li>释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（<code>MRC</code>下即谁创建，谁释放，避免重复释放）</li><li>模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。</li><li>多线程操作时，不确定哪个线程最后使用完毕<br><a href="http://onevcat.com/2012/06/arc-hand-by-hand/" target="_blank" rel="noopener">手把手教你ARC——iOS/Mac开发ARC入门和使用</a><br><a href="http://www.oschina.net/translate/objc-automatic-reference-counting-in-xcode-explained" target="_blank" rel="noopener">理解 Objective-C 的 ARC</a></li></ul></li><li>请解释以下keywords的区别： <code>assign</code> vs <code>weak</code>, <code>block</code> vs <code>weak</code><br><code>assign</code>适用于基本数据类型，<code>weak</code>是适用于<code>NSObject</code>对象，并且是一个弱引用。<ul><li><code>assign</code>其实也可以用来修饰对象，那么我们为什么不用它呢？<br>因为被<code>assign</code>修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为<code>nil</code>。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。</li><li><code>weak</code>修饰的对象在释放之后，指针地址会被置为<code>nil</code>。所以现在一般弱引用就是用<code>weak</code>。</li><li><code>block</code>是用来修饰一个变量，这个变量就可以在<code>block</code>中被修改，使用<code>block</code>修饰的变量在<code>block</code>代码快中会被<code>retain</code>（<code>ARC</code>下，<code>MRC</code>下不会<code>retain</code>） </li><li><code>weak</code>：使用<code>weak</code>修饰的变量不会在<code>block</code>代码块中被<code>retain</code>同时，在ARC下，要避免<code>block</code>出现循环引用 <code>weak typedof(self)weakSelf = self</code></li></ul></li><li><code>__block</code>在<code>arc</code>和<code>非arc</code>下含义一样吗<br>是不一样的，ARC会retain，非ARC不会。</li><li>描述一个你遇到过的<code>retain</code> cycle例子<br>在<code>viewController</code>中避免循环引用<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ downloadData:^(<span class="keyword">id</span> responseData)&#123;</span><br><span class="line">    _data = responseData;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>  解决办法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> ViewController *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[ downloadData:^(<span class="keyword">id</span> responseData)&#123;</span><br><span class="line">    weakSelf.data = responseData;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><code>+(void)load;</code> <code>+(void)initialize;</code>有什么用处<br>在Objective-C中，<code>runtime</code>会自动调用每个类的两个方法。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。<br>共同点：两个方法都只会被调用一次。</li><li><code>UIView</code>和<code>CALayer</code>有什么关系<ul><li><code>UIView</code>是iOS界面元素的基础，所有的界面元素都继承于它。它本身是由<code>CoreAnimation</code>来实现的，它真正绘图的部分是由一个<code>CALayer</code>的类来管理的，<code>UIView</code>本身更像是一个<code>CALayer</code>的管理器。</li><li><code>UIView</code>都存在一个<code>layer</code>属性，可以访问到<code>CALayer</code>的实例。</li><li><code>UIView</code>的<code>CALayer</code>类也存在一个<code>view</code>树结构，可以像<code>UIView</code>一样进行添加</li><li><code>UIView</code>的<code>layer</code>树在系统内部，由系统来维护，它存在着三棵树，分别是逻辑树，动画树，显示树</li></ul></li><li>如何高性能的给<code>UIImageView</code>加个圆角<ul><li>使用贝塞尔曲线来切割图片</li><li>使用<code>Quartz2D</code>直接绘制图片</li></ul></li><li>使用<code>drawRect</code>有什么影响<br><code>drawRect</code>方法依赖<code>Core Graphics</code>框架来进行自定义的绘制，但这种方法主要的缺点就是它处理<code>touch</code>事件的方式：每次按钮被点击后，都会用<code>setNeddsDisplay</code>进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对<code>CPU</code>和内存来说都是欠佳的。</li><li>SDWebImage里面给UIImageView加载图片的逻辑是什么样的<br>详情看<a href="http://www.cnblogs.com/6duxz/p/4159572.html" target="_blank" rel="noopener">最新版SDWebImage的使用</a></li><li>麻烦你设计个简单的图片内存缓存器<br>图片的内存缓存，可以考虑将图片数据保存到一个数据模型中，所以在程序运行时这个模型都存在内存中，一定要具备移除策略，即释放数据模型。</li><li>讲讲你用<code>Instrument</code>优化动画性能的经历<br><a href="http://www.hrchen.com/2013/05/performance-with-instruments/" target="_blank" rel="noopener">怎么使用instrument</a></li><li><code>loadView</code>是干嘛用的<br>当你访问一个<code>ViewController</code>的<code>view</code>属性时，如果此时<code>view</code>的值是<code>nil</code>，那么，<code>ViewController</code>就会自动调用<code>loadView</code>这个方法。这个方法就会加载或者创建一个<code>view</code>对象，赋值给<code>view</code>属性。<br><code>loadView</code>默认做的事情是：如果此<code>ViewController</code>存在一个对应的<code>nib</code>文件，那么就加载这个<code>nib</code>。否则，就创建一个<code>UIView</code>对象。<br>如果你用<code>Interface Builder</code>来创建界面，那么不应该重载这个方法。<br>如果你想自己创建<code>view</code>对象，那么可以重载这个方法。此时你需要自己给<code>view</code>属性赋值。你自定义的方法不应该调用<code>super</code>。如果你需要对<code>view</code>做一些其他的定制操作，在<code>viewDidLoad</code>里面去做。<br><a href="http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html" target="_blank" rel="noopener">iOS 的loadView 及使用loadView中初始化View注意的问题</a></li><li>用过<code>CoreData</code>或者<code>SQLite</code>吗？读写是分线程的吗？遇到过死锁没？咋解决的<br>参考<a href="http://blog.csdn.net/hanangellove/article/details/44966769" target="_blank" rel="noopener">CoreData与SQLite的线程安全</a></li><li><code>GCD</code>里面有哪几种<code>Queue</code>？你自己建立过串行<code>queue</code>吗？背后的线程模型是什么样的<ul><li>主队列 <code>dispatch_main_queue();</code> 串行 ，更新UI</li><li>全局队列 <code>dispatch_global_queue();</code> 并行，四个优先级：<code>background</code>，<code>low</code>，<code>default</code>，<code>high</code></li><li>自定义队列 <code>dispatch_queue_t queue;</code> 可以自定义是并行：<code>DISPATCH_QUEUE_CONCURRENT</code>或者串行<code>DISPATCH_QUEUE_SERIAL</code></li></ul></li><li>为什么其他语言里叫函数调用， <code>Objective-C</code>里则是给对象发消息（或者谈下对<code>runtime</code>的理解）<br>网上关于<code>runtime</code>的资料非常多，其实这方面在平时的开发中使用非常非常之少，底层的黑魔法。<br><a href="http://www.jianshu.com/p/25a319aee33d" target="_blank" rel="noopener">Objective-C特性：Runtime</a><br><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li><li>什么是<code>method swizzling</code><br>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<code>selector</code>的名字。利用<code>Objective-C</code>的动态特性，可以实现在运行时偷换<code>selector</code>对应的方法实现，达到给方法挂钩的目的。<br><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">详细的案例</a></li><li>runtime 如何实现 weak 属性 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_RETAIN</span><br><span class="line">OBJC_ASSOCIATION_COPY</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>可以自定义<code>weak</code>来实现内存管理，Apple已经为我们准备了常量。<br>参考<br><a href="http://nshipster.cn/associated-objects/" target="_blank" rel="noopener">Associated Objects</a><br><a href="http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/" target="_blank" rel="noopener">Objective-C Runtime 运行时之二：成员变量与属性</a></li><li><code>objc</code>中向一个<code>nil</code>对象发送消息将会发生什么<br><code>objc</code>的特性是允许对一个 <code>nil</code> 对象发送消息不会 Crash，因为会被忽略掉。</li><li>什么时候会报<code>unrecognized selector</code>的异常<br>调用一个不存在的方法</li><li><code>objc</code>中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[obj foo];</span><br><span class="line"><span class="comment">//编译时会变成</span></span><br><span class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(foo));</span><br><span class="line"></span><br><span class="line">[obj foo:parameter];</span><br><span class="line"><span class="comment">//编译时会变成</span></span><br><span class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(foo:),parameter);</span><br></pre></td></tr></table></figure></li><li>一个objc对象如何进行内存布局<br>可参考<a href="http://www.cnblogs.com/csutanyu/archive/2011/12/12/objective-c_memory_layout.html" target="_blank" rel="noopener">Objective-C内存布局</a></li><li>一个objc对象的isa的指针指向什么？有什么作用？<br>isa是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。</li><li>下面的代码输出什么<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>输出Son</li><li>runtime如何通过selector找到对应的IMP地址<br>id (*IMP)(id, SEL, …)<br>这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。<br>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。<br>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</li></ol><h2 id="Hybrid-混合开发"><a href="#Hybrid-混合开发" class="headerlink" title="Hybrid 混合开发"></a>Hybrid 混合开发</h2>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云之小直播开发</title>
      <link href="/2017/01/23/%E5%85%B6%E4%BB%96/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E5%B0%8F%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
      <url>/2017/01/23/%E5%85%B6%E4%BB%96/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E5%B0%8F%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="视频服务"><a href="#视频服务" class="headerlink" title="视频服务"></a>视频服务</h1><ol><li><p><a href="https://www.qcloud.com/product/LVB" target="_blank" rel="noopener">直播LVB</a> </p><ol><li><a href="https://www.qcloud.com/document/product/267/7964" target="_blank" rel="noopener">开发指南</a></li></ol></li><li><p><a href="https://www.qcloud.com/product/mlvb" target="_blank" rel="noopener">移动直播MLVB</a></p><ol><li><a href="https://www.qcloud.com/document/product/454/7876" target="_blank" rel="noopener">开发指南</a><br>移动直播是一套移动终端直播解决方案的<code>集合</code>，它以免费源码的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。</li></ol></li></ol><h2 id="快速集成方案"><a href="#快速集成方案" class="headerlink" title="快速集成方案"></a>快速集成方案</h2><img src="https://mc.qcloudimg.com/static/img/92a464fc26bbe52fea8816f8e6061ef3/image.jpg" class="导图" title="100% 200 集成导图 图片"><p>如果您想要在自己的 APP 里集成直播推流和播放功能，下面三步就能达成目标：</p><ol><li>开通直播服务<br><a href="https://console.qcloud.com/live" target="_blank" rel="noopener">文档</a></li><li>集成 RTMP SDK<br><a href="https://www.qcloud.com/document/product/454/7880" target="_blank" rel="noopener">RTMP SDK - iOS 平台播放</a></li><li>对接直播流管理<ol><li><a href="https://www.qcloud.com/document/product/454/7915" target="_blank" rel="noopener">云端API - 如何获取推流URL？</a></li><li><a href="https://www.qcloud.com/document/product/454/7916" target="_blank" rel="noopener">云端API - 如何构建房间列表？</a></li><li><a href="https://www.qcloud.com/document/product/454/7920" target="_blank" rel="noopener">云端API - 如何管理直播流？</a><br>小直播是有腾讯云研发团队提供的一套开源源码集，致力于以 DEMO 的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迁移SVN库到git库保留branchs和tags</title>
      <link href="/2017/01/18/git/%E8%BF%81%E7%A7%BBSVN%E5%BA%93%E5%88%B0git%E5%BA%93%E4%BF%9D%E7%95%99branchs%E5%92%8Ctags/"/>
      <url>/2017/01/18/git/%E8%BF%81%E7%A7%BBSVN%E5%BA%93%E5%88%B0git%E5%BA%93%E4%BF%9D%E7%95%99branchs%E5%92%8Ctags/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository.</p><h2 id="首先导入一个本地存储库"><a href="#首先导入一个本地存储库" class="headerlink" title="首先导入一个本地存储库"></a>首先导入一个本地存储库</h2><h3 id="在本地创建一个存储库的目录"><a href="#在本地创建一个存储库的目录" class="headerlink" title="在本地创建一个存储库的目录"></a>在本地创建一个存储库的目录</h3><figure class="highlight bash"><figcaption><span>新建目录</span><a href="http://www.sailmaker.co.uk/blog/2013/05/05/migrating-from-svn-to-git-preserving-branches-and-tags-3/#import-staging" target="_blank" rel="noopener">Create a local staging directory</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir staging</span><br><span class="line"><span class="built_in">cd</span> staging</span><br></pre></td></tr></table></figure><blockquote><p>注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。</p></blockquote><h3 id="初始化git-svn"><a href="#初始化git-svn" class="headerlink" title="初始化git svn"></a>初始化git svn</h3><h4 id="使用SVN标准库结构初始化"><a href="#使用SVN标准库结构初始化" class="headerlink" title="使用SVN标准库结构初始化"></a>使用SVN标准库结构初始化</h4><figure class="highlight bash"><figcaption><span>标准初始化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn init SVNRepo_ROOT_URL --stdlayout --prefix=svn/</span><br></pre></td></tr></table></figure><p><code>SVNRepo_ROOT_URL</code>: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：<code>trunk</code>，<code>branches</code>， <code>tags</code>。<br><code>--prefix</code>: 强烈建议使用<code>svn/</code>作为分支和标签的前缀：设置为 <code>--prefix=svn/</code>. 这样有助于防止Git用户混淆原声的Git分支和标签。</p><h4 id="使用SVN自定义库结构初始化"><a href="#使用SVN自定义库结构初始化" class="headerlink" title="使用SVN自定义库结构初始化"></a>使用SVN自定义库结构初始化</h4><p>使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录：<br><figure class="highlight bash"><figcaption><span>非标准化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn init SVN_URL -T Trunk -b Branches -t Tags --prefix=svn/</span><br></pre></td></tr></table></figure></p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><ol><li><code>review</code>命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">review the config</span><br></pre></td></tr></table></figure>会有以下信息输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn-remote.svn.url=svn://svn.example.com</span><br><span class="line">svn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunk</span><br><span class="line">svn-remote.svn.tags=some/path/tags/*:refs/remotes/svn/tags/*</span><br></pre></td></tr></table></figure>高级用户可以在执行之前，修改相关配置。</li><li><code>git config</code>命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list </span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=true</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.ignorecase=true</span><br><span class="line">core.precomposeunicode=true</span><br><span class="line">svn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Mac</span><br><span class="line">svn-remote.svn.fetch=trunk:refs/remotes/origin/trunk</span><br><span class="line">svn-remote.svn.branches=branches/*:refs/remotes/origin/*</span><br><span class="line">svn-remote.svn.tags=tags/*:refs/remotes/origin/tags/*</span><br><span class="line">remote.PBBReader.url=https://git.oschina.net/iTBoyer/PBBReader.git</span><br><span class="line">remote.PBBReader.fetch=+refs/heads/*:refs/remotes/PBBReader/*</span><br><span class="line">branch.master.remote=PBBReader</span><br><span class="line">branch.master.merge=refs/heads/master</span><br><span class="line">remote.server.url=https://server.local/git/PBBReader.git</span><br><span class="line">remote.server.fetch=+refs/heads/*:refs/remotes/server/*</span><br><span class="line">branch.v34.remote=PBBReader</span><br><span class="line">branch.v34.merge=refs/heads/v28</span><br></pre></td></tr></table></figure></li></ol><h3 id="从远程SVN服务器拉取代码到新建的本地存储库"><a href="#从远程SVN服务器拉取代码到新建的本地存储库" class="headerlink" title="从远程SVN服务器拉取代码到新建的本地存储库"></a>从远程SVN服务器拉取代码到新建的本地存储库</h3><figure class="highlight bash"><figcaption><span>拉取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn fetch</span><br></pre></td></tr></table></figure><h2 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h2><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight bash"><figcaption><span>status</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight bash"><figcaption><span>内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p><h3 id="查看分支信息"><a href="#查看分支信息" class="headerlink" title="查看分支信息"></a>查看分支信息</h3><figure class="highlight bash"><figcaption><span>branch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* master</span><br><span class="line">remotes/svn/tags/0.1.0</span><br><span class="line">remotes/svn/trunk</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。</p></blockquote><h2 id="SVN分支和标签转为本地git仓库中的标签和分支"><a href="#SVN分支和标签转为本地git仓库中的标签和分支" class="headerlink" title="SVN分支和标签转为本地git仓库中的标签和分支"></a>SVN分支和标签转为本地git仓库中的标签和分支</h2><h3 id="SVN分支迁移"><a href="#SVN分支迁移" class="headerlink" title="SVN分支迁移"></a>SVN分支迁移</h3><p>把远程svn分支转换为本地git仓库中的分支：<br><figure class="highlight bash"><figcaption><span>分支转分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> branch <span class="keyword">in</span> `git branch -r | grep <span class="string">"branches/"</span> | sed <span class="string">'s/ branches\///'</span>`; <span class="keyword">do</span></span><br><span class="line">git branch <span class="variable">$branch</span> refs/remotes/<span class="variable">$branch</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h3 id="SVN标签迁移"><a href="#SVN标签迁移" class="headerlink" title="SVN标签迁移"></a>SVN标签迁移</h3><ol><li>把远程svn标签转换为本地git仓库中的标签 :<figure class="highlight bash"><figcaption><span>tags转换tags</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> `git branch -r | grep <span class="string">"tags/"</span> | sed <span class="string">'s/ tags\///'</span>`; <span class="keyword">do</span></span><br><span class="line">git tag -a -m<span class="string">"Converting SVN tags"</span> <span class="variable">$tag</span> refs/remotes/<span class="variable">$tag</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="SVN标签转为本地git分支"><a href="#SVN标签转为本地git分支" class="headerlink" title="SVN标签转为本地git分支"></a>SVN标签转为本地git分支</h3><ol start="2"><li>把远程svn标签转换为本地git仓库中的分支:<figure class="highlight bash"><figcaption><span>标签转分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> `git branch -r | grep <span class="string">"tags/"</span> | sed <span class="string">'s/ tags\///'</span>`; <span class="keyword">do</span></span><br><span class="line">git branch <span class="variable">$tag</span> refs/remotes/<span class="variable">$tag</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="在本地测试git命令push和clone操作"><a href="#在本地测试git命令push和clone操作" class="headerlink" title="在本地测试git命令push和clone操作"></a>在本地测试git命令push和clone操作</h2><p>在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。</p><h3 id="创建一个临时的git库，用于测试push和clone测试"><a href="#创建一个临时的git库，用于测试push和clone测试" class="headerlink" title="创建一个临时的git库，用于测试push和clone测试"></a>创建一个临时的git库，用于测试push和clone测试</h3><p>在git中的说法，<code>bare</code>库是一个不存在工作空间备份的库。<br><figure class="highlight bash"><figcaption><span>bare创建</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><br>这样，在<code>~/test</code>就生成了一个<code>bare</code>git库。</p><h3 id="push-测试"><a href="#push-测试" class="headerlink" title="push 测试"></a>push 测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/staging</span><br><span class="line">git remote add <span class="built_in">test</span> `~/<span class="built_in">test</span>`</span><br><span class="line">git push --all <span class="built_in">test</span></span><br><span class="line">git push --tags <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>把<code>~/test</code>的放在反引号中，反引号在命令行中会<code>~</code>自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。<br>尽管它的名字，<code>--all</code>选项不推送<code>tags</code>，所以需要对标签单独push操作。</p><h3 id="clone-测试"><a href="#clone-测试" class="headerlink" title="clone 测试"></a>clone 测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir aclone</span><br><span class="line"><span class="built_in">cd</span> aclone</span><br><span class="line">git <span class="built_in">clone</span> ~/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>There should now be a clone with a working copy in ~/aclone/test.<br>在<code>~/aclone/test</code>目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。</p><h3 id="Push到正式git库中"><a href="#Push到正式git库中" class="headerlink" title="Push到正式git库中"></a>Push到正式git库中</h3><p>如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。<br>以<code>Unfuddle</code>为例,路径如下：<br><a href="mailto:`git@example.unfuddle.com" target="_blank" rel="noopener">`git@example.unfuddle.com</a>:example/blah.git<code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/staging</span><br><span class="line">git remote add unfuddle REAL_HOST_URL</span><br><span class="line">git push --all unfuddle</span><br><span class="line">git push --tags unfuddle</span><br></pre></td></tr></table></figure>在上面的例子中，制定了远程名：</code>unfuddle<code>而不是默认的</code>origin`。当然，你可以使用任何你喜欢的名字。</p><h2 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h2><h3 id="删除临时git库"><a href="#删除临时git库" class="headerlink" title="删除临时git库"></a>删除临时git库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/staging</span><br><span class="line">git remote rm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>staging</code>库忽略<code>test</code>远程仓库.</p><h3 id="清除clone生成的库"><a href="#清除clone生成的库" class="headerlink" title="清除clone生成的库"></a>清除clone生成的库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">rm -rf aclone</span><br><span class="line">rm -rf <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="Either-keep-or-delete-the-staging-repo"><a href="#Either-keep-or-delete-the-staging-repo" class="headerlink" title="Either keep or delete the staging repo"></a>Either keep or delete the staging repo</h3><ol><li>如果需要Git和SVN之间频繁交互，建议保留<code>staging</code>库这会节省你非常耗时的初始化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn fetch</span><br></pre></td></tr></table></figure></li><li>如果你确信svn是报废的，你可以删除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">rm -rf staging</span><br></pre></td></tr></table></figure></li></ol><h1 id="题外小贴士"><a href="#题外小贴士" class="headerlink" title="题外小贴士"></a>题外小贴士</h1><p>在局域网内访问server搭建服务器提供的git服务：<br><figure class="highlight bash"><figcaption><span>小贴士</span><a href="https://confluence.atlassian.com/fishkb/unable-to-clone-git-repository-due-to-self-signed-certificate-376838977.html" target="_blank" rel="noopener">SSL证书问题</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://.../git/mupdf.git</span><br><span class="line">错误：fatal: unable to access <span class="string">'https://..../git/mupdf.git/'</span>: SSL certificate problem: Invalid certificate chain</span><br></pre></td></tr></table></figure><br>解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> svn </tag>
            
            <tag> 语法 </tag>
            
            <tag> git-svn </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift错误处理</title>
      <link href="/2017/01/12/swift/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2017/01/12/swift/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.<br>Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.<br>As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.<br>举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。</p><h1 id="Representing-and-Throwing-Errors"><a href="#Representing-and-Throwing-Errors" class="headerlink" title="Representing and Throwing Errors"></a>Representing and Throwing Errors</h1><p>In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.<br>在swift中，错误类型是遵循Error 协议。</p><p>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:<br>swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如：<br>一个在操作一台游戏机时的会出现的错误枚举类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> invalidSelection</span><br><span class="line"><span class="keyword">case</span> insufficientFunds(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">case</span> outOfStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:<br>抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h1 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h1><p>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.<br>当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。</p><p>There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.<br>在swift中有四种处理错误机制:</p><pre><code>1. 向调用方法中传递这个错误2. 使用do-catch语句处理3. 把错误设置为可选型4.断言不会出现异常的情况下，使用try!禁止异常抛出</code></pre><p>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.<br>当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字<code>try</code> 要注意 <code>try?</code>或<code>try!</code>之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。</p><h2 id="Propagating-Errors-Using-Throwing-Functions"><a href="#Propagating-Errors-Using-Throwing-Functions" class="headerlink" title="Propagating Errors Using Throwing Functions"></a>Propagating Errors Using Throwing Functions</h2><p>To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-&gt;).<br>函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：<code>throws</code>即可，这种方法被称为<code>throws</code>函数，<code>throws</code>关键字位置在参数之后，返回值(-&gt;)之前</p><p>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.<br>抛出函数会把错误抛给调用它的函数周期中去。</p><a id="more"></a><p>Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function.<br>只有抛出函数能传递错误，如果不是抛出函数，它自己必须处理掉任何抛进来的错误。</p><p>In the example below, the VendingMachine class has a <code>vend(itemNamed:)</code> method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:<br>在下面的例子中，对某个请求内容不可用时，自动售货机会通过<code>vend(itemNamed:)</code>方法抛出一个对应的<code>VendingMachineError</code>错误，缺货或超过目前的存款金额成本：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> <span class="keyword">throws</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line">        <span class="keyword">var</span> newItem = item</span><br><span class="line">        newItem.<span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        inventory[name] = newItem</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing \(name)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The implementation of the <code>vend(itemNamed:)</code> method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.<br><code>vend(itemNamed:)</code>方法的实现中使用 <code>guard语句</code>来判断，当在购买操作不符合相应条件会直接抛出相应的错误，来打断该方法的其他操作。因为<code>throw语句</code>会立即转移程序控制权，保证了机器仅出售满足所有条件的物品。</p><p>Because the <code>vend(itemNamed:)</code> method propagates any errors it throws, any code that calls this method must either handle the errors—using a <code>do-catch</code> statement, <code>try?</code>, or <code>try!</code>—or continue to propagate them. For example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> in the example below is also a throwing function, and any errors that the <code>vend(itemNamed:)</code> method throws will propagate up to the point where the <code>buyFavoriteSnack(person:vendingMachine:)</code>function is called.<br>因为vend(itemNamed:)的方法抛出所有错误，所以调用该方法的函数必须处理错误（ <code>do-catch, try?, or try!</code>处理，或使用<code>try</code>向上抛出）。</p><p>例如，<code>buyFavoriteSnack(person:vendingMachine:)</code>也是一个抛出函数，从<code>vend(itemNamed:)</code>方法接受到的所有错误，都会被会<code>buyFavoriteSnack(person:vendingMachine:)</code>继续抛给调用它的函数中。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">    <span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">    <span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">    <span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> <span class="keyword">throws</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">    <span class="keyword">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, the <code>buyFavoriteSnack(person: vendingMachine:)</code> function looks up a given person’s favorite snack and tries to buy it for them by calling the <code>vend(itemNamed:)</code> method. Because the <code>vend(itemNamed:)</code> method can throw an error, it’s called with the trykeyword in front of it.<br><code>buyFavoriteSnack(person: vendingMachine:)</code> 函数查找买家中意的snake，并<code>vend(itemNamed:)</code>调用尝试购买。使用在方法前使用<code>try</code>关键字来抛出异常，并向上传递。</p><p>Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the <code>PurchasedSnackstructure</code> in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.<br>抛出构造器也能向抛出函数一样传递错误，例如：<code>PurchasedSnackstructure</code>的构造器中调用了抛出函数：<code>vend(itemNamed:)</code>，抛出构造器可以通过向上传递来处理这些错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PurchasedSnack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, vendingMachine: <span class="type">VendingMachine</span>) <span class="keyword">throws</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> vendingMachine.vend(itemNamed: name)</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Handling-Errors-Using-Do-Catch"><a href="#Handling-Errors-Using-Do-Catch" class="headerlink" title="Handling Errors Using Do-Catch"></a>Handling Errors Using Do-Catch</h2><p>You use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the <code>do</code> clause, it is matched against the <code>catch</code>clauses to determine which one of them can handle the error.<br>使用<code>do-catch</code>语句通过运行代码块来处理错误。在<code>do</code>分句中如果抛出了一个错误，那么就可以在<code>catch</code>分句中进行处理的匹配到错误<br>Here is the general form of a <code>do-catch</code>statement:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>You write a pattern after catch to indicate what errors that clause can handle. If a <code>catch</code> clause doesn’t have a pattern, the clause matches any <code>error</code> and binds the <code>error</code> to a local constant named error. For more information about pattern matching, see Patterns.<br>在关键字catch后边跟随匹配模式，这个<code>catch分句</code>就会处理匹配到的错误，如果关键字<code>catch分句</code>没有任何匹配模式，那么这个分句将会匹配到所有错误，并把这些错误信息赋值给系统常量<code>error</code>。</p><p>The <code>catch</code>clauses don’t have to handle every possible error that the code in its <code>do</code> clause can throw. If none of the catch clauses handle the error, the error propagates to the surrounding scope. However, the error must be handled by some surrounding scope—either by an enclosing <code>do-catch</code> clause that handles the error or by being inside a throwing function. For example, the following code handles all three cases of the <code>VendingMachineError</code>enumeration, but all other errors have to be handled by its surrounding scope:<br><code>catch分句</code>不必对<code>do分句</code>中的代码可能抛出每一个的错误，如果某个错误没有被<code>catch分句</code>匹配到处理，这个错误将会传递到调用它的函数周期中，这个错误必须在这个函数周期中处理，或通过<code>do-catch语句</code>来处理，或通过内部的抛出函数处理。</p><p>例如，下面的代码处理<code>VendingMachineError</code>枚举类中的三个错误<code>cases</code>，但其他的错误都是由其周边范围处理：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> buyFavoriteSnack(person: <span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.invalidSelection &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.outOfStock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.insufficientFunds(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional \(coinsNeeded) coins."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "Insufficient funds. Please insert an additional 2 coins."</span></span><br></pre></td></tr></table></figure></p><p>In the above example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> function is called in a try expression, because it can throw an error. If an error is thrown, execution immediately transfers to the <code>catch</code> clauses, which decide whether to allow propagation to continue. If no error is thrown, the remaining statements in the do statement are executed.<br>在上述代码中因为<code>buyFavoriteSnack(person:vendingMachine:)</code>函数会抛出错误异常，所以要在try表达式中调用。如果抛出异常就会立马执行是否继续传递的catch分句，如果没有抛出异常，会保持do分句中的代码正常进行。</p><h2 id="Converting-Errors-to-Optional-Values"><a href="#Converting-Errors-to-Optional-Values" class="headerlink" title="Converting Errors to Optional Values"></a>Converting Errors to Optional Values</h2><p>You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the <code>try?</code> expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior:<br>使用<code>try?表达式</code>处理错误，是通过把错误转换为<code>可选值(?)类型</code>处理。在<code>try?</code>表达式中出现抛出错误时，这个表达式的值<code>=nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">try</span>? someThrowingFunction()</span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int?</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = <span class="keyword">try</span> someThrowingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>If someThrowingFunction() throws an error, the value of x and y is nil. Otherwise, the value of x and y is the value that the function returned. Note that x and y are an optional of whatever type someThrowingFunction() returns. Here the function returns an integer, so xand y are optional integers.<br>如果函数<code>someThrowingFunction()</code>抛出异常，<code>x,y = nil</code>，否则:<code>x,y</code>就时函数<code>return</code>的值。</p><blockquote><p>注意：<code>x,y</code>是一个可选的someThrowingFunction()返回类型。在这里函数返回integer，那么x,y是可选的integer类型。</p></blockquote><p>Using <code>try?</code> lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.<br>当用这种方式来处理所有错误时，使用<code>try?</code>表达式能写更简洁的错误处理代码，例如：下面的代码使用几种方法来获取数据，如果这些方法失败就会返回nil。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data?</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Disabling-Error-Propagation"><a href="#Disabling-Error-Propagation" class="headerlink" title="Disabling Error Propagation"></a>Disabling Error Propagation</h2><p>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write <code>try!</code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.<br>有时你认为不会出现异常的抛出函数或方法，但事实上，却在运行时抛出异常了。在其他情况下，可以使用<code>try!</code>表达式来禁止错误传递，并且十分肯定断言在运行时不会有异常抛出。如果有异常抛出，就会得到一个运行时错误。</p><p>For example, the following code uses a <code>loadImage(atPath:)</code> function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.<br>例如：使用<code>loadImage(atPath:)</code>函数要么通过这个路径加载image，要么image加载失败抛出一个错误。在这种情况下，因为<code>image</code>在app资源目录<code>resources</code>中，所以在运行时肯定不会有异常抛出。因此可以使用<code>try!</code>禁止错误传递。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = <span class="keyword">try</span>! loadImage(atPath: <span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Specifying-Cleanup-Actions"><a href="#Specifying-Cleanup-Actions" class="headerlink" title="Specifying Cleanup Actions"></a>Specifying Cleanup Actions</h2><p>You use a defer statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break. For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.<br>在代码执行离开当前代码块之前，使用一个“defer语句”来执行一组语句。defer语句让做一些必要的清理操作，在执行如何离开当前代码块：因为抛出异常或者因为<code>return，break语句</code>导致。例如：使用<code>defer语句</code>执行关闭文件和内存的释放操作，来确保清理操作完成。</p><p>A defer statement defers execution until the current scope is exited. This statement consists of the defer keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error. Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on.<br><code>defer语句</code>推迟在直到当前作用域推出时，再执行。<code>defer语句</code>由<code>defer</code>关键字和一些清理操作语句组成。<code>defer语句</code>不包含transfer control out of the statements例如<code>（return，break，throw）</code>等。</p><p><code>defer</code>延迟操作是按照指定的顺序执行的，就是先执行最后一个<code>defer语句</code>中的代码之后，再执行第倒数第二个<code>defer语句</code>的代码，以此类推，倒叙清理退场。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = <span class="keyword">open</span>(filename)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = <span class="keyword">try</span> file.readline() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// close(file) is called here, at the end of the scope.</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The above example uses a defer statement to ensure that the <code>open(_:)</code> function has a corresponding call to <code>close(_:)</code>.<br>使用defer语句，确保了在open的同时与之相关的还有close。</p><p>You can use a defer statement even when no error handling code is involved.<br>即使在没有涉及错误处理代码的时候，也可以使用“延迟”语句。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在OC和swift中区分多个targets</title>
      <link href="/2017/01/11/iOS/%E5%9C%A8OC%E5%92%8Cswift%E4%B8%AD%E5%8C%BA%E5%88%86%E5%A4%9A%E4%B8%AAtargets/"/>
      <url>/2017/01/11/iOS/%E5%9C%A8OC%E5%92%8Cswift%E4%B8%AD%E5%8C%BA%E5%88%86%E5%A4%9A%E4%B8%AAtargets/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="build-setting预编译位置"><a href="#build-setting预编译位置" class="headerlink" title="build setting预编译位置"></a>build setting预编译位置</h2><ol><li>Preprocessor Macros</li><li>Other Swift Flags</li></ol><p>为生产和开发target配置预处理宏/编译器标识。之后我们就可以使用该标识在我们的代码来检测应用程序正在运行的版本。</p><h3 id="Objective-C项目中Preprocessor-Macros"><a href="#Objective-C项目中Preprocessor-Macros" class="headerlink" title="Objective-C项目中Preprocessor Macros"></a>Objective-C项目中Preprocessor Macros</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><hr><p>添加位置：选择项目中对应的target名-&gt;在<code>Build Settings</code>下<code>Apple LLVM 7.0 - Preprocessing</code>-&gt;<code>Preprocessor Macros</code>。<br>添加变量：在Rebug和Release区域添加一个变量<code>DEVELOPMENT</code><br>    对应target1: 设<code>DEVELOPMENT=1</code>表示开发版<br>    对应target2: 设<code>DEVELOPMENT=0</code>表示生产版</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><hr><p>根据已配置的宏DEV_VERSION，我们可以在代码中利用它动态地编译项目。下面是一个简单的例子：<br>Objective-C中使用<code>＃if</code>检查<code>DEVELOPMENT</code>的环境，并相应的设置URLs/ API密钥。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DEVELOPMENT</span></span><br><span class="line">     <span class="meta">#define SERVER_URL @<span class="meta-string">"http://dev.server.com/api/"</span></span></span><br><span class="line">     <span class="meta">#define API_TOKEN @<span class="meta-string">"DI2023409jf90ew"</span></span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">     <span class="meta">#define SERVER_URL @<span class="meta-string">"http://prod.server.com/api/"</span></span></span><br><span class="line">     <span class="meta">#define API_TOKEN @<span class="meta-string">"71a629j0f090232"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="Swift中Other-Swift-Flags"><a href="#Swift中Other-Swift-Flags" class="headerlink" title="Swift中Other Swift Flags"></a>Swift中Other Swift Flags</h3><p>对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><hr><p>选中开发target，添加一个标识表示开发版本<br>选中<code>target</code> -&gt; <code>Build Setting</code>-&gt;<code>Swift Compiler - Custom Flags</code>-&gt;将值设为<code>-DDEVELOPMENT</code>表示这个target作为开发版本。</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><hr><p>Swift中你仍然可以使用<code>#if</code>判定build的参数动态编译。然而，除了使用<code>#define</code>定义基本常量，在swift中我们也可以用<code>let</code>定义一个全局常量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEVELOPMENT</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">SERVER_URL</span> = <span class="string">"http://dev.server.com/api/"</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">API_TOKEN</span> = <span class="string">"DI2023409jf90ew"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">SERVER_URL</span> = <span class="string">"http://prod.server.com/api/"</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">API_TOKEN</span> = <span class="string">"71a629j0f090232"</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><a href="http://www.cocoachina.com/ios/20160331/15832.html" target="_blank" rel="noopener">参照</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> targets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 语言指南[转]</title>
      <link href="/2017/01/04/swift/SwiftGuide/"/>
      <url>/2017/01/04/swift/SwiftGuide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Swift-语言指南"><a href="#Swift-语言指南" class="headerlink" title="Swift 语言指南"></a>Swift 语言指南</h1><blockquote><p><span style="color:lightgray;font-size:12px"><a href="http://weibo.com/swiftlanguage" target="_blank" rel="noopener">@SwiftLanguage</a> 更新于 2016-6-6，更新内容详见 <a href="https://github.com/ipader/SwiftGuide/blob/master/weekly/Issue-55.md" target="_blank" rel="noopener">Issue 55</a>。往期更新回顾详见《<a href="https://github.com/ipader/SwiftGuide/blob/master/weekly/README.md" target="_blank" rel="noopener">收录周报</a>》</span></p></blockquote><p>　　<a href="https://github.com/ipader/SwiftGuide/blob/master/2014%20letter.md" target="_blank" rel="noopener">这份指南</a>汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排。对于精选项目及文章，可直接访问《<a href="https://github.com/ipader/SwiftGuide/blob/master/Featured.md" target="_blank" rel="noopener">Swift 项目精选</a>》和《<a href="https://github.com/ipader/SwiftGuide/blob/master/Featured-Articles.md" target="_blank" rel="noopener">Swift 文章精选</a>》。还有开发者们自己维护的《<a href="https://github.com/ipader/SwiftGuide/wiki/%E5%BC%80%E5%8F%91%E8%80%85%E3%80%81%E9%A1%B9%E7%9B%AE%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" target="_blank" rel="noopener">开发者、项目、最佳实践</a>》。当然也不能错过那些活跃、优秀的《<a href="https://github.com/ipader/SwiftGuide/wiki/%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E9%A1%B5" target="_blank" rel="noopener">开发者个人资料页</a>》。</p><h2 id="入门指引"><a href="#入门指引" class="headerlink" title="入门指引"></a>入门指引</h2><p>苹果为 <a href="http://www.apple.com/swift/" target="_blank" rel="noopener">Swift</a>（<a href="http://www.apple.com/cn/swift/" target="_blank" rel="noopener">中文介绍</a>）开发者提供的<a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">官方文档入口</a>，包括 <a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">概述</a>，<a href="https://developer.apple.com/swift/blog/" target="_blank" rel="noopener">博客</a>（<a href="https://github.com/ipader/SwiftGuide/tree/master/mirror/Swift%20Blog%20-%20Apple%20Developer" target="_blank" rel="noopener">中文镜像</a>）及 <a href="https://developer.apple.com/swift/resources/" target="_blank" rel="noopener">开发资源</a>。其中以下几份文档（Swift 2.1）为入门级必备（<a href="https://itunes.apple.com/us/book-series/swift-programming-series/id888896989?mt=11" target="_blank" rel="noopener">iBooks 版</a>）：</p><ul><li><p><a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">Swift Programming Language</a>（<a href="http://gg.swiftguide.cn" target="_blank" rel="noopener">中文版</a>｜<a href="http://wiki.jikexueyuan.com/download/swift/pdf/" target="_blank" rel="noopener">PDF 版</a> By <a href="http://weibo.com/swiftguide" target="_blank" rel="noopener">SwiftGG翻译组</a>）</p></li><li><p><a href="https://developer.apple.com/swift/resources/" target="_blank" rel="noopener">Start Developing iOS Apps</a> </p></li><li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html" target="_blank" rel="noopener">Using Swift with Cocoa and Objective-C</a>（<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md" target="_blank" rel="noopener">中文版</a> By <a href="http://weibo.com/cocoachina" target="_blank" rel="noopener">@CocoaChina</a>）</li></ul><p><em>苹果同时也维护着相应 Beta 版（Swift 2.2）文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html" target="_blank" rel="noopener">Swift Programming Language</a>，<a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html" target="_blank" rel="noopener">Start Developing iOS Apps</a>，<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html" target="_blank" rel="noopener">Using Swift with Cocoa and Objective-C</a>。</em></p><p>学习实践的角度，标准库示例代码 <a href="https://developer.apple.com/sample-code/swift/downloads/Standard-Library.zip" target="_blank" rel="noopener">Swift Standard Library.playground</a> 是很棒的学习伴侣。</p><p>教程方面，苹果力荐了斯坦福课程 <a href="https://itunes.com/StanfordSwift" target="_blank" rel="noopener">Stanford University: Developing iOS 8 Apps with Swift</a>（<a href="http://open.163.com/special/opencourse/ios8.html" target="_blank" rel="noopener">中文字幕版</a> By <a href="http://weibo.com/163open" target="_blank" rel="noopener">@网易公开课</a>）</p><p>除以上所涉及入门级文档，<a href="https://developer.apple.com/library/ios/navigation/" target="_blank" rel="noopener">iOS Developer Library</a> 还为开发者提供了更庞大、系统化的开发文档支持。</p><p>以下列举了几份已有第三方中文翻译文档：</p><ul><li><a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="noopener">API Design Guidelines</a>（<a href="http://swift.gg/2016/05/18/api-design-guidelines/" target="_blank" rel="noopener">中文版</a> By <a href="http://weibo.com/u/5174822990" target="_blank" rel="noopener">@SwiftGG翻译组</a>）</li><li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html" target="_blank" rel="noopener">App Extension Programming Guide</a>（<a href="https://github.com/ipader/SwiftGuide/tree/master/mirror/App%20Extension%20Programming%20Guide" target="_blank" rel="noopener">中译镜像</a>）</li><li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html" target="_blank" rel="noopener">iOS Human Interface Guidelines</a>（<a href="https://isux.tencent.com/?s=iOS+9+%E4%BA%BA%E6%9C%BA%E7%95%8C%E9%9D%A2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">中文版</a>｜<a href="http://ixdc.org/2016/files/ISUX[%E8%AF%91]iOS9%20human%20Interface%20Guideline.pdf" target="_blank" rel="noopener">PDF 版</a> By <a href="http://weibo.com/txisux" target="_blank" rel="noopener">@腾讯ISUX</a>）</li><li><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/HomeKitDeveloperGuide/Introduction/Introduction.html" target="_blank" rel="noopener">HomeKit Developer Guide</a>（<a href="http://www.cocoachina.com/ios/20150324/11411.html" target="_blank" rel="noopener">中文版</a> By <a href="http://weibo.com/cocoachina" target="_blank" rel="noopener">@CocoaChina</a>）</li></ul><p>值得称道的还有：苹果为 <a href="https://developer.apple.com/videos/" target="_blank" rel="noopener">Apple TV Tech Talks</a> 和 <a href="https://developer.apple.com/videos/wwdc2015/" target="_blank" rel="noopener">WWDC 2015</a> 的视频添加简体中文字幕，从而方便中国开发者观看来自官方的权威技术分享。</p><p>有关于 Swift 开源及跨平台开发，可以关注 <a href="https://swift.org/" target="_blank" rel="noopener">swift.org</a></p><h2 id="教程文章"><a href="#教程文章" class="headerlink" title="教程文章"></a><a href="https://github.com/ipader/SwiftGuide/blob/master/Featured-Articles.md" target="_blank" rel="noopener">教程文章</a></h2><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a><a href="https://github.com/ipader/SwiftGuide/blob/master/Featured.md" target="_blank" rel="noopener">开源项目</a></h2><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><ul><li><strong>苹果官方</strong></li><li><a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">Swift</a>：Swift 概述、博客以及开发资源。</li><li><a href="https://swift.org/" target="_blank" rel="noopener">swift.org</a>：开源后独立出来的 Swift 开源社区。</li><li><a href="https://github.com/apple" target="_blank" rel="noopener">GitHub:apple</a>：苹果在 GitHub 上的开源项目。</li><li><a href="https://github.com/apple/swift" target="_blank" rel="noopener">GitHub:apple/swift</a>：swift 语言在 GitHub 上的开源项目。</li><li><a href="https://github.com/ksm/SwiftInFlux" target="_blank" rel="noopener">ksm/SwiftInFlux</a>：作者（Karol Mazur）将 Apple Developer Forums 上有关 Swift 特性、缺陷及变更讨论分类汇总并更新到 GitHub，具有很好的可读性。从中可以一窥 Swift 缺陷及未来潜在地变化。最关键地是有 Chris Lattner 及核心团队答疑解惑。</li><li><del><a href="https://www.raywenderlich.com/" target="_blank" rel="noopener">raywenderlich.com</a>(<a href="https://www.raywenderlich.com/zh-hans/" target="_blank" rel="noopener">中文版</a>)：由Ray Wenderlich创建，专注于开发高质量编程指南（近期优质Swift文章及视频教程不断），著名的iOS/OS X博客及开发教程网站，非常适合新手学习。近期第一时间出了<a href="https://www.raywenderlich.com/74832/three-new-swift-books" target="_blank" rel="noopener">三本 Swift 新书</a>。</del></li><li><a href="http://www.natashatherobot.com/" target="_blank" rel="noopener">Natasha The Robot</a>： 时髦码农不容错过的 Swift 开发实战教程类网站。为了简化学习复杂性，每一篇文章涵盖技术点单一又独立，配以开发步骤、运行结果以及代码等标准方式教授。难能可贵的是，它往往出品“追剧式”（最新开发特性或API跟进式）教程，实在是开发者必藏精品网站。</li><li><a href="http://nshipster.com/" target="_blank" rel="noopener">NShipster</a> (<a href="http://nshipster.cn/" target="_blank" rel="noopener">中译版</a>：<a href="http://weibo.com/croath" target="_blank" rel="noopener">@刘镇夫</a>，<a href="http://nshipster.cn/translators/april-peng/" target="_blank" rel="noopener">April Peng</a>，<a href="http://weibo.com/leelejia" target="_blank" rel="noopener">@李乐佳</a>，<a href="http://weibo.com/fallhunter" target="_blank" rel="noopener">@程序员付恒</a> 等翻译)：著名开源作者 <a href="https://github.com/mattt" target="_blank" rel="noopener">Matt Thompson</a> 创建的开发技术博客网站，他开发了 <a href="https://github.com/afnetworking/afnetworking" target="_blank" rel="noopener">AFNetworking</a> 网络库，也是非常多产的开源作者。更多了解参考：<a href="http://www.fallhunter.com/p/10709" target="_blank" rel="noopener">《COCOA 潮人 MATTT THOMPSON》</a> By <a href="http://weibo.com/fallhunter" target="_blank" rel="noopener">@程序员付恒</a></li><li><a href="http://jamesonquave.com/blog/" target="_blank" rel="noopener">jamesonquave.com</a>：移动开发者，优秀个人博客（近期文章同样关注于Swift 语言，写得很优质）。同时他将于8/30发布一本新书<a href="http://jamesonquave.com/swiftebook/" target="_blank" rel="noopener">《Developing iOS 8 Apps in Swift》</a> (Learn To Make Real World iOS 8 Apps)及视频教程。</li><li><a href="https://www.objc.io/" target="_blank" rel="noopener">objc.io</a>(<a href="http://objccn.io" target="_blank" rel="noopener">中译版 By @onevcat 及其朋友们</a>)：”关于 Objective-C 最佳实践和先进技术的期刊。 由 Chris Eidhof, Daniel Eggert 和 Florian Kugler 成立于柏林。我们成立 objc.io 的目的是针对深入的、跟所有 iOS 和 OS X 开发者相关的技术话题创造一个正式的平台。“</li><li><a href="http://www.ioscreator.com/" target="_blank" rel="noopener">iOSCreator</a>：这类开发指引式教程对于初学者来讲，是直接明了的有效学习资源。推荐者<a href="http://weibo.com/qq184675420" target="_blank" rel="noopener">@荧星诉语</a></li><li><a href="https://iosdevweekly.com/" target="_blank" rel="noopener">iOS Dev Weekly</a>：收录一周以来 iOS 开发资讯链接，并于周五发布。由 <a href="https://twitter.com/daveverwer" target="_blank" rel="noopener">Dave Verwer</a> 创办，他是一位 iPhone 和 iPad 开发者以及培训师。</li><li><a href="http://www.appcoda.com/" target="_blank" rel="noopener">Appcoda.com</a>：质量很高的一个 iOS 开发教程站，其中<a href="http://www.appcoda.com/ios-programming-course/" target="_blank" rel="noopener">iOS Programming Course</a>这个专题很适合刚接触 iOS 开发的新手学习。</li><li><a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="noopener">中文 iOS/Mac 开发博客列表</a>：By <a href="http://weibo.com/tangqiaoboy" target="_blank" rel="noopener">@唐巧_body</a></li><li><a href="http://www.devtalking.com/" target="_blank" rel="noopener">devtalking.com</a>：高产的中译博客。翻译了官方博客 Swift Blog - Apple Developer,《App Extension Programming Guide》。参与翻译了《Swift Programming Language》等。</li><li><a href="http://swift.gg/" target="_blank" rel="noopener">SwiftGG</a>：一个走心的 Swift 翻译组，由《The Swift Programming Language》中文版翻译团队原班人马组成， 翻译的文章来源于国外的优秀 Swift 网站和博客，且全部获得作者和网站授权。</li><li><a href="http://www.jessesquires.com" target="_blank" rel="noopener">Swift Weekly Brief</a>：“这个博客现在每周会将Swift开源中的重要讨论和提交整理成Open source Swift weekly brief，这对一线开发者尽早了解这门语言的动态情报很有帮助。By <a href="http://weibo.com/cuikang82" target="_blank" rel="noopener">@崔康总编</a> ”。来源：<a href="http://www.jessesquires.com" target="_blank" rel="noopener">Jesse Squires</a></li><li><a href="http://swiftdevweekly.co/" target="_blank" rel="noopener">Swift Developer Weekly</a>:这个网站每周推送最新的技术文章和书本推荐到你的email，由Phil Wright创办。</li><li><p><a href="http://iosdevtips.co" target="_blank" rel="noopener">iosdevtips.co</a>：iOS Development Tips</p></li><li><p><strong>资源合集</strong></p><blockquote><p>以下是其它开发者社区或 Swift 爱好者整理的有关 Swift 语言学习的资源列表。</p></blockquote></li><li><p><a href="https://github.com/SwiftEducation" target="_blank" rel="noopener">SwiftEducation</a>：“这是建立在 GitHub 上的一个 Swift 学习资料汇集，包括了有关幻灯和多个练手的应用程序源码。By @极客头条”。的确有不少基础实用的好<a href="https://github.com/SwiftEducation/presentations" target="_blank" rel="noopener">教程</a>。这对于基础学起的同学有福了。</p></li><li><a href="https://github.com/hsavit1/Awesome-Swift-Education" target="_blank" rel="noopener">Awesome-Swift-Education</a>：整理地如此美妙的学习资源，实在让人太欢喜了。</li><li><a href="http://www.ioscookies.com/" target="_blank" rel="noopener">iOS Cookies</a>：分类合理、排序靠谱的 Swift 开源类库集合。</li><li><a href="https://github.com/matteocrippa/awesome-swift" target="_blank" rel="noopener">matteocrippa/awesome-swift</a>：这个版本的 Swift 资源集合内容丰富，分类也不错。作者：<a href="https://github.com/matteocrippa" target="_blank" rel="noopener">Matteo Crippa</a></li><li><a href="http://www.csdn.net/article/2015-03-04/2824108-ios-developers-sites/1" target="_blank" rel="noopener">适合iOS开发者的 15 大网站推荐</a>：的确很全、很主流的国外 iOS 开发者网站。</li><li><a href="http://gold.xitu.io/#/tag/Swift" target="_blank" rel="noopener">掘金 Swift 版块</a></li><li><a href="http://weekly.manong.io/issues/33?ref=swift" target="_blank" rel="noopener">码农周刊 －《Swift 特刊》</a></li><li><a href="http://www.cocoachina.com/bbs/read.php?tid=204512" target="_blank" rel="noopener">CocoaChina －《Swift 新手入门汇集帖》</a></li><li><a href="http://code.csdn.net/news/2820075" target="_blank" rel="noopener">CSDN_CODE －《Swift 编程语言资料大合集》</a></li><li><a href="http://www.infoq.com/cn/news/2014/06/apple-swift-learning-resources" target="_blank" rel="noopener">InfoQ －《学习苹果 Swift 语言的一些在线资源（英文）》</a></li><li><a href="https://github.com/Lax/iOS-Swift-Demos/wiki" target="_blank" rel="noopener">刘兰涛 －《Swift 学习资源》</a> By <a href="http://weibo.com/u/1653644220" target="_blank" rel="noopener">@懒桃儿吃桃儿</a></li><li><a href="http://www.learnswift.tips/" target="_blank" rel="noopener">learnswift.tips</a>：国外主流 Swift 学习资源集合。</li><li><a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="noopener">Awesome iOS</a>：一个 iOS 的各类优秀的开源项目集合。真不错！可惜Swift开源项目资源不足。</li><li><a href="http://iosdevelopertips.com/" target="_blank" rel="noopener">iOS Developer Tips</a>：还是有关 iOS 的开发资源及文章合集。</li><li><a href="https://github.com/Wolg/awesome-swift" target="_blank" rel="noopener">Wolg/awesome-swift</a>：一位俄罗斯朋友分类整理的 Swift 资源列表（有持续更新）。</li><li><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="noopener">Aufree/trip-to-iOS</a>：显然作者很用心的做了非常深入的整理。它对于开发者拓展学习范围及开发知识面非常有益。</li><li><a href="https://swift.zeef.com/robin.eggenkamp" target="_blank" rel="noopener">Robin Eggenkamp - Awesome Swift</a>：“一个收集了很多 Swift 开发资源的网站”。</li><li><a href="https://github.com/hehonghui/iOS-tech-frontier" target="_blank" rel="noopener">iOS 开发技术前线</a>：“一个定期翻译、发布国内外iOS优质的技术、开源库、软件架构设计、测试等文章的开源项目”。主要翻译来源 Ray Wenderlich，App Coda，Medium。来源：<a href="http://weibo.com/u/5589212242" target="_blank" rel="noopener">@开发技术前线</a></li><li><a href="http://www.cocoachina.com/ios/20150626/11348.html" target="_blank" rel="noopener">11个超棒的 iOS 开发学习网站</a>：还算比较主流的归纳。不过，缺了raywenderlich.com 和 ioscreator.com 这两个重量级教程网站实在是不应该啊。</li></ul><hr><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="1-编程工具"><a href="#1-编程工具" class="headerlink" title="1. 编程工具"></a>1. 编程工具</h3><ul><li><a href="https://developer.apple.com/swift/resources/" target="_blank" rel="noopener">Xcode 下载</a>：苹果应用集成开发环境。支持 C/C++, Objective C, Swift 等。不用购买开发者计划，直接下载。</li><li><a href="http://macromates.com/" target="_blank" rel="noopener">Textmate</a>：Mac OS X 上一个可高度自定义的编辑器，尤其在我想做出一个快速改变但又不想等待 Xcode 加载的时候。该工具目前已经<a href="https://github.com/textmate/textmate" target="_blank" rel="noopener">开源</a></li><li><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou ($)</a>：OS X 上一款 Markdown 的编辑器。非常适用于编写自述文件、变更日志以及其他方面的内容。作者：<a href="http://chenluois.com/" target="_blank" rel="noopener">罗晨</a></li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text ($)</a>：Mac OS X 上另一款非常受欢迎的轻量级，可高度自定义的编辑器。</li><li><a href="http://www.runswiftlang.com/" target="_blank" rel="noopener">RunSwift</a>:正在犹豫是否入手苹果电脑开始一段 Swift 编程旅程的同学们，或仅仅为了试验一段简单 Swift 代码又懒得打开 Xcode，可以试试这款 Web 版 Swift 编译环境 RunSwift。</li><li><a href="http://infinitapps.com/bezel/" target="_blank" rel="noopener">InfinitApps - Bezel</a>：“嫌 Xcode 6 目前提供的 Watch 模拟器不够直观？Bezel 是一个用于视觉预览 WatchKit 所开发程序效果的小工具，前提是你安装了 xScope 软件（Mac端）或 xScopeMirror（iPhone端）。 By <a href="http://weibo.com/twios" target="_blank" rel="noopener">@WatchKit开发</a>”</li><li><a href="https://github.com/jas/playground" target="_blank" rel="noopener">Markdown -&gt; Playground</a>：该开源项目可将内含有 Swift 代码的 Markdown 自动转换为 Xcode Playgrounds 文件。喜欢用 Markdown 编辑的同学很激动吧。P.S. 这款工具写于 NodeJS，原因作者有交待。</li><li><a href="https://autolayoutconstraints.com" target="_blank" rel="noopener">iOS/Mac Autolayout Constraints</a>：这个工具不错，很直观，布局时可以省不少工夫。推荐者：<a href="http://weibo.com/qq184675420" target="_blank" rel="noopener">@荧星诉语</a></li><li><a href="https://appscreens.io/yK7cLuBNij" target="_blank" rel="noopener">在线生成 AppStore 审核用截图</a>：便捷的生产力工具。免费，易操作，可自定义。</li><li><a href="https://swiftlang.ng.bluemix.net/#/repl" target="_blank" rel="noopener">IBM Swift Sandbox</a>：IBM的在线Swift网站，需要翻墙。</li><li><a href="http://swiftstub.com/" target="_blank" rel="noopener">SwiftStub</a>：另外一个Swift在线练习网站。</li></ul><h3 id="2-代码管理"><a href="#2-代码管理" class="headerlink" title="2. 代码管理"></a>2. 代码管理</h3><ul><li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>：声望日盛的资源分享之地。</li><li><a href="https://desktop.github.com/" target="_blank" rel="noopener">GitHub for Mac</a>：一个设计的非常美观的 git 客户端，不能取代你从命令行获得的所有功能，但使用起来非常简单。</li><li><a href="https://gitcafe.com/" target="_blank" rel="noopener">GitCafe</a>：GitCafe is a source code hosting service based on version control system Git。国内的代码托管服务，基于 Git，值得一提的是最近也推出了和 GitHub Pages 类似的服务 Gitcafe Pages。因为是在国内，所以相比较 GitHub 有速度优势，在网络环境差的情况下也许可以作为 GitHub 的备用。</li><li><a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a>：国外的代码托管服务，不同于 GitHub 的是，Bitbucket 可以免费建立 private 项目。</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>：分布式版本控制系统和源码管理系统，其优点是：快和简单易用。对于新手来说，可在此查看免费电子书籍。</li><li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>：A free Git &amp; Mercurial client for Windows or Mac.免费的Git和Mercurial客户端，当然也可以配合Bitbucket使用。</li></ul><h3 id="3-Xcode-插件"><a href="#3-Xcode-插件" class="headerlink" title="3. Xcode 插件"></a>3. Xcode 插件</h3><ul><li><a href="http://beta.cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a>：第三方库的管理利器，允许你简单地把第三方库整合进自己的应用中。对我个人来说，我基本上每个项目都使用 CocoaPods。</li><li><a href="https://github.com/kattrali/cocoapods-xcode-plugin" target="_blank" rel="noopener">CocoaPods Xcode Plugin</a>：一款 Xcode 插件，允许你直接从 Xcode 管理 CocoaPod 依赖。</li><li><a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">onevcat/VVDocumenter-Xcode</a>：快捷注释 Xcode 插件。By <a href="http://weibo.com/onevcat" target="_blank" rel="noopener">@onevcat</a></li><li><a href="https://github.com/omz/ColorSense-for-Xcode" target="_blank" rel="noopener">ColorSense</a>：一款显示颜色数值的插件，还可以直接通过系统的ColorPicker来自动生成对应颜色代码</li><li><a href="https://github.com/sopig/DeepIniOS" target="_blank" rel="noopener">Xcode 优秀插件整理</a>:持续保持整理更新的 Xcode 插件整理 By <a href="https://github.com/ddapps" target="_blank" rel="noopener">@ddapps</a></li><li><a href="https://github.com/CodeEagle/SwiftCodeSnippets" target="_blank" rel="noopener">CodeEagle/SwiftCodeSnippets</a>：自动下载指定 Xcode Snippet 源的 Xcode Plugin。项目缺省提供 Snippet 代码源 <a href="https://github.com/burczyk/XcodeSwiftSnippets/tree/master/plist" target="_blank" rel="noopener">burczyk/XcodeSwiftSnippets</a> 。</li><li><a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">realm/SwiftLint</a>：Realm 采用 Swift 编写的基于 GitHub’s Swift Style Guide 规则的检查工具。除了命令行运行方式，也提供集成 Xcode 的方法。对于新团队，这样的工具可以自动约束大家遵循编程规范。</li><li><a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/" target="_blank" rel="noopener">XCode 升级后插件失效的原理与修复办法</a>：由一条命令引发的分析文章。<a href="http://weibo.com/u/2068840121" target="_blank" rel="noopener">@_TongJZ</a></li><li><a href="https://github.com/feinstruktur/CoPilot" target="_blank" rel="noopener">feinstruktur/CoPilot</a>：通过此插件，Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。<a href="https://vimeo.com/128713880" target="_blank" rel="noopener">演示视频</a></li><li><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>：新兴起的去中心化的依赖管理器，目标是用最简单的方式来管理Cocoa第三方框架。优势很明显，但是也有不足，看后面的发展吧。</li></ul><h3 id="4-管理工具"><a href="#4-管理工具" class="headerlink" title="4. 管理工具"></a>4. 管理工具</h3><ul><li><a href="https://github.com/kylef/swiftenv" target="_blank" rel="noopener">swiftenv</a>：Swift 版本管理器。类似 rvm（Ruby）, nvm（Node.js）。</li><li><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">HomeBrew</a>：OS X 上非常出色的包管理工具。</li><li><a href="http://panic.com/transmit/" target="_blank" rel="noopener">Transmit ($)</a>：一个Mac OS X 上 FTP 客户端，有着非常漂亮的用户界面和有用的功能。</li></ul><h3 id="5-调试工具"><a href="#5-调试工具" class="headerlink" title="5. 调试工具"></a>5. 调试工具</h3><ul><li><a href="http://fuckingclangwarnings.com/" target="_blank" rel="noopener">mattt/fuckingclangwarnings.com</a>：警告与语义对照表。以后再也不用为 Xcode 各种警告纠结啦！By <a href="http://weibo.com/foogry" target="_blank" rel="noopener">@foogry</a></li></ul><h3 id="6-设计工具"><a href="#6-设计工具" class="headerlink" title="6. 设计工具"></a>6. 设计工具</h3><ul><li><a href="http://www.sketchapp.com/" target="_blank" rel="noopener">sketch</a>：更适合开发应用的矢量设计工具。通过插件还支持与代码协同工作。推荐书籍：<a href="https://designcode.io/sketch" target="_blank" rel="noopener">Learn Sketch 3</a></li><li><a href="http://www.paintcodeapp.com/" target="_blank" rel="noopener">PaintCode</a><br>:PaintCode是Apple Designer入门APP开发最合适的辅助工具之一，她可以把你绘制的矢量UI自动转化为适用于iOS/OS X的Objective-C代码。</li></ul><h3 id="7-发布工具"><a href="#7-发布工具" class="headerlink" title="7. 发布工具"></a>7. 发布工具</h3><ul><li><a href="https://fabric.io" target="_blank" rel="noopener">Frabic</a></li><li><a href>fastlane</a></li><li><a href="https://support.apple.com/zh-cn/macos/server" target="_blank" rel="noopener">Xcode Server</a></li></ul><h3 id="7-开源项目"><a href="#7-开源项目" class="headerlink" title="7. 开源项目"></a>7. 开源项目</h3><ul><li><a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="noopener">RESideMenu</a>侧滑布局类库,支持左右滑动，滑动距离;</li><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a>易于集成，支持设备的方向，可通过类的方法来启用和禁用键盘管理器；</li><li><a href="https://github.com/antoniocasero/ACPDownload" target="_blank" rel="noopener">ACPDownload</a>实现类似AppStore下载状态样式；</li><li><a href="https://github.com/thibaultCha/TCBlobDownload" target="_blank" rel="noopener">TCBlobDownload</a>支持后台线程执行大文件下载任务，暂停和重新恢复下载；</li><li><a href="https://github.com/shingwasix/MobShareSDK" target="_blank" rel="noopener">MobShareSDK</a>实现微信朋友，朋友圈分享;</li><li><a href="https://zwaldowski.github.io/BlocksKit" target="_blank" rel="noopener">BlocksKit</a>没有创建新的宏，函数，方法和类，仅对Cocoa基础类的一个扩展，是取代了通常的delegate用法;</li><li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>图片缓存的框架; </li><li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a>下拉刷新上拉加载更多MJRefresh类库;</li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a>Android风格的Toast控件,用户提示便捷得体；</li><li><a href="https://github.com/kcandr/IQLabelView" target="_blank" rel="noopener">IQLabelView</a>对文本控件覆盖，缩放和旋转；</li><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></li><li><a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>处理web服务api,解析JSON映射响应对象；</li><li><a href="https://github.com/Masonry/Masonry" target="_blank" rel="noopener">Masonry</a>一个轻量级的布局框架,拥有自己的描述语法，采用更优雅的链式语法封装自动布局；</li></ul><p>*<a href="https://github.com/PerfectlySoft/Perfect/blob/master/README.zh_CN.md" target="_blank" rel="noopener">Perfect 服务器</a></p><h2 id="媒体报道"><a href="#媒体报道" class="headerlink" title="媒体报道"></a><a href="https://github.com/ipader/SwiftGuide/tree/master/archive/news.md" target="_blank" rel="noopener">媒体报道</a></h2><h2 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a><a href="https://github.com/ipader/SwiftGuide/tree/master/archive/platforms.md" target="_blank" rel="noopener">开放平台</a></h2><h2 id="Apple-Watch-指南"><a href="#Apple-Watch-指南" class="headerlink" title="Apple Watch 指南"></a><a href="https://github.com/ipader/SwiftGuide/blob/master/Apple%20Watch/README.md" target="_blank" rel="noopener">Apple Watch 指南</a></h2>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
            <tag> 资源 </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/2016/12/22/%E5%85%B6%E4%BB%96/Docker%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/12/22/%E5%85%B6%E4%BB%96/Docker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="安装Docker-for-Mac"><a href="#安装Docker-for-Mac" class="headerlink" title="安装Docker for Mac"></a>安装<a href="https://www.docker.com/products/docker#/mac" target="_blank" rel="noopener">Docker for Mac</a></h2><p>在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'下载dmg...'</span></span><br><span class="line">curl -o Docker.dmg <span class="symbol">https:</span>/<span class="regexp">/dn-dao-github-mirror.qbox.me/docker</span><span class="regexp">/install/mac</span><span class="regexp">/Docker.dmg</span></span><br><span class="line"><span class="regexp">#安装Docker.dmg</span></span><br><span class="line"><span class="regexp">MOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \</span></span><br><span class="line"><span class="regexp">| awk '&#123;$1=$2=""; print $0&#125;'` | xargs -0 echo) \</span></span><br><span class="line"><span class="regexp">&amp;&amp; cd $&#123;MOUNTDIR&#125; &amp;&amp; cp -R Docker.app /</span>Applications/ \</span><br><span class="line">&amp;&amp; open /Applications/Docker.app</span><br></pre></td></tr></table></figure></p><h3 id="配置-Docker-加速器镜像源"><a href="#配置-Docker-加速器镜像源" class="headerlink" title="配置 Docker 加速器镜像源"></a>配置 Docker 加速器镜像源</h3><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">国内加速器</a><br>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></p><p>点击 Apply &amp; Restart 按钮使设置生效。</p><h3 id="安装主机监控程序加速器"><a href="#安装主机监控程序加速器" class="headerlink" title="安装主机监控程序加速器"></a>安装主机监控程序加速器</h3><hr><ol><li>登录到 <code>DaoCloud 控制台</code>，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。</li><li>安装<a href="https://github.com/docker/toolbox/releases/" target="_blank" rel="noopener">DockerToolbox</a>，是一个完整的开发组件，通过安装和配置<code>DaoCloud加速器 v2</code>，提升下载 <code>Docker Hub 镜像</code>的速度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//下载pkg</span><br><span class="line">curl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v18.09.0/DockerToolbox-18.09.0.pkg</span><br><span class="line">//安装pkg</span><br><span class="line">sudo installer -pkg DockerToolbox.pkg -target /</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li>安装Toolbox好了，下一步：<br><img src="http://docs.daocloud.io/user/pages/03.faq/08.install-docker-daocloud/DashboardDaoCloudInstall.png" alt></li><li><code>$ docker-machine start default</code>启动 Docker.<br>当执行后提示：<code>Host does not exist: &quot;default&quot;</code><figure class="highlight plain"><figcaption><span>docker-machine create</span><a href="http://stackoverflow.com/a/38602630" target="_blank" rel="noopener">stackoverflow</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox default</span><br></pre></td></tr></table></figure></li><li><p>在 <code>Docker 主机</code> DaoCloud 加速器的组件包：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL <span class="symbol">https:</span>/<span class="regexp">/get.daocloud.io/daomonit</span><span class="regexp">/install.sh | sh -s d0312f829e9807ee0bf157******</span></span><br></pre></td></tr></table></figure></li><li><p>启动组件包,会在「安装主机监控程序」的 DaoCloud 控制台页面下方显示一台已经接入的主机。</p></li><li>执行<code>Dao Pull</code>命令,高速下载<code>Docker Hub</code>镜像文件<br>这台 Docker 主机已经被接入 DaoCloud 平台，用户可以在 DaoCloud 控制台的「我的集群」页面发现这台主机，可以执行管理和部署应用的操作。</li></ol><h3 id="从Docker-Hub-仓库中获取一个镜像"><a href="#从Docker-Hub-仓库中获取一个镜像" class="headerlink" title="从Docker Hub 仓库中获取一个镜像"></a>从Docker Hub 仓库中获取一个镜像</h3><hr><p>Docker 使用类似 git 的方式管理镜像。通过基本的镜像可以定制创建出来不同种应用的 Docker 镜像。Docker Hub 是 Docker 官方提供的镜像中心。在这里可以很方便地找到各类应用、环境的镜像。由于 Docker 使用联合文件系统，所以镜像就像是夹心饼干一样一层层构成，相同底层的镜像可以共享。所以 Docker 还是相当节约磁盘空间的。要使用一 个镜像，需要先从远程的镜像注册中心拉取，这点非常类似 git。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure></p><h2 id="Docker-命令创建管理容器"><a href="#Docker-命令创建管理容器" class="headerlink" title="Docker 命令创建管理容器"></a>Docker 命令创建管理容器</h2><hr><h3 id="获取镜像的两种方式"><a href="#获取镜像的两种方式" class="headerlink" title="获取镜像的两种方式"></a>获取镜像的两种方式</h3><hr><h4 id="1-docker-pull命令"><a href="#1-docker-pull命令" class="headerlink" title="1. docker pull命令"></a>1. <code>docker pull</code>命令</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search perfectlysoft/ubuntu</span><br><span class="line">docker pull perfectlysoft/ubuntu</span><br></pre></td></tr></table></figure><h4 id="2-docker-import命令"><a href="#2-docker-import命令" class="headerlink" title="2. docker import命令"></a>2. <code>docker import</code>命令</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure><h3 id="通过镜像创建容器"><a href="#通过镜像创建容器" class="headerlink" title="通过镜像创建容器"></a>通过镜像创建容器</h3><hr><p>创建一个容器有两种方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create 镜像名</span><br><span class="line">docker run   镜像名   /<span class="regexp">/立即启动容器 等价于：create + start 命令组合</span></span><br></pre></td></tr></table></figure></p><p>进入容器终端控制台如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ec72dc76502e:/# ls</span><br><span class="line">app  boot  etc   lib    media  opt   root  sbin  sys  usr</span><br><span class="line">bin  dev   home  lib64  mnt    proc  run   srv   tmp  var</span><br></pre></td></tr></table></figure></p><h4 id="docker-run-images命令"><a href="#docker-run-images命令" class="headerlink" title="docker run images命令"></a><code>docker run images</code>命令</h4><ol><li><p>样例1<br>执行<code>run images</code>，并将 Ubuntu 的 Shell 作为入口，进入Docker容器环境操作</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it <span class="symbol">ubuntu:</span>latest sh -c <span class="string">'/bin/bash'</span></span><br></pre></td></tr></table></figure></li><li><p>样例2<br>执行<code>docker start -i 容器</code>命令进入容器环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start -i 容器ID/容器名</span><br></pre></td></tr></table></figure></li></ol><h4 id="从KitematicGUI进入容器环境"><a href="#从KitematicGUI进入容器环境" class="headerlink" title="从KitematicGUI进入容器环境"></a>从<code>Kitematic</code>GUI进入容器环境</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">"clear &amp;&amp; docker exec -it perfectswift sh"</span></span><br></pre></td></tr></table></figure><blockquote><p>参数<br>-i 表示这是一个交互容器，会把当前标准输入重定向到容器的标准输入中，而不是终止程序运行<br>-t 指为这个容器分配一个终端</p></blockquote><p>这时候我们成功创建了一个 Ubuntu 的容器，并将当前终端连接为这个 Ubuntu 的 bash shell。这时候就可以愉快地使用 Ubuntu 的相关命令了。</p><h3 id="ps-查看容器状态"><a href="#ps-查看容器状态" class="headerlink" title="ps 查看容器状态"></a>ps 查看容器状态</h3><hr><p>在容器运行期间，我们可以通过 <code>docker ps</code> 命令看到所有当前正在运行的容器。<br>添加-a参数可以看到所有创建的容器：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></p><h3 id="容器ID标识"><a href="#容器ID标识" class="headerlink" title="容器ID标识"></a>容器ID标识</h3><hr><p>每个容器都有一个唯一的 ID 标识，通过 ID 可以对这个容器进行管理和操作。在创建容器时，我们可以通过 –name 参数指定一个容器名称，如果没有指定系统将会分配一个，就像这里的「trusting_morse」。</p><h3 id="启动-退出-移除容器"><a href="#启动-退出-移除容器" class="headerlink" title="启动/退出/移除容器"></a>启动/退出/移除容器</h3><hr><p>启动：<code>start</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start -i trusting_morse</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：每次执行 docker run 命令都会创建新的容器，建议一次创建后，使用 docker start/stop 来启动和停用容器。</p></blockquote><p>退出：<br>按 <code>Ctrl+D</code> 退出</p><p>移除：<code>rm</code>ID/name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [CONTAINER ID/NAMES]</span><br></pre></td></tr></table></figure></p><p>重命名：<code>rename</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename 容器ID newName</span><br></pre></td></tr></table></figure></p><h2 id="创建管理镜像"><a href="#创建管理镜像" class="headerlink" title="创建管理镜像"></a>创建管理镜像</h2><hr><p>Docker 强大的威力在于可以把自己开发的应用随同各种依赖环境一起打包、分发、运行。要创建一个新的 Docker 镜像，通常基于一个已有的 Docker 镜像来创建。<br>Docker 提供了两种方式来创建镜像：</p><ol><li>把容器创建为一个新的镜像</li><li>使用 Dockerfile 创建镜像。</li></ol><h3 id="将容器创建为镜像"><a href="#将容器创建为镜像" class="headerlink" title="将容器创建为镜像"></a>将容器创建为镜像</h3><hr><ol><li><p>为了创建一个新的镜像，我们先创建一个新的容器作为基底：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it <span class="symbol">ubuntu:</span>latest sh -c <span class="string">'/bin/bash'</span></span><br></pre></td></tr></table></figure></li><li><p>定制这个容器，例如我们可以配置 PHP 环境、将我们的项目代码部署在里面等：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install php</span><br><span class="line"><span class="comment"># some other opreations ...</span></span><br></pre></td></tr></table></figure></li></ol><p>当执行完操作之后，我们按 Ctrl+D 退出容器.</p><ol start="3"><li><p>获取定制后的容器ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE                        COMMAND                    CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">cb2b06c83a50        ubuntu:latest                &quot;sh -c /bin/bash&quot;          7 minutes ago       Exited (0) 7 seconds ago                       trusting_morse</span><br></pre></td></tr></table></figure></li><li><p>执行<code>docker commit</code> 把这个容器变为一个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit cb2b06c83a50 ubuntu:myubuntu</span><br></pre></td></tr></table></figure></li></ol><p>这时候 docker 容器会被创建为一个新的 Ubuntu 镜像，版本名称为 myubuntu。以后我们可以随时使用这个镜像来创建容器了，新的容器将自动包含上面对容器的操作。    </p><ol start="5"><li><p>打包/发布镜像</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myubuntu.tar.gz <span class="symbol">ubuntu:</span>myubuntu</span><br></pre></td></tr></table></figure></li><li><p>导入打包镜像</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure></li></ol><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><hr><h4 id="通过Dockerfile创建镜像"><a href="#通过Dockerfile创建镜像" class="headerlink" title="通过Dockerfile创建镜像"></a>通过<code>Dockerfile</code>创建镜像</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build yourDir/Dockerfile</span><br></pre></td></tr></table></figure><blockquote><p>确保Dockerfile文件在一个目录中，否则会提示错误</p></blockquote><p>Docker Hub 提供了类似 GitHub 的镜像存管服务。一个镜像发布到 Docker Hub 不仅可以供更多人使用，而且便于镜像的版本管理。在一个企业内部可以通过自建 Docker Registry 的方式来统一管理和发布镜像。将 Docker Registry 集成到版本管理和上线发布的工作流之中，还有许多工作要做，在我整理出最佳实践后会第一时间分享。<br>使用命令行的方式创建 Docker 镜像通常难以自动化操作。在更多的时候，我们使用 Dockerfile 来创建 Docker 镜像。Dockerfile 是一个纯文本文件，它记载了从一个镜像创建另一个新镜像的步骤。撰写好 Dockerfile 文件之后，我们就可以轻而易举的使用 docker build 命令来创建镜像了。<br>Dockerfile 非常简单，仅有以下命令在 Dockerfile 中常被使用：</p><table><thead><tr><th style="text-align:right">命令</th><th style="text-align:right">参数</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td style="text-align:right">#</td><td style="text-align:right">-</td><td style="text-align:right">注释说明</td></tr><tr><td style="text-align:right">FROM</td><td style="text-align:right"><image>[:<tag>]</tag></image></td><td style="text-align:right">从一个已有镜像创建，例如ubuntu:latest</td></tr><tr><td style="text-align:right">MAINTAINER</td><td style="text-align:right">Author <a href="mailto:&#x73;&#x6f;&#x6d;&#101;&#x2d;&#x6f;&#110;&#x65;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x73;&#x6f;&#x6d;&#101;&#x2d;&#x6f;&#110;&#x65;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td><td style="text-align:right">镜像作者名字，如Max Liu <a href="mailto:&#x73;&#111;&#109;&#101;&#x2d;&#x6f;&#110;&#x65;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x73;&#111;&#109;&#101;&#x2d;&#x6f;&#110;&#x65;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a></td></tr><tr><td style="text-align:right">RUN</td><td style="text-align:right"><cmd>或者[‘cmd1’, ‘cmd2’…]</cmd></td><td style="text-align:right">在镜像创建用的临时容器里执行单行命令</td></tr><tr><td style="text-align:right">ADD</td><td style="text-align:right"><src> <dest></dest></src></td><td style="text-align:right">将本地的<src>添加到镜像容器中的<dest>位置</dest></src></td></tr><tr><td style="text-align:right">VOLUME</td><td style="text-align:right"><path>或者[‘/var’, ‘home’]</path></td><td style="text-align:right">将指定的路径挂载为数据卷</td></tr><tr><td style="text-align:right">EXPOSE</td><td style="text-align:right"><port> [<port>…]</port></port></td><td style="text-align:right">将指定的端口暴露给主机</td></tr><tr><td style="text-align:right">ENV</td><td style="text-align:right"><key> <value> 或者 <key> = <value></value></key></value></key></td><td style="text-align:right">指定环境变量值</td></tr><tr><td style="text-align:right">CMD</td><td style="text-align:right">[“executable”,”param1”,”param2”]</td><td style="text-align:right">容器启动时默认执行的命令。注意一个Dockerfile中只有最后一个CMD生效。</td></tr><tr><td style="text-align:right">ENTRYPOINT</td><td style="text-align:right">[“executable”, “param1”, “param2”]</td><td style="text-align:right">容器的进入点</td></tr></tbody></table><h4 id="配置Dockerfile"><a href="#配置Dockerfile" class="headerlink" title="配置Dockerfile"></a>配置Dockerfile</h4><hr><p>下面是一个 Dockerfile 的例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line">FROM <span class="symbol">ubuntu:</span><span class="number">14.04</span></span><br><span class="line">MAINTAINER Kate Smith &lt;ksmith@example.com&gt;</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev</span><br><span class="line">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p><h5 id="CMD命令"><a href="#CMD命令" class="headerlink" title="CMD命令"></a><code>CMD</code>命令</h5><hr><p><code>CMD</code>: 命令可用指定 Docker 容器启动时默认的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:latest sh -c &apos;/bin/bash&apos;</span><br></pre></td></tr></table></figure></p><p>其中 <code>sh -c &#39;/bin/bash&#39;</code> 就是手工指定的<code>CMD</code>,否则容器将会使用默认 <code>CMD</code> 指定的命令启动。</p><h5 id="ENTRYPOINT命令"><a href="#ENTRYPOINT命令" class="headerlink" title="ENTRYPOINT命令"></a><code>ENTRYPOINT</code>命令</h5><hr><p>用来指定可执行文件、Shell 脚本，同时会并把启动参数或 CMD 指定的默认值，当作附加参数传递给 执行文件、Shell 脚本。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">'/usr/bin/mysql'</span>]</span><br><span class="line">CMD [<span class="string">'-h 192.168.100.128'</span>, <span class="string">'-p'</span>]</span><br></pre></td></tr></table></figure></p><p>执行mysql启动程序，连接<code>192.168.100.128</code> 主机,也可以通过指定参数，来连接别的主机。</p><p>因此，我们在使用 Dockerfile 创建文件的时候，可以创建一个 entrypoint.sh 脚本，作为系统入口。在这个文件里面，我们可以进行一些基础性的自举操作，比如检查环境变量，根据需要初始化数据库等等。下面两个文件是我在日常工作的项目中添加的 Dockerfile 和 entrypoint.sh，仅供参考：<br><a href="https://github.com/starlight36/SimpleOA/blob/master/Dockerfile" target="_blank" rel="noopener">https://github.com/starlight36/SimpleOA/blob/master/Dockerfile</a><br><a href="https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh" target="_blank" rel="noopener">https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh</a><br>在准备好 Dockerfile 之后，我们就可以创建镜像了：</p><h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t starlight36/simpleoa .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hackmd使用</title>
      <link href="/2016/12/21/hexo/hackmd%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/12/21/hexo/hackmd%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="編輯"><a href="#編輯" class="headerlink" title="編輯"></a>編輯</h1><h2 id="快速鍵"><a href="#快速鍵" class="headerlink" title="快速鍵"></a>快速鍵</h2><p>跟又快又方便的Sublime text很像</p><blockquote><p>更多訊息請至 <a href="https://codemirror.net/demo/sublime.html" target="_blank" rel="noopener">這裡</a></p></blockquote><h2 id="自動完成"><a href="#自動完成" class="headerlink" title="自動完成"></a>自動完成</h2><p>提供完整的 Markdown 自動完成與提示</p><ul><li>表情符號：輸入 <code>:</code> 顯示提示</li><li>程式碼區塊：輸入 <code>3个</code> ` 加上一個字元 顯示提示 </li><li>標頭：輸入 <code>#</code> 顯示提示</li><li>參考：輸入 <code>[]</code> 顯示提示</li><li>外部：輸入 <code>{}</code> 顯示提示</li><li>圖片：輸入 <code>!</code> 顯示提示</li></ul><h2 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h2><p>會使用 <strong>第一個第一級標頭</strong> 作為筆記標題</p><h2 id="標籤"><a href="#標籤" class="headerlink" title="標籤"></a>標籤</h2><p>如同以下方式來使用標籤，它們會顯示在您的 <strong>歷史紀錄</strong></p><h6 id="tags-功能-酷-更新"><a href="#tags-功能-酷-更新" class="headerlink" title="tags: 功能 酷 更新"></a>tags: <code>功能</code> <code>酷</code> <code>更新</code></h6><h2 id="YAML-metadata"><a href="#YAML-metadata" class="headerlink" title="YAML metadata"></a><a href="./yaml-metadata">YAML metadata</a></h2><p>提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結</p><ul><li>robots: 設定網路機器人 meta</li><li>lang: 設定瀏覽器顯示語言</li><li>dir: 設定文字方向</li><li>breaks: 設定是否使用分行</li><li>mathjax: 設定是否使用 mathjax</li></ul><h2 id="表情符號"><a href="#表情符號" class="headerlink" title="表情符號"></a>表情符號</h2><p>您可以像是這樣使用表情符號 :smile: :smiley: :cry: :wink:</p><blockquote><p>完整的表情符號列表 <a href="http://www.emoji-cheat-sheet.com/" target="_blank" rel="noopener">在這裡</a></p></blockquote><h2 id="待辦清單"><a href="#待辦清單" class="headerlink" title="待辦清單"></a>待辦清單</h2><ul><li>[ ] 待辦<ul><li>[x] 買些沙拉</li><li>[x] 刷牙</li><li>[ ] 喝水<a id="more"></a><h2 id="程式碼區塊"><a href="#程式碼區塊" class="headerlink" title="程式碼區塊"></a>程式碼區塊</h2>我們支援非常多程式語言，使用自動完成來看看有些什麼<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript syntax highlighting"</span>;</span><br><span class="line">alert(s);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$initHighlight</span>(<span class="params">block, cls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls.search(<span class="regexp">/\bno\-highlight\b/</span>) != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> process(block, <span class="literal">true</span>, <span class="number">0x0F</span>) + </span><br><span class="line">             <span class="string">' class=""'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/* handle exception */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> / <span class="number">2</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkCondition(classes[i]) === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/\d+[\s/]/g</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>如果想要 <strong>行號</strong>，在表明程式語言之後輸入 <code>=</code><br>您也可以指定開始行號，如下所示，行號從101開始</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript syntax highlighting"</span>;</span><br><span class="line">alert(s);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$initHighlight</span>(<span class="params">block, cls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls.search(<span class="regexp">/\bno\-highlight\b/</span>) != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> process(block, <span class="literal">true</span>, <span class="number">0x0F</span>) + </span><br><span class="line">             <span class="string">' class=""'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/* handle exception */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> / <span class="number">2</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkCondition(classes[i]) === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/\d+[\s/]/g</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或是可以接續上一個程式碼區塊的行號，使用 <code>=+</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript syntax highlighting"</span>;</span><br><span class="line">alert(s);</span><br></pre></td></tr></table></figure><h2 id="引用區塊標籤"><a href="#引用區塊標籤" class="headerlink" title="引用區塊標籤"></a>引用區塊標籤</h2><blockquote><p>您可以使用以下語法，表明自己的 <strong>姓名、時間與顏色</strong> 並與其他的引用區塊做區別<br>[name=ChengHan Wu] [time=Sun, Jun 28, 2015 9:59 PM] [color=#907bf7]</p><blockquote><p>也支援巢狀引用區塊喔！<br>[name=ChengHan Wu] [time=Sun, Jun 28, 2015 10:00 PM] [color=red]</p></blockquote></blockquote><h2 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h2><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><div class="video-container"><iframe src="//www.youtube.com/embed/1G4isv_Fylg" frameborder="0" allowfullscreen></iframe></div><h3 id="Vimeo"><a href="#Vimeo" class="headerlink" title="Vimeo"></a>Vimeo</h3><div class="video-container"><iframe src="//player.vimeo.com/video/124148255" frameborder="0" allowfullscreen></iframe></div><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><script src="//gist.github.com/schacon/4277.js"></script><h3 id="SlideShare"><a href="#SlideShare" class="headerlink" title="SlideShare"></a>SlideShare</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%slideshare briansolis/<span class="number">26</span>-disruptive-technology-trends<span class="number">-2016</span><span class="number">-2018</span><span class="number">-56796196</span> %&#125;</span><br></pre></td></tr></table></figure><h3 id="Speakerdeck"><a href="#Speakerdeck" class="headerlink" title="Speakerdeck"></a>Speakerdeck</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%speakerdeck sugarenia/xxlcss-how-to-scale-css-and-keep-your-sanity %&#125;</span><br></pre></td></tr></table></figure><h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><p><strong>注意：請使用 https 的網址，否則可能會被您的瀏覽器阻擋載入</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%pdf https:<span class="comment">//papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf %&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p>您可以使用 <strong>MathJax</strong> 語法 來產生 <em>LaTeX</em> 數學表達式，如同 <a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>：</p><p>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p><p>$$<br>x = {-b \pm \sqrt{b^2-4ac} \over 2a}.<br>$$</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p><blockquote><p>更多關於 <strong>LaTeX</strong> 數學表達式 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">請至這裡</a></p></blockquote><h2 id="UML-圖表"><a href="#UML-圖表" class="headerlink" title="UML 圖表"></a>UML 圖表</h2><h3 id="循序圖"><a href="#循序圖" class="headerlink" title="循序圖"></a>循序圖</h3><p>您可以像是以下使用循序圖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">艾莉絲-&gt;包柏: 哈摟，你好嗎？</span><br><span class="line">Note right of 包柏: 包柏思考中</span><br><span class="line">包柏--&gt;艾莉絲: 我很好，謝謝！</span><br><span class="line">Note left of 艾莉絲: 艾莉絲回應</span><br><span class="line">艾莉絲-&gt;包柏: 最近過得怎樣？</span><br></pre></td></tr></table></figure><h3 id="流程圖"><a href="#流程圖" class="headerlink" title="流程圖"></a>流程圖</h3><p>您可以像是以下使用流程圖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 開始</span><br><span class="line">e=&gt;end: 結束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">op2=&gt;operation: 啦啦啦</span><br><span class="line">cond=&gt;condition: 是或否？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;op2-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op2</span><br></pre></td></tr></table></figure></p><h3 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">digraph hierarchy &#123;</span><br><span class="line"></span><br><span class="line">                nodesep=1.0 // increases the separation between nodes</span><br><span class="line">                </span><br><span class="line">                node [color=Red,fontname=Courier,shape=box] //All nodes will this shape and colour</span><br><span class="line">                edge [color=Blue, style=dashed] //All the lines look like this</span><br><span class="line"></span><br><span class="line">                Headteacher-&gt;&#123;Deputy1 Deputy2 BusinessManager&#125;</span><br><span class="line">                Deputy1-&gt;&#123;Teacher1 Teacher2&#125;</span><br><span class="line">                BusinessManager-&gt;ITManager</span><br><span class="line">                &#123;rank=same;ITManager Teacher1 Teacher2&#125;  // Put them on the same level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line"></span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    anther task      : 24d</span><br></pre></td></tr></table></figure><blockquote><p>更多關於 <strong>循序圖</strong> 語法 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">在這裡</a>.<br>更多關於 <strong>流程圖</strong> 語法 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">在這裡</a>.<br>更多關於 <strong>Graphviz</strong> 語法 <a href="http://www.tonyballantyne.com/graphs.html" target="_blank" rel="noopener">在這裡</a><br>更多關於 <strong>Mermaid</strong> 語法 <a href="http://knsv.github.io/mermaid" target="_blank" rel="noopener">在這裡</a></p></blockquote><h2 id="警告區塊"><a href="#警告區塊" class="headerlink" title="警告區塊"></a>警告區塊</h2><p>:::success<br>耶 :tada:<br>:::</p><p>:::info<br>這是訊息 :mega:<br>:::</p><p>:::warning<br>注意 :zap:<br>:::</p><p>:::danger<br>喔不 :fire:<br>:::</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="標頭"><a href="#標頭" class="headerlink" title="標頭"></a>標頭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1 標頭</span><br><span class="line">## h2 標頭</span><br><span class="line">### h3 標頭</span><br><span class="line">#### h4 標頭</span><br><span class="line">##### h5 標頭</span><br><span class="line">###### h6 標頭</span><br></pre></td></tr></table></figure><h3 id="水平分隔線"><a href="#水平分隔線" class="headerlink" title="水平分隔線"></a>水平分隔線</h3><hr><hr><hr><h3 id="字形替換"><a href="#字形替換" class="headerlink" title="字形替換"></a>字形替換</h3><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>測試.. 測試… 測試….. 測試?….. 測試!….</p><p>!!!!!! ???? ,,</p><p>Remarkable – awesome</p><p>“Smartypants, 雙引號”</p><p>‘Smartypants, 單引號’</p><h3 id="強調"><a href="#強調" class="headerlink" title="強調"></a>強調</h3><p><strong>這是粗體文字</strong></p><p><strong>這是粗體文字</strong></p><p><em>這是斜體文字</em></p><p><em>這是斜體文字</em></p><p><del>這是刪除文字</del></p><p>上標： 19^th^</p><p>下標： H~2~O</p><p>++這是底線文字++</p><p>==這是標記文字==</p><h3 id="引用區塊"><a href="#引用區塊" class="headerlink" title="引用區塊"></a>引用區塊</h3><blockquote><p>引用區塊也可以是巢狀的喔…</p><blockquote><p>…可以多層次的使用…</p><blockquote><p>…或是用空白隔開 </p></blockquote></blockquote></blockquote><h3 id="清單"><a href="#清單" class="headerlink" title="清單"></a>清單</h3><h4 id="項目"><a href="#項目" class="headerlink" title="項目"></a>項目</h4><ul><li>在行開頭使用 <code>+</code> <code>-</code> 或是 <code>*</code> 來建立清單</li><li>空兩個空白就可以產生子清單<ul><li>當清單標記使用的字元不同，會強制建立新的清單<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>非常簡單！</li></ul><h4 id="編號"><a href="#編號" class="headerlink" title="編號"></a>編號</h4><ol><li>Lorem ipsum dolor sit amet</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><ol><li>您可以逐次增加項目數字…</li><li>…或是全部都使用 <code>1.</code></li><li>feafw</li><li>332</li><li>242</li><li>2552</li><li>e2</li></ol><p>從其他範圍開始編號清單</p><ol start="57"><li>foo</li><li>bar</li></ol><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><p>行內 <code>程式碼</code></p><p>縮排程式碼</p><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><p>程式碼區塊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure><p>語法標色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>選項</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td>ext</td><td>extension to be used for dest files.</td></tr></tbody></table><p>向右對齊</p><table><thead><tr><th style="text-align:right">選項</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:right">data</td><td style="text-align:right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:right">engine</td><td style="text-align:right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:right">ext</td><td style="text-align:right">extension to be used for dest files.</td></tr></tbody></table><p>向左對齊</p><table><thead><tr><th style="text-align:left">選項</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">data</td><td style="text-align:left">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:left">engine</td><td style="text-align:left">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:left">ext</td><td style="text-align:left">extension to be used for dest files.</td></tr></tbody></table><p>置中對齊</p><table><thead><tr><th style="text-align:center">選項</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">data</td><td style="text-align:center">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:center">engine</td><td style="text-align:center">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:center">ext</td><td style="text-align:center">extension to be used for dest files.</td></tr></tbody></table><h3 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h3><p><a href="http://dev.nodeca.com" target="_blank" rel="noopener">連結文字</a><br><a href="http://nodeca.github.io/pica/demo/" title="標題文字！" target="_blank" rel="noopener">加上標題的連結文字</a><br>自動轉換連結 <a href="https://github.com/nodeca/pica" target="_blank" rel="noopener">https://github.com/nodeca/pica</a></p><h3 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h3><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"><br>如同連結一般，圖片也可以用註腳語法<br><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"><br>使用參考，可以在稍後的文件中再定義圖片網址</p><p><img src="https://octodex.github.com/images/minion.png =200x200" alt="Minion"><br>使用指定的大小顯示圖片</p><h3 id="註腳"><a href="#註腳" class="headerlink" title="註腳"></a>註腳</h3><p>註腳 1 連結[^first].<br>註腳 2 連結[^second].<br>行內註腳^[行內註腳的文字] 定義<br>重複的註腳參考[^second].</p><p>[^first]: 註腳 <strong>也可以標記</strong><br>    還可以有很多段落<br>[^second]: 註腳 文字</p><h3 id="定義清單"><a href="#定義清單" class="headerlink" title="定義清單"></a>定義清單</h3><p>名詞 1</p><p>:   定義 1 快速連續項目</p><p>名詞 2 加上 <em>行內標記</em></p><p>:   定義 2</p><pre><code>    { 這些程式碼屬於 定義 2 的一部分 }定義 2 的第三段落</code></pre><p><em>緊密樣式：</em></p><p>名詞 1<br>  ~ 定義 1</p><p>名詞 2<br>  ~ 定義 2a<br>  ~ 定義 2b</p><h3 id="縮寫"><a href="#縮寫" class="headerlink" title="縮寫"></a>縮寫</h3><p>這是 HTML 的縮寫範例<br>它會轉換 “HTML”，但是縮寫旁邊其他的部分，例如：”xxxHTMLyyy”，不受影響</p><p>*[HTML]: Hyper Text Markup Language</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-hello-world</title>
      <link href="/2016/12/21/hexo/Hexo-hello-world/"/>
      <url>/2016/12/21/hexo/Hexo-hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 <code>Node.js</code> 的最佳方式是使用 <code>nvm</code>,或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">node.js安装包</a>来安装。</p><ol><li>安装<code>nvm</code><br>方式一：cURL命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></li></ol><p>方式二：linux方法Wget命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><ol start="2"><li>更新npm命令工具至最新版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>为了便于在多台电脑上部署博客，可以使用使用git版本库来管理个人博客的内容：<br>具体部署过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://xxxxx/boyer.git boyer</span><br><span class="line">cd boyer</span><br><span class="line">npm install  #安装package.json是插件包，使用git管理更加便于管理安装的完整性。</span><br></pre></td></tr></table></figure></p><p>新建完成后，指定文件夹的目录如下：<br>    .<br>    ├── _config.yml     # 网站的 配置 信息，您可以在此配置大部分的参数。<br>    ├── package.json    # 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装。<br>    ├── scaffolds       # 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>    ├── source<br>    |   ├── _drafts<br>    |   └── _posts<br>    └── themes</p><ol><li><p>scaffolds<br>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p></li><li><p>source<br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></li><li>themes<br>主题 文件夹。Hexo 会根据主题来生成静态页面。</li></ol><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"草稿名"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish <span class="string">"草稿名"</span>  <span class="comment">#Moves a draft post from _drafts to _posts folder.</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>在我们开始之前,你必须在 <code>_config.yml</code> 修改设置。一个有效的部署设置必须有 <code>type</code> 字段。例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br></pre></td></tr></table></figure></p><p>你可用同时部署到多个type，Hexo将依次执行每个部署。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    - <span class="built_in">type</span>: git</span><br><span class="line">      repo:</span><br><span class="line">    - <span class="built_in">type</span>: heroku</span><br><span class="line">      repo:</span><br></pre></td></tr></table></figure></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="安装同步到git-插件"><a href="#安装同步到git-插件" class="headerlink" title="安装同步到git 插件"></a>安装同步到git 插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code>设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repo: &lt;repository url&gt;</span><br><span class="line">    branch: [branch]</span><br><span class="line">    message: [message]</span><br></pre></td></tr></table></figure></p><h4 id="安装生成RSS支持插件"><a href="#安装生成RSS支持插件" class="headerlink" title="安装生成RSS支持插件"></a>安装生成RSS支持插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install  hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code>设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">    <span class="built_in">type</span>: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    <span class="built_in">limit</span>: 20</span><br><span class="line">    hub:</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发-一</title>
      <link href="/2016/12/20/%E5%85%B6%E4%BB%96/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E4%B8%80/"/>
      <url>/2016/12/20/%E5%85%B6%E4%BB%96/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>我们需要通过<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html?t=20161122" target="_blank" rel="noopener">开发者工具</a>，来完成小程序创建和代码编辑。</p><p>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。</p><p>为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。</p><p>项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>点击开发者工具左侧导航的“编辑”，看到这个项目文件结构。</p><p>三个必不可少的<code>app.js、app.json、app.wxss</code>:</p><ul><li><code>.js</code>后缀的是脚本文件</li><li><code>.json</code>后缀的文件是配置文件</li><li><code>.wxss</code>后缀的是样式表文件</li></ul><p>微信小程序会读取这些文件，并生成小程序实例。<br><a id="more"></a></p><h4 id="app-js脚本代码"><a href="#app-js脚本代码" class="headerlink" title="app.js脚本代码"></a>app.js脚本代码</h4><p>app.json 是对整个小程序的全局配置。 可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</p><blockquote><p>调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。想了解更多可用 API，可参考 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161122" target="_blank" rel="noopener">API 文档</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//调用API从本地缓存中获取数据</span></span><br><span class="line">    <span class="keyword">var</span> logs = wx.getStorageSync(<span class="string">'logs'</span>) || []</span><br><span class="line">    logs.unshift(<span class="built_in">Date</span>.now())</span><br><span class="line">    wx.setStorageSync(<span class="string">'logs'</span>, logs)</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo:<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.globalData.userInfo)&#123;</span><br><span class="line">      <span class="keyword">typeof</span> cb == <span class="string">"function"</span> &amp;&amp; cb(<span class="keyword">this</span>.globalData.userInfo)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//调用登录接口</span></span><br><span class="line">      wx.login(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">              that.globalData.userInfo = res.userInfo;</span><br><span class="line">              <span class="keyword">typeof</span> cb == <span class="string">"function"</span> &amp;&amp; cb(that.globalData.userInfo)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData:&#123;</span><br><span class="line">    userInfo:<span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="app-json-全局配置"><a href="#app-json-全局配置" class="headerlink" title="app.json 全局配置"></a>app.json 全局配置</h4><p>可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>:[</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>:&#123;</span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>:<span class="string">"light"</span>,</span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"WeChat"</span>,</span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>:<span class="string">"black"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意该文件不可添加任何注释。更多配置可参考<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=20161122" target="_blank" rel="noopener">配置详解</a></p></blockquote><h4 id="app-wxss-公共样式表"><a href="#app-wxss-公共样式表" class="headerlink" title="app.wxss 公共样式表"></a>app.wxss 公共样式表</h4><p>我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**app.wxss**/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">200</span>rpx <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>在这个教程里，我们有两个页面，index 欢迎页和 logs 小程序启动日志的展示页，他们都在 pages 目录下。</p><p>微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p><p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成:</p><ul><li>.js后缀的文件是脚本文件</li><li>.json后缀的文件是配置文件（非必须）</li><li>.wxss后缀的是样式表文件（非必须）</li><li>.wxml后缀的文件是页面结构文件  </li></ul><h4 id="index-wxml页面结构："><a href="#index-wxml页面结构：" class="headerlink" title="index.wxml页面结构："></a>index.wxml页面结构：</h4><p>使用了<code>&lt;view/&gt;、&lt;image/&gt;、&lt;text/&gt;</code>来搭建页面结构(container)，绑定数据(userInfo)和交互处理函数(bindViewTap)。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--index.wxml--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">view</span>  <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;image class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="code">    &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h4 id="index-js脚本文件"><a href="#index-js脚本文件" class="headerlink" title="index.js脚本文件"></a>index.js脚本文件</h4><p>在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">var</span> app = getApp()</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">'Hello World'</span>,</span><br><span class="line">    userInfo: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//事件处理函数</span></span><br><span class="line">  bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: <span class="string">'../logs/logs'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onLoad'</span>)</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">//调用应用实例的方法获取全局数据</span></span><br><span class="line">    app.getUserInfo(<span class="function"><span class="keyword">function</span>(<span class="params">userInfo</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//更新数据</span></span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        userInfo:userInfo</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="index-wxss样式表"><a href="#index-wxss样式表" class="headerlink" title="index.wxss样式表"></a>index.wxss样式表</h4><ol><li>页面的样式表是非必要的,该样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。</li><li>页面的结构文件中可以直接使用 app.wxss 中指定的样式规则。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line"><span class="selector-class">.userinfo</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.userinfo-avatar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">128</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">128</span>rpx;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.userinfo-nickname</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.usermotto</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="index-json配置文件"><a href="#index-json配置文件" class="headerlink" title="index.json配置文件"></a>index.json配置文件</h4><p>页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p><h3 id="logs-的页面"><a href="#logs-的页面" class="headerlink" title="logs 的页面"></a>logs 的页面</h3><h4 id="logs-wxml页面结构"><a href="#logs-wxml页面结构" class="headerlink" title="logs.wxml页面结构"></a>logs.wxml页面结构</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--logs.wxml--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container log-list"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;logs&#125;&#125;"</span> <span class="attr">wx:for-item</span>=<span class="string">"log"</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;text class="log-item"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="logs-js脚本文件"><a href="#logs-js脚本文件" class="headerlink" title="logs.js脚本文件"></a>logs.js脚本文件</h4><p>logs 页面使用 <code>&lt;block/&gt;</code> 控制标签来组织代码，在 <code>&lt;block/&gt;</code> 上使用 <code>wx:for</code> 绑定 logs 数据，并将 logs 数据循环展开节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logs.js</span></span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'../../utils/util.js'</span>)</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    logs: []</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      logs: (wx.getStorageSync(<span class="string">'logs'</span>) || []).map(<span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> util.formatTime(<span class="keyword">new</span> <span class="built_in">Date</span>(log))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">运行结果如下：</span><br></pre></td></tr></table></figure></p><h3 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h3><p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/start_result.png?t=20161122" alt></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTD任务清单整理技巧</title>
      <link href="/2016/01/08/%E5%AF%BC%E5%9B%BE/GTD%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7/"/>
      <url>/2016/01/08/%E5%AF%BC%E5%9B%BE/GTD%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>什么是GTD？<br>GTD 的基本理论是把一个人所要要完成的任务和事件全部从大脑中移出来，记录到纸上。这样，大脑便会不被多余的事情打搅而集中于现在所需完成的事情上面。</p><h2 id="GTD守则："><a href="#GTD守则：" class="headerlink" title="GTD守则："></a>GTD守则：</h2><pre><code>收集任务  设置每天最重要的任务  （把所有你需要做的和需要完成的事情全部记录下来，放在一个“收集箱”里）  ↓  过程  （每次按照顺序，一次只做一件事）  ↓  管理任务  （列出有详细内容的to-do列表）  ↓  复习任务   （复习你所有完成的任务，计划方案和等待完成的事情。确保每一件新进入的任务都有很好的安排）  ↓  开始行动！  </code></pre><h3 id="建立有强行动性的任务清单"><a href="#建立有强行动性的任务清单" class="headerlink" title="建立有强行动性的任务清单"></a>建立有强行动性的任务清单</h3><p>任务清单（To-do List）的重要性毋庸置疑，建立有强行动性的任务清单可以让你更清楚地明白自己需要完成的任务，同时还保持了你去完成任务的激情和动力。</p><ol><li>分解任务：就像走远路时，以每一段路程为目标，让人更有动力去追求一样。如果你要阅读一本书，便可以将任务分成“读完第一章”，“读完第二章”等等。</li><li>使用有力的动词：比如说联系某个人，就要写上“给某某打电话”或者“发邮件给某某”而不是写“联系某某”。</li><li>有限的清单：谁都不希望有一张写满几大页的任务清单，你需要找出那些有强动力的行动。</li><li>清理已完成的任务：已完成的任务要及时清理，否者会阻碍你的下一步行动任务。<!--nore--></li></ol><h2 id="7W3H"><a href="#7W3H" class="headerlink" title="7W3H"></a>7W3H</h2><p>7W3H是一个用于项目规划和管理的专业术语。公司管理者邀请相关员工一起进行分析讨论，按照7W3H进行各述己见，收集、归纳、再收集、再归纳，这样一种互动、发散性思维的工作方法极大调动下属员工的积极性、责任感。否则，公司管理者单方面出台项目计划，对下属员工解释耗费时力不说，项目计划的有效性、完善性、可行性也都可能存在质疑。</p><h3 id="7W"><a href="#7W" class="headerlink" title="7W"></a>7W</h3><pre><code>what 指目标与内容，包括主体，目标，机能，性能等why 指原因，包括任务，期望，背景，技术等who 指人员，包括制造，行销，流通，负责的主体等where 指地点类，包括 环境，市场，区域，渠道等when 指时间，包括期限，时机，预期等whom 买家，消费者，接收者which 附属品</code></pre><h3 id="3H"><a href="#3H" class="headerlink" title="3H"></a>3H</h3><pre><code>how to 如何做，指方式和手段，包括集体方案，详实计划，战略方针how much 价格成本，投入产出，综效成果how many 负面效益，各种量（问题，业务，工作）</code></pre><h3 id="案例6W1H"><a href="#案例6W1H" class="headerlink" title="案例6W1H"></a>案例6W1H</h3><p>截自《5个图表解决12大难题》</p><h2 id="十二个赛博学习问题"><a href="#十二个赛博学习问题" class="headerlink" title="十二个赛博学习问题"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&amp;mid=403475231&amp;idx=1&amp;sn=bbf21f2e37e91fc10d1a48285e8abefd&amp;scene=23&amp;srcid=0115194ziliaGGBscdYC3N0d#rd" target="_blank" rel="noopener">十二个赛博学习问题</a></h2><p>赛博学习法是一种动态的学习过程，在这个过程中你（不是你的老师，也不是某些教科书的作者）会掌握控制权，成为你自己教育的“引航员”。<br>这种方法的第一步是对话：你会针对正在学习的材料，提出一系列具体的问题。慢慢地，通过信息的整理和再整理，以及在新材料与你学过的知识之间建立新的联系，你将真正理解材料。<br>用这种方法改进你的笔记，只要回答12个问题就能掌握科教书的要点：</p><h2 id="个人常用的工具类"><a href="#个人常用的工具类" class="headerlink" title="个人常用的工具类"></a>个人常用的工具类</h2>]]></content>
      
      
      <categories>
          
          <category> 导图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 逻辑思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git svn桥接命令的基础</title>
      <link href="/2016/01/05/git/gitsvn%E6%A1%A5%E6%8E%A5%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/01/05/git/gitsvn%E6%A1%A5%E6%8E%A5%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://git-scm.com/book/zh/v1/Git-与其他系统-Git-与-Subversion#git-svn" target="_blank" rel="noopener">git svn</a></p><p>通过几个简单的工作流程了解到<code>git svn</code>常见命令：<br>值得警戒的是，在使用 git svn 的时候，你实际是在与 Subversion 交互，Git 比它要高级复杂的多。尽管可以在本地随意的进行分支和合并，最好还是通过衍合保持线性的提交历史，</p><ol><li>尽量避免类似与远程 Git 仓库动态交互这样的操作。</li><li>避免修改历史再重新推送的做法，也不要同时推送到并行的 Git 仓库来试图与其他 Git 用户合作。</li><li>Subersion 只能保存单一的线性提交历史，一不小心就会被搞糊涂。</li><li>合作团队中同时有人用 SVN 和 Git，一定要确保所有人都使用 SVN 服务来协作——这会让生活轻松很多。</li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015年12月22日冬至-圣诞节最新中关村骗术</title>
      <link href="/2015/12/26/%E5%85%B6%E4%BB%96/2015%E5%B9%B412%E6%9C%8822%E6%97%A5%E5%86%AC%E8%87%B3-%E5%9C%A3%E8%AF%9E%E8%8A%82%E6%9C%80%E6%96%B0%E4%B8%AD%E5%85%B3%E6%9D%91%E9%AA%97%E6%9C%AF/"/>
      <url>/2015/12/26/%E5%85%B6%E4%BB%96/2015%E5%B9%B412%E6%9C%8822%E6%97%A5%E5%86%AC%E8%87%B3-%E5%9C%A3%E8%AF%9E%E8%8A%82%E6%9C%80%E6%96%B0%E4%B8%AD%E5%85%B3%E6%9D%91%E9%AA%97%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>被骗经过:<br>12月22号，本人午饭后拿着64G苹果6去中关村解锁，维修师傅说因为是日版内置卡贴机，加上系统已经升级ios9.2，就算拆机去除卡贴，再配上市面上的卡贴卡托也只能使用移动2G网络而且网络很不稳定的说法，再检测我手机质量后，开始让我以旧换新，并承诺加五百元就换一台他们店售卖的全新64G国行苹果6，我信以为真，在他们带领下，仅仅看到他们提供的白色包装盒，她们只说是国行全新机，其他没做任何说明，便刷去我500元整，并写下小条让我签字，我当时要求当场拆封查看真机，他们推辞说还需办理其它手续，就差人把白色包装盒拿走了，让我耐心等候便带我到另一间休息室里，她说需要我手机卡去帮我激活他们所说的全新苹果6，让我拔卡给她，没有争取我的同意，就要伸手帮我拔卡，只能拔卡给她，接着安排了一人陪我，拿着我的卡离开了休息室。</p><p>和这人闲聊一会便要看我刚才换机的小票，当他看到“专网”字样，起初对我说只能用4G网络，没有4G信号的话手机会自动进入休眠状态，无法接打电话，必须用他们所说的4G卡否则手机就无法开机使用。听到这，我就要求取消交易，在他打了一通电话百般为难的说，工作人员在排队等待办理激活手续了，已经无法取消，只能等。一番焦急等待后，仍不见人拿手机过来，已经意识到被骗，本想报案，手机卡已经被他们拿走，一个人没底没落完全崩溃，后来又听他说在专网手机上下载应用还必须绑定银行账号，每下载一个APP就要收取高额费用，一个QQ就要扣除70多元，估算一年下来最低消费就要达万元，我追问到如果办理不使用这部手机会怎么样，他说和服务商绑定后，达不到最低消费，手机号就会被锁定，火车票都买不到，我完全慌了，只能央求他任何条件帮忙。</p><p>他就让购买他的苹果5s，否则不会打电话让他们取消上一个被蒙骗的交易，拿不到我的手机卡，并承诺说购买他提供的机型是国行全新iPhone5s，支持全网，系统随便升级，下载APP不收任何费用，如果发现有任何问题，全额退款。当场就在先前的小票背面写了字据作保证。换购就让我把日版苹果6抵算1500元再加1900元，换购他所说的全新国行iPhone5s，当时心理已经感受到威胁恐吓，急于脱身，只想早点拿回手机卡，不得不任他们摆布，威逼利诱再次被刷走1900元整。</p><p>当拿到他拿到我的日版苹果6之后，又私自拆卸说我手机为翻新机，机壳和主板完全不是一套，非得让我再加200元，才肯归还手机卡和全新iPhone5s。</p>]]></content>
      
      
      <categories>
          
          <category> 骗局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中关村 </tag>
            
            <tag> 被骗 </tag>
            
            <tag> iPhone6 </tag>
            
            <tag> iPhone5s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Realm数据库引擎-swift</title>
      <link href="/2015/12/16/%E5%BC%80%E6%BA%90%E5%BA%93/Realm%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E-swift/"/>
      <url>/2015/12/16/%E5%BC%80%E6%BA%90%E5%BA%93/Realm%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E-swift/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>中心思想：<br>继承RLMObject新建数据模型，添加相应属性，即可使用realm数据库引擎，对用户数据创建持久化，更新，删除等操作。</p><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p><a href="http://realm.io/" target="_blank" rel="noopener">Realm</a> 是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。</p><ul><li>特点：它拥有自己的数据库存储引擎<br>  Realm 并不是对 Core Data 的简单封装，相反地， Realm 并不是基于 Core Data ，也不是基于 SQLite 所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。</li><li>Realm 支持 Swift 、 Objective-C 以及 Java 语言来编写（ Android 平台和 iOS 平台使用不同的 SDK ）。</li><li>Realm 比使用 SQLite 以及 Core Data 要快很多。</li><li>可视化工具<a href="https://itunes.apple.com/cn/app/realm-browser/id1007457278?mt=12" target="_blank" rel="noopener">Realm Browser</a> ：可以让您轻松地读写 Realm 数据库的逻辑结构以及其中的数据（以 .realm 结尾），虽然 Realm Browser 的功能还十分简陋，真的只能读写而已。</li><li>RealmPlugin：是 Xcode 建模插件，通过 <a href="http://alcatraz.io/" target="_blank" rel="noopener">Alcatraz</a>安装“RealmPlugin”<h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4>学习如何导入 Realm 框架、创建数据模型，实现 Swift 执行查询以及插入、更新和删除记录，以及使用既有的数据库。<h4 id="实例学习："><a href="#实例学习：" class="headerlink" title="实例学习："></a>实例学习：</h4>测试APP<a href="https://github.com/SemperIdem/SISpeciesNotes/tree/master" target="_blank" rel="noopener">物种监测</a><br>用于记录这个 “ 动植物王国 ” 当中所发现物种的相关信息，包括种群数量、发现区域、年龄结构等等。</li></ul><p>在 Xcode 当中打开我们的起始项目。此时， <a href="http://www.raywenderlich.com/81615/www.raywenderlich.com/21365/introduction-to-mapkit-in-ios-6-tutorial" target="_blank" rel="noopener">MapKit</a><br>已经在项目当中建立好了，而且项目已经拥有了一些简单的创建、更新和删除物种信息的功能.</p><h4 id="cocoapods安装（Swift-2-1）："><a href="#cocoapods安装（Swift-2-1）：" class="headerlink" title="cocoapods安装（Swift 2.1）："></a>cocoapods安装（Swift 2.1）：</h4><p>在项目中创建Podfile配置文件，添加RealmSwift支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_frameworks!   //</span><br><span class="line">pod &apos;RealmSwift&apos;</span><br></pre></td></tr></table></figure></p><p>执行 <code>pod install</code>下载realmSwift框架，生成<strong>.xcworkspace</strong>文件，自动重启原始项目。<br>设置Xcode项目在git版本控制中的忽略配置：详见<a href="http://stackoverflow.com/questions/49478/git-ignore-file-for-xcode-projects" target="_blank" rel="noopener">.gitignore</a></p><p><a href="http://blog.csdn.net/remote_roamer/article/details/47835347" target="_blank" rel="noopener">use_frameworks!</a>   </p><pre><code>如果在cocoapods 里面不使用 use_frameworks!,则是通过static libraries 这个方式来管理pod的代码。这样就需要在app-Bridging-Header.h 文件里面去import相应的.h 文件。而如果使用了use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。 </code></pre><h4 id="开始使用："><a href="#开始使用：" class="headerlink" title="开始使用："></a>开始使用：</h4><p>编译并运行这个应用，然后尝试定位到某个您感兴趣的位置（使用模拟器的位置模拟），然后点击右上角的 “+” 按钮创建一个新的标记点。点选地图上的这个标记点，然后点击其弹出来的气泡，接下来会弹出这个标记点的详细信息。随后，点击类别文本框，就可以看到如下图所示的类别列表了:<br><img src="http://cc.cocimg.com/api/uploads/20150505/1430807925718367.jpg" alt></p><ol><li><p>使用Realm数据库将类别列表持久化</p><ul><li><p>打开<strong>CategoriesTableViewController.swift </strong>文件添加方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">populateDefaultCategories</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">self</span>.results = <span class="type">CategoryModel</span>.allObjects() <span class="comment">// 1 查询数据返回包含类别对象的RLMResults数组</span></span><br><span class="line"><span class="keyword">if</span> results.<span class="built_in">count</span> == <span class="number">0</span> &#123; <span class="comment">// 2   通过返回结果的个数，初始化本地realm数据库</span></span><br><span class="line"><span class="keyword">let</span> realm = <span class="type">RLMRealm</span>.defaultRealm() <span class="comment">// 3 访问默认的 realm 单例对象</span></span><br><span class="line">realm.beginWriteTransaction() <span class="comment">// 4   在默认 realm 数据库中启动一个事务</span></span><br><span class="line"><span class="keyword">let</span> defaultCategories = <span class="type">Categories</span>.allValues <span class="comment">// 5 使用Categories 枚举来创建一个含有全部默认类别的数组</span></span><br><span class="line"><span class="keyword">for</span> category <span class="keyword">in</span> defaultCategories &#123;</span><br><span class="line"><span class="comment">// 6 初始化类别实例对象，设置其 name 属性，加入realm中</span></span><br><span class="line"><span class="keyword">let</span> newCategory = <span class="type">CategoryModel</span>()</span><br><span class="line">newCategory.name = category</span><br><span class="line">realm.addObject(newCategory)</span><br><span class="line">&#125;</span><br><span class="line">realm.commitWriteTransaction() <span class="comment">// 7    调用 commitWriteTransaction() 方法来关闭事务，并且向数据库提交数据</span></span><br><span class="line"><span class="keyword">self</span>.results = <span class="type">CategoryModel</span>.allObjects()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 viewDidLoad() 方法的底部加入以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateDefaultCategories()</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> realm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015-12-15-zong-jie</title>
      <link href="/2015/12/15/%E5%85%B6%E4%BB%96/2015-12-15-zong-jie/"/>
      <url>/2015/12/15/%E5%85%B6%E4%BB%96/2015-12-15-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>####联系方式</p><ul><li>手机：13522834108</li><li>Email：<a href="mailto:huos3203@gmail.com" target="_blank" rel="noopener">huos3203@gmail.com</a> </li><li>QQ：724987481</li></ul><hr><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>霍曙光/男/1988 </li><li>本科/郑州轻工业学院 计算机网络技术 </li><li>工作年限：5年</li><li>QQ：724987481</li><li>技术博客：<a href="http://huos3203.github.io/MyBlog/">布衣男儿</a></li><li>Github：<a href="https://github.com/huos3203/" target="_blank" rel="noopener">https://github.com/huos3203/</a> </li><li><p>GitBook：<a href="https://huoshuguang.gitbooks.io" target="_blank" rel="noopener">https://huoshuguang.gitbooks.io</a></p></li><li><p>期望职位：iOS高级程序员，应用架构师</p></li><li>期望薪资：税前月薪20k~25k</li><li>期望城市：北京</li></ul><hr><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>##北京创世泰克科技有限公司 (2013年11月~至今)</p><p>###工作描述：  </p><ol><li>负责iPhone/iPad应用软件设计与开发；  </li><li>参与项目需求分析，产品模块的概要设计；  </li><li>优化软件性能，提高用户体验；  </li><li>scrum分解任务控制开发进度；</li><li>管理itunes，搭建fastlane自动化部署Appstore</li></ol><hr><p>###<a href="https://itunes.apple.com/cn/app/peng-bao-bao/id794859712?mt=8" target="_blank" rel="noopener">鹏保宝</a></p><p>鹏保宝是一款用于为数字内容的传播及销售环节保价护航，确保受保护的视频、文档、图纸等内容不被二次传播或转售，广泛用于在教育培训、淘宝数字内容销售、设计企业、印刷、电子书出版等领域，建立起了很好的用户基础。</p><p>####技术描述：</p><p>四人项目，担任IOS组组长</p><p>主要负责：任务分解和分配，每天了解开发进度更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><ul><li>使用<a href="https://cocoapods.org" target="_blank" rel="noopener">cocoaPods</a>工具管理第三方类库，<a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a>控制版本迭代协作开发；</li><li>定制<a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="noopener">ffmpeg</a>,<a href="http://mupdf.com/repos/mupdf" target="_blank" rel="noopener">mupdf</a>阅读器底层业务,集成IJKPlayer支持鹏保宝加密阅读；</li><li>使用storyboard/xib，AutoLayout与Size Class技术适配iPad/iPhone；</li><li>使用<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>开源包实现socket传输协议封装；</li><li>使用<a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>处理web服务api,解析JSON映射响应对象；</li><li>通过<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a>/<a href="http://nshipster.cn/javascriptcore/" target="_blank" rel="noopener">JavaScriptCore</a>实现In-APP Purchase内购；</li><li>封装<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>接口，SQLite数据库设计及<a href="http://www.sqlcipher.net" target="_blank" rel="noopener">SQLCipher</a>数据库加密；</li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a>Android风格的Toast控件,用户提示便捷得体；</li><li>集成微信SDK,腾讯SDK，ShareSDK，JpushSDK；</li></ul><p>#####项目管理成长：<br>由周期长、响应速度慢、维护修改困难，以文档为核心的传统开发模式到敏捷开发以人为本，专注于交付对客户有价值的软件，在高度协作的开环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行自我调整和完善。</p><p>#####技术突破：<br>在阅读鹏保宝视频文件时，MediaPlayer.framework仅支持普通视频播放，如何在保证鹏保宝文件不被解密的情况下，实现用户正常阅读。我通过google发现ffmpeg是基于C开发的开源程序，能够通过编译源码支持多平台，在此基础上，我们对ffmpeg定制开发，在底层代码中加入解密算法，传入文件秘钥，实现了ffmpeg支持鹏保宝视频文件的阅读。<br>  雷同，对于鹏保宝PDF加密文件时，我们对mupdf开源程序，进行二次开发，实现了mupdf支持鹏保宝PDF文件的阅读。</p><p>###<a href="https://itunes.apple.com/cn/app/pbb-reader/id954969456?mt=8" target="_blank" rel="noopener">PBB Reader</a><br><code>Pbb Reader</code>是鹏保宝加密文件的阅读器，使用此软件可以打开被鹏保宝加密后的文件，最新版本集成了<code>开会APP</code>的相关功能，并支持绥知文件的阅读。</p><p>四人项目，担任IOS组组长  </p><p>主要负责：任务分解，了解开发进度，更新燃尽图，讨论和跟进各种具体的技术问题，协调一些产品需求的变更，响应一些市场同事的需求，跟进相关功能上线。</p><p>#####技术描述：</p><ul><li>作为<code>鹏保宝</code>lite阅读器，使用<code>URL Schemes</code>实现文件共享；</li><li>使用一个target对应一个新的product方案，创建<code>PBB Reader</code>阅读器；</li><li>使用扫描二维码技术登录<code>开会</code>APP；</li><li>AutoLayout与Size Class技术适配iPad机型；</li></ul><p>#####项目收获：</p><ol><li>使用target功能充分利用代码，开发新产品，以最小的代价产出lite版应用；</li><li>使用autolayout和size class重构界面实现，去除机型判断，坐标硬适配的冗长代码；</li><li>学习自动化部署工具包<code>fastlane</code>部署Appstore；</li></ol><p>###<a href="https://itunes.apple.com/cn/app/sui-zhi/id848758969?mt=8" target="_blank" rel="noopener">绥知</a><br>绥知是一款可加强保护这些数字化的音视频节目内容的版权，涉及的技术就是数字权限管理技术。本应用现可支持在PC端进行图书，音乐，视频加密后买卖交易，在移动端可进行解密查看。</p><p>###<a href="https://itunes.apple.com/cn/app/kai-hui/id1063916218?mt=8" target="_blank" rel="noopener">开会</a><br>开会是一款会议管理系统，主要功能包括创建会议、发布会议通知、管理会议资料、管理会务等相关功能，通过该系统可实现无纸化会议办公，使得企业可以环保高效的开展会议。本APP为该系统的移动客户端，主要为参会人员提供了会议资料的领取、使用、收藏、管理等功能。</p><hr><p>#个人作品： </p><p>###<a href="https://itunes.apple.com/cn/app/iresearcher/id1048834926?mt=8" target="_blank" rel="noopener">iResearcher</a><br>iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务，iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。</p><p>#####工作描述：</p><p>本项目包含IOS端，安卓端，<a href="http://www.iresearch.xyz" target="_blank" rel="noopener">PC端</a>，担任项目Scrum Master</p><ul><li>和业务方沟通确定产品需求和流程，形成文档和原型设计，敲定开发方案；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>负责IOS项目架构设计，UI界面和功能实现；</li><li>android端APP发布（友盟，应用宝，小米应用商店）；</li><li>IOS端自动化部署发布appstore；</li></ul><p>#####技术描述：</p><ul><li>使用<a href="https://cocoapods.org" target="_blank" rel="noopener">cocoaPods</a>工具管理第三方类库，<a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a>控制版本迭代协作开发；</li><li><a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="noopener">RESideMenu</a>侧滑布局类库,支持左右滑动，滑动距离;</li><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a>易于集成，支持设备的方向，可通过类的方法来启用和禁用键盘管理器；</li><li><a href="https://github.com/antoniocasero/ACPDownload" target="_blank" rel="noopener">ACPDownload</a>实现类似AppStore下载状态样式；</li><li><a href="https://github.com/thibaultCha/TCBlobDownload" target="_blank" rel="noopener">TCBlobDownload</a>支持后台线程执行大文件下载任务，暂停和重新恢复下载；</li><li><a href="https://github.com/shingwasix/MobShareSDK" target="_blank" rel="noopener">MobShareSDK</a>实现微信朋友，朋友圈分享;</li><li><a href="https://zwaldowski.github.io/BlocksKit" target="_blank" rel="noopener">BlocksKit</a>没有创建新的宏，函数，方法和类，仅对Cocoa基础类的一个扩展，是取代了通常的delegate用法;</li><li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>图片缓存的框架; <!--点点滴滴--></li><li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a>下拉刷新上拉加载更多MJRefresh类库;</li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a>Android风格的Toast控件,用户提示便捷得体；</li><li><a href="https://github.com/kcandr/IQLabelView" target="_blank" rel="noopener">IQLabelView</a>对文本控件覆盖，缩放和旋转；</li><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></li><li><a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>处理web服务api,解析JSON映射响应对象；</li><li><a href="https://github.com/Masonry/Masonry" target="_blank" rel="noopener">Masonry</a>一个轻量级的布局框架,拥有自己的描述语法，采用更优雅的链式语法封装自动布局；</li><li>BaiduMobStat使用百度统计，统计用户使用时长、使用频率、访问页面、使用间隔等数据；</li></ul><p>#####能力提高：<br>Scrum开发的认识与学习：强调团队需要是“自组织”的，需要群体进行决策而不是领导，Scrum强调的是信息的透明化，定期地查看自己和团队的状态，保证大家信息充分共享，透明的方法，即有了信息的透明，这样团队成员就能共同发现项目执行中的问题，进而一起寻找解决办法，从而达到“自组织”的团队。在开发时间上也保持着一周一次的Sprint评审会议，保证项目开发进度和质量。</p><p>###爱跑</p><p><code>爱跑</code>是一款鼓励用户多运动的APP社区应用，能安排运动日程，统计每日运动量，统计圈子排行榜，支持圈子好友即时通讯，提供穿戴设备购买的入口。</p><p>######工作描述：<br>四人项目，项目负责人  </p><ul><li>沟通需求，敲定开发方案，组织人员开发；</li><li>在<code>worktile</code>平台分配任务，监控项目进度，处理客户反馈；</li><li>android端APP发布；</li><li>部署后台服务器；</li></ul><p>######技术描述：</p><ul><li>集成融云IMKit组件，嵌入到现有代码框架中，实现圈子好友聊天功能；</li><li>日历控件上的日程和提醒；</li></ul><p>#####能力提高：<br>组织能力，协作沟通能力。</p><hr><p>##北京鼎晟中天科技有限公司（2011年3月~2013年11月）</p><p>###工作描述：</p><ol><li>负责公司IOS平台的iPhone应用程序的软件设计及开发；  </li><li>参与项目需求分析，产品模块的概要和详细设计；  </li><li>优化软件性能，提高用户体验；  </li></ol><p>###会议通<br>本项目以蓝牙技术为基础，进行近距离的人员搜索，结合移动互联网技术让参展人员可以方便的进行进行电子名片的交换和管理。同时系统通过对参展人员交换名片的行为进行多维度的分析，使得会展组织者可以及时准确的了解展会效果，为组织者指定下一步工作计划提供数据基础。</p><p>#####技术描述：</p><ul><li>sqlite数据库工具FMDB开发</li><li>ABAddressBook通讯录数据库开发</li><li>CoreBluetooth蓝牙开发</li><li>ASIHTTPRequest实现了图片上传下载</li><li>JavaPNS服务器推送工具，IOS推送技术推送</li></ul><p>###<a href="https://itunes.apple.com/cn/app/yi-gou8/id663698075?mt=8" target="_blank" rel="noopener">易购8</a>(已下架)<br><code>易购8</code>是一款简易的口袋购物软件，支持通过输入关键字直接在淘宝查询商品，支持用户选择“商品价格分段”、“商家信誉分段”、“商品销量分段”以及其他条件对商品进行过滤。</p><p>###众信旅游ERP客户端（Java）</p><p>本系统通过对旅行社关键业务的分析，将旅行社业务中需要移动处理的部分抽取出来，通过与企业内部业务管理系统协作，既能够与企业现有的流程一致，又保持一定的独立性，避免影响核心业务系统的运转。<br>系统用户群定位：旅行社的销售人员、管理人员、导游！<br>具体实现:是以移动互联网技术为基础，结合当前主流的移动终端技术，将企业内部的ERP延伸到移动终端，可以让旅行社工作人员随时随地高效、安全的进行业务操作！  </p><p>###淘宝信息搜集工具（Java）<br>实现了定时爬取指定商品的基本信息包括:商品原价，实价，评价数量，评价星级，运费，和店铺等级，店铺信誉度，以及商品连接，店铺连接，和缩略图获取。</p><p>###<a href="http://www.jgbw.cn/" target="_blank" rel="noopener">今古博文</a>（java）<br>作为公司的企业文化，地理位置，招聘信息，等最新信息的展示平台….</p><hr><p>#技能清单：  </p><ol><li>熟练掌握Object C/swift/java，ruby脚本，Linux 命令，regex</li><li>熟练掌握MVC，MVVM，MVP，单例，观察者，代理，工厂等设计模式</li><li>熟悉socket通信，HTTP协议，xmpp框架，Restful框架，json/xml解析</li><li>熟悉cocoa，uikit，block,多线程,disptach</li><li>熟练interface builder，Playground，autolayout，SizeClass</li><li>熟悉IOS内购，QQ登录，极光推送，融云等第三方SDK</li><li>熟悉ffmpeg视频播放器，mupdf阅读器，实现密文阅读</li><li>熟悉Pods，Alcatraz，Xvim，VVDocumenter，Dash等</li><li>Scrum开发：Jira/worklite/Trello/OmniPlan</li><li>自动化部署工具:fastlane/jenkins/Docker</li><li>数据库：MySQL/SQLServer/SQLite/Realm</li><li>测试平台：蒲公英，HockeyApp，Crashlytics，OXServer</li><li>异常分析：instruments，dsym，友盟，百度统计，Crashlytics</li><li>版本管理：Svn/Git GUI:cornerstone/smartSVN/sourceTree</li><li>文档工具：appleDoc/jazzy/GistBox/MOU/GitBook/Snippets</li><li>前端工具：PhoneGap/PaintCode/Photoshop/flash/dreamweaver</li><li>Web开发：PHP/JSP/ASP</li><li>Web框架：Nutz、Octopress</li><li>云和开放平台：SAE/AWS/微信应用开发</li></ol><hr><p>##致谢</p><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      <categories>
          
          <category> .. </category>
          
          <category> _drafts </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OC与swift相互调用</title>
      <link href="/2015/12/01/swift/OC%E4%B8%8Eswift%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
      <url>/2015/12/01/swift/OC%E4%B8%8Eswift%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Swift中使用OC的类声明-–-实现配置-桥接的头文件"><a href="#Swift中使用OC的类声明-–-实现配置-桥接的头文件" class="headerlink" title="Swift中使用OC的类声明  – 实现配置 桥接的头文件"></a>Swift中使用OC的类声明  – 实现配置 桥接的头文件</h4><h6 id="方式一：自动添加桥接头文件"><a href="#方式一：自动添加桥接头文件" class="headerlink" title="方式一：自动添加桥接头文件"></a>方式一：自动添加桥接头文件</h6><ol><li>在一个全新的Swift，利用第一次新建提示的方式自动添加桥接头文件。</li><li>点确定这后就会生成一个以&lt;produceName-Bridging-Header.h&gt;的头文件。</li><li>在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。</li><li>把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Use this file to import your target's public headers that you would like to expose to Swift.  </span></span><br><span class="line"><span class="comment">//MixDemo/MixDemo-Bridging-Header.h    </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OCChannel.h"</span></span></span><br></pre></td></tr></table></figure></li></ol><h6 id="方式二：手动添加桥接头文件"><a href="#方式二：手动添加桥接头文件" class="headerlink" title="方式二：手动添加桥接头文件"></a>方式二：手动添加桥接头文件</h6><p>同样的，当你知道这个swift搜索头文件的关系后，就不需要再理会这个-Bridging-Header.h的文件了。<br>完全可以手工建一个并取自己喜欢的名字：</p><ol><li>新建一个头文件，名为:OCContainerHeader.h</li><li>在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。</li><li>把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Use this file to import your target's public headers that you would like to expose to Swift.  </span></span><br><span class="line"><span class="comment">//MixDemo/MixDemo-Bridging-Header.h    </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OCChannel.h"</span></span></span><br></pre></td></tr></table></figure></li></ol><h4 id="OC如何调用Swift写的类-–-为了在-Objective-C-中可用，-Swift-类必须是-Objective-C-类的子类，或者用-Objective-C-标记；"><a href="#OC如何调用Swift写的类-–-为了在-Objective-C-中可用，-Swift-类必须是-Objective-C-类的子类，或者用-Objective-C-标记；" class="headerlink" title="OC如何调用Swift写的类  –     为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记；"></a>OC如何调用Swift写的类  –     为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记；</h4><ol><li>选中targets-&gt;build settings -&gt;packing-&gt;Product Module Name 中设置模块名（可以自定义），这个名称很重要 swift 的头文件就是根据这个来命名的，例如：SwiftModule。</li><li>在OC头文件类中，添加import “SwiftModule-swift.h”但你在整个工程中是找不到这个文件的，但可以使用CMD+ 鼠标点击可看这个头文件中的内容。  </li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>这样，工程中如查Swift要使用OC,则把需要使用的OC类的头文件，全写在MixDemo-Bridging-Header.h里。同样如果OC中所使用的swift类，只需要Clean一把，再编就可以了，但不要忘了导入SwiftModule-swift.h哦（名称自取，但-swift.h是固定的），另外还有一个需要读者注意的。</p><p>注：<br>    凡是用Swift写的类，如果不继成自NSObject或NSObject 的派生类，哪么编译后将不会生成对应的转换类。从而使得OC 中找不到相应的声明。<br>如我的例子中 class Act 这样不会被编译到SwiftModule-swift.h中，但写为 class Act : NSObject，就可以编译出相应的声明。另外可以使用@objc加以声明，但这个还是一样，类最好继承NSObject下来。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> OC混编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift入门</title>
      <link href="/2015/11/28/swift/Swift%E5%85%A5%E9%97%A8/"/>
      <url>/2015/11/28/swift/Swift%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1" target="_blank" rel="noopener">苹果官方</a>  </li><li><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="noopener">中文版</a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4>Apple基于已有的编译器、调试器、框架作为其基础架构。通过ARC(Automatic Reference Counting，自动引用计数)来简化内存管理。我们的框架栈则一直基于Cocoa，且Objective-C进化支持了块、collection literal和模块，允许现代语言的框架无需深入即可使用。<br>(by gashero)感谢这些基础工作，才使得可以在Apple软件开发中引入新的编程语言Swift。</li></ul><h4 id="swift有点"><a href="#swift有点" class="headerlink" title="swift有点"></a>swift有点</h4><p>编译器是按照性能优化的，而语言是为开发优化的</p><p>Swift采用了Objective-C的命名参数和动态对象模型。提供了对Cocoa框架和mix-and-match的互操作性。基于这些基础，Swift引入了很多新功能和结合面向过程和面向对象的功能。<br>Swift对新的程序员也是友好的：</p><ol><li>它是工业级品质的系统编程语言，却又像脚本语言一样的友好。</li><li>它支持playground，允许程序员实验一段Swift代码功能并立即看到结果，而无需麻烦的构建和运行一个应用。<br>Swift集成了现代编程语言思想，以及Apple工程文化的智慧，编译器是按照性能优化的，而语言是为开发优化的，无需互相折中。</li></ol><h4 id="swift语法"><a href="#swift语法" class="headerlink" title="swift语法"></a>swift语法</h4><p>Playground允许你编辑代码并立即看到结果,可以从”Hello, world”开始学起并过渡到整个系统。<br>在Xcode的playground中打开:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Hello, world"</span>)</span><br></pre></td></tr></table></figure></p><p>在Swift，这就是完整的程序:</p><ol><li>无需导入(import)输入输出和字符串处理的系统库。</li><li>全局范围的代码就是用于程序的入口，所以你无需编写一个 main() 函数。也无需在每个语句后写分号。</li></ol><p>所有这些使得Swift成为Apple软件开发者创新的源泉。</p><h4 id="简单值-–-使用-let-来定义常量，-var-定义变量"><a href="#简单值-–-使用-let-来定义常量，-var-定义变量" class="headerlink" title="简单值  – 使用 let 来定义常量， var 定义变量"></a>简单值  – 使用 let 来定义常量， var 定义变量</h4><p>提供一个值就可以创建常量或变量，并让编译器推断其类型,一个常量或变量必须与赋值时拥有相同的类型。因此你不用严格定义类型。<br>常量定义类似于函数式编程语言中的变量,常量的值无需在编译时指定，但是至少要赋值一次,赋值后就无法修改。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable = <span class="number">42</span></span><br><span class="line">myVariable = <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> myConstant = <span class="number">42</span></span><br></pre></td></tr></table></figure></p><p>在上面例子中，编译其会推断myVariable是一个整数类型，因为其初始化值就是个整数。</p><h6 id="1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言"><a href="#1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言" class="headerlink" title="1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言"></a>1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言</h6><p>类型与变量名绑定，属于静态类型语言。有助于静态优化。与Python、JavaScript等有所区别。<br>例如：初始化值没有提供足够的信息(或没有初始化值)，可以在变量名后写类型，以冒号分隔。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imlicitInteger = <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> imlicitDouble = <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure></p><h6 id="2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型"><a href="#2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型" class="headerlink" title="2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型"></a>2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型</h6><ul><li><p>String(变量名)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="string">"The width is "</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure></li><li><p>以小括号来写值，并用反斜线(“”)放在小括号之前</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span>     <span class="comment">//by gashero</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have \(apples) apples."</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have \(apples + oranges) pieces of fruit."</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="数组和字典的用法"><a href="#数组和字典的用法" class="headerlink" title="数组和字典的用法"></a>数组和字典的用法</h4><ol><li>声明并初始化<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = <span class="type">String</span>[]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Float</span>&gt;()</span><br><span class="line">shoppingList = [] <span class="comment">//去购物并买些东西</span></span><br></pre></td></tr></table></figure></li></ol><p>如果数组类型无法推断，你可以写空的数组为 “[]” 和空的字典为 “[:]“。</p><ol start="2"><li>访问<br>创建一个数组和字典使用方括号 “[]”，访问其元素则是通过方括号中的索引或键。                      <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>, <span class="string">"blue paint"</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">   <span class="string">"Malcolm"</span>: <span class="string">"Captain"</span>,</span><br><span class="line">   <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="控制流-–-条件控制，循环控制"><a href="#控制流-–-条件控制，循环控制" class="headerlink" title="控制流  –  条件控制，循环控制"></a>控制流  –  条件控制，循环控制</h4><h6 id="1-条件控制"><a href="#1-条件控制" class="headerlink" title="1. 条件控制"></a>1. 条件控制</h6><ul><li><p>if  条件必须是布尔表达式<br>在 if 语句中，条件必须是布尔表达式，这意味着 if score { … } 是错误的，不能隐含的与0比较。<br>你可以一起使用 if 和 let 来防止值的丢失。这些值是可选的。<br>可选值可以包含一个值或包含一个 nil 来指定值还不存在。写一个问号 “?” 在类型后表示值是可选的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String?</span> = <span class="string">"Hello"</span></span><br><span class="line">optionalString == <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String?</span> = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">"Hello, \(name)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch 支持多种数据以及多种比较，不限制必须是整数和测试相等  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">    <span class="keyword">let</span> vegetableComment = <span class="string">"Add some raisins and make ants on a log."</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">    <span class="keyword">let</span> vegetableComment = <span class="string">"That would make a good tea sandwich."</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">    <span class="keyword">let</span> vegetableComment = <span class="string">"Is it a spicy \(x)?"</span></span><br><span class="line"><span class="keyword">default</span>:    <span class="comment">//by gashero</span></span><br><span class="line">    <span class="keyword">let</span> vegetableComment = <span class="string">"Everything tastes good in soup."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在执行匹配的情况后，程序会从 switch 跳出，而不是继续执行下一个情况。所以不再需要 break 跳出 switch 。</p><h6 id="2-循环控制"><a href="#2-循环控制" class="headerlink" title="2. 循环控制"></a>2. 循环控制</h6><ul><li>for-in 来迭代字典中的每个元素<br>可使用 for-in 来迭代字典中的每个元素，提供一对名字来使用每个键值对。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers = [</span><br><span class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">你可以在循环中保持一个索引，通过“..”来表示索引范围或明确声明一个初始值、条件、增量。   </span><br><span class="line">这两个循环做相同的事情:  </span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">var</span> firstForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">    firstForLoop += i</span><br><span class="line">&#125;</span><br><span class="line">firstForLoop</span><br><span class="line"><span class="keyword">var</span> secondForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i &#123;</span><br><span class="line">    secondForLoop += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用 .. 构造范围忽略最高值，而用 … 构造的范围则包含两个值。</p><ul><li>while 来重复执行代码块直到条件改变<br>使用 while 来重复执行代码块直到条件改变。循环的条件可以放在末尾来确保循环至少执行一次。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">n</span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    m = m * <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line">m</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数与闭包-–-函数是闭包的特殊情况"><a href="#函数与闭包-–-函数是闭包的特殊情况" class="headerlink" title="函数与闭包  – 函数是闭包的特殊情况"></a>函数与闭包  – 函数是闭包的特殊情况</h4><h6 id="1-闭包-无需名字，只需要放在大括号中即可"><a href="#1-闭包-无需名字，只需要放在大括号中即可" class="headerlink" title="1. 闭包 无需名字，只需要放在大括号中即可"></a>1. 闭包 无需名字，只需要放在大括号中即可</h6><p>编写闭包时有多种选项:</p><ol><li><p>使用 in 到特定参数和主体的返回值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="built_in">map</span>(&#123;</span><br><span class="line">    (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>单一语句的闭包可以直接返回值<br>例如：当一个闭包的类型是已知时，例如代表回调，你可以忽略其参数和返回值，或两者</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="built_in">map</span>(&#123;number <span class="keyword">in</span> <span class="number">3</span> * number&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过数字而不是名字来引用一个参数，这对于很短的闭包很有用。<br>例如：一个闭包传递其最后一个参数到函数作为返回值。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">2</span>]) &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h6><ul><li><p>函数的声明   –  使用func 声明一个函数  使用 -&gt;分隔参数的名字和返回值类型,<br>调用函数使用他的名字加上小括号中的参数列表</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello \(name), today is \(day)."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"Bob"</span>, <span class="string">"Tuesday"</span>)</span><br></pre></td></tr></table></figure></li><li><p>函数的嵌套<br>内嵌函数可以访问其定义所在函数的变量。<br>你可以使用内嵌函数来组织代码，避免过长和过于复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数接收的参数</p><ol><li><p>可变参数的个数  sumOf(numbers: Int…) -&gt; Int{}<br>函数可以接受可变参数个数，收集到一个数组中</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">sumOf(<span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure></li><li><p>其他函数作为参数  func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool{}</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: Int[], condition: Int -&gt; Bool)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(numbers, lessThanTen)</span><br></pre></td></tr></table></figure><p>函数实际是闭包的特殊情况。你可以写一个闭包而无需名字，只需要放在大括号中即可。使用 in 到特定参数和主体的返回值。</p></li></ol></li><li><p>函数的返回值</p><ol><li><p>返回多个值 ： getGasPrices() -&gt; (Double, Double, Double)<br>使用元组(tuple)来返回多个值                           </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGasPrices</span><span class="params">()</span></span> -&gt; (<span class="type">Double</span>, <span class="type">Double</span>, <span class="type">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3.59</span>, <span class="number">3.69</span>, <span class="number">3.79</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回另一个函数  ： makeIncrementer() -&gt; (Int -&gt; Int)<br>函数是第一类型的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h4><h6 id="1-类的创建-：class-类名"><a href="#1-类的创建-：class-类名" class="headerlink" title="1. 类的创建  ：class 类名 {}"></a>1. 类的创建  ：class 类名 {}</h6><ol><li><p>使用 class 可以创建一个类。<br>一个属性的声明则是在类里作为常量或变量声明的，除了是在类的上下文中。方法和函数也是这么写的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的构造器  ： 构造器来在创建实例时设置类，使用 init 来创建</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;   <span class="comment">//by gashero</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A Shape with \(numberOfSides) sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>self 用来区分 name 属性和 name 参数。<br>构造器的声明跟函数一样，除了会创建类的实例。每个属性都需要赋值，无论在声明里还是在构造器里。</p><ol start="3"><li>类的析构器，来执行对象销毁时的清理工作，使用 deinit 来创建<br>使用 deinit 来创建一个析构器，来执行对象销毁时的清理工作。</li><li>超类的继承    <ul><li>子类包括其超类的名字，以冒号分隔。在继承标准根类时无需声明，所以你可以忽略超类。  </li><li>子类的方法可以通过标记 override 重载超类中的实现，而没有 override 的会被编译器看作是错误,编译器也会检查那些没有被重载的方法。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length \(sideLength)."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure></li></ul></li></ol><h6 id="2-类的实例创建-类名-点语法来访问实例的属性和方法"><a href="#2-类的实例创建-类名-点语法来访问实例的属性和方法" class="headerlink" title="2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法"></a>2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法</h6><p>通过在类名后加小括号来创建类的实例。使用点语法来访问实例的属性和方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure></p><p>可选类型 Int?<br>可选绑定 if while</p><p>强制取值表达式 expression!<br>可选链表达式   expression?</p><p>类型转换运算符 is , as, is?, as!</p><p>标示符模式<br>值绑定模式<br>可选模式<br>类型转换模式</p><p>实例方法  func<br>类型方法 class func</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品领导者的五种特质</title>
      <link href="/2015/11/27/%E7%AE%A1%E7%90%86/%E4%BA%A7%E5%93%81%E9%A2%86%E5%AF%BC%E8%80%85%E7%9A%84%E4%BA%94%E7%A7%8D%E7%89%B9%E8%B4%A8/"/>
      <url>/2015/11/27/%E7%AE%A1%E7%90%86/%E4%BA%A7%E5%93%81%E9%A2%86%E5%AF%BC%E8%80%85%E7%9A%84%E4%BA%94%E7%A7%8D%E7%89%B9%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-善于观察"><a href="#1-善于观察" class="headerlink" title="1.善于观察"></a>1.善于观察</h4><p>他们一直在观察用户，不仅仅是借助指标和仪表盘。他们对每件小事情感到好奇：</p><ul><li>用户正尝试完成什么？  </li><li>为什么用户选择这款产品而非其它产品？  </li><li>他们在和这款产品交互之前、之中和之后，做了什么。  </li></ul><p>他们查看收到的每一条反馈，对每个客户问题做出响应。他们创建让人愉悦的调查，知道该问什么，什么时候该倾听或无视。他们在 Facebook 上和用户交朋友——他们能叫得出用户名字。他们深知，核心用户会成为产品本身的一部分。</p><p>他们痴迷于研究。他们知道市场的运作方式、未来走向以及竞争要做什么。他们密切注视着一切，除了没有创建一个显而易见的版本。</p><a id="more"></a><h4 id="2-技术"><a href="#2-技术" class="headerlink" title="2.技术"></a>2.技术</h4><p>他们或许没有计算机科学学位，但是凭借其悟性，足以解释事物运作的方式。他们理解软件开发的过程（和复杂度），打造增量改变的文化，还能借助可用的数据点清晰明了地交流。他们对优先级毫不留情。</p><p>他们是脚本瘾君子——他们能够不依赖工程师而自动化很多工作。为了检查产品，他们创造工具，最终成为每个人手头最重要的工具。</p><p>他们在工程师圈子里保持良好联系——知道从哪儿得到某些工程师的快速帮助、或雇佣到全职的明星工程师。</p><p>他们明白，写代码除了开发产品——还能节约大量时间。</p><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h4><p>他们或许不是正式的数据科学家，但他们是数据狂热者。他们理解大数据和不良数据的差异。他们对各种分析工具一点儿也不陌生，为了捕捉到有意义的数据，他们知道该增加什么或何时增加。</p><p>他们熟悉足够多的数据工具和框架，能够快速分析，并找到见解。他们总是寻找盲点。他们做出数据启迪、而非数据驱动的决定。</p><p>他们和数据科学社区保持良好联系——他们知道从哪儿能得到快速的数据科学方面的帮助，以及雇佣到明星数据科学家。</p><p>他们明白，大量的数据分析只用 web 浏览器就能快速搞定。</p><h4 id="4-聚焦设计"><a href="#4-聚焦设计" class="headerlink" title="4.聚焦设计"></a>4.聚焦设计</h4><p>他们可能不是视觉设计师，但是理解设计的真谛及其重要性。他们知道，好的设计不单单取决于优秀的设计师，而要在团队内部打造一种强烈的设计文化。他们理解，好的设计花费时间，也知道良好、完美与完成之间的区别。</p><p>他们熟悉快速设计的工具，除了编写产品说明，还能够清晰地为振奋人心的想法和概念添加插图。他们不断地寻找设计灵感，他们激发着设计师。</p><p>他们和设计社区保持良好联系——他们知道从哪儿能得到快速的兼职设计方面的帮助，以及雇佣到优秀的全职设计师。</p><p>他们明白，设计不单单是设计师的工作——它是团队每个人的心态和文化。</p><h4 id="5-企业家精神"><a href="#5-企业家精神" class="headerlink" title="5.企业家精神"></a>5.企业家精神</h4><p>他们或许还没有打造过十亿美元的业务，但是已经上线了、并使得至少一款产品取得了增长（他们自己出钱），并以此为荣，即使没有上线亦如此。他们乐于介绍过程——为什么世界需要他们的产品、他们怎样获取用户、效果不佳的问题在哪儿。</p><p>他们相信，世界真的是平的，渴望成功。他们以之前的作品为荣，但是在内心深处藏着更大的欲望，那就是为十亿用户开发产品，让世界变得更美好。</p><p>他们明白，在拥有的全部技能中，勇气和坚持不懈才是最重要的两个特点。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIImage的渲染模式</title>
      <link href="/2015/11/27/iOS/UI/UIImage%E7%9A%84%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/11/27/iOS/UI/UIImage%E7%9A%84%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>设置UIImage的渲染模式：UIImage.renderingMode<br>在 iOS 7 中 UIImage 添加了一个 <code>renderingMode</code> 属性。我们可以使用 <code>imageWithRenderingMode:</code>并传入一个合适的<code>UIImageRenderingMode</code> 来指定这个 image 要不要以 Template 的方式进行渲染。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageRenderingModeAutomatic</span> <span class="comment">// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。</span></span><br><span class="line"><span class="built_in">UIImageRenderingModeAlwaysOriginal</span> <span class="comment">// 始终绘制图片原始状态，不使用Tint Color。</span></span><br><span class="line"><span class="built_in">UIImageRenderingModeAlwaysTemplate</span> <span class="comment">// 始终根据Tint Color绘制图片，忽略图片的颜色信息。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myimage"</span>];</span><br><span class="line">img = [img imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysTemplate</span>];</span><br><span class="line"><span class="comment">//实际效果，效果依旧显示为baritem的Tint Color</span></span><br><span class="line"><span class="built_in">UIBarButtonItem</span> *barButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:setImage</span><br><span class="line">                                                   style:<span class="built_in">UIBarButtonItemStylePlain</span></span><br><span class="line">                                                  target:<span class="keyword">self</span></span><br><span class="line">                                                  action:<span class="keyword">@selector</span>(setAction:)];</span><br><span class="line">```    </span><br><span class="line">在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在`<span class="built_in">UIApperance</span>`中，Apple 也为我们对于 `Size Classes` 添加了相应的方法。使用 `+appearanceForTraitCollection:` 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="built_in">UIView</span>.appearanceForTraitCollection(<span class="built_in">UITraitCollection</span>(verticalSizeClass:.Compact)).tintColor = <span class="built_in">UIColor</span>.redColor()  </span><br><span class="line"><span class="built_in">UIView</span>.appearanceForTraitCollection(<span class="built_in">UITraitCollection</span>(verticalSizeClass:.Regular)).tintColor = <span class="built_in">UIColor</span>.greenColor()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 控件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷开发总结</title>
      <link href="/2015/11/20/%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2015/11/20/%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>传统开发模型的局限性<br>什么是敏捷软件开发<br>Scrum概述<br>Scrum角色<br>Scrum活动<br>Scrum实践<br>Scrum工具和模板<br>Scrum常见问题<br>推荐书籍<br>敏捷方法强调以人为本，专注于交付对客户有价值的软件。在高度协作的开发环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行自我调整和完善。</p><p>Scrum Team中的三种角色</p><p>Product Owner- 产品所有者<br>个人：代表所有的干系人</p><p>Scrum Master:<br>个人：负责指导过程的执行</p><p>Scrum Team – Scrum团队:<br>承诺完成工作，向干系人交付产品价值</p><p>Product Owner- 产品所有者：</p><p>1 利益相关方的代表,重点是产品方面，与Scrum Master和Team合作</p><p>2 从业务角度出发对需求进行排序</p><p>3 合理的调整产品功能和迭代顺序</p><p>4 侧重于投资回报</p><p>Scrum Master职责:<br>1 为Scrum Team服务,确保每个成员都认同Scrum价值观和游戏规则</p><p>2 帮助Scrum Team规划Sprit计划</p><p>3 组织每天的Daily Scrum会议</p><p>4 负责保证Scrum Team 高效持续运转</p><p>5 决策和免除障碍，保证团队不受外来无端的影响</p><p>Scrum Team – Scrum团队:  </p><p>1 尽一切可能去完成任务-发布产品</p><p>2 充分理解产品负责人的产品愿景</p><p>3 合作完成冲刺(Sprint)中每一个目标</p><p>4 更好的支持可能需要进一步开发的产品发布</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scrum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calabash一款跨平台UI测试工具初探</title>
      <link href="/2015/10/06/%E6%B5%8B%E8%AF%95/calabash%E4%B8%80%E6%AC%BE%E8%B7%A8%E5%B9%B3%E5%8F%B0UI%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2/"/>
      <url>/2015/10/06/%E6%B5%8B%E8%AF%95/calabash%E4%B8%80%E6%AC%BE%E8%B7%A8%E5%B9%B3%E5%8F%B0UI%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>参考：<a href="http://blog.csdn.net/zangcw/article/details/25299243" target="_blank" rel="noopener">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></p><ol><li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li><li><p>安装Calabash  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure></li><li><p>安装Calabash中文支持包  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure></li></ol><h4 id="For-automatic-setup"><a href="#For-automatic-setup" class="headerlink" title="For automatic setup:"></a>For automatic setup:</h4><ol><li><p>In a terminal, go to your iOS project  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class="line">```  </span><br><span class="line">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure><p> gem install calabash-cucumber</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure><p> calabash-ios setup  //Answer the questions and read the output :)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure><p> calabash-ios gen</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. In Xcode, build your project using the -cal scheme</span><br><span class="line"></span><br><span class="line">6. Run the generated test!</span><br></pre></td></tr></table></figure><p> cucumber</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">#### [cucumber官网](https://cukes.info/)   </span><br><span class="line"></span><br><span class="line">* Feature（功能）  </span><br><span class="line">* Scenario（情景）  </span><br><span class="line">*  Given（给定）  </span><br><span class="line">*  When（当）  </span><br><span class="line">*  Then（则） </span><br><span class="line">#####[运行原理](http://www.educity.cn/se/619226.html)  </span><br><span class="line">![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg)  </span><br><span class="line">cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </span><br><span class="line">#####结构框架</span><br><span class="line">calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。   </span><br><span class="line">![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg)  </span><br><span class="line">feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。  </span><br><span class="line">再看一下其中的内容：</span><br><span class="line"></span><br><span class="line">　　my_first.feature</span><br><span class="line"></span><br><span class="line">　　Feature： 登陆</span><br><span class="line"></span><br><span class="line">　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class="line"></span><br><span class="line">　　When 打开登陆页面</span><br><span class="line"></span><br><span class="line">　　And    输入用户名XXX输入密码XXX</span><br><span class="line"></span><br><span class="line">　　And   点击登陆</span><br><span class="line"></span><br><span class="line">　　Then  验证登陆成功</span><br><span class="line"></span><br><span class="line">　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。  </span><br><span class="line">如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，  </span><br><span class="line">那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</span><br><span class="line"></span><br><span class="line">When /^ 输入用户名\&quot;([^\\\&quot;]*)\&quot; 输入密码\&quot;([^\\\&quot;]*)\&quot;  $/ do |username，password|</span><br><span class="line">performAction(&apos;enter_text_into_numbered_field&apos;，username，1)</span><br><span class="line">performAction(&apos;enter_text_into_numbered_field&apos;，password，2)</span><br><span class="line">end</span><br><span class="line">现在应该能明白为什么你需要写汉字的脚本就可以了吧。  </span><br><span class="line">在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。  </span><br><span class="line">还是以这个登录脚本为例：</span><br><span class="line"></span><br><span class="line">假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</span><br><span class="line">#####运行报告</span><br><span class="line">alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</span><br><span class="line"></span><br><span class="line">　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告  </span><br><span class="line">　　![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)</span><br><span class="line"></span><br><span class="line">[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) </span><br><span class="line">1. my_first.feature: 描述在这个条件下需要做什么事情；</span><br><span class="line"></span><br><span class="line">Feature: Running a test  </span><br><span class="line">  As an iOS developer  </span><br><span class="line">  I want to have a sample feature file  </span><br><span class="line">  So I can begin testing quickly  </span><br><span class="line">  </span><br><span class="line">Scenario: Example steps1  </span><br><span class="line">  Given I am on the Welcome Screen  </span><br><span class="line">  Then I swipe left  </span><br><span class="line">  And I wait until I don&apos;t see &quot;Please swipe left&quot;  </span><br><span class="line">  And take picture  </span><br><span class="line">  </span><br><span class="line">Scenario: Example steps2  </span><br><span class="line">  Given I am on the Welcome Screen  </span><br><span class="line"> #ASSERTION  </span><br><span class="line">  Then I should see a &quot;login&quot; button  </span><br><span class="line"> #INPUT TEXT  </span><br><span class="line">  Then I enter &quot;my_username&quot; into text field number 1  </span><br><span class="line">#  Then I touch &quot;Return&quot;  </span><br><span class="line">  </span><br><span class="line"> #TOGGLE SWITCH  </span><br><span class="line">  Then I toggle the switch  </span><br><span class="line">  Then I touch &quot;Login&quot;  </span><br><span class="line">  And I touch &quot;Second&quot;  </span><br><span class="line">  And take picture  </span><br><span class="line">该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </span><br><span class="line"></span><br><span class="line">2. my_first_step.rb: 解释了Given的具体条件</span><br><span class="line"></span><br><span class="line">Given /^I am on the Welcome Screen$/ do  </span><br><span class="line">  element_exists(&quot;view&quot;)  </span><br><span class="line">  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  </span><br><span class="line">  sleep(STEP_PSEAU)  </span><br><span class="line">end</span><br><span class="line">这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot;</span><br><span class="line"></span><br><span class="line">[更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)</span><br><span class="line"></span><br><span class="line">UIAutomation</span><br><span class="line"></span><br><span class="line">UIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。</span><br><span class="line"></span><br><span class="line">通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：</span><br><span class="line"></span><br><span class="line">- 如何找到界面上的一个UI元素</span><br><span class="line">- 如何指定针对一个UI元素的操作</span><br><span class="line"></span><br><span class="line">在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：</span><br><span class="line"></span><br><span class="line">- name</span><br><span class="line">- value</span><br><span class="line">- elements</span><br><span class="line">- parent</span><br><span class="line">- …</span><br><span class="line"></span><br><span class="line">而整个界面的层级结构如下：</span><br><span class="line"></span><br><span class="line">arget（设备级别的UI，用于支持晃动，屏幕方向变动等操作）</span><br><span class="line">    Application（设备上的应用，比方说Status Bar，keyboard等）</span><br><span class="line">      Main window（应用的界面，比方说导航条）</span><br><span class="line">        View（界面下的View，比方说UITableView）</span><br><span class="line">           Element（View下的一个元素）</span><br><span class="line">              Child element(元素下的一个子元素)</span><br><span class="line">下面是一个访问到Child element的例子：</span><br><span class="line"></span><br><span class="line">UIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()</span><br><span class="line">开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。</span><br><span class="line"></span><br><span class="line">找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：</span><br><span class="line"></span><br><span class="line">- 点击按钮，例: ***.buttons[“add”].tap()</span><br><span class="line">- 输入文本, 例:***.textfields[0].setValue(“new”)</span><br><span class="line">- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)</span><br><span class="line">- ……</span><br><span class="line">关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation)  </span><br><span class="line">Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:</span><br><span class="line">1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下</span><br><span class="line">```ruby</span><br><span class="line">xcodebuild</span><br><span class="line">-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; </span><br><span class="line">-schemeAudioDemo</span><br><span class="line">-sdk iphonesimulator6.1 </span><br><span class="line">-configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/</span><br><span class="line">AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/</span><br><span class="line">build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; </span><br><span class="line">install</span><br></pre></td></tr></table></figure></li><li><p>启动Instruments，基于第一步生成的应用运行UIAutomation测试</p><pre><code class="ruby">instruments-t  <span class="string">"/Applications/Xcode.app/Contents/Applications/Instruments.app/</span><span class="string">Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/</span><span class="string">Automation.tracetemplate"</span> <span class="string">"/Users/twer/Documents/xcodeworkspace/AudioDemo</span><span class="string">/build/Applications/TestExample.app"</span>-e UIASCRIPT &lt;absolute_path_to_the_test_file&gt;</code></pre><p>为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: <a href="https://github.com/shaune/jasmine-ios-acceptance-tests" target="_blank" rel="noopener">https://github.com/shaune/jasmine-ios-acceptance-tests</a></p></li></ol><p>UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，<a href="https://gorillalogic.com/fonemonkey-0-7-1-released/" target="_blank" rel="noopener">Fone Monkey,最新版本更新于2010年，估计过时</a>就是其中的一个优秀成果。</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> UI </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SmartSVN创建版本库</title>
      <link href="/2015/10/06/git/%E4%BD%BF%E7%94%A8SmartSVN%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
      <url>/2015/10/06/git/%E4%BD%BF%E7%94%A8SmartSVN%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>SmartSVN有以下版本：</p><ol><li>SmartSVN enterprise 9 企业版</li><li>SmartSVN foundation 8 基础版</li></ol><p>由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。</p><h4 id="用基础版来说明创建版本库。"><a href="#用基础版来说明创建版本库。" class="headerlink" title="用基础版来说明创建版本库。"></a>用基础版来说明创建版本库。</h4><p>参考：<a href="http://hammadk.com/how-to-create-repository-in-smartsvn-tutorial/" target="_blank" rel="noopener">Create Repository in SmartSVN – Tutorial</a>  </p><ol><li>启动SmartSVN SmartSVN foundation 8 基础版  </li><li>菜单栏Project-&gt; set up Local Repository…<br>需要设置如下两个参数：  <ol start="3"><li>svnadmin 在终端执行： whereis svnadmin  </li><li>svnserve 在终端执行： whereis svnserve<br>￼<img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832" alt="image">  </li></ol></li><li>指定版本库的目录位置：<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/a3f00903-101c-4848-a10a-3479643baea7/screenshot.png?resizeSmall&amp;width=832" alt="image">  </li><li>初始化账户密码：<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/140f257e-e452-47ea-8317-34a5ed8d6c7f/screenshot.png?resizeSmall&amp;width=832" alt="image">  </li><li>完成。<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ed975623-72bb-4132-8d04-ac9a7b1d2fc9/screenshot.png?resizeSmall&amp;width=832" alt="image"><br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/53306789-9d97-485c-a54d-a143e7b078f1/screenshot.png?resizeSmall&amp;width=832" alt="image"><a id="more"></a>    <h5 id="开始导入项目源码，来跟踪版本变化，实现版本控制。"><a href="#开始导入项目源码，来跟踪版本变化，实现版本控制。" class="headerlink" title="开始导入项目源码，来跟踪版本变化，实现版本控制。"></a>开始导入项目源码，来跟踪版本变化，实现版本控制。</h5></li><li>新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ee02bf65-27e3-435a-8300-8189bc087eb8/screenshot.png?resizeSmall&amp;width=832" alt="image"></li><li>菜单栏Project -&gt; Import Into Repository…<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/eccc10f0-4c5a-435c-8397-062028d0d4f4.png?resizeSmall&amp;width=832" alt="image"></li><li>选择以上新建的SmartSVN版本库：svn://localhost<br><img src="https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ecfe16b4-17ac-4fc1-a64f-1ce259d77b3b/screenshot.png?resizeSmall&amp;width=832" alt="image"> </li></ol><p>查看是否安装SVN服务：</p><pre><code>svnserve —version</code></pre><p>SVN随系统一起启动：</p><pre><code>vi /etc/rc.local   //(此文件Mac系统中默认是不存在的，需手动创建)添加启动SVN服务： svnserve -d -r /data/svn/repos  </code></pre><p>关闭svn服务:</p><pre><code>直接ps aux | grep svn，然后kill -9 进程号</code></pre><ol><li><p>创建库:<br> 打印应用目录命令：</p><pre><code>whereis svn</code></pre><p> 新建版本库目录：</p><pre><code>sudo mkdir -p /data/svn/repos/local    chmod u+w 文件名</code></pre><p> 创建：</p><pre><code>sudo svnadmin create /data/svn/repos/local查看文件权限： ls -l</code></pre></li><li><p>配置版本库的访问权限</p><pre><code>cd conf/ </code></pre><ol><li><p>开启密码权限，普通用户/匿名用户</p><pre><code>sudo vi svnserve.conf</code></pre></li><li><p>设置用户：密码</p><pre><code>sudo vi passwd</code></pre></li><li><p>分组设置，组权限</p><pre><code>sudo vi authz</code></pre></li></ol></li><li><p>启动svnserve服务  </p><pre><code>sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log</code></pre></li><li><p>测试端口：</p><pre><code>telnet localhost 3690</code></pre></li><li><p>重启必先kill ：</p><pre><code>sudo kill PID</code></pre></li><li><p>版本库路径：</p><pre><code>svn://localhost/local</code></pre><p>其他：</p><pre><code>svn ls svn://svnpath 可以查询snv仓库内容  lsof -i :3690 查看svn是否启动  ps aux | grep ‘svn’ 查找所有svn启动的进程id  kill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程  </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 搭建 </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]Swift最佳实践</title>
      <link href="/2015/09/30/swift/%5B%E8%BD%AC%5DSwift%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2015/09/30/swift/%5B%E8%BD%AC%5DSwift%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>[英文][SwiftCommunityBestPractices]<br>[SwiftCommunityBestPractices]: <a href="https://github.com/schwa/Swift-Community-Best-Practices" target="_blank" rel="noopener">https://github.com/schwa/Swift-Community-Best-Practices</a><br>[SwiftCommunity]: <a href="http://swift-lang.schwa.io/" target="_blank" rel="noopener">http://swift-lang.schwa.io/</a><br>[swiftCaptureLists]: <a href="http://www.russbishop.net/swift-capture-lists" target="_blank" rel="noopener">http://www.russbishop.net/swift-capture-lists</a><br>[SwiftURL]: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html" target="_blank" rel="noopener">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html</a><br>[驼峰命名法URL]: <a href="http://www.wikiwand.com/en/Studly_caps" target="_blank" rel="noopener">http://www.wikiwand.com/en/Studly_caps</a><br>[匈牙利命名法URL]: <a href="http://www.wikiwand.com/en/Hungarian_notation" target="_blank" rel="noopener">http://www.wikiwand.com/en/Hungarian_notation</a></p><h2 id="黄金法则"><a href="#黄金法则" class="headerlink" title="黄金法则"></a>黄金法则</h2><ul><li>Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。</li><li>不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: “VehicleController”)。</p><p>变量与常量应该使用首字母小写的驼峰命名法(例如: “ vehicleName “ )。</p><p>推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。</p><p>不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 <code>SNAKE_CASE</code> 这样的名字。</p><p>这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Nepture</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>有必要的话命名不要缩写<br>实际上在 Xcode 的”文本自动补全”功能下你可以轻而易举地键入 类似 <code>ViewController</code> 的长命名。</li><li>极为常见的缩写<br>例如: <code>URL</code> 缩写应该是全部大写 ( “URL” )或者酌情全部小写( “url” )。<blockquote><p>URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。</p></blockquote></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。<br>如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。</p><p>(TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接)</p><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentLocation = <span class="type">Location</span>()</span><br></pre></td></tr></table></figure></p><p>而非：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentLocation: <span class="type">Location</span> = <span class="type">Location</span>()</span><br></pre></td></tr></table></figure><h3 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h3><p>让编译器自动推断所有的情况，这是可以做到的。在一些领域 <code>self</code> 应该被显式地使用，包括在 init 中设置参数，或者 <code>non-escaping</code>闭包。<br>例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">   <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">   <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">       <span class="keyword">self</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="捕获列表的类型推导"><a href="#捕获列表的类型推导" class="headerlink" title="捕获列表的类型推导"></a>捕获列表的类型推导</h3><p>在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">    (<span class="string">"Mary"</span>, <span class="number">42</span>),</span><br><span class="line">    (<span class="string">"Susan"</span>, <span class="number">27</span>),</span><br><span class="line">    (<span class="string">"Charlie"</span>, <span class="number">18</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = people.<span class="built_in">map</span>() &#123;</span><br><span class="line">    (name: <span class="type">String</span>, age: <span class="type">Int</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name) is \(age) years old"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译器可以推导出来的话，完全可以把类型删掉：<br><code>(name: String, age: Int) -&gt; String</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = people.<span class="built_in">map</span>() &#123;</span><br><span class="line">    (name, age) <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(name) is \(age) years old"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用编号的参数名 (“$0”) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。</p><p>Apple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。<br>例如，<code>optionals</code> 被删除或更改为 <code>auto-unwrapping</code> 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。</p><p>你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    ()-&gt;<span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Fired."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(以上内容也可以参考:[这里][swiftCaptureLists])</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>类型定义中使用的常量应当被申明成静态类型。例如:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PhysicsModel</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> speedOfLightInAVacuum = <span class="number">299_792_458</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spaceship</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">let</span> topSpeed = <span class="type">PhysicsModel</span>.speedOfLightInAVacuum</span><br><span class="line">      <span class="keyword">var</span> speed: <span class="type">Double</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">fullSpeedAhead</span><span class="params">()</span></span> &#123;</span><br><span class="line">       speed = <span class="type">Spaceship</span>.topSpeed</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将常量标示为 <code>static</code> ，允许它们可以被无类型的实例引用。</p><p>一般应该避免生成全局范围的常量，单例除外。</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装gitLab服务器</title>
      <link href="/2015/09/28/git/Mac%E5%AE%89%E8%A3%85gitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2015/09/28/git/Mac%E5%AE%89%E8%A3%85gitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组*开启gitlab用户的远程登录</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p><pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab</code></pre><p>显示git用户</p><pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList</code></pre><h4 id="添加系统账户gitlab"><a href="#添加系统账户gitlab" class="headerlink" title="添加系统账户gitlab"></a>添加系统账户gitlab</h4><h6 id="生成gitlab服务器目录，即用户根目录"><a href="#生成gitlab服务器目录，即用户根目录" class="headerlink" title="生成gitlab服务器目录，即用户根目录"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p><h6 id="安装-Gitlab-Shell"><a href="#安装-Gitlab-Shell" class="headerlink" title="安装 Gitlab Shell"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlabsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.gitcd gitlab-shellsudo -u gitlab git checkout v1.9.1sudo -u gitlab cp config.yml.example config.yml</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p><pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\/home\//\/Users\//g&quot; config.ymlsudo -u gitlab sed -i &quot;&quot; &quot;s/\/usr\/bin\/redis-cli/\/usr\/local\/bin\/redis-cli/&quot; config.yml</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p><h6 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h6><p>先下载gitlab</p><pre><code>cd /Users/gitlabsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.gitcd gitlabsudo -u gitlab git checkout 6-7-stable</code></pre><p>配置gitlab</p><pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.ymlsudo -u gitlab sed -i &quot;&quot; &quot;s/\/usr\/bin\/git/\/usr\/local\/bin\/git/g&quot; config/gitlab.ymlsudo -u gitlab sed -i &quot;&quot; &quot;s/\/home/\/Users/g&quot; config/gitlab.ymlsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p><pre><code># Login to MySQL$ mysql -u root -p# Create the GitLab production databasemysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;# Create the MySQL User change $password to a real passwordmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;# Grant proper permissions to the MySQL Usermysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;</code></pre><h6 id="安装-Gitolite帮助管理git内部用户"><a href="#安装-Gitolite帮助管理git内部用户" class="headerlink" title="安装 Gitolite帮助管理git内部用户"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p><pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite</code></pre><p>安装：</p><pre><code>cd /Users/gitlabsudo -u gitlab -H mkdir binsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\$PATH:/Users/gitlab/bin\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;sudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;sudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pubsudo chmod 0444 /Users/gitlab/gitlab.pubsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;</code></pre><p>为 Git 创建用户：    </p><pre><code>sudo adduser \  --system \  --shell /bin/sh \  --gecos &apos;git version control&apos; \  --group \  --disabled-password \  --home /home/git \  git</code></pre><p>若干问题解决办法：<a href="http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html" target="_blank" rel="noopener">Mac搭建Git服务器—开启SSH</a></p><pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...ssh: connect to host localhost port 22: Connection refusedfatal: Could not read from remote repository.</code></pre><p>SSH无密码登陆设置：</p><pre><code>$ cd /etc$ chmod 666 sshd_config$ vim sshd_config#PermitRootLogin yes  改为：PermitRootLogin no#UsePAM yes             改为: UsePAM no</code></pre><p>Remove the # from the following</p><pre><code>#RSAAuthentication yes#PubkeyAuthentication yes#AuthorizedKeysFile     .ssh/authorized_keys    #PasswordAuthentication no#PermitEmptyPasswords no</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> gitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
            <tag> gitLab </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米路由常用操作</title>
      <link href="/2015/09/26/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2015/09/26/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol><li><p>ssh登录</p><pre><code>局域网登录:ssh [user@]hostname [command] 例如：ssh root@192.168.31.1  或  远程登录：ssh root@222.35.145.28 -p 2195回车输入密码**修改密码：**root@xiaoqiang:~#passwd   回车输入新密码回车再次输入新密码</code></pre></li><li><p>远程拷贝数据</p><pre><code>scp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx</code></pre></li><li><p>每次重启路由获取IP:</p><pre><code>vi /etc/rc.localsh /etc/getIP.sh</code></pre><p>//启动后，等待20秒，然后，获取当前时间作为文件名称<br>//使用ifconfig 获取路由器的ip信息<br>//使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行<br>// &gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中<br>//通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中<br>//查看该文件，既有路由重启后的当前IP  </p><a id="more"></a><p> 详见getIP.sh</p><pre><code>#!/bin/shsleep 20current_date=`date +%Y_%m_%d`current_time=`date +%H_%M_%S`echo $current_dateecho $current_time#local_ip=`ifconfig |grep &apos;[0-9]\{1,3\}.*P-t-P&apos;`local_ip=`ifconfig | grep P-t-P`echo $local_ip &gt; /userdisk/data/my/ip/$current_date:$current_time.txt</code></pre></li><li><p>修改防火墙设置<strong>/etc/config</strong>目录下的<strong>dropbear</strong>和<strong>firewall</strong>  </p><pre><code>cd /etc/config  //把备份文件内容覆盖新文件即可1.cat dropbear.bak &gt; dropbear      增加如下内容：    config dropbear    option PasswordAuth &apos;on&apos;    option RootPasswordAuth &apos;on&apos;    option Interface &apos;wan&apos;    option Port &apos;2195&apos;2.保存文件修改后，再重启dropbear服务，一次输入下面两行命令：    /etc/init.d/dropbear reload    /etc/init.d/dropbear restart1.cat firewall.bak &gt; firewall    增加如下内容：     config rule    option name &apos;Allow-wan-ssh&apos;    option src &apos;wan&apos;    option proto &apos;tcp&apos;    option dest_port &apos;2195&apos;    option target &apos;ACCEPT&apos;2.保存文档的更改后，重启防火墙服务，依次输入以下两条命令：    /etc/init.d/firewall reload    /etc/init.d/firewall restart</code></pre></li></ol><p>5.由于铁通机制，分配的独立iP，并不能被外网访问</p><h4 id="ssh登录数据库-转"><a href="#ssh登录数据库-转" class="headerlink" title="ssh登录数据库    转"></a>ssh登录数据库    <a href="http://bbs.xiaomi.cn/thread-10339070-1-1.html" target="_blank" rel="noopener">转</a></h4><p>先确保能访问<a href="http://192.168.31.1:8088/phpinfo.php" target="_blank" rel="noopener">LLMP搭建的个人网站地址</a>  </p><p>修复教程：  </p><ol><li>登录路由： <code>ssh root@192.168.31.1</code>  mm:admin</li><li>执行命令：<code>/userdisk/data/lamp.sh fix</code>  </li><li><p>再次访问个人网站地址。  <a href="http://192.168.31.1:8088/phpinfo.php" target="_blank" rel="noopener">LLMP搭建的个人网站地址</a> 。 </p><pre><code>1./userdisk/data/lamp.sh  (安装本插件，一键开启llmp，具体安装过程可见前面的安装步骤）       2./userdisk/data/lamp.sh a（卸载本插件，恢复安装前，注：卸载本插件时路由器会自动重启一次，自动断网几分钟）3./userdisk/data/lamp.sh fix（升级小米路由器固件后，能瞬间恢复自己搭建的网站功能，另外，如果在极特殊的情况的情况下，本功能无效，可使用如下方法恢复自建网站的功能：先尝试重新安装本插件，如果提示不能重复安装，可先卸载本插件，再重新安装本插件，并按说明3对数据库执行修改密码命令，改回原来的密码，原来自己搭建网站就可恢复使用）4./userdisk/data/lamp.sh help  (插件用法的帮助信息）</code></pre></li></ol><p>登录数据库：<code>ssh mysql@192.168.31.1 -p 2222</code></p><p>正确日志：</p><pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222The authenticity of host &apos;[192.168.31.1]:2222 ([192.168.31.1]:2222)&apos; can&apos;t be established.RSA key fingerprint is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[192.168.31.1]:2222&apos; (RSA) to the list of known hosts.mysql@192.168.31.1&apos;s password:adminBusyBox v1.19.4 (2015-05-08 18:41:26 CST) built-in shell (ash)Enter &apos;help&apos; for a list of built-in commands.    ~ $</code></pre><p>错误日志：<br>需要修改本地的ssh配置。</p><ol><li>vi /Users/admin/.ssh/known_hosts文件</li><li>删除包含[192.168.31.1]:2222的一行内容。</li><li><p>重新登录数据库：ssh <a href="mailto:mysql@192.168.31.1" target="_blank" rel="noopener">mysql@192.168.31.1</a> -p 2222。  </p><pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.Please contact your system administrator.Add correct host key in /Users/admin/.ssh/known_hosts to get rid of this message.Offending RSA key in /Users/admin/.ssh/known_hosts:10RSA host key for [192.168.31.1]:2222 has changed and you have requested strict checking.Host key verification failed.</code></pre></li></ol><h5 id="客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库"><a href="#客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库" class="headerlink" title="客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库"></a>客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库</h5>]]></content>
      
      
      <categories>
          
          <category> 智能设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> 小米路由 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode7编译发布问题</title>
      <link href="/2015/09/25/%E7%BC%96%E8%AF%91/Xcode7%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/"/>
      <url>/2015/09/25/%E7%BC%96%E8%AF%91/Xcode7%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Xcode7编译发布问题"><a href="#Xcode7编译发布问题" class="headerlink" title="Xcode7编译发布问题"></a>Xcode7编译发布问题</h4><ol><li><p>ERROR ITMS-90535: “Unexpected CFBundleExecutable Key. The bundle at ‘Payload/PBBReader.app/TencentOpenApi_IOS_Bundle.bundle’ does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.”</p><p> 解决办法：搜索CFBundleExecutable 字段，删除所有第三方框架中的info.plist文件中包含的字段，重新打包上传。</p></li></ol><ol start="2"><li>ERROR ITMS-90475: “Invalid Bundle. iPad Multitasking support requires launch story board in bundle ‘pyc.com.cn.pbbReader’.”</li><li><p>苹果邮件：We have discovered one or more issues with your recent delivery for “PBB Reader”. To process your delivery, the following issues must be corrected:<br>Invalid Bundle - A nested bundle doesn’t have the right platforms listed in CFBundleSupportedPlatforms Info.plist key.</p></li><li><p>IOS9访问网络设置：<strong>NSAppTransportSecurity</strong> 字典，字段：<strong>NSAllowsArbitraryLoads</strong>  字段值：<strong>YES</strong></p></li><li>搜索Target对应的build setting中，把<strong>bitCode</strong>支持设置为NO</li><li><a href="http://onevcat.com/2015/06/multitasking/" target="_blank" rel="noopener">iPad 中的多任务适配</a><br>如果你不想你的 app 可以作为多任务的副 app 被使用的话，你可以在 Info.plist 中添加 <strong>UIRequiresFullScreen</strong> 并将其设为 <strong>YES</strong></li><li>对第三方SDK后台运行，有严格的把控，要求bundle资源必须为最新有效，上传包时必要条件</li></ol><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>退回Xcode6.4,进行打包发布</p><h4 id="Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package"><a href="#Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package" class="headerlink" title="Cannot proceed with delivery: an existing transporter instance is currently uploading this package"></a>Cannot proceed with delivery: an existing transporter instance is currently uploading this package</h4><p>把Application Loader(XCode-&gt;Organizer-&gt;Archived Applications-&gt;Submit)中正在上传的文件中断或者删除，再次Submit提示：<br>Cannot proceed with delivery: an existing transporter instance is currently uploading this package。<br>无论如何Clean All、重新Submit都失败，给出上述提示。<br>原因：上传的动作被记录在UploadToken中了。<br>解决方法：<br>（1）打开终端，输入cd，到达个人用户目录下。<br>（2）输入ls -a，可以看到一个隐藏的目录 .itmstransporter<br>（3）cd .itmstransporter/UploadTokens<br>（4）ls ，可以看到一个类似 xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token文件<br>（5）nano  xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token，在里面把内容都删除，保存。<br>（6）重新在Organizer里面submit，ok了  </p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 编译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode和Jenkins持续集成的几种实现方式</title>
      <link href="/2015/09/19/macOS/Xcode%E5%92%8CJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2015/09/19/macOS/Xcode%E5%92%8CJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="CI服务器"><a href="#CI服务器" class="headerlink" title="CI服务器"></a>CI服务器</h2><p>写到这儿，对于iOS开发者来说，需要准备好：</p><ul><li>一个比较容易获取的源代码仓库(包含源代码)</li><li>一套自动化构建脚本</li><li>一系列围绕构建的可执行测试  </li></ul><p>接下来就需要一个CI服务器来根据源代码的变更触发构建，监控测试结果。</p><p>目前，业界比较流行的，支持iOS构建的CI服务器有</p><ul><li><a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a>：是一个免费的云服务平台，基本上支持所有目前主流的语言，Object-C自然也在其中，但是只支持github极大的限制了其应用场景。目前国内无法访问，<a href="http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part3" target="_blank" rel="noopener">详见</a></li><li><strong>Jenkins</strong>：经过多年的发展，其活跃的社区和丰富的插件让其成为了业界最受欢迎的CI服务器。通过使用Xcode插件，可以非常方便在Jenkins中运行iOS项目的构建脚本。</li></ul><a id="more"></a><h2 id="xcode-持续集成的实现"><a href="#xcode-持续集成的实现" class="headerlink" title="xcode 持续集成的实现"></a>xcode 持续集成的实现</h2><p><a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1" target="_blank" rel="noopener">Setting Up Xcode Server</a></p><p>jenkins使用配置：  </p><ol><li>下载：<a href="http://mirrors.jenkins-ci.org/war/lastest/jenkins.war" target="_blank" rel="noopener">http://mirrors.jenkins-ci.org/war/lastest/jenkins.war</a>  </li><li><p>运行命令行：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  nohup java -jar ~/Downloads/jenkins.war —httpPort=8081 —ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp;</span><br><span class="line">```  </span><br><span class="line">3. 写入启动文件中，起别名</span><br></pre></td></tr></table></figure><p> vi /Users/(username)/.bash_profile<br> 输入:alias jenkins=”nohup java -jar ~/Downloads/SVNRepos/jenkins.war –httpPort=8081 –ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp;”  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">4. 启动时，在命令行中输入：**`jenkins`** 回车  即可启动</span><br><span class="line">5. 访问：http://127.0.0.1:8081/</span><br><span class="line">6. 重启：http://[jenkins-server]/[command] exit推出，restart重启，reload重载。</span><br><span class="line"></span><br><span class="line">#### 方法二：</span><br><span class="line">安装jenkins还是使用brew</span><br><span class="line"></span><br><span class="line">brew install jenkins</span><br><span class="line">安装好之后，可以通过使用命令行启动</span><br><span class="line"></span><br><span class="line">java -jar /usr/local/opt/jenkins/libexec/jenkins.war</span><br><span class="line">如果想**开机自动启动**，需要先执行以下命令，创建启动项：</span><br><span class="line"></span><br><span class="line">ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</span><br><span class="line">可以编辑一下~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist这个文件</span><br><span class="line"></span><br><span class="line">open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class="line"></span><br><span class="line">具体内容：</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;homebrew.mxcl.jenkins&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">      &lt;string&gt;/usr/bin/java&lt;/string&gt;</span><br><span class="line">      &lt;string&gt;-Dmail.smtp.starttls.enable=true&lt;/string&gt;</span><br><span class="line">      &lt;string&gt;-jar&lt;/string&gt;</span><br><span class="line">      &lt;string&gt;/usr/local/opt/jenkins/libexec/jenkins.war&lt;/string&gt;</span><br><span class="line">      &lt;string&gt;--httpListenAddress=127.0.0.1&lt;/string&gt;</span><br><span class="line">      &lt;string&gt;--httpPort=8088&lt;/string&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line"></span><br><span class="line">想要让局域网都可以访问或修改端口号，需要把—httpListenAddress=127.0.0.1改成自己的局域网IP  </span><br><span class="line"></span><br><span class="line">手动启动启动项可以执行,制作替身：</span><br><span class="line"></span><br><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist  </span><br><span class="line">之后用浏览器就可以访问 **http://localhost:8088/** 来登录jenkins了</span><br><span class="line"></span><br><span class="line">#### 方法三：</span><br><span class="line">使用tomcat</span><br><span class="line">制作替身：</span><br><span class="line"></span><br><span class="line">cd ~/Downloads/soft/Tomcat/</span><br><span class="line">ln -sfv apache-tomcat-8.0.27 tomcat</span><br><span class="line"></span><br><span class="line">将jenkins.war拷贝到 $tomcat/webapp下面。  </span><br><span class="line"></span><br><span class="line"> $tomcat/bin/start.sh  </span><br><span class="line">用浏览器打开 **localhost:8080/jenkins** tomcat默认端口号为8080，就可以看到 jenkin运行了。</span><br><span class="line"></span><br><span class="line">#### 自动化构建和依赖管理[参考](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part1/)</span><br><span class="line">作为以GUI和命令行操作结合的完美性著称的苹果公司来说，当然也不会忘记为自己的封闭的iOS系统提供开发环境下命令行编译工具：xcodebuild</span><br><span class="line">在介绍xcodebuild之前，需要先弄清楚一些在XCode环境下的一些概念【4】：</span><br><span class="line"></span><br><span class="line">- **Workspace**：简单来说，Workspace就是一个容器，在该容器中可以存放多个你创建的Xcode Project， 以及其他的项目中需要使用到的文件。使用Workspace的好处有，1),扩展项目的可视域，即可以在多个项目之间跳转，重构，一个项目可以使用另一个项目的输出。Workspace会负责各个Project之间提供各种相互依赖的关系;2),多个项目之间共享Build目录。</span><br><span class="line">- **Project**：指一个项目，该项目会负责管理生成一个或者多个软件产品的全部文件和配置，一个Project可以包含多个Target。</span><br><span class="line">- **Target**：一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。</span><br><span class="line">- **Scheme**：一个定义好构建过程的Target成为一个Scheme。可在Scheme中定义的Target的构建过程有：Build/Run/Test/Profile/Analyze/Archive</span><br><span class="line">- **BuildSetting**：配置产品的Build设置，比方说，使用哪个Architectures？使用哪个版本的SDK？。在Xcode Project中，有Project级别的Build Setting，也有Target级别的Build Setting。Build一个产品时一定是针对某个Target的，因此，XCode中总是优先选择Target的Build Setting，如果Target没有配置，则会使用Project的Build Setting。</span><br><span class="line"></span><br><span class="line">xcodebuild就是用了构建产品的命令行工具，其用法可以归结为3个部分：</span><br><span class="line"></span><br><span class="line">- 可构建的对象</span><br><span class="line">- 构建行为</span><br><span class="line">- 一些其他的辅助命令</span><br><span class="line"></span><br><span class="line">可以构建的对象有，默认情况下会运行project下的第一个target：</span><br><span class="line"></span><br><span class="line">- workspace：必须和“-scheme”一起使用，构建该workspace下的一个scheme。</span><br><span class="line">- project：当根目录下有多个Project的时候，必须使用“-project”指定project，然后会运行</span><br><span class="line">- target：构建某个Target</span><br><span class="line">- scheme：和“-workspace”一起使用，指定构建的scheme。</span><br><span class="line">- ……</span><br><span class="line"></span><br><span class="line">构建行为包括：</span><br><span class="line"></span><br><span class="line">- clean:清除build目录下的</span><br><span class="line">- build: 构建</span><br><span class="line">- test: 测试某个scheme，必须和&quot;-scheme&quot;一起使用</span><br><span class="line">- archive:打包，必须和“-scheme”一起使用</span><br><span class="line">- ……</span><br><span class="line">辅助命令包括：</span><br><span class="line"></span><br><span class="line">- -sdk：指定构建使用的SDK</span><br><span class="line">- -list：列出当前项目下所有的Target和scheme。</span><br><span class="line">- -version：版本信息</span><br><span class="line">- …...</span><br><span class="line">关于xcodebuild更多详细的命令行请参见：[点击](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html)</span><br><span class="line"></span><br><span class="line">xcodebuild的主要缺陷：</span><br><span class="line"></span><br><span class="line">- 其脚本输出的可读性极差，</span><br><span class="line">- 只能要么完整的运行一个target或者scheme，要么全部不运行。不能指定运行Target中特定的测试。</span><br><span class="line"></span><br><span class="line">**安装xctool** </span><br><span class="line"></span><br><span class="line">xctool的安装非常简单，只需要clone xctool的repository到项目根目录就可以使用， 如果你的机器上安装有Homebrew，可以通过“brew install xctool”命令直接安装。（**注意：使用xctool前一定要首先确认xcodebuild已安装且能正确工作**）。</span><br><span class="line"></span><br><span class="line">**用法**</span><br><span class="line"></span><br><span class="line">关于xctool的用法就更加人性化了，几乎可以重用所有的xcodebuild的指令，配置。只需要注意一下几点：</span><br><span class="line"></span><br><span class="line">- xctool不支持target构建，只能使用scheme构建。</span><br><span class="line">- 支持“-only”指令运行指定的测试。</span><br><span class="line">- 支持多种格式的build报告。</span><br><span class="line">例子：</span><br><span class="line">```ruby</span><br><span class="line">path/to/xctool.sh </span><br><span class="line">  -workspaceYourWorkspace.xcworkspace</span><br><span class="line">  -schemeYourScheme</span><br><span class="line">test -only SomeTestTarget:SomeTestClass/testSomeMethod</span><br></pre></td></tr></table></figure></li></ol><h4 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h4><p>这儿的想谈的“部署”不是传统意义上的直接部署到产品环境的部署，而是指如何把最新版本的应用快速的部署到测试用户的机器上以收集反馈，或者做一些探索性的测试。  </p><p>在我写第一个iOS应用的时候，我想把应用安装到多个机器上测试的时候，需要非常繁琐的步骤：</p><ul><li>需要申请到苹果开发者账号，获得开发者证书。</li><li>需要在苹果的开发者网站上注册我想使用的设备。</li><li>使用开发者证书打包应用，使用Ad-HOC部署模式，生成ipa文件。</li><li>通过ipa文件把应用安装到iTunes上。</li><li>通过iTunes把应用同步到多台测试机器上。</li></ul><p>如果是测试机器在多个地理位置的时候，还需要把ipa文件发送到对应的地点，每个地点都需要重复的做第4，5步。 这样一个繁琐，且低效的过程让开发者非常痛苦，直到TestFlight的出现。</p><h4 id="TestFlight"><a href="#TestFlight" class="headerlink" title="TestFlight"></a>TestFlight</h4><p>TestFlight：就是一个专门解决上面提到的痛点的云服务方案，它可以帮助开发者：</p><ul><li>轻松采集测试用户的UDID和iOS 版本、硬件版本，并发送给开发者。</li><li>实时反馈应用是否成功安装到测试机器</li><li>轻松部署最新版本应用到测试用机上。</li><li>开发者可以灵活选择部署哪个版本到哪部分测试机器上。</li></ul><p>使用使用Test Flight服务非常简单，只需要到Test Flight注册一个账号。然后把链接发送给测试设备，测试设备只要打开该链接，并授权给Test Flight，在Test Flight的设备中心就可以看到这些设备。</p><h4 id="使用jenkins-calabash-cocoapods搭建ios持续集成环境"><a href="#使用jenkins-calabash-cocoapods搭建ios持续集成环境" class="headerlink" title="使用jenkins+calabash+cocoapods搭建ios持续集成环境"></a><a href="http://blog.csdn.net/zangcw/article/details/25299243" target="_blank" rel="noopener">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></h4><ol><li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li><li><p>安装Calabash  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure></li><li><p>安装Calabash中文支持包  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure></li></ol><h4 id="For-automatic-setup"><a href="#For-automatic-setup" class="headerlink" title="For automatic setup:"></a>For automatic setup:</h4><ol><li><p>In a terminal, go to your iOS project  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class="line">```  </span><br><span class="line">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure><p> gem install calabash-cucumber</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure><p> calabash-ios setup  //Answer the questions and read the output :)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure><p> calabash-ios gen</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. In Xcode, build your project using the -cal scheme</span><br><span class="line"></span><br><span class="line">6. Run the generated test!</span><br></pre></td></tr></table></figure><p> cucumber<br> <code>`</code></p></li></ol><p>If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</p><h4 id="cucumber官网"><a href="#cucumber官网" class="headerlink" title="cucumber官网"></a><a href="https://cukes.info/" target="_blank" rel="noopener">cucumber官网</a></h4><pre><code>* Feature（功能）  * Scenario（情景）  *  Given（给定）  *  When（当）  *  Then（则） </code></pre><h5 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a><a href="http://www.educity.cn/se/619226.html" target="_blank" rel="noopener">运行原理</a></h5><p><img src="http://img.educity.cn/img_7/262/2013122000/125005907.jpg" alt="image"><br>cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </p><h5 id="结构框架"><a href="#结构框架" class="headerlink" title="结构框架"></a>结构框架</h5><p>calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。<br><img src="http://img.educity.cn/img_7/262/2013122000/126005907.jpg" alt="image"><br>feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。<br>再看一下其中的内容：</p><pre><code>　　my_first.feature　　Feature： 登陆　　Scenario： 输入正确的用户名密码能够正常登陆　　When 打开登陆页面　　And    输入用户名XXX输入密码XXX　　And   点击登陆　　Then  验证登陆成功</code></pre><p>　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。<br>如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，<br>那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</p><pre><code>When /^ 输入用户名\&quot;([^\\\&quot;]*)\&quot; 输入密码\&quot;([^\\\&quot;]*)\&quot;  $/ do |username，password|performAction(&apos;enter_text_into_numbered_field&apos;，username，1)performAction(&apos;enter_text_into_numbered_field&apos;，password，2)end</code></pre><p>现在应该能明白为什么你需要写汉字的脚本就可以了吧。<br>在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。<br>还是以这个登录脚本为例：</p><pre><code>假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</code></pre><h5 id="运行报告"><a href="#运行报告" class="headerlink" title="运行报告"></a>运行报告</h5><p>alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</p><p>　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告<br>　　<img src="http://img.educity.cn/img_7/262/2013122000/127005907.jpg" alt="image"></p><p><a href="http://blog.csdn.net/qs_csu/article/details/9000262" target="_blank" rel="noopener">【cucumber解析features文件】</a>         </p><ol><li><p>my_first.feature: 描述在这个条件下需要做什么事情；</p><pre><code>Feature: Running a test    As an iOS developer    I want to have a sample feature file    So I can begin testing quickly  Scenario: Example steps1    Given I am on the Welcome Screen    Then I swipe left    And I wait until I don&apos;t see &quot;Please swipe left&quot;    And take picture  Scenario: Example steps2    Given I am on the Welcome Screen   #ASSERTION    Then I should see a &quot;login&quot; button   #INPUT TEXT    Then I enter &quot;my_username&quot; into text field number 1  #  Then I touch &quot;Return&quot;   #TOGGLE SWITCH    Then I toggle the switch    Then I touch &quot;Login&quot;    And I touch &quot;Second&quot;    And take picture  </code></pre><p> 该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </p></li><li><p>my_first_step.rb: 解释了Given的具体条件</p><pre><code>Given /^I am on the Welcome Screen$/ do    element_exists(&quot;view&quot;)    check_element_exists(&quot;label text:&apos;First View&apos;&quot;)    sleep(STEP_PSEAU)  end</code></pre><p> 这个语句，判定了当前条件”on the Welcome Screen”是否满足，如果element存在，则就在”Welcome Screen”；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDD </tag>
            
            <tag> BDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mupdf集成pyc加密算法</title>
      <link href="/2015/08/14/%E7%BC%96%E8%AF%91/mupdf%E9%9B%86%E6%88%90pyc%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2015/08/14/%E7%BC%96%E8%AF%91/mupdf%E9%9B%86%E6%88%90pyc%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="加密算法中区分64位"><a href="#加密算法中区分64位" class="headerlink" title="加密算法中区分64位"></a>加密算法中区分64位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span><br><span class="line">    #ifndef uint32</span><br><span class="line">        #define uint32 unsigned int</span><br><span class="line">    #endif</span><br><span class="line">#else</span><br><span class="line">    #ifndef uint32</span><br><span class="line">        #define uint32 unsigned long int</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol><li>把SMS4.h文件内容合并到include/mupdf/fitz/stream.h文件中，然后删除SMS4.h文件</li><li>把SMS4.c文件内容合并到source/fitz/stream-open.c 文件中，然后删除SMS4.c</li><li>在include/mupdf/fitz/stream.h增加以下内容:  用于方法声明，供其他类使用。<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> void set_key_info(char* key, long long code_len);  </span><br><span class="line">int pbb_read(int fd, unsigned char *buf, int size);  </span><br><span class="line">int fpbb_read(unsigned char *buf, int count, int size, FILE* fp);  </span><br><span class="line"> ```  </span><br><span class="line">4. 替换source/pdf/pdf-write.c  2530：fread 替换为 fpbb_read</span><br><span class="line">5. 替换source/fitz/stream-prog.c  57: read 替换为  pbb_read</span><br><span class="line">6. 替换source/fitz/stream-open.c  73: read 替换为  pbb_read </span><br><span class="line">7. 配置document Type    public.data,public.centent</span><br><span class="line"></span><br><span class="line">传递秘钥：</span><br></pre></td></tr></table></figure></li></ol><p>char keycode[] = {-12,7,106,95,82,118,-64,-78,-98,5,-3,-128,-28,95,-84,120};<br>long long keylength = 37761;<br>set_key_info(keycode, keylength);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### ijkplayer</span><br><span class="line">- https://github.com/kolyvan/kxmovie.git  </span><br><span class="line">- https://github.com/Bilibili/ijkplayer.git</span><br><span class="line">- 支持所有视频格式的操作：</span><br><span class="line">- cd ijkplyer-master/config/</span><br><span class="line">- rm module.sh</span><br><span class="line">- ln -s module-default.sh module.sh</span><br><span class="line">- 加密集成  </span><br><span class="line">  - 处理文件的目录位置：ijkplyer-master/ios/ffmpeg-arm64,armv7,armv7s,i386,x86_64/libavformat目录</span><br><span class="line">  - 把pyckey.h,sms4.h文件内容移动到处理文件目录中的avformat.h文件中</span><br><span class="line">  - 把pyckey.c, sms4.c文件内容移动到处理文件目录中的file.c文件中  </span><br><span class="line">  - 将extra.tar.gz解压，放入ijkplayer-master/extra目录下 </span><br><span class="line">  - 暴漏头文件，编辑目录中的Makefile文件</span><br><span class="line">  - - HEADERS = 新增.h文件，例如:url.h</span><br><span class="line">  - - OBJS = 新增.o文件，例如:url.o</span><br></pre></td></tr></table></figure></p><p>  注意：要替换ios目录下针对不同内核的目录arm64,armv7,armv7s,i386，都需要操作如上步骤。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">然后，在IOS目录下执行编译命令脚本集合文件:</span><br></pre></td></tr></table></figure></p><p>  ./compile-ffmpeg.sh clean<br>  ./compile-ffmpeg.sh all<br><code>`</code></p><h4 id="将ijkplayer集成到自己的项目中"><a href="#将ijkplayer集成到自己的项目中" class="headerlink" title="将ijkplayer集成到自己的项目中"></a>将ijkplayer集成到自己的项目中</h4><ol><li>将ijkplayer-master/ios、目录下的IJKMediaPlayer目录拷贝到自己项目的同目录下</li><li>打开自己的项目，将IJKMediaPlayer.xcodeproj项目文件拖入自己项目中</li><li>选择项目名称，配置Targets<ul><li>选中 build phases标签，添加 Target Dpendencies  ，选中IJKMediaFramework 添加即可。 </li></ul></li><li>因为移动了IJK项目目录到本项目，需要重新配置IJKMediaPlayer中文件关联设置<ul><li>需要将ijkplayer-master/目录下的ijkmedia目录中的ijkplayer目录和ijksdl目录(Android.mk除外)，拷贝到IJKMediaPlyaer项目的IJKMediaPlyaer/IJKMediaPllayer/ijkmedia/目录下</li><li>需要将编译后得到的静态库（ijkplayer-master/ios/build/universal/目录）拷贝至IJKMediaPlayer目录：$(PROJECT_DIR)/ffmpeg/universal/lib</li><li>选中IJKMediaPlayer项目名称，配置Targets</li><li>选中 build Setting标签：<br><strong>设置HeaderSearch Paths</strong>:$(PROJECT_DIR)/IJKMediaPlayer/ijkmedia $(PROJECT_DIR)/ffmpeg/universal/include<br><strong>设置Library Search Paths</strong>:$(PROJECT_DIR)/ffmpeg/universal/lib  </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速正确的安装Ruby,Rails运行环境</title>
      <link href="/2015/01/22/shell/%E5%BF%AB%E9%80%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%89%E8%A3%85Ruby,Rails%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2015/01/22/shell/%E5%BF%AB%E9%80%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%89%E8%A3%85Ruby,Rails%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>安装ruby环境：<br>方法一：下载源码，编译安装：<a href="http://fsjoy.blog.51cto.com/318484/115045/" target="_blank" rel="noopener">配置中制定安装目录</a><br>方法二：使用rvm安装：<a href="https://ruby-china.org/wiki/rvm-guide" target="_blank" rel="noopener">可以提供一个便捷的多版本 Ruby 环境的管理和切换</a><br>方法三：使用macport安装 <code>port install ruby</code></p><p><a href="https://ruby-china.org/wiki/install_ruby_guide" target="_blank" rel="noopener">详细教程</a></p><p>问题：<br><code>ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rake</code><br><a href="http://stackoverflow.com/questions/30812777/cannot-install-cocoa-pods-after-uninstalling-results-in-error/30851030#30851030" target="_blank" rel="noopener">stackoverflow方法</a>测试结果没走通。<br>最终通过<a href="http://tadaland.com/os-x-rootless.html" target="_blank" rel="noopener">OS X 10.11中Rootless的实现与解释以及关闭方法</a>解决.</p><h4 id="Gem介绍"><a href="#Gem介绍" class="headerlink" title="Gem介绍"></a>Gem介绍</h4><p>Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。</p><p>Ruby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。<br><a id="more"></a></p><h4 id="升级RubyGem"><a href="#升级RubyGem" class="headerlink" title="升级RubyGem"></a>升级RubyGem</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem update --system</span><br></pre></td></tr></table></figure><h4 id="安装新的Gem"><a href="#安装新的Gem" class="headerlink" title="安装新的Gem"></a>安装新的Gem</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rai</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/指定安装某一版本的Gem包</span></span><br><span class="line"><span class="regexp">gem install [gemname] --version=1.3.2</span></span><br></pre></td></tr></table></figure><p>在安装过程中可以看到如下提示，说明它是从rubygems.org内去寻找并安装gem package的。<br>Fetching source index for <a href="http://rubygems.org/" target="_blank" rel="noopener">http://rubygems.org/</a></p><h4 id="gem-的安装方式"><a href="#gem-的安装方式" class="headerlink" title="gem 的安装方式"></a>gem 的安装方式</h4><h4 id="MacPorts安装和使用"><a href="#MacPorts安装和使用" class="headerlink" title="MacPorts安装和使用"></a>MacPorts安装和使用</h4><p><a href="http://ccvita.com/434.html" target="_blank" rel="noopener">http://ccvita.com/434.html</a><br><a href="http://guide.macports.org" target="_blank" rel="noopener">http://guide.macports.org</a><br><a href="http://www.fantageek.com/318/install-pkg-config-for-mac-osx/" target="_blank" rel="noopener">http://www.fantageek.com/318/install-pkg-config-for-mac-osx/</a>  </p><p>Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。</p><p>安装后，配置：</p><pre><code>sudo vi /etc/profileexport PATH=/opt/local/bin:$PATHexport PATH=/opt/local/sbin:$PATH</code></pre><p>MacPorts使用 <a href="http://witcheryne.iteye.com/blog/991821" target="_blank" rel="noopener">http://witcheryne.iteye.com/blog/991821</a></p><ol><li><p>更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。<br>sudo port -v selfupdate</p></li><li><p>搜索索引中的软件</p><p> port search name</p></li><li><p>安装新软件<br>sudo port install name</p></li><li><p>卸载软件<br>sudo port uninstall name</p></li><li><p>查看有更新的软件以及版本<br>port outdated</p></li><li><p>升级可以更新的软件<br>sudo port upgrade outdated</p></li></ol><p>实例：<br>Eclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装</p><pre><code>sudo port install subversion-javahlbindingsinstalled </code></pre><p>列出全部或者指定的已经安装的软件：</p><pre><code>port installedport -v installed atlas</code></pre><p>dependents 查看哪些软件时依赖与这个软件的</p><pre><code>删除一个软件时候，最好先执行一下这个命令.    port dependents openssl</code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 脚本 </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IAP开发步骤</title>
      <link href="/2015/01/20/jinhe%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/"/>
      <url>/2015/01/20/jinhe%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>dev定制 服务器：110<br>用户名：jinherDev  密码  i@sJH110dZ</p><p>test定制 服务器:105<br>用户名：jinherTest  密码  i@sJH105dZ</p><p>备注：test需要和其他项目沟通，确定test环境没有被占用，才可以进行test部署。<br>建议：当被占用时，本地打tag，以便在等待的同时，进行下步任务。</p><p>正式 定制 服务器: 192.168.10.124<br>用户名：jinher1 密码  i@sJH224dZ</p><p>备注：test提测之后，等待产品经理通知，然后发布到正式服务器上。</p><p>主工程发布流程：</p><ol><li>完成开发之后，可以在组件工程中编译.a静态库。</li><li>pull git服务器端的最新代码 ，再将第一步静态替换到正式的主工程中。</li><li><p>push 主工程master主分支项目到git远程库中。</p></li><li><p>进入主工程目录，执行发布脚本：即：将主工程的代码，同步到对应的服务器端。<br>开发环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh  /User/.../release.command -d</span><br></pre></td></tr></table></figure></li></ol><p>测试环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh  /User/.../release.command -t</span><br></pre></td></tr></table></figure></p><p>正式环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh  /User/.../release.command -t</span><br></pre></td></tr></table></figure></p><p>辅助功能：</p><ol start="4"><li><p>发布的手动部分：</p><ol><li>VNC协议登陆对应的服务器，进行手动部分：</li><li>将桌面的uploadFile目录项目，拷贝至 perfectfile目录</li></ol></li><li><p>通知测试人员，在web端进行打包测试。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内购 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IAP开发步骤</title>
      <link href="/2015/01/20/%E5%85%B6%E4%BB%96/IAP%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/"/>
      <url>/2015/01/20/%E5%85%B6%E4%BB%96/IAP%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>内购开发文档的使用要领：</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内购 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中的储藏工具stash</title>
      <link href="/2015/01/20/git/Git%E4%B8%AD%E7%9A%84%E5%82%A8%E8%97%8F%E5%B7%A5%E5%85%B7stash/"/>
      <url>/2015/01/20/git/Git%E4%B8%AD%E7%9A%84%E5%82%A8%E8%97%8F%E5%B7%A5%E5%85%B7stash/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li><a href="#Stashing">Stashing</a></li><li><a href="#work">储藏工作</a></li><li><a href="#apply">应用储藏</a></li><li><a href="#applyIndex">被暂存的文件重新暂存</a></li><li><a href="#drop">应用后，移除储藏的内容</a></li><li><a href="#unapply">取消储藏(Un-applying a Stash)</a></li><li><a href="#stash-unapply">新建stash-unapply别名</a></li><li><a href="#stashBranch">从储藏中创建分支</a></li></ol><h3 id="Git工具-储藏（Stashing）git"><a href="#Git工具-储藏（Stashing）git" class="headerlink" title="Git工具 - 储藏（Stashing）git"></a><a name="Stashing">Git工具 - 储藏（Stashing）</a>git</h3><hr><p><a href="https://git-scm.com/book/zh/v2/Git-工具-储藏与清理" target="_blank" rel="noopener">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p><p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p><p>解决：<strong><font color="red">git stash </font></strong>命令。</p><p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p><h3 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a><a name="work">储藏工作</a></h3><hr><ol><li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li><li><strong><font color="red">git status </font></strong>命令,查看中间状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color="red">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  <span class="string">"WIP on master: 049d078 added the index file"</span></span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them <span class="built_in">type</span> <span class="string">"git stash apply"</span>)</span><br></pre></td></tr></table></figure></li><li>执行step 2查看目录库，中间状态就不见了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment">#######On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li><li>使用<strong><font color="red">git stash list</font></strong>要查看现有的储藏：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class="string">"added file_size"</span></span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class="built_in">log</span></span><br></pre></td></tr></table></figure>在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id="应用储藏"><a href="#应用储藏" class="headerlink" title="应用储藏"></a><a name="apply">应用储藏</a></h3></li></ol><hr><p>执行<strong><font color="red">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color="red">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><br><a id="more"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p><h3 id="被暂存的文件重新暂存"><a href="#被暂存的文件重新暂存" class="headerlink" title="被暂存的文件重新暂存"></a><a name="applyIndex">被暂存的文件重新暂存</a></h3><hr><p>执行<strong><font color="red">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color="red">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply --index</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h3 id="应用后，移除储藏的内容"><a href="#应用后，移除储藏的内容" class="headerlink" title="应用后，移除储藏的内容"></a><a name="drop">应用后，移除储藏的内容</a></h3><hr><p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color="red">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class="string">"added file_size"</span></span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class="built_in">log</span></span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color="red">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p><h3 id="取消储藏-Un-applying-a-Stash"><a href="#取消储藏-Un-applying-a-Stash" class="headerlink" title="取消储藏(Un-applying a Stash)"></a><a name="unapply">取消储藏(Un-applying a Stash)</a></h3><hr><p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color="red">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p><h4 id="新建stash-unapply别名"><a href="#新建stash-unapply别名" class="headerlink" title="新建stash-unapply别名"></a><a name="stash-unapply">新建stash-unapply别名</a></h4><hr><p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color="red">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.stash-unapply <span class="string">'!git stash show -p | git apply -R'</span></span><br><span class="line">$ git stash apply</span><br><span class="line">$ <span class="comment">#... work work work</span></span><br><span class="line">$ git stash-unapply</span><br></pre></td></tr></table></figure></p><h3 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a><a name="stashBranch">从储藏中创建分支</a></h3><hr><p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch <span class="string">"testchanges"</span></span><br><span class="line"><span class="comment"># On branch testchanges</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XMPP简单研究[转]</title>
      <link href="/2015/01/06/%E5%BC%80%E6%BA%90%E5%BA%93/XMPP%E7%AE%80%E5%8D%95%E7%A0%94%E7%A9%B6%5B%E8%BD%AC%5D/"/>
      <url>/2015/01/06/%E5%BC%80%E6%BA%90%E5%BA%93/XMPP%E7%AE%80%E5%8D%95%E7%A0%94%E7%A9%B6%5B%E8%BD%AC%5D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等）</p><p>后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。</p><p>其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。</p><p>实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。<br>￼<!--显示文章缩略部分的标记方法--><br><a id="more"></a><br>第二个方案就是使用已有的 IM 互通方案，自己提供一个特有的 Game-IM 网络，跟已有的 IM 网络互通。比较流行的 IM 互通协议用基于 SIP 的 SIMPLE 和起源于 Jabber 的 XMPP 。</p><p>我最常用的 IM 是 google talk ，本身就实现了标准的 XMPP Client 和 XMPP Server 协议；而我们的 网易 popo 也实现了 XMPP 的 s2s 网关。我想研究一下 XMPP 是个不错的选择。</p><p>花了一整天的时间，把 XMPP 核心协议 仔细通读了一遍，收获颇多。原来以为 XMPP 是个可怕的巨无霸。我对 XML 原本也没有太多好感。最后，看法有所改变。</p><p>其实，XMPP 仅仅是定义了一个网络服务间相互通讯的协议。它已经把服务间需要关心的东西减少到了最少。具体的应用每家服务提供商可以随意扩展。popo 在制作新版本时，我曾多次建议采用已有的标准协议，再此基础上开发自己的东西。当时或许大家都认为标准协议容易促手促脚，我当时也没啥研究，没有多言。今天看来，我更觉得这是一个决策失误。本来我们有一个很好的机会，利用 popo 联系起网易的各种服务，现在这条路将走的更为艰辛。其实，XMPP 定义的东西，即使自己去设计也会定义出类似的一套来。而把各种网络服务互通本该是发展的重点，为 IM Client 增添专有花哨的特性就有些舍本逐末了。更为恼火的是，popo 到现在也没有一个很好的非 Windows 平台解决方案。怎能让诸多把握着互联网上部分话语权的技术人士接受？（或者，同在杭州的 IT 圈子，popo 的开发人员是不是应该看看支付宝的同行们做了些什么？）</p><p>谈谈我对 XMPP 的粗浅理解。这些仅仅建立在我对 RFC3920 的一天阅读的基础上，难免会有错误，不足以做技术参考。</p><p>XMPP 抽象出一个在互联网上唯一的对象实体，用 JID 来表达。通常一个 JID 由三部分组成，node@domain/resource 。比 email 的表达形式多了一个 /resource 。这是因为 email 地址本身虽然可以表达一个实体，都是往往不够表达这个实体下的具体服务。就好比一个 ip 地址可以表示一台机器，但是我们还需要 port 号来表达这台机器具体提供的服务一样。</p><p>用过 gtalk 的人应该很喜欢 gtalk 可以在不同的地方同时登陆这个不错的特性。用过以后，才能体会，无论是 qq 还是 msn 还是 popo ，只允许一个登陆是多么愚蠢的设定。gtalk 其实遵守了标准的 XMPP 协议，它用来区别一个帐号（一般是一个 gmail 邮件地址）的多处登陆，正是利用了不同的 resource 标识。</p><p>XMPP 规范的最重要的一条通信协议就是，如何把消息从一个 JID 发送到另一个 JID (message)。这有点像 email 协议，但不同的是，它强调了实时性和安全性（虽然不是必须的）。因为 JID 可以在不同的 domain 下，这就需要 domain 间相互协作。对于 IM 网络来说（XMPP 远不只用于 IM 协议），就是不同的 IM 服务间互通。</p><p>对于 domain 下的 xmpp 服务的发现，利用了 DNS 协议的一些功能。xmpp 的 s2s 服务提供位置，放在了 DNS 的 SRV 记录里。你可以用 nslookup 做个试验，启动 nslookup ，输入 set type=SRV</p><p>然后查询 _xmpp-server._tcp.gmail.com 你会发现 gmail.com 的 xmpp s2s 服务地址已经端口号 5269 。同样，也可以查询 _xmpp-server._tcp.163.com 或 _xmpp-server._tcp.popo.163.com 查到网易 popo 的 xmpp 中转服务器地址。</p><p>btw, 查询 _xmpp-client._tcp.gmail.com 可以查到 gtalk 的 client 登陆地址，而网易 popo 则没有提供 xmpp client 登陆点。</p><p>按 RFC3920 所述，在 xmpp server 互联的时候，会优先尝试获取 domain 的 SRV 记录，如果失败就直接去连默认的 6259 端口。然后就可以开始握手协议。</p><p>xmpp 比较强调 s2s 的安全性，所以推荐的握手都是建立在 TLS 层之上，使用 SASL 认证。TLS 层需要服务器有一个数字证书，为了安全可信，建议是找个根证书签名。不过自己签名也行，只需要服务器缓存证书即可。握手过程在 RFC3920 中描述的非常细致，可以按照其编码，问题不大。需要注意的是，这里的 XML 流格式要求很精确，不允许传输多余的东西。我一度认为采用 XML 会导致协议的实现上非常臃肿，其实不然。采用 XML 只是一个表象，适合人阅读和调错而已。RFC 中特别要求不去实现 XML 中的某某特性就是一例。我们不应该为了 XML 而去 XML 。</p><p>其实 XMPP 的 c2s 和 s2s 并无太大区别，s2s 做的人手我想是因为开源项目和开源库比较少吧。而开源的 client 实现则是一大堆。c2s 和 s2s 的通讯都是基于那几条协议而已，s2s 的实现难点在于握手比较复杂（其实 c2s 也一样，只是很多库帮你做好了）。c2s 是共享一个 tcp 连接做双向通讯；而 s2s 则是用两条 TCP 连接。两条连接也一定程度上避免了 s2s 的欺骗，当然真正的安全来至于 TLS 和 SASL 的保障。DNS 毕竟是一个很脆弱的东西。</p><p>除了点对点消息外，XMPP 定义了消息的组播。也就是一个 JID 可以以自己的名义发布消息 (presence)。而服务器来决定该发给谁。发送目标是由订阅消息决定的。其它多个 JID 可以订阅某个 JID 的消息。对于 IM 来说，最常用的就是上线下线等状态变化消息了。</p><p>第三条即是对某个 JID 的状态进行设置和获取 (iq)。于 IM 应用来说，设置签名，昵称，状态等都依赖于它。</p><p>XMPP 的核心协议无非规定了以上三种通讯协议，此外规范了服务器间互连的握手认证方案。然后给出了一些错误信息的表述方法。稍微了解过之后，很容易编写。如果希望重造轮子的话，对于 C 语言开发者来说，最繁琐的可能是 XML 的解析于生成。我自己稍微考察了一下，有个叫 LoudMouth 的库还不错。</p><p>如果实现 s2s 网关的话，有些细节做起来可能很麻烦，比如查询 DNS 的 SRV 记录。这个在 jabberd 1.x 里其实有独立的模块实现好了，取来用即可 (见 dnsrv) 。而 TLS SASL 层的实现则早就有现成的开源库了。</p><p>实现一个 jabber server 或许比你想象的还简单。in.jabberd 居然只用 600 多行 C 代码就从零实现了一个 jabber 服务器。当然功能非常的简陋了。</p><p>至于我想做的东西，我希望一个在名为 xyz 的梦幻西游服务器上的 12345 号玩家，一旦选择绑定他的 popo 帐号 <a href="mailto:player@popo.163.com" target="_blank" rel="noopener">player@popo.163.com</a> ，他在他的 popo 上就会收到名叫 <a href="mailto:12345.xyz@xyq.163.com" target="_blank" rel="noopener">12345.xyz@xyq.163.com</a> 的好友请求。当他通过好友认证后，就可以从这个通道获取游戏里的信息，也可以对游戏帐号做有限的操作。我想有了这样一项服务，对玩家对运营商都会有极大的好处的。<br>其他资源：<br><a href="http://www.ibm.com/developerworks/cn/xml/tutorials/x-realtimeXMPPtut/" target="_blank" rel="noopener">使用 XMPP 构建一个基于 web 的通知工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码实现AutoLayout相关特性</title>
      <link href="/2014/09/02/iOS/UI/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0AutoLayout%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"/>
      <url>/2014/09/02/iOS/UI/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0AutoLayout%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="按比例缩放"><a href="#按比例缩放" class="headerlink" title="按比例缩放"></a>按比例缩放</h2><p>按比例缩放，这是在Interface Builder中无法设置的内容。<br>而在代码中，有如下两种实现方式:</p><ol><li>使用<code>NSLayoutConstraint</code>类型的初始化函数中的<code>multiplier</code>参数就可以非常简单的设置按比例缩放。  </li><li>同时也可以设置不同<code>NSLayoutAttribute</code>参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。  </li></ol><p>现在就拿一个简单的<strong><code>UIButton</code></strong>做示例，在ViewController中创建一个UIButton字段：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *btn;  </span><br></pre></td></tr></table></figure>  </p><h4 id="需求-1："><a href="#需求-1：" class="headerlink" title="需求 1："></a>需求 1：</h4><ol><li>要求<strong><code>UIButton</code></strong>水平居中，始终距离父View底部<strong>20</strong>单位，其高度是父View高度的三分之一。</li><li>使用<strong>KVO</strong>来监控<strong><code>UIButton</code></strong>的大小并实时输出到屏幕上。  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建UIButton，不需要设置frame</span></span><br><span class="line">    btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeRoundedRect</span>];</span><br><span class="line">    [btn setTitle:<span class="string">@"mgen"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    btn.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁止自动转换AutoresizingMask</span></span><br><span class="line">    btn.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//居中</span></span><br><span class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line">                              constraintWithItem:btn</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeCenterX</span></span><br><span class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                              toItem:<span class="keyword">self</span>.view</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeCenterX</span></span><br><span class="line">                              multiplier:<span class="number">1</span></span><br><span class="line">                              constant:<span class="number">0</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//距离底部20单位</span></span><br><span class="line">    <span class="comment">//注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。</span></span><br><span class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line">                              constraintWithItem:btn</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                              toItem:<span class="keyword">self</span>.view</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                              multiplier:<span class="number">1</span></span><br><span class="line">                              constant:<span class="number">-20</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义高度是父View的三分之一</span></span><br><span class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line">                              constraintWithItem:btn</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeHeight</span></span><br><span class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                              toItem:<span class="keyword">self</span>.view</span><br><span class="line">                              attribute:<span class="built_in">NSLayoutAttributeHeight</span></span><br><span class="line">                              multiplier:<span class="number">0.3</span></span><br><span class="line">                              constant:<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册KVO方法</span></span><br><span class="line">    [btn addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"bounds"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionInitial</span> context:<span class="literal">nil</span>];    </span><br><span class="line">&#125;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="comment">//KVO回调</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == btn &amp;&amp; [keyPath isEqualToString:<span class="string">@"bounds"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        [btn setTitle:<span class="built_in">NSStringFromCGSize</span>(btn.bounds.size) forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  运行结果：  <a id="more"></a><h4 id="需求-2："><a href="#需求-2：" class="headerlink" title="需求 2："></a>需求 2：</h4></li><li>在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。   </li></ol><p>涉及到的相关特性：</p><ul><li><strong>优先级</strong>：当两个<strong><code>Constraint</code></strong>同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置<strong><code>Constraint</code></strong>的优先级来解决。<br>优先级对应<strong><code>NSLayoutConstraint</code></strong>类型的<strong><code>priority</code></strong>属性，默认值是<strong><code>UILayoutPriorityRequired</code></strong>，数值上等于<strong>1000</strong>. 设置一个低的值代表更低的优先级。  </li><li><strong>最小值的定义</strong>：使用<strong><code>NSLayoutRelationGreaterThanOrEqual</code></strong>作为<strong><code>NSLayoutConstraint</code></strong>类型创建时的<strong><code>relatedBy</code></strong>参数。</li></ul><p>修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义高度是父View的三分之一</span></span><br><span class="line"><span class="comment">//设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *con = [<span class="built_in">NSLayoutConstraint</span></span><br><span class="line">                          constraintWithItem:btn</span><br><span class="line">                          attribute:<span class="built_in">NSLayoutAttributeHeight</span></span><br><span class="line">                          relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                          toItem:<span class="keyword">self</span>.view</span><br><span class="line">                          attribute:<span class="built_in">NSLayoutAttributeHeight</span></span><br><span class="line">                          multiplier:<span class="number">0.3</span></span><br><span class="line">                          constant:<span class="number">0</span>];</span><br><span class="line">con.priority = <span class="built_in">UILayoutPriorityDefaultHigh</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:con];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置btn最小高度为150</span></span><br><span class="line">[btn addConstraint:[<span class="built_in">NSLayoutConstraint</span></span><br><span class="line">                    constraintWithItem:btn</span><br><span class="line">                    attribute:<span class="built_in">NSLayoutAttributeHeight</span></span><br><span class="line">                    relatedBy:<span class="built_in">NSLayoutRelationGreaterThanOrEqual</span></span><br><span class="line">                    toItem:<span class="literal">nil</span></span><br><span class="line">                    attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></span><br><span class="line">                    multiplier:<span class="number">1</span></span><br><span class="line">                    constant:<span class="number">150</span>]];</span><br></pre></td></tr></table></figure><br>运行后，横向屏幕中的Button高度成了150：  </p><h4 id="intrinsicContentSize-控件的内置大小"><a href="#intrinsicContentSize-控件的内置大小" class="headerlink" title="intrinsicContentSize 控件的内置大小"></a>intrinsicContentSize 控件的内置大小</h4><p>控件的内置大小是由控件本身的内容所决定的，比如一个<code>UILabel</code>的文字很长，那么该<code>UILabel</code>的内置大小自然会很长。<br>在代码中获取控件的内置大小的方法：  </p><ol><li>通过<code>UIView</code>的<code>intrinsicContentSize</code>属性来获取；</li><li>通过<code>invalidateIntrinsicContentSize</code>方法来在下次UI规划事件中重新计算<code>intrinsicContentSize</code>。  </li></ol><p>注意：如果直接创建一个原始的UIView对象，它的内置大小为0。  </p><p>先写一个辅助方法来快速设置UIView的边距限制：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Autolayout中的边距辅助方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setEdge:(<span class="built_in">UIView</span>*)superview view:(<span class="built_in">UIView</span>*)view attr:(<span class="built_in">NSLayoutAttribute</span>)attr constant:(<span class="built_in">CGFloat</span>)constant</span><br><span class="line">&#123;</span><br><span class="line">    [superview addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view </span><br><span class="line">    attribute:attr </span><br><span class="line">    relatedBy:<span class="built_in">NSLayoutRelationEqual</span> </span><br><span class="line">       toItem:superview</span><br><span class="line">    attribute:attr </span><br><span class="line">   multiplier:<span class="number">1.0</span> </span><br><span class="line">     constant:constant]</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//view1</span></span><br><span class="line"><span class="built_in">UIView</span> *view1 = [<span class="built_in">UIView</span> new];</span><br><span class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"><span class="comment">//不允许AutoresizingMask转换成Autolayout</span></span><br><span class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:view1];</span><br><span class="line"><span class="comment">//设置左，上，右边距为20.</span></span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view1 attr:<span class="built_in">NSLayoutAttributeLeft</span> constant:<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view1 attr:<span class="built_in">NSLayoutAttributeTop</span> constant:<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view1 attr:<span class="built_in">NSLayoutAttributeRight</span> constant:<span class="number">-20</span>];</span><br></pre></td></tr></table></figure><br>但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，<code>UIView</code>默认是没有<strong><code>intrinsicContentSize</code></strong>的。</p><p>创建一个自定义的<code>UIView</code>来改写<strong><code>intrinsicContentSize</code></strong>：MyView:<br>然后在.m文件中改写<strong>intrinsicContentSize</strong>方法，并返回有效值，比如这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改写UIView的intrinsicContentSize</span></span><br><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="number">70</span>, <span class="number">40</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyView *view1 = [MyView new];  </span><br></pre></td></tr></table></figure><br>再次运行代码，View会按照要求显示在屏幕上：<br>按照同样的方式，在下方添加另一个<code>MyView</code>，要求其距离父控件边距左，下，右各为<strong>20</strong>，代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//view2  </span></span><br><span class="line">MyView *view2 = [MyView new];  </span><br><span class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];  </span><br><span class="line"><span class="comment">//不允许AutoresizingMask转换成Autolayout  </span></span><br><span class="line">view2.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;  </span><br><span class="line">[<span class="keyword">self</span>.view addSubview:view2];  </span><br><span class="line"><span class="comment">//设置左，下，右边距为20.  </span></span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view2 attr:<span class="built_in">NSLayoutAttributeLeft</span> constant:<span class="number">20</span>];  </span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view2 attr:<span class="built_in">NSLayoutAttributeBottom</span> constant:<span class="number">-20</span>];  </span><br><span class="line">[<span class="keyword">self</span> setEdge:<span class="keyword">self</span>.view view:view2 attr:<span class="built_in">NSLayoutAttributeRight</span> constant:<span class="number">-20</span>];  </span><br></pre></td></tr></table></figure>  </p><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ol><li><p>通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 </p><ol start="2"><li><ul><li>这里要求view2在view1之下的<strong>20</strong>单位，所以创建<strong>NSLayoutConstraint</strong>中view2参数在前面。  </li></ul></li><li><ul><li>view2的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeTop</code></strong>，而view1的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeBottom</code></strong>  </li></ul></li></ol></li><li><p>拉伸view2,而不拉伸view1。  </p><ol><li><ul><li>控件的<strong><code>Content Hugging Priority</code></strong>拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。    </li></ul></li><li><ul><li>控件的<strong><code>Content Compression Resistance Priority</code></strong>拒绝压缩内置空间(<code>intrinsicContentSize</code>)的优先级。优先级越高，控件的内置空间(<code>intrinsicContentSize</code>)会越不容易被压缩。  </li></ul></li></ol></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置两个View上下间距为20</span></span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2 </span><br><span class="line">attribute:<span class="built_in">NSLayoutAttributeTop</span> </span><br><span class="line">relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">   toItem:view1</span><br><span class="line">    attribute:<span class="built_in">NSLayoutAttributeBottom</span> </span><br><span class="line">   multiplier:<span class="number">1.0</span></span><br><span class="line"> constant:<span class="number">20</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>  <p>OK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。</p><p>使用控件的<strong><code>Content Hugging Priority</code></strong>，如下图：<br>如图,把view1（上图中被拉伸的，在上面的View）的<strong><code>Content Hugging Priority</code></strong>设置一个更高的值，那么当<code>Autolayout</code>遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。<br>可以直接通过UIView的<code>setContentHuggingPriority:forAxis</code>方法来设置控件的<strong><code>Content Hugging Priority</code></strong>，其中<code>forAxis</code>参数代表横向和纵向，本例中只需要设置纵向，所以传入<strong><code>UILayoutConstraintAxisVertical</code></strong>。整句代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高view1的Content Hugging Priority</span></span><br><span class="line">[view1 setContentHuggingPriority:<span class="built_in">UILayoutPriorityDefaultHigh</span> forAxis:<span class="built_in">UILayoutConstraintAxisVertical</span>];</span><br></pre></td></tr></table></figure>  </p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> SB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storyboard </tag>
            
            <tag> AutoLayout </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在IOS中自定义URLSchemes教程</title>
      <link href="/2014/08/29/iOS/%E5%9C%A8IOS%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89URLSchemes%E6%95%99%E7%A8%8B/"/>
      <url>/2014/08/29/iOS/%E5%9C%A8IOS%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89URLSchemes%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="URL-Schemes"><a href="#URL-Schemes" class="headerlink" title="URL Schemes"></a>URL Schemes</h4><p>iPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！</p><p>首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。</p><h4 id="注册自定义URL协议"><a href="#注册自定义URL协议" class="headerlink" title="注册自定义URL协议"></a>注册自定义URL协议</h4><p>首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。</p><p>默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。</p><h6 id="Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array"><a href="#Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array" class="headerlink" title="Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:"></a>Step1. 右键，选择“Add Row”,在下拉选框中选择“<strong>URL types</strong>”，类型为Array:</h6><h6 id="Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。"><a href="#Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。" class="headerlink" title="Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。"></a>Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。</h6><h5 id="Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array"><a href="#Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array" class="headerlink" title="Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:"></a>Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:</h5><a id="more"></a><ul><li>类型为Array:  </li></ul><h5 id="Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。"><a href="#Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。" class="headerlink" title="Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。"></a>Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。</h5><h6 id="完成后如图所示："><a href="#完成后如图所示：" class="headerlink" title="完成后如图所示："></a>完成后如图所示：</h6><ul><li><h6 id="另两种视图浏览方式："><a href="#另两种视图浏览方式：" class="headerlink" title="另两种视图浏览方式："></a>另两种视图浏览方式：</h6>在info.plist页面上右击，选择<strong>Raw Keys/Values</strong>显示如下：  <h6 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h6></li></ul><!--more--><h4 id="处理URL"><a href="#处理URL" class="headerlink" title="处理URL"></a>处理URL</h4><p>现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。</p><ul><li><h5 id="使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】"><a href="#使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】" class="headerlink" title="使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】"></a>使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【<a href="http://iosdevelopertips.com/downloads/#customURLScheme" target="_blank" rel="noopener">下载</a>】</h5></li></ul><p>Using the simulator, here’s how to call the app:</p><ul><li>Run the application from within Xcode  </li><li>Once installed, the custom URL scheme will now be registered</li><li>Close the app via the Hardware menu in simulator and choose Home</li><li>Start Safari</li><li>Enter the URL scheme defined previously in the browser address bar (see below)  </li></ul><ul><li><h5 id="通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】"><a href="#通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】" class="headerlink" title="通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】"></a>通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【<a href="http://iosdevelopertips.com/downloads/#customURLScheme" target="_blank" rel="noopener">下载</a>】</h5></li></ul><p>按钮的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)buttonPressed:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSString</span> *customURL = <span class="string">@"iOSDevTips://"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] </span><br><span class="line">    canOpenURL:[<span class="built_in">NSURL</span> URLWithString:customURL]])</span><br><span class="line">  &#123;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:customURL]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"URL error"</span></span><br><span class="line">                          message:[<span class="built_in">NSString</span> stringWithFormat:</span><br><span class="line">                            <span class="string">@"No custom URL defined for %@"</span>, customURL]</span><br><span class="line">                          delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"Ok"</span> </span><br><span class="line">                          otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).<br>The <strong><code>openURL:</code></strong>method starts the application and passes the URL into the app. The current application is exited during this process.  </p><ul><li><h5 id="通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme"><a href="#通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme" class="headerlink" title="通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme"></a>通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme</h5>Chances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with.</li></ul><p>The <strong><code>NSURL</code></strong>class which is the basis for calling from one app to another conforms to the <code>RFC 1808</code> (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well.</p><p>In the application with the custom <code>URL scheme</code>, the app delegate must implement the method with the signature below:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application  openURL:(<span class="built_in">NSURL</span> *)url </span><br><span class="line">  sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication </span><br><span class="line">         annotation:(<span class="keyword">id</span>)annotation</span><br></pre></td></tr></table></figure><br>The trick to passing in parameters from one app to another is via the URL.<br>For example, assume we are using the following custom <code>URL scheme</code>and want to pass in a value for a ‘<strong>token</strong>’ and a flag indicating registration state, we could create URL as follows:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *customURL = <span class="string">@"iOSDevTips://?token=123abct&amp;registered=1"</span>;</span><br></pre></td></tr></table></figure><br>As in web development, the string <strong><code>?token=123abct&amp;registered=1</code></strong> is known as the <code>query</code> string.</p><p>Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">        sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Calling Application Bundle ID: %@"</span>, sourceApplication);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"URL scheme:%@"</span>, [url scheme]);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"URL query: %@"</span>, [url query]);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calling Application Bundle ID: com<span class="number">.3</span>Sixty.CallCustomURL</span><br><span class="line">URL scheme:iOSDevTips</span><br><span class="line">URL query: token=<span class="number">123</span>abct&amp;registered=<span class="number">1</span></span><br></pre></td></tr></table></figure><br>Take note of the ‘<strong>Calling Application Bundle ID</strong>’ as you could use this to ensure that only an application that you define can interact directly with your app.</p><p>Let’s change up the delegate method to verify the calling application Bundle ID is known:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">        sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Check the calling application Bundle ID</span></span><br><span class="line">  <span class="keyword">if</span> ([sourceApplication isEqualToString:<span class="string">@"com.3Sixty.CallCustomURL"</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Calling Application Bundle ID: %@"</span>, sourceApplication);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"URL scheme:%@"</span>, [url scheme]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"URL query: %@"</span>, [url query]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>It’s important to note that you cannot prevent another application from calling your app via custom <strong><code>URL scheme</code></strong>, however you can skip any further processing and <code>return NO</code> as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) <code>URL scheme</code>. Although this will guarantee you app won’t be called, it will make it more unlikely.</p><p>Custom URL Scheme Example Projects</p><p>I realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s.</p><p><a href="http://iosdevelopertips.com/downloads/#customURLScheme" target="_blank" rel="noopener">Download Xcode project for app with Custom URL scheme</a><br><a href="http://iosdevelopertips.com/downloads/#customURLScheme" target="_blank" rel="noopener">Download Xcode project for app to call custom URL scheme</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> schemes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XcodeHeaderDoc教程</title>
      <link href="/2014/08/28/xcode/XcodeHeaderDoc%E6%95%99%E7%A8%8B/"/>
      <url>/2014/08/28/xcode/XcodeHeaderDoc%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。</p><p>另外，Xcode 还会在 quick look 面板中以<strong>HeaderDoc</strong>风格显示你的注释。</p><p>通过本教程，将学习如下几点：</p><ul><li>如何书写 HeaderDoc 风格的注释</li><li>分如何在 Xcode 中预览文档</li><li>如何生成 HTML 文档</li><li>如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具)</li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>下载本教程中用到的 <a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Starter.zip" target="_blank" rel="noopener">示例项目</a></p><p>这个简单的示例程序只包含了两个类：</p><ul><li>Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。</li><li>MathAPI: 包含了1个方法，用于累加两个数。<br>现在，这两个类还没有任何注释。以便演示如何通过 <strong>HeaderDoc</strong> 为这两个类创建文档。<a id="more"></a><h4 id="HeaderDoc-注释"><a href="#HeaderDoc-注释" class="headerlink" title="HeaderDoc 注释"></a>HeaderDoc 注释</h4></li></ul><p><strong>HeaderDoc</strong> 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式：<br>这3中语法在 Xcode 中产生同样效果的文档</p><pre><code>注释 1. 一般用于单行注释    /// Your documentation comment will go here注释 2.    /**  * Your documentation comment will go here  */注释 3: 一般用于较长的注释块    /*!  * Your documentation comment will go here  */注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。</code></pre><h4 id="HeaderDoc-标签"><a href="#HeaderDoc-标签" class="headerlink" title="HeaderDoc 标签"></a>HeaderDoc 标签</h4><p>当 <strong>HeaderDoc</strong> 发现上述3种注释，它就开始寻找其中的<strong>HeaderDoc 标签</strong>。<strong>HeaderDoc 标签</strong> 用来修饰<strong>HeaderDoc 注释</strong>。</p><p><strong>HeaderDoc 标签</strong>以 <strong>@</strong> 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。<br>HeaderDoc 标签可以分为两种：</p><ol><li><p>顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。</p><ul><li>顶级标签，例如 @typedef，用于表示 <strong>typedef</strong> 定义的类型，比如枚举、结构体和函数指针。</li><li><strong>HeaderDoc</strong> 能够根据上下文自动产生顶级标签，因此通常不是必须的。</li></ul></li><li><p>二级标签:这些标签才是具体的注释内容。</p><ul><li>@brief: 简单描述你准备文档化的数据的类型，方法等等。</li><li>@abstract: 等于 @brief。<ul><li>@discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。</li><li>@param: 描述方法、回调或函数的参数名称。</li><li>@return: 描述方法或函数的返回值。（等同于 @result）</li></ul></li></ul></li></ol><!-- More --><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><h6 id="属性的文档化"><a href="#属性的文档化" class="headerlink" title="属性的文档化"></a>属性的文档化</h6><p>用 Xcode 打开<strong>DocumentationExamples</strong> 项目, 打开<strong>ViewController.h</strong>,<br>在<strong> car </strong>属性的前面，加入一行注释:</p><pre><code>/*!  * @brief The ViewController class&apos; car object.  */@property (nonatomic) Car *car;</code></pre></li></ul><p>编译项目。编译结束，按住 alt/option 键，点击<strong>car</strong> 变量名。你将看到<strong>pop菜单</strong>中显示了刚才的注释内容。<br> 另一种方法:切换到Utitlities 面板的<strong>Quick Help</strong> 检查器窗口。点击 <strong>car</strong> 变量名，通过<strong>Quick Help</strong>,你将看到如下效果：</p><ul><li><h6 id="方法的文档化"><a href="#方法的文档化" class="headerlink" title="方法的文档化"></a>方法的文档化</h6><p><strong>MathAPI</strong>包含一个方法需要文档化。打开<strong>MathAPI.h</strong>,找到<code>addNumber:toNumber:</code>。</p></li></ul><p>这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示：</p><pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.      * @param firstNumber An NSInteger to be used in the summation of two numbers      * @param secondNumber The second half of the equation.       * @return The sum of the two numbers passed in.*/+ (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber;</code></pre><p>编译，再 <strong>alt + 左键</strong>：</p><p> 问题: 在 Xcode 文本编辑窗口，很多地方都支持 <strong>alt+左键</strong>。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。</p><p>你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。</p><pre><code>* @warning Please make note that this method is only good for adding non-negative numbers.</code></pre><p>编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下：</p><h4 id="Code-Snippets，让一切变得更简单"><a href="#Code-Snippets，让一切变得更简单" class="headerlink" title="Code Snippets，让一切变得更简单:"></a>Code Snippets，让一切变得更简单:</h4><p>一个<strong>snippet</strong> 是一个可以重用的代码块（存储在 snippet 库中）。<strong>Snippets</strong> 甚至可以包含一些需要你去填充的占位符。<br>这意味着, 可以用 <strong>snipppet</strong>来进行文档化。</p><p>在 <strong>MathAPI.h</strong> 中，在原有的注释上面加入以下内容：</p><pre><code>/*!  * @discussion      * @param      * @return */</code></pre><p> 注意，当粘贴上述代码时，“”之间的内容会变成一个<strong>token</strong>,意味着可以通过 <strong>tab 键</strong>在 <strong>token</strong> 之间来回切换。就像编写代码时的自动完成功能。</p><h6 id="学习使用Code-Snippets工具"><a href="#学习使用Code-Snippets工具" class="headerlink" title="学习使用Code Snippets工具"></a>学习使用Code Snippets工具</h6><p> 打开 <strong>Utilities 面板</strong>中的 <strong>CodeSnippets Library 检查器</strong>窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如开始拖）:<br>  将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个<strong>自动完成快捷方式</strong>。要修改某个<strong>snippet</strong>时,直接点击 <strong>Code Snippet Library</strong> 中的 snippet，然后点 Edit 按钮。按照如下形式填写：</p><p>要想让 <strong>snippet</strong> 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入<strong>doccomment</strong>，然后回车，该<strong>snippet</strong> 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下:</p><pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.     * @param firstNumber An NSInteger to be used in the summation of two numbers.     * @param secondNumber The second half of the equation.     * @warning Please make note that this method is only good for adding non-negative numbers.     * @return The sum of the two numbers passed in.*/</code></pre><p><strong>@param 标签</strong>和 <strong>@warning 标签</strong>需要手动书写。</p><h4 id="Typedefs的文档化"><a href="#Typedefs的文档化" class="headerlink" title="Typedefs的文档化"></a>Typedefs的文档化</h4><p> 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。</p><p>还记得 @typedef 标签吗？<br>这个顶级标签稍微特殊一点。它可以对<strong>typedef enum</strong> 或者 <strong>typedef struct</strong> 的类型进行注释。<br>根据注释的对象的不同，它会包含与定义的类型相关的二级标签。</p><p>以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。</p><p>找到 <strong>enum OldCarType</strong>。它包含两个常量，是用于古典汽车的。在<strong>typedef</strong> 声明之上，将原来的注释替换为：</p><pre><code>/*!  * @typedef OldCarType     * @brief A list of older car types.     * @constant OldCarTypeModelT A cool old car.     * @constant OldCarTypeModelA A sophisticated old car.*/typedef enum {        /// A cool, old car.         OldCarTypeModelT,        /// A sophisticated older car.        OldCarTypeModelA} OldCarType;</code></pre><p> 编译，然后在 <strong>OldCarType</strong> 或上<strong>OldCarTypeModelT</strong>使用<strong>alt + 左键</strong>。</p><p>在这个类中只有一个 <strong>NS_ENUM</strong>，因此接下来进行进行文档化。常量已经注释了，只要对整个<strong>NS_ENUM</strong> 进行一个总体的注释就可以了。</p><pre><code>/*!  * @typedefCarType     * @brief Alist of newer car types.     * @constantCarTypeHatchback Hatchbacks are fun, but small.     * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs     * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc.     * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back.*/</code></pre><p>注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 <strong>typedef enum</strong> 一样的文档特性，虽然<strong>NS_ENUM</strong> 实际上是声明 enums 的推荐的方法。</p><h4 id="typedef-block-文档化"><a href="#typedef-block-文档化" class="headerlink" title="typedef block 文档化"></a>typedef block 文档化</h4><pre><code>/*!  * @brief A block that makes the car drive.     * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;]*/typedef void(^driveCompletion)(CGFloat distance);</code></pre><p><strong>typedef block</strong> 的文档化和之前的并无多少不同，它包含了：</p><ul><li>一个 @brief 标签，简单说明了一下这个块的作用。</li><li>一个 @param 标签，说明调用块时需要传递的参数。</li></ul><h4 id="添加格式化代码到文档中"><a href="#添加格式化代码到文档中" class="headerlink" title="添加格式化代码到文档中"></a>添加格式化代码到文档中</h4><p>例如，Car 类的 <strong>driveCarWithComplete:</strong> 方法。</p><p>这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。</p><p>这需要使用 <strong>@code 标签</strong>。在 <strong>driveCarWithCompletion</strong>方法声明之前添加如下内容：</p><pre><code>/*!  * @brief The car will drive, and then execute the drive block     * @param completion A driveCompletion block     * @code [car driveCarWithCompletion:^(CGFloat distance){                            NSLog(@&quot;Distance driven %f&quot;, distance);                         }];*/</code></pre><p>编译，在方法名上使用<strong>alt+左键</strong>。如下图所示：</p><h4 id="检查文档"><a href="#检查文档" class="headerlink" title="检查文档"></a>检查文档</h4><p>学会了如何添加注释，如果 <strong>Xcode</strong> 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“<strong>CLANG_WARN_DOCUMENTATION_COMMENTS</strong>”,可以用于检查 <strong>HeaderDoc</strong> 格式的注释。</p><p>打开 <strong>DocumentationExamples</strong>的项目设置，点击 <strong>Build Settings</strong>，找到 <strong>DocumentationComments</strong>, 将值设置为 <strong>YES</strong>。<br>如下，打开 <strong>MathAPI.h</strong>，将第一个 @param 标签的参数名由<strong>firstNumber</strong> 修改为 <strong>thirdNumber</strong>,然后编译。<br>有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。</p><h4 id="特殊注释"><a href="#特殊注释" class="headerlink" title="特殊注释"></a>特殊注释</h4><p><strong>Xcode</strong> 还支持几种特殊注释，对于你或者使用你代码的人非常有用。</p><p>打开 Car.m，在 <strong>driveCarWithCompletion:</strong> 方法中，在调用<strong>completion</strong> 块之前添加下列注释：</p><pre><code>// FIXME: This is broken// !!!: Holy cow, it should be checked!// ???: Perhaps check if the block is not nil first?</code></pre><p>这里出现了3中注释：</p><ul><li>FIXME: 某个地方需要修正</li><li>!!!: 某个地方需要注意。</li><li>???: 代码中有问题，或者代码是可疑的。</li></ul><p>这些注释不但有助于浏览代码，而且 Xcode 绘制 <strong>Jump Bar</strong> 中显示它们。点击<strong>Jump Bar</strong>，如下图所示：</p><p> 你将看到这3个注释以粗体显示：</p><p> 到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。</p><p>#用headerdoc2html 创建 HTML文档<br>文档化是由一个 <strong>HeaderDoc 工具</strong>完成的。当 Xcode 安装时，它就已经安装好了。<br>它除了解释已添加的注释，显示一个弹出菜单以及将注释在<strong>Quick Help</strong> 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。</p><p>本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html" target="_blank" rel="noopener">HeaderDoc 用户指南</a>.</p><p>打开终端，转到 DocumentationExamples 项目目录：</p><pre><code>cd /path/to/your/folder确保该路径下包含了 Xcodeproject  文件(“DocumentationExamples.xcodeproj”)。</code></pre><p>然后用下列命令创建 HTML 文档：</p><pre><code>headerdoc2html -o ~/Desktop/documentation DocumentationExamples/</code></pre><p>此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html：</p><p><strong>headerdoc2html 脚本</strong>有两个参数：</p><p>So what justhappened? Well, you ran the headerdoc2htmlscript with 2 options:</p><ul><li>-o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。</li><li>DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码）</li></ul><p>问题:</p><ol><li>最新版本<strong>headerdoc2html</strong>有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。</li><li>最新版本的<strong>headerdoc2html</strong> 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。</li></ol><p>这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，<strong>HeaderDoc</strong>还会创建一个主目录索引。<br>返回终端，导航至新建的 <strong>documentation</strong> 目录，输入：</p><pre><code>cd ~/Desktop/documentation</code></pre><p>然后输入命令，创建内容索引:</p><pre><code>gatherheaderdoc .</code></pre><p><strong>gatherheaderdoc</strong>自动查找目录，为 <strong>.</strong> 目录（表示当前目录）创建索引。<br>用 Finder 打开 documentation  目录。你会发现多出一个 <strong>masterTOC.html</strong> 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。<br>你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！</p><p>#VVDocumenter-Xcode</p><p>最后的内容是 <strong>VVDocumenter-Xcode</strong>，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 <strong>Code Snippet</strong> 更容易。</p><p>首先，从 <a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">Github</a> 下载插件。</p><p>你所需要做的全部工作就是打开项目，然后 <strong>Build</strong>。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。</p><p>然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 <strong><code>addNumber:toNumber</code></strong> 方法的注释块，然后在方法声明上面输入：</p><pre><code>///</code></pre><p><strong>VVDocumenter-Xcode</strong> 将自动创建注释块，包括所有必要的 <strong>@param</strong> 标签以及自动完成 <strong>token</strong>。</p><p>打开 Car.h，删除 <strong>NS_ENUM CarType</strong> 的注释，以及每个常量的注释。在<strong>NS_ENUM</strong> 声明之上，输入：</p><pre><code>///</code></pre><p>这回，它会在 enum 之上创建 <strong>discussion</strong> 标签，甚至还每个常量上面放入了必要的注释！</p><p><strong>VVDocumenter-Xcode</strong> 使你的生活更加轻松。如果你想定制<strong>VVDocumenter-Xcode</strong>，在Xcode中，使用 <strong>Window&gt;VVDocumenter菜单</strong>。</p><p>这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！<br>接下来做什么？</p><p>最终完成的示例项目在 这里<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Final.zip" target="_blank" rel="noopener">下载</a>。</p><p>在你自己的代码中进行文档化。尝试自己编写 <strong>code snippet</strong> 并使用<strong>VVDocumentor</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storyboard之Segue</title>
      <link href="/2014/07/22/iOS/UI/Storyboard%E4%B9%8BSegue/"/>
      <url>/2014/07/22/iOS/UI/Storyboard%E4%B9%8BSegue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="Segue原理"><a href="#Segue原理" class="headerlink" title="Segue原理:"></a>Segue原理:</h5><p>在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作：</p><ol><li>实例化目标视图控制器</li><li>实例化一个新segue对象，该对象持有所有的信息</li><li>调用源视图控制器的prepareForSegue:sender:方法，</li><li>调用segue的 perform 方法将目标控制器带到屏幕上。<br>这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。</li></ol><p>在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。<br><a id="more"></a><br>在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> ([[segue identifier] isEqualToString:<span class="string">@"ShowSightingsDetails"</span>])  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//当用户选择表视图中的一行时，触发**segue**事件，传输数据到目标视图控制器，使目标控制器上能显示`sighting`</span></span><br><span class="line">        DetailViewController *detailViewController = [segue destinationViewController];  </span><br><span class="line">        detailViewController.sighting = [<span class="keyword">self</span>.dataController objectInListAtIndex:[<span class="keyword">self</span>.tableView indexPathForSelectedRow].row];  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> ([[segue identifier] isEqualToString:<span class="string">@"ShowAddSightingView"</span>])  </span><br><span class="line">    &#123;  </span><br><span class="line">        AddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:<span class="number">0</span>];  </span><br><span class="line">        addSightingViewController.delegate = <span class="keyword">self</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>在<code>storyboard</code>中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的<strong>segue</strong>。这两个<strong>segue</strong>通过它们的<code>identifier</code>属性进行判断，具体解释如下：  </p><ul><li><p><code>identifier</code>为”<strong>ShowSightingsDetails</strong>“时，目标视图控制器是一个展示明细信息的视图控制器,使用的<strong>segue</strong>类型为<code>push</code>。这种通常用于<strong>navigator</strong>视图控制器中。  </p></li><li><p>在<code>identifier</code>为”<strong>ShowAddSightingView</strong>“时，目标视图控制器管理的是一个新加的<strong>sighting</strong>信息视图，我们称之为<strong>add</strong>视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。  </p><ul><li><ul><li>实现方式是采用<code>delegate</code>，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。  </li></ul></li></ul></li></ul><p>在add视图控制器上，有两个按钮，用于执行<strong>cancel</strong>和<strong>done</strong>操作。这两个按钮操作的方法在主视图控制器中实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)addSightingViewControllerDidCancel:(AddSightingViewController *)controller  </span><br><span class="line">&#123;  </span><br><span class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">NULL</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// </span></span><br><span class="line">- (<span class="keyword">void</span>)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location &#123;  </span><br><span class="line"><span class="keyword">if</span> ([name length] || [location length]) &#123;  </span><br><span class="line">[<span class="keyword">self</span>.dataController addBirdSightingWithName:name location:location];  </span><br><span class="line">[[<span class="keyword">self</span> tableView] reloadData];  </span><br><span class="line">&#125;  </span><br><span class="line">[<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在add视图控制器实现代码中，调用它的委托中这两个方法。  </p><h5 id="segue三种类型-modal-segue、push-segue、custom-segue"><a href="#segue三种类型-modal-segue、push-segue、custom-segue" class="headerlink" title="segue三种类型:modal segue、push segue、custom segue"></a>segue三种类型:modal segue、push segue、custom segue</h5><ul><li><h6 id="modal-segue"><a href="#modal-segue" class="headerlink" title="modal segue"></a>modal segue</h6>是一个视图控制器（源）为了完成一个任务而模态地（<strong>modally</strong>）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(<strong>navigation view controller</strong>)的栈中的一部分。<br>在任务完成后，使用<code>delegate</code>将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。  </li></ul><p>这个过程的实现代码可以看成是<code>present</code>和<code>dismiss</code>两个操作。  </p><ul><li><h6 id="push-segue"><a href="#push-segue" class="headerlink" title="push segue"></a>push segue</h6>是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(<strong>navigation view controller</strong>)一起使用。<br>新压入的视图控制器会有一个回退按钮，可以退回来上一层。</li></ul><p>这个过程的实现代码可以看成是<code>push</code>和<code>pop</code>两个操作。</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> SB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转场 </tag>
            
            <tag> Storyboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextKit之便笺实战</title>
      <link href="/2014/07/04/iOS/UI/TextKit%E4%B9%8B%E4%BE%BF%E7%AC%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2014/07/04/iOS/UI/TextKit%E4%B9%8B%E4%BE%BF%E7%AC%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="便笺练习功能点"><a href="#便笺练习功能点" class="headerlink" title="便笺练习功能点:"></a>便笺练习功能点:</h2><p>通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。</p><ul><li>动态样式（Dynamic type）  </li><li>凸版印刷效果（Letterpress effects）  </li><li>环绕路径（Exclusion paths）  </li><li>动态文本格式及存储（Dynamic text formatting and storage）  </li></ul><p>这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。<br>效果图:<br><img src="/images/bianqian.png" alt="image"><br>App开始运行后自动生成一组便笺实例并利用<code>tableViewController</code>显示出来。<code>Storyboards</code>和<code>segues</code>会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。<br>项目开发包：<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/TextKitNotepad-starter.zip" target="_blank" rel="noopener">Notepad.zip</a></p><h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p><code>动态样式（Dynamic type）</code>是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。<br>选择 <strong>通用-&gt;文字大小</strong> 或 <strong>通用-&gt;辅助功能</strong> 来查看app中的字体设置。</p><p><img src="/images/UserTextPreferences.png" alt="image"><br>iOS 7 支持通过<code>粗体</code>、<code>设置字体大小</code>等方式提高支持动态文本的应用的易读性。<br>例如<strong><code>UIFont</code></strong>新增的一个方法： <strong><code>preferredFontForTextStyle</code></strong> 用来根据用户对字体大小的设置来自动制定字体样式。<br>下面表格中是六种可用字体样式的示例：<br><img src="/images/TextStyles.png" alt="image"><br>最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。  </p><h3 id="使用系统动态字体样式"><a href="#使用系统动态字体样式" class="headerlink" title="使用系统动态字体样式"></a>使用系统动态字体样式</h3><p>使用动态文本，是通过给<code>文本字体</code>设置字体样式<strong>style</strong>而不是指定具体的<code>字体名称</code>和<code>大小</code>。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。</p><h4 id="preferredFontForTextStyle-方法设置字体样式"><a href="#preferredFontForTextStyle-方法设置字体样式" class="headerlink" title="preferredFontForTextStyle:方法设置字体样式"></a><code>preferredFontForTextStyle:</code>方法设置字体样式</h4><ol><li>打开 <code>NoteEditorViewController.m/swift</code> 在<code>viewDidLoad：</code>方法实现的最后面加入以下代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textView.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textView.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br></pre></td></tr></table></figure></li><li>打开 <code>NotesListViewController.m/swift</code> 在 <code>tableView:cellForRowAtIndexPath:</code> 方法中增加如下代码:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.textLabel.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.textLabel?.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br></pre></td></tr></table></figure>上面两行代码都用到了新版iOS的字体样式.   <blockquote><p>字体样式：通过语义法命名字体，例如 <code>UIFontTextStyleSubHeadline</code>, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。</p></blockquote></li></ol><h4 id="APP响应用户字体设置"><a href="#APP响应用户字体设置" class="headerlink" title="APP响应用户字体设置"></a>APP响应用户字体设置</h4><ol><li>设置系统字体<br>返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置.<br>再运行App, <strong>Note</strong>页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。<br><img src="/images/NotepadWithDynamicType.png" alt="image"> </li><li>设置系统字体生效<br>当我们返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置. 再打开<strong>Note</strong>页面, 会发现app并没有<strong>立即</strong>对字体设置的变化做出相应反应。</li></ol><h5 id="监听系统通知：实现APP响应用户字体设置"><a href="#监听系统通知：实现APP响应用户字体设置" class="headerlink" title="监听系统通知：实现APP响应用户字体设置"></a>监听系统通知：实现APP响应用户字体设置</h5><p>当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，<code>preferredFontForTextStyle:</code>方法返回的字体也会变化。</p><ol><li>添加监听系统通知<code>UIContentSizeCategoryDidChangeNotification</code>通知APP响应用户字体设置的变化<br>打开 <code>NoteEditorViewController.m</code> 并在 <code>viewDidLoad</code> 方法的实现的最后加入以下代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">                              addObserver:<span class="keyword">self</span></span><br><span class="line">                                 selector:<span class="keyword">@selector</span>(preferredContentSizeChanged:)</span><br><span class="line">                                     name:<span class="built_in">UIContentSizeCategoryDidChangeNotification</span></span><br><span class="line">                                   object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字体变化通知:调用preferredContentSizeChanged:方法</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(<span class="type">NoteEditorViewController</span>.preferredContentSizeChanged(<span class="number">_</span>:)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIContentSizeCategoryDidChange</span>, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></li><li>添加系统通知响应事件<br>收到用于指定本类接收字体设定变化的通知后，调用<code>preferredContentSizeChanged:</code>方法<br>在<code>NoteEditorViewController.m</code>中<code>viewDidLoad</code>方法之后紧接着添加以下方法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)preferredContentSizeChanged:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.textView.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字体变化通知时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(<span class="number">_</span> notification:NSNotification)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.textView.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这一方法作用是根据新的字体设置来设定<code>textView</code>中的字体。<br>Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。<a id="more"></a></li></ol><h3 id="更新布局"><a href="#更新布局" class="headerlink" title="更新布局"></a>更新布局</h3><p>现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示：<br>  <img src="/images/ChangingLayout.png" alt="image">  </p><p>这是<strong>动态样式</strong>有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。<br>在<code>NotesListViewController.m</code>中实现<code>tableView:heightForRowAtIndexPath:</code> 代理方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">UILabel</span>* label;</span><br><span class="line">    <span class="keyword">if</span> (!label) &#123;</span><br><span class="line">        label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, FLT_MAX, FLT_MAX)];</span><br><span class="line">        label.text = <span class="string">@"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    label.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br><span class="line">    [label sizeToFit];  <span class="comment">//自适应文本内容大小</span></span><br><span class="line">    <span class="keyword">return</span> label.frame.size.height * <span class="number">1.7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">FLT_MAX</span>, height: <span class="type">FLT_MAX</span>))</span><br><span class="line">    label.text = <span class="string">"test"</span></span><br><span class="line">    <span class="keyword">let</span> font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class="line">    label.font = font</span><br><span class="line">    label.sizeToFit()</span><br><span class="line">    <span class="keyword">return</span> label.frame.size.height * <span class="number">1.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码创建了一个共享的——或者说静态的——<strong>UILabel</strong>实例，设定它的字体和表中单元格内文本字体一致。然后调用它的<code>sizeToFit</code>方法，使这个<code>label</code>的<code>frame</code>恰好能放得下它的内容文字, 然后把这个<code>label</code>的高度乘个<code>1.7</code>作为表内单元格高度。<br>Build并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示：<br><img src="/images/TableViewAdaptsHeights.png" alt="image">  </p><h3 id="凸版印刷效果（Letterpress-effects）"><a href="#凸版印刷效果（Letterpress-effects）" class="headerlink" title="凸版印刷效果（Letterpress effects）"></a>凸版印刷效果（Letterpress effects）</h3><p>凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。  </p><blockquote><font size="3">注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。</font>  </blockquote><p>打开NotesListViewController.m 将<code>tableView:cellForRowAtIndexPath:</code>方法中的代码用以下代码替换:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"Cell"</span>;</span><br><span class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier </span><br><span class="line">                                                        forIndexPath:indexPath];</span><br><span class="line">Note* note = [<span class="keyword">self</span> notes][indexPath.row];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIFont</span>* font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleHeadline</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIColor</span>* textColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.175</span>f green:<span class="number">0.458</span>f blue:<span class="number">0.831</span>f alpha:<span class="number">1.0</span>f];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *attrs = @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : textColor,</span><br><span class="line">                                    <span class="built_in">NSFontAttributeName</span> : font,</span><br><span class="line">                              <span class="built_in">NSTextEffectAttributeName</span> : <span class="built_in">NSTextEffectLetterpressStyle</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAttributedString</span>* attrString = [[<span class="built_in">NSAttributedString</span> alloc]</span><br><span class="line">                                       initWithString:note.title</span><br><span class="line">                                           attributes:attrs];</span><br><span class="line">cell.textLabel.attributedText = attrString;</span><br><span class="line"><span class="keyword">return</span> cell;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"noteListCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">    <span class="comment">// Configure the cell...</span></span><br><span class="line">    <span class="keyword">let</span> note = notes[indexPath.row] <span class="keyword">as</span>! <span class="type">NoteModel</span></span><br><span class="line">    <span class="comment">//cell.textLabel?.text = note.title</span></span><br><span class="line">    <span class="keyword">let</span> font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class="line">    <span class="keyword">let</span> textColor = <span class="type">UIColor</span>.<span class="keyword">init</span>(red: <span class="number">0.175</span>, green: <span class="number">0.458</span>, blue: <span class="number">0.831</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    <span class="comment">//字体凸版印刷效果</span></span><br><span class="line">    <span class="keyword">let</span> store:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>:textColor,</span><br><span class="line">    <span class="type">NSFontAttributeName</span>:font,</span><br><span class="line">    <span class="type">NSTextEffectAttributeName</span>:<span class="type">NSTextEffectLetterpressStyle</span>]</span><br><span class="line">    cell.textLabel?.attributedText = <span class="type">NSAttributedString</span>.<span class="keyword">init</span>(string: note.title, attributes: store)</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码为单元格的标题创建了一个使用了凸版印刷效果的<strong><code>NSAttributedString</code></strong>。  </p><p><br>Build并运行app， 表格将显示凸版印刷效果，如下图所示：<br><img src="/images/Letterpress.png" alt="image"><br>凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。</p><h3 id="环绕路径（Exclusion-paths）"><a href="#环绕路径（Exclusion-paths）" class="headerlink" title="环绕路径（Exclusion paths）"></a>环绕路径（Exclusion paths）</h3><p>文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。<code>Text Kit</code>允许你通过环绕路径（<code>exclusion paths</code>）将文字按照复杂路径和形状分布。  </p><p>在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期：   </p><ul><li>首先添加一个视图  </li><li>创建一个环绕路径，使文字按照这个路径分布。 </li></ul><h4 id="添加视图"><a href="#添加视图" class="headerlink" title="添加视图"></a>添加视图</h4><p>打开 <code>NoteEditorViewController.m</code> 在顶部的<code>imports</code>和接口实现中添加变量加入以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"TimeIndicatorView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NoteEditorViewController</span></span></span><br><span class="line">&#123;</span><br><span class="line">    TimeIndicatorView* _timeView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去<br>在NoteEditorViewController.m的<code>viewDidLoad</code>方法的最后添加以下代码：<br><figure class="highlight objc"><figcaption><span>objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:_timeView];</span><br></pre></td></tr></table></figure></p><h4 id="设置视图位置及自动适应布局：viewDidLayoutSubviews"><a href="#设置视图位置及自动适应布局：viewDidLayoutSubviews" class="headerlink" title="设置视图位置及自动适应布局：viewDidLayoutSubviews"></a>设置视图位置及自动适应布局：<code>viewDidLayoutSubviews</code></h4><p>当<strong>NoteEditor</strong>视图的控件调用系统方法<code>viewDidLayoutSubviews</code>方法，对子视图进行布局时，<code>TimeIndicatorView</code>作为子控件也需要有相应的变化。<br>在控件接收到文本内容的尺寸发生了变化的时候调用<code>updateTimeIndicatorFrame</code>： </p><ol><li>第一调用<code>updateSize</code>来设定<code>_timeView</code>的尺寸  </li><li>第二将<code>_timeView</code>放在右上角<br>在NoteEditorViewController.m 的最后添加如下代码：<figure class="highlight objc"><figcaption><span>objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> updateTimeIndicatorFrame];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)updateTimeIndicatorFrame</span><br><span class="line">&#123;</span><br><span class="line">    [_timeView updateSize];</span><br><span class="line">    _timeView.frame = <span class="built_in">CGRectOffset</span>(_timeView.frame,</span><br><span class="line">                          <span class="keyword">self</span>.view.frame.size.width - _timeView.frame.size.width, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateTimeIndicatorFrame</span><span class="params">()</span></span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一调用updateSize来设定_timeView的尺寸</span></span><br><span class="line">    timeIndicatorView.updateSize()</span><br><span class="line">    <span class="comment">//通过偏移frame参数，将timeIndicatorView放在右上角</span></span><br><span class="line">    timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width,</span><br><span class="line">                                                               dy: <span class="number">0.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="响应系统偏好设置字体样式"><a href="#响应系统偏好设置字体样式" class="headerlink" title="响应系统偏好设置字体样式"></a>响应系统偏好设置字体样式</h4><p>修改<code>NoteEditorViewController.m</code>中<code>preferredContentSizeChanged:</code>方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)preferredContentSizeChanged:(<span class="built_in">NSNotification</span> *)n </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.textView.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    [<span class="keyword">self</span> updateTimeIndicatorFrame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示：<br><img src="/images/TimIndicator.png" alt="修改设备中文本大小设置，这个视图也将自动调整到相应的合适尺寸">    </p><h3 id="文本环绕视图"><a href="#文本环绕视图" class="headerlink" title="文本环绕视图"></a>文本环绕视图</h3><ol><li>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径</li><li>设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。</li></ol><h4 id="curvePathWithOrigin-创建文本容器的赛尔路径"><a href="#curvePathWithOrigin-创建文本容器的赛尔路径" class="headerlink" title="curvePathWithOrigin:创建文本容器的赛尔路径"></a>curvePathWithOrigin:创建文本容器的赛尔路径</h4><p>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径<br>添加<code>curvePathWithOrigin:</code>方法，定义文本遵循的环绕路径：<br><figure class="highlight objc"><figcaption><span>objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIBezierPath</span> *)curvePathWithOrigin:(<span class="built_in">CGPoint</span>)origin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:origin</span><br><span class="line">                                          radius: [<span class="keyword">self</span> radiusToSurroundFrame:_label.frame]</span><br><span class="line">                                      startAngle: <span class="number">-180.0</span>f</span><br><span class="line">                                        endAngle: <span class="number">180.0</span>f</span><br><span class="line">                                       clockwise: <span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curvePathWithOrigin</span><span class="params">(origin:CGPoint)</span></span>-&gt;<span class="type">UIBezierPath</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//画弧形</span></span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>.<span class="keyword">init</span>(arcCenter: origin,</span><br><span class="line">    radius: radiusToSurroundFrame(frame: timeLabel.frame),</span><br><span class="line">                             startAngle: -<span class="number">180</span>,                <span class="comment">//-180.0</span></span><br><span class="line">                               endAngle: <span class="number">180.0</span>,               <span class="comment">//CGFloat(M_PI * 2),   //180.0</span></span><br><span class="line">                              clockwise: <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">//        UIColor.blueColor().set()</span></span><br><span class="line">    <span class="comment">//        path.fill()</span></span><br><span class="line">    <span class="comment">//        UIColor.blueColor().set()</span></span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="设置文本容器的环绕路径：exclusionPaths"><a href="#设置文本容器的环绕路径：exclusionPaths" class="headerlink" title="设置文本容器的环绕路径：exclusionPaths"></a>设置文本容器的环绕路径：exclusionPaths</h4><p><code>exclusionPaths</code>是<code>NSArray</code>类型，因此一个文本容器是可以支持多个环绕路径，文本<strong>环绕路径</strong>发生改变后会通知文本管理器，然后<strong>环绕路径</strong>的变化就可以动态地，甚至是动画式地体现到文本上！<br>在<code>updateTimeIndicatorFrame</code>方法实现的最后面添加如下代码：<br><figure class="highlight objc"><figcaption><span>objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIBezierPath</span>* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center];</span><br><span class="line">    _textView.textContainer.exclusionPaths  = @[exclusionPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center)</span><br><span class="line">    ibTextView.textContainer.exclusionPaths = [exclusionPath]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，选择一个便笺项，如下图所示：<br><img src="/images/ExclusionPath.png" alt="实现文本环绕效果">  </p><h2 id="动态文本格式及存储（Dynamic-text-formatting-and-storage）"><a href="#动态文本格式及存储（Dynamic-text-formatting-and-storage）" class="headerlink" title="动态文本格式及存储（Dynamic text formatting and storage）"></a>动态文本格式及存储（Dynamic text formatting and storage）</h2><p>你已经看到了<code>Text Kit</code>可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？<br>实现类似markdown语法的效果：  </p><ul><li>把波浪线(~)之间的文本变为艺术字体  </li><li>把下划线(_)之间的文本变为斜体  </li><li>为破折号(-)之间的文本添加删除线  </li><li>把字母全部大写的单词变为红色<br><img src="/images/DynamicTextExample.png" alt="利用Text Kit framework来实现的效果">   </li></ul><h3 id="Text-Kit文本系统工作机制"><a href="#Text-Kit文本系统工作机制" class="headerlink" title="Text Kit文本系统工作机制"></a>Text Kit文本系统工作机制</h3><p><code>Text Kit 堆栈</code>存储、处理以及显示文本：<br><img src="/images/TextKitStack-443x320.png" alt="image"><br>当你创建<code>UITextView</code>, <code>UILabel</code> or <code>UITextField</code>的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。</p><ul><li><strong><code>NSTextStorage</code>文本存储器</strong>: 作为一个<code>NSMutableAttributedString</code>的子类，动态处理的文本可以通过<code>attributedString</code>的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义<code>NSTextStorage</code>的子类，当文本发生变化时，动态地对文本属性做出相应改变。  </li><li><strong><code>NSLayoutManager</code>布局引擎</strong>: 获取存储的文本并经过修饰处理再显示在屏幕上； </li><li><strong><code>NSTextContainer</code>文本容器</strong>: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的<code>UITextView</code>. 可以创建 <code>NSTextContainer</code>的子类来定义<strong>一个复杂的形状</strong>，然后在这个形状内处理文本。  </li></ul><h3 id="NSTextStorage文本存储器动态添加文本属性"><a href="#NSTextStorage文本存储器动态添加文本属性" class="headerlink" title="NSTextStorage文本存储器动态添加文本属性"></a><code>NSTextStorage</code>文本存储器动态添加文本属性</h3><ol><li>需要创建一个<code>NSTextStorage</code>的子类，用以在用户输入文本的时候，动态地添加文本属性。</li><li>将<code>UITextView</code>的默认文本存储器,用自定义的实现替换掉。</li></ol><h4 id="创建文本存储器NSTextStorage子类"><a href="#创建文本存储器NSTextStorage子类" class="headerlink" title="创建文本存储器NSTextStorage子类"></a>创建文本存储器NSTextStorage子类</h4><p>新建<strong><code>NSTextStorage</code></strong>的子类，类命名为<strong><code>SyntaxHighlightTextStorage</code></strong><br>打开<strong>SyntaxHighlightTextStorage.m</strong>并添加实例变量并初始化：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SyntaxHighlightTextStorage.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SyntaxHighlightTextStorage</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *_backingStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) </span><br><span class="line">    &#123;</span><br><span class="line">        _backingStore = [<span class="built_in">NSMutableAttributedString</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyntaxHighlightTextStorage</span>: <span class="title">NSTextStorage</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//文本存储器子类必须提供它自己的“数据持久化层”。</span></span><br><span class="line">    <span class="keyword">var</span> backingStore = <span class="type">NSMutableAttributedString</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重载文本存储器的数据持久化层方法"><a href="#重载文本存储器的数据持久化层方法" class="headerlink" title="重载文本存储器的数据持久化层方法"></a>重载文本存储器的数据持久化层方法</h4><p>要使用<strong><code>NSMutableAttributedString</code></strong>作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_backingStore string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)attributesAtIndex:(<span class="built_in">NSUInteger</span>)location</span><br><span class="line">                     effectiveRange:(<span class="built_in">NSRangePointer</span>)range</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [_backingStore attributesAtIndex:location</span><br><span class="line">                             effectiveRange:range];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> string: <span class="type">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> backingStore.string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">(at location: Int, effectiveRange range: NSRangePointer?)</span></span> -&gt; [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> range == <span class="literal">nil</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> [:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print("backingStore:location\(location),effectiveRange:\(range!)")</span></span><br><span class="line">    <span class="keyword">return</span> backingStore.attributes(at: location, effectiveRange: range!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面两个方法直接把任务代理给了后台存储。  </p><h4 id="重载编辑文本时通知布局管理器的方法"><a href="#重载编辑文本时通知布局管理器的方法" class="headerlink" title="重载编辑文本时通知布局管理器的方法"></a>重载编辑文本时通知布局管理器的方法</h4><p>同样的，这些方法也是把任务代理给后台存储。它们通过调用<code>beginEditing</code> / <code>edited</code> / <code>endEditing</code>这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。<br>最后，还在这个文件中，重载以下方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)replaceCharactersInRange:(<span class="built_in">NSRange</span>)range withString:(<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"replaceCharactersInRange:%@ withString:%@"</span>, <span class="built_in">NSStringFromRange</span>(range), str);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> beginEditing];</span><br><span class="line">    [_backingStore replaceCharactersInRange:range withString:str];</span><br><span class="line">    [<span class="keyword">self</span> edited:<span class="built_in">NSTextStorageEditedCharacters</span> | <span class="built_in">NSTextStorageEditedAttributes</span></span><br><span class="line">              range:range</span><br><span class="line">     changeInLength:str.length - range.length];</span><br><span class="line">    [<span class="keyword">self</span> endEditing];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAttributes:(<span class="built_in">NSDictionary</span> *)attrs range:(<span class="built_in">NSRange</span>)range</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setAttributes:%@ range:%@"</span>, attrs, <span class="built_in">NSStringFromRange</span>(range));</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> beginEditing];</span><br><span class="line">    [_backingStore setAttributes:attrs range:range];</span><br><span class="line">    [<span class="keyword">self</span> edited:<span class="built_in">NSTextStorageEditedAttributes</span> range:range changeInLength:<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> endEditing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">replaceCharacters</span><span class="params">(<span class="keyword">in</span> range: NSRange, with str: String)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"replaceCharactersInRange:\(NSStringFromRange(range)) withString:\(str)"</span>)</span><br><span class="line">    beginEditing()</span><br><span class="line">    backingStore.replaceCharacters(<span class="keyword">in</span>: range, with: str)</span><br><span class="line">    edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.<span class="built_in">count</span> - range.length)</span><br><span class="line">    endEditing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setAttributes</span><span class="params">(<span class="number">_</span> attrs: [String : <span class="keyword">Any</span>]?, range: NSRange)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Sets the attributes for the characters in the specified range to the specified attributes.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"setAttributes:\(attrs!) range:\(NSStringFromRange(range))"</span>)</span><br><span class="line">    beginEditing()</span><br><span class="line">    backingStore.setAttributes(attrs!, range: range)</span><br><span class="line">    edited(.editedAttributes, range: range, changeInLength: <span class="number">0</span>)</span><br><span class="line">    endEditing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类族介绍"><a href="#类族介绍" class="headerlink" title="类族介绍"></a>类族介绍</h4><p>类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类<code>NSArray</code>和<code>NSNumber</code>类似的就是一族类的公共接口。</p><p>上例中<code>NSTextStorage</code>文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方<code>attributedString</code>数据的后台存储。</p><p>Apple使用类族来封装同一个公共<code>抽象超类</code>下的私有具体子类，<code>抽象超类</code>声明了客户在创建<code>私有子类实例</code>时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。<br>使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。 </p><h3 id="创建UITextView使用自定义Text-Kit堆栈"><a href="#创建UITextView使用自定义Text-Kit堆栈" class="headerlink" title="创建UITextView使用自定义Text Kit堆栈"></a>创建UITextView使用自定义Text Kit堆栈</h3><p>现在有了一个自定义的<code>NSTextStorage</code>，还需创建一个<code>UITextView</code>来使用它。 </p><h4 id="storyboard创建UITextView时，Text-Kit组件只读问题"><a href="#storyboard创建UITextView时，Text-Kit组件只读问题" class="headerlink" title="storyboard创建UITextView时，Text Kit组件只读问题"></a>storyboard创建UITextView时，Text Kit组件只读问题</h4><p>从<strong>storyboard</strong>编辑器实例化<code>UITextView</code>会自动创建<strong><code>NSTextStorage</code></strong>, <strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong> (例如<strong>Text Kit</strong>堆栈)实例以及所有的这三个只读属性。<br>虽然没有办法从<strong>storyboard</strong>编辑器中改变这种设定，但可以手动编程创建<code>UITextView</code>和<strong>Text Kit</strong>堆栈。  </p><h4 id="在UITextView中使用自定义的SyntaxHighlightTextStorage"><a href="#在UITextView中使用自定义的SyntaxHighlightTextStorage" class="headerlink" title="在UITextView中使用自定义的SyntaxHighlightTextStorage"></a>在UITextView中使用自定义的SyntaxHighlightTextStorage</h4><h5 id="清理IB相关设置"><a href="#清理IB相关设置" class="headerlink" title="清理IB相关设置"></a>清理IB相关设置</h5><ul><li>在IB中打开<strong>Main.storyboard</strong> 找到<strong>NoteEditorViewController</strong>。 删除<code>UITextView</code>实例。<br>然后，打开<strong>NoteEditorViewController.m</strong>删除<strong>UITextView outlet</strong>。<br>既然不再为文本视图使用<code>IBOutlet</code>，而是要编程添加，所以也就不需要这些代码了。<br>从<code>viewDidLoad</code> 方法中删除以下代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textView.text = <span class="keyword">self</span>.note.contents;</span><br><span class="line"><span class="keyword">self</span>.textView.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.textView.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure></li></ul><h5 id="手动创建UITextView和Text-Kit堆栈"><a href="#手动创建UITextView和Text-Kit堆栈" class="headerlink" title="手动创建UITextView和Text Kit堆栈"></a>手动创建<code>UITextView</code>和Text Kit堆栈</h5><ul><li>在<strong>NoteEditorViewController.m</strong>最上面，添加下面一行代码:<figure class="highlight objc"><figcaption><span>objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SyntaxHighlightTextStorage.h"</span></span></span><br></pre></td></tr></table></figure>在NoteEditorViewController.m中<code>TimeIndicatorView</code>实例变量后面紧接着添加以下代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SyntaxHighlightTextStorage* _textStorage;</span><br><span class="line"><span class="built_in">UITextView</span>* _textView;</span><br></pre></td></tr></table></figure>文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。  </li></ul><h5 id="创建Text-Kit堆栈"><a href="#创建Text-Kit堆栈" class="headerlink" title="创建Text Kit堆栈"></a>创建<code>Text Kit</code>堆栈</h5><ul><li>创建自定义的<code>NSTextStorage</code>文本存储器实例，一个用来承载便笺内容的<code>NSAttributedString</code>  </li><li>创建一个<code>NSLayoutManager</code>布局管理器，并添加到文本存储器。</li><li>创建一个<code>NSTextContainer</code>文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来  </li><li>最后用你自定义的文本容器和代理组创建实际的文本视图，  并把文本视图添加为子视图<br>在NoteEditorViewController.m中，添加下面方法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createTextView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. Create the text storage that backs the editor</span></span><br><span class="line">    <span class="built_in">NSDictionary</span>* attrs = @&#123;<span class="built_in">NSFontAttributeName</span>:</span><br><span class="line">        [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>]&#125;;</span><br><span class="line">    <span class="built_in">NSAttributedString</span>* attrString = [[<span class="built_in">NSAttributedString</span> alloc]</span><br><span class="line">                                   initWithString:_note.contents</span><br><span class="line">                                       attributes:attrs];</span><br><span class="line">    _textStorage = [SyntaxHighlightTextStorage new];</span><br><span class="line">    [_textStorage appendAttributedString:attrString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGRect</span> newTextViewRect = <span class="keyword">self</span>.view.bounds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Create the layout manager</span></span><br><span class="line">    <span class="built_in">NSLayoutManager</span> *layoutManager = [[<span class="built_in">NSLayoutManager</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Create a text container</span></span><br><span class="line">    <span class="built_in">CGSize</span> containerSize = <span class="built_in">CGSizeMake</span>(newTextViewRect.size.width,  <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    <span class="built_in">NSTextContainer</span> *container = [[<span class="built_in">NSTextContainer</span> alloc] initWithSize:containerSize];</span><br><span class="line">    container.widthTracksTextView = <span class="literal">YES</span>;</span><br><span class="line">    [layoutManager addTextContainer:container];</span><br><span class="line">    [_textStorage addLayoutManager:layoutManager];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Create a UITextView</span></span><br><span class="line">    _textView = [[<span class="built_in">UITextView</span> alloc] initWithFrame:newTextViewRect</span><br><span class="line">                                    textContainer:container];</span><br><span class="line">    _textView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_textView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文本区域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTextView</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. Create the text storage that backs the editor</span></span><br><span class="line">    <span class="keyword">let</span> bodyFont = <span class="type">UIFont</span>.preferredFont(forTextStyle: <span class="type">UIFontTextStyle</span>.body)</span><br><span class="line">    <span class="keyword">let</span> attrs = [<span class="type">NSFontAttributeName</span>:bodyFont]</span><br><span class="line">    <span class="keyword">let</span> attrString = <span class="type">NSAttributedString</span>(string: note.contents,attributes: attrs)</span><br><span class="line">    textStorage = <span class="type">SyntaxHighlightTextStorage</span>()</span><br><span class="line">    textStorage.append(attrString)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------使用Storyboard声明TextView时,只需一行，可惜为只读属性----------</span></span><br><span class="line">    textStorage.addLayoutManager(ibTextView.layoutManager)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**--------使用代码声明TextView时，4步骤----------</span></span><br><span class="line"><span class="comment">    let newTextViewRect = view.bounds</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2. Create the layout manager</span></span><br><span class="line"><span class="comment">    let layoutManager = NSLayoutManager()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3. Create a text container</span></span><br><span class="line"><span class="comment">    //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。</span></span><br><span class="line"><span class="comment">    let containerSize = CGSize.init(width: newTextViewRect.size.width,</span></span><br><span class="line"><span class="comment">    height: CGFloat.greatestFiniteMagnitude)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    let container = NSTextContainer.init(size: containerSize)</span></span><br><span class="line"><span class="comment">    //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized.</span></span><br><span class="line"><span class="comment">    container.widthTracksTextView = true</span></span><br><span class="line"><span class="comment">    //</span></span><br><span class="line"><span class="comment">    layoutManager.addTextContainer(container)</span></span><br><span class="line"><span class="comment">    textStorage.addLayoutManager(layoutManager)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4. Create a UITextView</span></span><br><span class="line"><span class="comment">    textView = UITextView()//.init(frame: newTextViewRect, textContainer: container)</span></span><br><span class="line"><span class="comment">    textView.isScrollEnabled = true</span></span><br><span class="line"><span class="comment">    textView.delegate = self</span></span><br><span class="line"><span class="comment">    view.addSubview(textView)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在回顾之前那个图表所展示的四个关键类(文本存储器<code>storage</code>, 布局管理器<code>layout manager</code>, 文本容器<code>container</code> 和文本视图<code>textView</code>)之间的关系，是不是觉得理解起来容易多了。<br><img src="/images/TextKitStack-443x320.png" alt="image"></p><blockquote><font size="3">注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于<code>CGFLOAT_MAX</code>，它的值可以是无限大。不管怎么说，它的高度足够让<code>UITextView</code>上下滚动以容纳很长的文本。</font>    </blockquote><p>在<code>viewDidLoad</code>方法中调用超类的<code>viewDidLoad</code>方法的语句后面添加以下一行代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> createTextView];</span><br></pre></td></tr></table></figure><br>然后修改<code>preferredContentSizeChanged</code>的第一行代码为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_textView.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure></p><h5 id="自定义视图实现在storyboard中自动布局约束的效果"><a href="#自定义视图实现在storyboard中自动布局约束的效果" class="headerlink" title="自定义视图实现在storyboard中自动布局约束的效果"></a>自定义视图实现在<code>storyboard</code>中自动布局约束的效果</h5><p>用自定义的实例变量来替换掉旧的<code>outlet</code>属性。自定义视图不会自动继承<code>storyboard</code>中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。  </p><p>可以在<code>viewDidLayoutSubviews</code>方法的最后添加以下代码来实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_textView.frame = <span class="keyword">self</span>.view.bounds;</span><br></pre></td></tr></table></figure><br>Build并运行app，打开一个便笺项，在Xcode控制台上有<code>SyntaxHighlightTextStorage</code>生成的运行日志，用来告诉你这些文本处理的代码确实被调用：<br><img src="/images/LogMessages-480x266.png" alt="image"><br>看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。</p><h3 id="通过正则修改文本存储器的动态格式（Dynamic-formatting）"><a href="#通过正则修改文本存储器的动态格式（Dynamic-formatting）" class="headerlink" title="通过正则修改文本存储器的动态格式（Dynamic formatting）"></a>通过正则修改文本存储器的动态格式（Dynamic formatting）</h3><p>接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体：</p><h4 id="processEditing：将文本的变化通知给布局管理器"><a href="#processEditing：将文本的变化通知给布局管理器" class="headerlink" title="processEditing：将文本的变化通知给布局管理器"></a><code>processEditing</code>：将文本的变化通知给布局管理器</h4><p><code>processEditing</code> 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。<br>打开<strong>SyntaxHighlightTextStorage.m</strong> 添加以下方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)processEditing</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performReplacementsForRange:[<span class="keyword">self</span> editedRange]];</span><br><span class="line">    [<span class="keyword">super</span> processEditing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####<br>NSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range<br>上面的代码拓展了受黑体格式类型影响的文本范围。因为<code>changedRange</code>一般只是作用到单独的一个字符； 而<code>lineRangeForRange</code> 则扩展到一整行<br>在 <code>processEditing</code>方法之后紧接着添加以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performReplacementsForRange:(<span class="built_in">NSRange</span>)changedRange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSRange</span> extendedRange = <span class="built_in">NSUnionRange</span>(changedRange, [[_backingStore string]</span><br><span class="line">                             lineRangeForRange:<span class="built_in">NSMakeRange</span>(changedRange.location, <span class="number">0</span>)]);</span><br><span class="line">    extendedRange = <span class="built_in">NSUnionRange</span>(changedRange, [[_backingStore string] </span><br><span class="line">                          lineRangeForRange:<span class="built_in">NSMakeRange</span>(<span class="built_in">NSMaxRange</span>(changedRange), <span class="number">0</span>)]);</span><br><span class="line">    [<span class="keyword">self</span> applyStylesToRange:extendedRange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><figcaption><span>swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定的区域中进行替换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performReplacementsForRange</span><span class="params">(<span class="number">_</span> changedRange:NSRange)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定位正在编辑文本的位置区间</span></span><br><span class="line">    <span class="keyword">let</span> locationRange = <span class="type">NSMakeRange</span>(changedRange.location, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//定位到文本当前行的位置区间</span></span><br><span class="line">    <span class="keyword">let</span> range1 = (backingStore.string <span class="keyword">as</span> <span class="type">NSString</span>).lineRange(<span class="keyword">for</span>: locationRange)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扩展范围</span></span><br><span class="line">    <span class="keyword">var</span> extendedRange = <span class="type">NSUnionRange</span>(changedRange, range1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxRange = <span class="type">NSMakeRange</span>(<span class="type">NSMaxRange</span>(changedRange), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> range2 = (backingStore.string <span class="keyword">as</span> <span class="type">NSString</span>).lineRange(<span class="keyword">for</span>: maxRange)</span><br><span class="line">    extendedRange = <span class="type">NSUnionRange</span>(changedRange, range2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"在指定的区域中进行替换:\(extendedRange)"</span>)</span><br><span class="line">    applyStylesToRange(searchRange: extendedRange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在 <code>performReplacementsForRange</code>方法之后紧接着添加以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applyStylesToRange:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. create some fonts</span></span><br><span class="line">    <span class="built_in">UIFontDescriptor</span>* fontDescriptor = [<span class="built_in">UIFontDescriptor</span></span><br><span class="line">                             preferredFontDescriptorWithTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    <span class="built_in">UIFontDescriptor</span>* boldFontDescriptor = [fontDescriptor</span><br><span class="line">                           fontDescriptorWithSymbolicTraits:<span class="built_in">UIFontDescriptorTraitBold</span>];</span><br><span class="line">    <span class="built_in">UIFont</span>* boldFont =  [<span class="built_in">UIFont</span> fontWithDescriptor:boldFontDescriptor size: <span class="number">0.0</span>];</span><br><span class="line">    <span class="built_in">UIFont</span>* normalFont =  [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. match items surrounded by asterisks</span></span><br><span class="line">    <span class="built_in">NSString</span>* regexStr = <span class="string">@"(*w+(sw+)**)s"</span>;</span><br><span class="line">    <span class="built_in">NSRegularExpression</span>* regex = [<span class="built_in">NSRegularExpression</span></span><br><span class="line">                                   regularExpressionWithPattern:regexStr</span><br><span class="line">                                                        options:<span class="number">0</span></span><br><span class="line">                                                          error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span>* boldAttributes = @&#123; <span class="built_in">NSFontAttributeName</span> : boldFont &#125;;</span><br><span class="line">    <span class="built_in">NSDictionary</span>* normalAttributes = @&#123; <span class="built_in">NSFontAttributeName</span> : normalFont &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. iterate over each match, making the text bold</span></span><br><span class="line">    [regex enumerateMatchesInString:[_backingStore string]</span><br><span class="line">              options:<span class="number">0</span></span><br><span class="line">                range:searchRange</span><br><span class="line">           usingBlock:^(<span class="built_in">NSTextCheckingResult</span> *match,</span><br><span class="line">                        <span class="built_in">NSMatchingFlags</span> flags,</span><br><span class="line">                        <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRange</span> matchRange = [match rangeAtIndex:<span class="number">1</span>];</span><br><span class="line">        [<span class="keyword">self</span> addAttributes:boldAttributes range:matchRange];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. reset the style to the original</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NSMaxRange</span>(matchRange)+<span class="number">1</span> &lt; <span class="keyword">self</span>.length) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addAttributes:normalAttributes</span><br><span class="line">                range:<span class="built_in">NSMakeRange</span>(<span class="built_in">NSMaxRange</span>(matchRange)+<span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码有以下作用：  </p><ol><li>创建一个粗体及一个正常字体并使用字体描述器（<strong>Font descriptors</strong>）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。  </li><li>创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。</li><li>对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。  </li></ol><p>将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。</p><blockquote><font size="3">注： 字体描述器（<strong>Font descriptors</strong>）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化<code>UIFont</code>实例便可获取字体规格的细节。</font>    </blockquote><p>Build并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示：<br><img src="/images/BoldText.png" alt="image">  </p><p>##进一步添加样式<br>为限定文本添加风格的基本原则很简单：<strong>使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。</strong><br>在SyntaxHighlightTextStorage.m中添加以下实例变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) createHighlightPatterns &#123;</span><br><span class="line">    <span class="built_in">UIFontDescriptor</span> *scriptFontDescriptor =</span><br><span class="line">      [<span class="built_in">UIFontDescriptor</span> fontDescriptorWithFontAttributes:</span><br><span class="line">          @&#123;<span class="built_in">UIFontDescriptorFamilyAttribute</span>: <span class="string">@"Zapfino"</span>&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. base our script font on the preferred body font size</span></span><br><span class="line">    <span class="built_in">UIFontDescriptor</span>* bodyFontDescriptor = [<span class="built_in">UIFontDescriptor</span></span><br><span class="line">      preferredFontDescriptorWithTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span>* bodyFontSize = bodyFontDescriptor.</span><br><span class="line">                  fontAttributes[<span class="built_in">UIFontDescriptorSizeAttribute</span>];</span><br><span class="line">    <span class="built_in">UIFont</span>* scriptFont = [<span class="built_in">UIFont</span></span><br><span class="line">              fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create the attributes</span></span><br><span class="line">    <span class="built_in">NSDictionary</span>* boldAttributes = [<span class="keyword">self</span></span><br><span class="line">     createAttributesForFontStyle:<span class="built_in">UIFontTextStyleBody</span></span><br><span class="line">                        withTrait:<span class="built_in">UIFontDescriptorTraitBold</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span>* italicAttributes = [<span class="keyword">self</span></span><br><span class="line">     createAttributesForFontStyle:<span class="built_in">UIFontTextStyleBody</span></span><br><span class="line">                        withTrait:<span class="built_in">UIFontDescriptorTraitItalic</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span>* strikeThroughAttributes = @&#123; <span class="built_in">NSStrikethroughStyleAttributeName</span> : @<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">NSDictionary</span>* scriptAttributes = @&#123; <span class="built_in">NSFontAttributeName</span> : scriptFont&#125;;</span><br><span class="line">    <span class="built_in">NSDictionary</span>* redTextAttributes =</span><br><span class="line">                          @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a dictionary of replacements based on regexes</span></span><br><span class="line">    _replacements = @&#123;</span><br><span class="line">              <span class="string">@"(\*w+(sw+)\*\*)s"</span> : boldAttributes,</span><br><span class="line">              <span class="string">@"(_w+(sw+)\*_)s"</span> : italicAttributes,</span><br><span class="line">              <span class="string">@"([0-9]+.)s"</span> : boldAttributes,</span><br><span class="line">              <span class="string">@"(-w+(sw+)\*-)s"</span> : strikeThroughAttributes,</span><br><span class="line">              <span class="string">@"(~w+(sw+)\*~)s"</span> : scriptAttributes,</span><br><span class="line">              <span class="string">@"s([A-Z]&#123;2,&#125;)s"</span> : redTextAttributes&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的作用：</p><ol><li>首先，它使用Zapfino字体来创建了“<code>script</code>”风格。<strong>Font descriptors</strong>会决定当前正文的首选字体，以保证<code>script</code>不会影响到用户的字体大小设置。  </li><li>然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 <strong><code>createAttributesForFontStyle:withTrait:</code></strong>。</li><li>最后，它将创建一个<code>NSDictionary</code>并将正则表达式映射到上面声明的属性上。</li></ol><p>如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。  </p><p>以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：<br>(*w+(sw+)**)s<br>上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：<br>(*w+(sw+)**)s<br>现在，逐步来分析这个正则表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(*    ——  匹配星号符  </span><br><span class="line">w+     —— 后接一个或多个 “word”式 字符串  </span><br><span class="line">(sw+)*   —— 后接零个或多组空格然后再接 “word” 式字符串  </span><br><span class="line">*)     —— 后接星号符  </span><br><span class="line">s     —— 以空格结尾  </span><br></pre></td></tr></table></figure></p><blockquote><font size="3">注：如果你想对正则表达式有更多了解，请参考 <a href="http://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet" target="_blank" rel="noopener">NSRegularExpression tutorial and cheat sheet</a>.</font>  </blockquote><p>现在你需要调用<code>createHighlightPatterns：</code><br>将<strong>SyntaxHighlightTextStorage.m</strong> 中的<code>init</code>方法更新如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _backingStore = [<span class="built_in">NSMutableAttributedString</span> new];</span><br><span class="line">        [<span class="keyword">self</span> createHighlightPatterns];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在SyntaxHighlightTextStorage.m方法中添加以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>*)createAttributesForFontStyle:(<span class="built_in">NSString</span>*)style</span><br><span class="line">                                    withTrait:(uint32_t)trait &#123;</span><br><span class="line">    <span class="built_in">UIFontDescriptor</span> *fontDescriptor = [<span class="built_in">UIFontDescriptor</span></span><br><span class="line">                               preferredFontDescriptorWithTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIFontDescriptor</span> *descriptorWithTrait = [fontDescriptor</span><br><span class="line">                                    fontDescriptorWithSymbolicTraits:trait];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIFont</span>* font =  [<span class="built_in">UIFont</span> fontWithDescriptor:descriptorWithTrait size: <span class="number">0.0</span>];</span><br><span class="line">    <span class="keyword">return</span> @&#123; <span class="built_in">NSFontAttributeName</span> : font &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码作用是将提供的字体样式作用到正文字体上。它给<code>fontWithDescriptor:size:</code> 提供的<code>size</code>值为0，这样做会迫使<code>UIFont</code>返回用户设置的字体大小。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 控件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TextKit </tag>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Document Interaction 编程指南</title>
      <link href="/2014/07/02/iOS/iOSDocumentInteraction%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2014/07/02/iOS/iOSDocumentInteraction%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="关于-Document-Interaction"><a href="#关于-Document-Interaction" class="headerlink" title="关于 Document Interaction"></a>关于 Document Interaction</h4><p>  iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDocumentInteractionController_class/Reference/Reference.html" target="_blank" rel="noopener">UIDocumentInteractionController</a>类，以及<a href="https://developer.apple.com/library/ios/documentation/QuickLook/Reference/QuickLookFrameworkReference_iPhoneOS/_index.html" target="_blank" rel="noopener">Quick Look</a>框架。</p><ul><li>######预览文档和呈现选项菜单<br>如果app需要打开自身并不支持的文件时，就需要使用<strong>UIDocumentInteractionController</strong>。一个<strong>document interaction controller</strong>通过<strong>Quick Look框架</strong>判断文档是否能被另一个app打开和预览。也就是说，app可以通过<strong>documentinteraction controller</strong>提供一些支持打开该文件方式的菜单。</li></ul><p>具体实现需要以下步骤：</p><ul><li><ul><li>需要通过其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象。  </li></ul></li><li><ul><li>在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。</li></ul></li><li><ul><li>用户交互，如触摸这个控件，则调用<code>documentinteractioncontroller</code>对象。  </li></ul></li></ul><p>三种交互界面:</p><pre><code>1. 预览文件的内容。2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。3. 一个菜单，仅包含“以其它方式打开”操作。</code></pre><p>同时，<code>documentinteractioncontroller</code>内置了一些手势，必要时可以直接实现它们。  </p><ul><li><p>######使用<code>documentinteractioncontroller</code>的场景:<strong>与文件交互的app都可以使用。</strong></p></li><li><ul><li>需要从网络下载文件的APP:<br>例如，email程序需要打开和预览邮件附件。</li></ul></li><li><ul><li>不下载文件的APP:<br>例如，APP需要支持文件共享（参考“File-Sharing Support” in <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007898" target="_blank" rel="noopener">iOS Technology Overview</a>), 即可以对同步到app Documents/Shared目录下的文件使用<code>documentinteractioncontroller</code>。<a id="more"></a><h4 id="创建Document-Interaction-Controller"><a href="#创建Document-Interaction-Controller" class="headerlink" title="创建Document Interaction Controller"></a>创建Document Interaction Controller</h4>创建时，通过需要其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象，并设置它的<code>delegate</code>属性。<br><code>delegate</code>对象负责告诉<strong>document  interaction controller</strong>呈现视图时需要的信息，以及当视图显示和用户交互时要执行的动作。<br>如以下代码所示。注意方法的调用者必须返回对象。<figure class="highlight objc"><figcaption><span>实例化document interaction controller</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIDocumentInteractionController</span> *) setupControllerWithURL: (<span class="built_in">NSURL</span>) fileURL</span><br><span class="line">     usingDelegate: (<span class="keyword">id</span> &lt;<span class="built_in">UIDocumentInteractionControllerDelegate</span>&gt;) interactionDelegate </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">UIDocumentInteractionController</span> *interactionController =</span><br><span class="line">       [<span class="built_in">UIDocumentInteractionController</span> interactionControllerWithURL: fileURL];</span><br><span class="line">   interactionController.delegate = interactionDelegate;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> interactionController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>实例创建后，可以通过它的属性来读取与之关联的文件信息，包括文件名、类型和URL。该实例中还有一个<code>icons</code>属性，其中包含了多个 <code>UIImage</code> 对象,可以用于表示该文档的多个大小的图标。这些信息可用于UI。</p><p>如果用其他APP打开该文件，可以利用该实例的 <code>annotation</code> 属性，该属性包含了其他APP所需的附加信息。当然信息的格式必须能够被该APP识别。<br>例如:当程序想与套件中的其他程序进行交互时，就可以使用<code>annotation</code> 属性。当被调用应用程序打开一个文件时，<code>option</code> 字典中会包含 <code>annotation</code> 的值，可以使用<font color="red" size="1">UIApplicationLaunchOptionsAnnotationKey</font> 作为键在<code>option</code>字典中检索它。</p><h4 id="呈现-Document-Interaction-Controller"><a href="#呈现-Document-Interaction-Controller" class="headerlink" title="呈现 Document Interaction Controller"></a>呈现 Document Interaction Controller</h4><p>用户可以通过 <code>Document interaction controller</code>实例，来预览该文件，或者通过弹出菜单让用户选择相应的动作。  </p><ul><li><p>模式化显示文件预览窗口，调用如下方法:</p><figure class="highlight objc"><figcaption><span>模式化预览窗口调用的方法 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Displays a full-screen preview of the target document.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)presentPreviewAnimated:(<span class="built_in">BOOL</span>)animated;</span><br></pre></td></tr></table></figure><p>预览窗口是以模式视图显示的，同时必须实现以下协议方法:</p><figure class="highlight objc"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Called when a document interaction controller needs the starting point for animating the display of a document preview.</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *) documentInteractionControllerViewControllerForPreview: (<span class="built_in">UIDocumentInteractionController</span> *) controller</span><br></pre></td></tr></table></figure><blockquote><p>注:该方法最终需要返回一个<strong><code>VC</code></strong>，来作为预览窗口的父窗口。假如没有实现该方法，或者在该方法中返回 nil，或者返回的<strong><code>VC</code></strong>无法呈现模式窗口，则该预览窗口不会显示。<br>最终会被<strong><code>documentinteractioncontroller</code></strong>会自动解散它呈现出来的窗口。或调用系统提供销毁模态视图的方法，手动销毁如下：</p><figure class="highlight objc"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dismisses the currently active menu.</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissMenuAnimated:(<span class="built_in">BOOL</span>)animated  </span><br><span class="line"><span class="comment">//Dismisses the currently active document preview.</span></span><br><span class="line">- (<span class="keyword">void</span>)dismissPreviewAnimated:(<span class="built_in">BOOL</span>)animated</span><br></pre></td></tr></table></figure></blockquote></li><li><p>通过弹出菜单提示用户选择相应动作，调用如下方法:</p><figure class="highlight objc"><figcaption><span>弹出"通过其他方式打开"菜单 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Displays an options menu and anchors it to the specified location in the view.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)presentOptionsMenuFromRect:(<span class="built_in">CGRect</span>)rect inView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line"><span class="comment">//Displays an options menu and anchors it to the specified bar button item.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)presentOptionsMenuFromBarButtonItem:(<span class="built_in">UIBarButtonItem</span> *)item animated:(<span class="built_in">BOOL</span>)animated</span><br></pre></td></tr></table></figure></li><li>提示用户用其他程序打开该文件，调用如下方法:<figure class="highlight objc"><figcaption><span>提示用户用其他程序打开 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Displays a menu for opening the document and anchors that menu to the specified view.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)presentOpenInMenuFromRect:(<span class="built_in">CGRect</span>)rect inView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line"><span class="comment">//Displays a menu for opening the document and anchors that menu to the specified bar button item.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)presentOpenInMenuFromBarButtonItem:(<span class="built_in">UIBarButtonItem</span> *)item animated:(<span class="built_in">BOOL</span>)animated</span><br></pre></td></tr></table></figure>以上几种方法都会显示一个视图或一个预览窗口或是弹出菜单。任何一个方法的调用，都要检查返回值。返回值为 <code>NO</code>，表示这个视图没有任何内容，将不能显示。<br>例如，<strong><code>presentOpenInMenuFromRect:inView:animated:</code></strong>方法返回<code>NO</code>,表明已安装的程序中没有任何程序能够打开该文档。</li></ul><h4 id="注册应用程序支持的文档类型"><a href="#注册应用程序支持的文档类型" class="headerlink" title="注册应用程序支持的文档类型"></a>注册应用程序支持的文档类型</h4><p>如果你的程序可以打开某种特定的文件类型，则可以通过<strong>Info.plist</strong>文件注册程序所能打开的文档类型。当其他程序向系统询问哪些程序可以识别该类型的文件时，你的程序就会被列到选项菜单中，供用户选择。  </p><ul><li>有如下概念:  </li><li><ul><li>需要在程序的<strong><code>Info.plist</code></strong>文件中添加新字段<strong><code>CFBundleDocumentTypes</code></strong> 键 (查看 “<a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249" target="_blank" rel="noopener">CoreFoundation Keys</a>”) 。系统会将该键中包含的内容进行登记，这样其他程序就可以通过<strong><code>document interaction controller</code></strong>访问到这些信息。</li></ul></li><li><ul><li><strong><code>CFBundleDocumentTypes</code></strong> 键是一个<code>dictionary</code>数组，一个<code>dictionary</code>表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。<br>例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软<strong>office</strong>文档），这样就可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。  </li></ul></li></ul><p><strong><code>CFBundleDocumentTypes</code></strong> 数组中的每个<code>dictionary</code>包含以下键：<br><figure class="highlight objc"><figcaption><span>字典键名称</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFBundleTypeName</span> <span class="comment">//指定文档类型名称。</span></span><br><span class="line"><span class="built_in">CFBundleTypeIconFiles</span>    <span class="comment">//是一个数组，包含多个图片文件名，用于作为该文档的图标。</span></span><br><span class="line">LSItemContentTypes <span class="comment">//是一个数组，包含多个 UTI 类型的字符串。UTI 类型是本文档类型（组）所包含的文件类型。</span></span><br><span class="line">LSHandlerRank <span class="comment">//表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。</span></span><br></pre></td></tr></table></figure><br>在应用程序的角度而言，一个文档类型其实就是一种文件类型（或者多个文件类型），该程序将一个文档类型的文件都视作同样的东西对待。例如，一个图片处理程序可能将各种图片文件都看成不同的文档类型，这样便于根据每个类型进行相应的优化。但是，对于字处理程序来说，它并不关心真正的图形格式，它把所有的图片格式都作为一个文档类型对待。</p><ul><li><strong><code>CFBundleDocumentTypes</code></strong>字典数组示例:<figure class="highlight html"><figcaption><span>自定义文件格式的文档类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleTypeName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>My File Format<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleTypeIconFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">string</span>&gt;</span>MySmallIcon.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">string</span>&gt;</span>MyLargeIcon.png<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>LSItemContentTypes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.example.myformat<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>LSHandlerRank<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>Owner<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="打开支持的文件类型"><a href="#打开支持的文件类型" class="headerlink" title="打开支持的文件类型"></a>打开支持的文件类型</h4><p>系统可能会请求某个程序打开某种文件，并呈现给用户。这种情况通常发生在某个应用程序调用 <strong><code>document interaction controller</code></strong> 去处理某个文件的时候。<br>这时应用程序可以通过委托方法:<br><figure class="highlight objc"><figcaption><span>获得文件的信息 Declared In UIApplication.h</span><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions:" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Tells the delegate that the launch process is almost done and the app is almost ready to run.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure></p><blockquote><font size="1">注:如果你的程序要处理某些自定义的文件类型，就必须实现这个委托方法（而不是<strong><code>applicationDidFinishLaunching:</code></strong>方法) 并用这个方法启动应用程序</font>  </blockquote><p>该方法的<strong><code>option</code></strong>包含了要打开的文件的相关信息，可以通过以下键名一一解析：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIApplicationLaunchOptionsURLKey</span>  <span class="comment">//该文件的NSURL</span></span><br><span class="line"><span class="built_in">UIApplicationLaunchOptionsSourceApplicationKey</span> <span class="comment">//发送请求的应用程序的Bundle ID</span></span><br><span class="line"><span class="built_in">UIApplicationLaunchOptionsSourceApplicationKey</span><span class="comment">//源程序向目标程序传递的与该文件相关的属性列表对象</span></span><br></pre></td></tr></table></figure><br>如果 <strong><code>UIApplicationLaunchOptionsURLKey</code></strong> 键存在，你的程序应当立即用该<strong><code>URL</code></strong>打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。</p><h4 id="使用-Quick-Look-框架"><a href="#使用-Quick-Look-框架" class="headerlink" title="使用 Quick Look 框架"></a>使用 Quick Look 框架</h4><p><strong><code>Quick Look</code></strong>框架提供了增强的预览功能，可以选择呈现预览窗口时的动画风格，并可以像预览单个文件一样预览多个文件。<br>该框架主要提供了 <strong><code>QLPreviewController</code></strong> 类。该类依赖于委托对象响应预览动作，以及一个用于提供预览文件的数据源，内置了所支持的文件类型的 <strong>AirPrint</strong> 打印。  </p><ul><li><h6 id="Quick-Look-Previews-中的预览及打印"><a href="#Quick-Look-Previews-中的预览及打印" class="headerlink" title="Quick Look Previews 中的预览及打印"></a>Quick Look Previews 中的预览及打印</h6>从 iOS 4.2 开始，<strong><code>QLPreviewController</code></strong> 提供了包含了一个 <code>action</code> 按钮（即打印按钮）的预览视图。对于 <strong><code>QLPreviewController</code></strong> 能预览的文件，不用编写任何打印代码，只需点击<code>action</code>按钮就能直接打印该文档。  </li></ul><p>通过以下方式显示<strong><code>QLPreviewController</code></strong>:</p><ul><li><ul><li>通过导航控制器，将预览窗口以“<strong><code>push</code> 方式</strong>”显示。</li></ul></li><li><ul><li>通过 <strong>UIViewController</strong> 的 <strong><code>presentModalViewController:animated:</code></strong>方法，将预览窗口以模态窗口的方式全屏显示。</li></ul></li><li><ul><li>显示一个<strong><code>document interaction controller</code></strong>(如 “预览及打开文件” 中所述），再在选项菜单中选择“<strong><code>Quick Look</code></strong>”即可。  </li></ul></li></ul><blockquote><font size="1">预览窗口中会包括一个标题，显示文件 URL 的最后一段路径。如果要重载标题，可以定制<strong><code>PreviewItem</code></strong> 类，并实现<strong><code>QLPreviewItem</code></strong> 协议中的 <strong>previewItemTitle</strong>方法。</font></blockquote><ul><li><h6 id="QLPreviewController能够预览下列文件："><a href="#QLPreviewController能够预览下列文件：" class="headerlink" title="QLPreviewController能够预览下列文件："></a><strong><code>QLPreviewController</code></strong>能够预览下列文件：</h6></li><li><ul><li>iWork 文档</li></ul></li><li><ul><li>Microsoft Office 文档(Office ‘97 以后版本)</li></ul></li><li><ul><li>Rich Text Format (RTF) 文档</li></ul></li><li><ul><li>PDF 文档</li></ul></li><li><ul><li>图片</li></ul></li><li><ul><li>文本文件，其 uniform type identifier (UTI)  在 public.text 文件中定义 (查看UniformType Identifiers 参考)</li></ul></li><li><ul><li>Comma-separated value (csv) 文件  </li></ul></li></ul><p>使用<strong><code>QLPreviewController</code></strong>，必须指定数据源对象（即实现 <strong><code>QLPreviewControllerDataSource</code></strong> 协议，请查看<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Reference/QLPreviewControllerDataSource_Protocol/Reference/Reference.html#//apple_ref/doc/uid/TP40009665" target="_blank" rel="noopener">QLPreviewControllerDataSource</a>协议参考）。数据源为 <strong><code>QLPreviewController</code></strong>提供预览对象（<strong><code>preivew item</code></strong>），及指明它们的数量以便在一个预览导航列表中包含它们。在这个列表中包含多个对象，在模态预览窗口（全屏显示）显示了导航箭头，以便用户在多个预览对象间切换。对于用导航控制器“push方式”显示的<strong><code>QLPreviewController</code></strong>，你可以在导航条上提供按钮以便在预览对象列表见切换。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instrument之Zombie工具</title>
      <link href="/2014/07/02/%E8%B0%83%E8%AF%95/instrument%E4%B9%8BZombie%E5%B7%A5%E5%85%B7/"/>
      <url>/2014/07/02/%E8%B0%83%E8%AF%95/instrument%E4%B9%8BZombie%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Zombie:针对<strong>僵尸对象</strong>导致应用程序崩溃，即已经<code>deallocated</code>的对象，它们的<code>retainCount</code>计数器已经为0，通过正常的手段是无法在<code>debug</code>中跟踪和观察到的。</p><p>如果你开启了 <code>Zombie Enabled</code> ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点：</p><pre><code>-[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt;</code></pre><a id="more"></a><p>虽然可以看到内存地址，知道是某个指针导致了 <code>Zombie</code> 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经<code>deallocated</code>，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针：</p><pre><code>（GDB）po &lt;内存地址&gt;</code></pre><p>仍然会得到一个 <strong><code>message sent to deallocated instance</code></strong> 的错误消息。</p><p>可以在 <code>Instrument</code> 用 <code>Zombie</code> 模板，来观察到这些 <code>Zombie</code> 对象。</p><blockquote><p>提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出<code>Zombie</code>对象，<code>Zombie</code>模板对物理设备无效。</p></blockquote><p>使用操作如下：<br>点击 Xcode 的 Project –&gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。<br><img src="/images/templateOfTraceDcument.jpg" alt="image"><br>在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。<br><img src="/images/ZombieMsgAlert.jpg" alt="image"></p><p>点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。</p><p>从列表中找到 retain count 在变为 -1 之前的那行,打开 View -&gt; Extended detail，将显示导致了过渡释放的代码调用：<br><img src="/images/ErrCodeline.jpg" alt="image"></p><p>双击这句代码，将在源文件中高亮显示该语句：</p><p><img src="/images/Errorcode.png" alt="image"><br>现在，知道问题出在哪里了吧？</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
          <category> instrument </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Storyboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIDevice类介绍</title>
      <link href="/2014/06/17/iOS/UIDevice%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
      <url>/2014/06/17/iOS/UIDevice%E7%B1%BB%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="UIDevice-h"><a href="#UIDevice-h" class="headerlink" title="UIDevice.h"></a>UIDevice.h</h3><figure class="highlight objc"><figcaption><span>设备的基本属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIDevice</span> *)currentDevice;   <span class="comment">// 获取当前设备</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span>    *name;                 <span class="comment">// e.g. "My iPhone"  </span></span><br><span class="line"><span class="built_in">NSString</span>    *model;                <span class="comment">// e.g. @"iPhone", @"iPod touch"  </span></span><br><span class="line"><span class="built_in">NSString</span>    *localizedModel;       <span class="comment">// localized version of model  </span></span><br><span class="line"><span class="built_in">NSString</span>    *systemName;       <span class="comment">// e.g. @"iOS"  </span></span><br><span class="line"><span class="built_in">NSString</span>    *systemVersion;     <span class="comment">// e.g. @"4.0"  </span></span><br><span class="line"><span class="built_in">UIDeviceOrientation</span> orientation;    <span class="comment">//除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown  </span></span><br><span class="line"><span class="built_in">NSUUID</span> *identifierForVendor         <span class="comment">//可用于唯一标识该设备，同一供应商不同应用具有相同的UUID</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>方向属性值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIDeviceOrientationUnknown</span>,</span><br><span class="line"><span class="built_in">UIDeviceOrientationPortrait</span>,                    <span class="comment">// 竖向，头向上</span></span><br><span class="line"><span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,  <span class="comment">// 竖向，头向下</span></span><br><span class="line"><span class="built_in">UIDeviceOrientationLandscapeLeft</span>,         <span class="comment">// 横向，头向左</span></span><br><span class="line"><span class="built_in">UIDeviceOrientationLandscapeRight</span>,       <span class="comment">// 横向，头向右</span></span><br><span class="line"><span class="built_in">UIDeviceOrientationFaceUp</span>,                  <span class="comment">// 平放，屏幕朝下</span></span><br><span class="line"><span class="built_in">UIDeviceOrientationFaceDown</span>                 <span class="comment">// 平放，屏幕朝下</span></span><br></pre></td></tr></table></figure><p>//使用内置的宏定义的函数，根据<strong>orientation</strong>判断设备方向,返回值类型<strong>BOOL</strong>.<br><figure class="highlight"><figcaption><span>纵向宏定义,返回YES:纵向</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UIDeviceOrientationIsPortrait(orientation)  ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown)</span><br></pre></td></tr></table></figure><br><figure class="highlight"><figcaption><span>横向宏定义,返回YES:横向</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight)</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><h4 id="横竖屏相关参数-方法与通知"><a href="#横竖屏相关参数-方法与通知" class="headerlink" title="横竖屏相关参数,方法与通知"></a>横竖屏相关参数,方法与通知</h4><ul><li>检测当前设备是否生成设备转向通知<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> generatesDeviceOrientationNotifications</span><br></pre></td></tr></table></figure></li><li>设备方向开始改变时，触发该方法，可以重写实现一些操作。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li><li>设备结束方向改变时，触发的事件，可以重写该实现一些操作。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)endGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li><li>通知<figure class="highlight objc"><figcaption><span>屏幕方向变化通知</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceOrientationDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>####手机电池相关属性与通知</li><li>电池属性<figure class="highlight objc"><figcaption><span>电池属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> batteryMonitoringEnabled      <span class="comment">// 是否启动电池监控，默认为NO </span></span><br><span class="line"><span class="built_in">UIDeviceBatteryState</span> batteryState <span class="comment">//电池状态</span></span><br><span class="line"><span class="keyword">float</span> batteryLevel    <span class="comment">//电量百分比， 0 .. 1.0,监控禁用时为-1</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>电池状态UIDeviceBatteryState属性值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIDeviceBatteryStateUnknown</span>, <span class="comment">//禁用电池监控</span></span><br><span class="line"><span class="built_in">UIDeviceBatteryStateUnplugged</span>,      <span class="comment">// 未充电</span></span><br><span class="line"><span class="built_in">UIDeviceBatteryStateCharging</span>,       <span class="comment">// 正在充电</span></span><br><span class="line"><span class="built_in">UIDeviceBatteryStateFull</span>,           <span class="comment">// 满电</span></span><br></pre></td></tr></table></figure></li><li>电池通知<figure class="highlight objc"><figcaption><span>电池状态变化通知</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryStateDidChangeNotification</span>   <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>电池电量变化通知</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryLevelDidChangeNotification</span>   <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br></pre></td></tr></table></figure></li></ul><h4 id="设备的其他属性及方法"><a href="#设备的其他属性及方法" class="headerlink" title="设备的其他属性及方法"></a>设备的其他属性及方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> proximityMonitoringEnabled <span class="comment">// 是否启动接近监控（例如接电话时脸靠近屏幕），默认为NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> proximityState <span class="comment">// 如果设备不具备接近感应器，则总是返回NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> multitaskingSupported <span class="comment">// 是否支持多任务</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIUserInterfaceIdiom</span> userInterfaceIdiom <span class="comment">// 当前用户界面模式</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playInputClick   <span class="comment">// 播放一个输入的声音</span></span><br></pre></td></tr></table></figure><p>//用户界面类型<br><figure class="highlight objc"><figcaption><span>iOS3.2以上有效</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if __IPHONE_3_2 <span class="meta-string">&lt;= __IPHONE_OS_VERSION_MAX_ALLOWED</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    UIUserInterfaceIdiomPhone,           // iPhone 和 iPod touch 风格</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    UIUserInterfaceIdiomPad,              // iPad 风格</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure><br><figure class="highlight"><figcaption><span>获取当前用户界面模式的宏定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UI_USER_INTERFACE_IDIOM() ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] ? [[UIDevice currentDevice] userInterfaceIdiom] : UIUserInterfaceIdiomPhone)</span><br></pre></td></tr></table></figure></p><h4 id="一些协议的定义"><a href="#一些协议的定义" class="headerlink" title="一些协议的定义"></a>一些协议的定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIInputViewAudioFeedback</span></span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 实现该方法，返回YES则自定义的视图能够播放输入的声音</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> enableInputClicksWhenVisible; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="其他通知"><a href="#其他通知" class="headerlink" title="其他通知"></a>其他通知</h4><figure class="highlight objc"><figcaption><span>接近状态变化通知</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceProximityStateDidChangeNotification</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS7新宠TextKit</title>
      <link href="/2014/06/17/iOS/UI/IOS7%E6%96%B0%E5%AE%A0TextKit/"/>
      <url>/2014/06/17/iOS/UI/IOS7%E6%96%B0%E5%AE%A0TextKit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Text-Kit"><a href="#Text-Kit" class="headerlink" title="Text Kit"></a>Text Kit</h2><p><strong><code>Text Kit</code></strong>：是个庞大的framework，继承了<code>Core Text</code>的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过<strong>NSTextStorage</strong>对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。  </p><blockquote><font size="3">更直观的理解，<strong>UITextView</strong>，<strong>UITextField</strong>、<strong>UILabel</strong>等UIKit控件都已经基于<strong>Text Kit</strong>重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>例如：NSTextStorage对象，它本身是<strong>NSMutableAttributedString</strong>的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。</font>  </blockquote><p>IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下<code>Core Text</code>。后来iOS6，增加一个很棒的属性:<code>NSAttributedString</code>，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的<code>Text Kit</code>新宠。<br>在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br>iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：  </p><a id="more"></a><h2 id="Text-Kit中4个重要的角色"><a href="#Text-Kit中4个重要的角色" class="headerlink" title="Text Kit中4个重要的角色"></a>Text Kit中4个重要的角色</h2><ul><li><ul><li><strong><code>Text Views</code></strong>: 用来显示文本内容的控件，主要包括<code>UILabel</code>、<code>UITextView</code>和<code>UITextField</code>。  </li></ul></li><li><ul><li><strong><code>Text containers</code></strong>: 对应着<code>NSTextContainer</code>类。<code>NSTextContainer</code>定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化<code>NSTextContainer</code>来创建别的一些形状，例如圆形、不规则的形状等。<code>NSTextContainer</code>不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。    </li></ul></li><li><ul><li><strong><code>Layout manager</code></strong>: 对应着<code>NSLayoutManager</code>类。该类负责对文字进行编辑排版处理——通过将存储在<code>NSTextStorage</code>中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(<code>glyphs</code>)上，然后将字形排版到<code>NSTextContainer</code>定义的区域中。  </li></ul></li><li><ul><li><strong><code>Text storage</code></strong>: 对应着<code>NSTextStorage</code>类。该类定义了<code>Text Kit</code>扩展文本处理系统中的基本存储机制。<code>NSTextStorage</code>继承自<code>NSmutableAttributedString</code>，主要用来存储文本的字符和相关属性。另外，当<code>NSTextStorage</code>中的字符或属性发生了改变，会通知<code>NSLayoutManager</code>，进而做到文本内容的显示更新。<br>通常情况下，<strong><code>NSTextStorage</code></strong>、<strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong>是一一对应关系:<br>如果将文字显示为多列，或多页，可以按照下图关系，使用多个<strong><code>NSTextContainer</code></strong>:<br>如果针对不同的排版方式，可以按照下图关系，使用多个<strong><code>NSLayoutManager</code></strong>:<br>通常由<strong><code>NSLayoutManager</code></strong>从<strong><code>NSTextStorage</code></strong>中读取出文本数据，然后根据一定的排版方式，将文本排版到<strong><code>NSTextContainer</code></strong>中，再由<strong><code>NSTextContainer</code></strong>结合<code>UITextView</code>将最终效果显示出来。<br>如下图，为了更直观理解，对<code>UITextView</code>的组成做了分解: </li></ul></li></ul><h2 id="Text-Kit示例"><a href="#Text-Kit示例" class="headerlink" title="Text Kit示例"></a>Text Kit示例</h2><ol><li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li><li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li><li><ol><li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个平移手势对象，该对象可以调用imagePanned：方法</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGes = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(imagePanned:)];</span><br><span class="line">    [<span class="keyword">self</span>.imageView addGestureRecognizer:panGes];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.textView.textContainer.exclusionPaths = @[[<span class="keyword">self</span> translatedBezierPath]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。  </li></ol></li><li><ol start="2"><li><strong>translatedBezierPath</strong>方法实现如下：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIBezierPath</span> *)translatedBezierPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> butterflyImageRect = [<span class="keyword">self</span>.textView convertRect:<span class="keyword">self</span>.imageView.frame fromView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *newButterflyPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:butterflyImageRect];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newButterflyPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。  </li></ol></li><li><ol start="3"><li><strong>imagePanned:</strong>方法实现如下：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)imagePanned:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([sender isKindOfClass:[<span class="built_in">UIPanGestureRecognizer</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIPanGestureRecognizer</span> *localSender = sender;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localSender.state == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.gestureStartingPoint = [localSender translationInView:<span class="keyword">self</span>.textView];</span><br><span class="line">            <span class="keyword">self</span>.gestureStartingCenter = <span class="keyword">self</span>.imageView.center;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (localSender.state == <span class="built_in">UIGestureRecognizerStateChanged</span>) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> currentPoint = [localSender translationInView:<span class="keyword">self</span>.textView];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGFloat</span> distanceX = currentPoint.x - <span class="keyword">self</span>.gestureStartingPoint.x;</span><br><span class="line">            <span class="built_in">CGFloat</span> distanceY = currentPoint.y - <span class="keyword">self</span>.gestureStartingPoint.y;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGPoint</span> newCenter = <span class="keyword">self</span>.gestureStartingCenter;</span><br><span class="line"></span><br><span class="line">            newCenter.x += distanceX;</span><br><span class="line">            newCenter.y += distanceY;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.imageView.center = newCenter;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.textView.textContainer.exclusionPaths = @[[<span class="keyword">self</span> translatedBezierPath]];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (localSender.state == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.gestureStartingPoint = <span class="built_in">CGPointZero</span>;</span><br><span class="line">            <span class="keyword">self</span>.gestureStartingCenter = <span class="built_in">CGPointZero</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用<code>translatedBezierPath</code>方法重新计算了一下排除区域。<br>示例效果:  </li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TextKit </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS7的变革</title>
      <link href="/2014/06/11/iOS/IOS7%E7%9A%84%E5%8F%98%E9%9D%A9/"/>
      <url>/2014/06/11/iOS/IOS7%E7%9A%84%E5%8F%98%E9%9D%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="性能提高以及被遗弃的功能"><a href="#性能提高以及被遗弃的功能" class="headerlink" title="性能提高以及被遗弃的功能"></a>性能提高以及被遗弃的功能</h2><h3 id="新增截屏通知-UIApplicationUserDidTakeScreenshotNotification"><a href="#新增截屏通知-UIApplicationUserDidTakeScreenshotNotification" class="headerlink" title="新增截屏通知:UIApplicationUserDidTakeScreenshotNotification"></a>新增截屏通知:<code>UIApplicationUserDidTakeScreenshotNotification</code></h3><p>在IOS 7之前，开发者使用了一种<strong><a href="http://dlj.bz/XflV" target="_blank" rel="noopener">很赞的方法</a></strong>，来<strong>拦截</strong>截屏事件的.<br>比如，Snapchat的实现原理: 用户通过<strong>Snapchat</strong>发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，<font color="red"><strong>截屏将打断触控操作</strong></font>，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。  </p><p>在iOS 7中，专门为<font color="red"><strong>截屏完成后</strong></font>提供了一个通知:<br>  <code>UIApplicationUserDidTakeScreenshotNotification</code>.同时，也规避了IOS 6中<font color="red"><strong>截屏将打断触控操作</strong></font>的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。<br>注册<font color="red"><strong>截屏完成后</strong></font>通知:<br><figure class="highlight objc"><figcaption><span>注册监听事件，接收截屏完成后的通知</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]  addObserver:<span class="keyword">self</span> </span><br><span class="line">  selector:<span class="keyword">@selector</span>(mymethod:)</span><br><span class="line">      name:<span class="built_in">UIApplicationUserDidTakeScreenshotNotification</span> </span><br><span class="line">    object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p><p>Note:<br>    1.This notification is posted after the screenshot is taken.<br>    2.This notification does not contain a userInfo dictionary.</p><h3 id="新增手势-UIScreenEdgePanGestureRecognizer"><a href="#新增手势-UIScreenEdgePanGestureRecognizer" class="headerlink" title="新增手势: UIScreenEdgePanGestureRecognizer"></a>新增手势: UIScreenEdgePanGestureRecognizer</h3><p><code>UIScreenEdgePanGestureRecognizer</code> inherits from <code>UIPanGestureRecognizer</code> and lets you <strong>detect gestures starting near the edge of the screen</strong>.<br>Using this new gesture recognizer is quite simple, as shown below:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScreenEdgePanGestureRecognizer</span> *recognizer = [[<span class="built_in">UIScreenEdgePanGestureRecognizer</span> alloc] </span><br><span class="line">initWithTarget:<span class="keyword">self</span> </span><br><span class="line">action:<span class="keyword">@selector</span>(handleScreenEdgeRecognizer:)];</span><br><span class="line"><span class="comment">// accept gestures that start from the left; we're probably building another hamburger menu!</span></span><br><span class="line">recognizer.edges = <span class="built_in">UIRectEdgeLeft</span>; </span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:recognizer];</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="新增返回类型-–-instancetype"><a href="#新增返回类型-–-instancetype" class="headerlink" title="新增返回类型 – instancetype"></a>新增返回类型 – <code>instancetype</code></h3><p>  苹果改变了大部分 initializer和简易构造函数（convenience constructors），<code>instancetype</code>可以代替<code>id</code>作返回类型。</p><pre><code>instancetype 作用：        1.作为从Objective-C方法的返回类型。        2.在编译时，该方法的返回类型将是该方法所属的类的实例，编译器就会对返回的实例做一些检查，有bug及时发现及时解决。这一点优于id类型。        3.在调用子类方法时，就可以省去对返回值的强制类型转换。</code></pre><p>  举例:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *d = [<span class="built_in">NSArray</span> arrayWithObjects:@(<span class="number">1</span>),@(<span class="number">2</span>), <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%i"</span>, d.count);</span><br><span class="line">```  </span><br><span class="line">这段代码显然有错误，但在Xcode4<span class="number">.6</span>上是可以编译通过的。是由于Objective-C是动态性语言。</span><br><span class="line">``` objc</span><br><span class="line">+ (<span class="keyword">id</span>)arrayWithObjects:(<span class="keyword">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p><p>并且，arrayWithObjects:返回<code>id</code>类型：是运行时的动态类型，编译器无法知道它的真实类型，即使调用一个id类型没有的方法，也不会产生编译警告。</p><p>那么，为什么<code>arrayWithObjects:</code>方法的返回类型还是<code>id</code>类型？来看看<code>NSArray</code>子类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyArray</span> : <span class="title">NSArray</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>Now consider the use of your new subclass in the code below:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyArray *array = [MyArray arrayWithObjects:@(<span class="number">1</span>), @(<span class="number">2</span>), <span class="literal">nil</span>];</span><br><span class="line">```  </span><br><span class="line">如果方法`arrayWithObjects:`返回值的类型是`<span class="built_in">NSArray</span> *`，那么子类`MyArray`就需要被强制转换为所需的类`<span class="built_in">NSArray</span>`。这是正是`<span class="keyword">instancetype</span>`返回类型的用武之地。</span><br><span class="line">在iPhone <span class="number">7.0</span> SDK的<span class="built_in">NSArray</span>中的头文件，已更新为：</span><br><span class="line">``` objc</span><br><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithObjects:(<span class="keyword">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p><p>唯一的区别是返回类<code>instancetype</code>取代<code>id</code>。这种新的返回类型会告知编译器，返回值是该方法所属的类的实例对象。<br>也就是说:当<code>NSArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为NSArray*;<br>当<code>MyArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为MyArray*。  </p><p><code>instancetype</code>解决<code>id</code>类型的问题，同时也继承<code>id</code>类型功能。如果编译在Xcode 5的原代码，你会看到下面的警告：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">warning: incompatible pointer types initializing 'NSDictionary *' with an expression of type 'NSArray *' [-Wincompatible-pointer-types]</span><br><span class="line">    <span class="built_in">NSDictionary</span> *d = [<span class="built_in">NSArray</span> arrayWithObjects:@(<span class="number">1</span>), @(<span class="number">2</span>), <span class="literal">nil</span>];</span><br><span class="line">                ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  </span><br><span class="line">```  </span><br><span class="line">  w00t — now that’s helpful! You now have the opportunity to fix the problem before it turns into a crash later down the line.  </span><br><span class="line"></span><br><span class="line">  Initializers are also candidates <span class="keyword">for</span> using <span class="keyword">this</span> new <span class="keyword">return</span> type. The compiler has warned you <span class="keyword">for</span> some time now <span class="keyword">if</span> you set the <span class="keyword">return</span> type of an initializer to that of an incompatible type. But presumably it’s just implicitly converting the <span class="keyword">id</span> <span class="keyword">return</span> type to <span class="keyword">instancetype</span> under the hood. You should still use <span class="keyword">instancetype</span> <span class="keyword">for</span> initializers though, because it’s better to be <span class="keyword">explicit</span> <span class="keyword">for</span> habit’s sake.  </span><br><span class="line"></span><br><span class="line">  Strive to use <span class="keyword">instancetype</span> as much as possible going forward; it’s become a standard <span class="keyword">for</span> Apple — and you never know when it will save you some painful debugging time later on.</span><br><span class="line">  </span><br><span class="line"><span class="meta">### UIScrollView新增属性：`UIScrollViewKeyboardDismissMode`</span></span><br><span class="line">像Messages app一样在滚动的时候，将键盘隐藏，是一种非常好的体验。  </span><br><span class="line">在以前，将这项功能整合到app很难，现在仅仅只需要在Storyboard中简单的改变一个属性值，或者增加一行代码即可。</span><br><span class="line"></span><br><span class="line">这个属性使用了新的`<span class="built_in">UIScrollViewKeyboardDismissMode</span>` <span class="keyword">enum</span>枚举类型。这个<span class="keyword">enum</span>枚举类型可能的值如下：  </span><br><span class="line">``` objc  <span class="built_in">UIScrollViewKeyboardDismissMode</span>枚举值</span><br><span class="line"><span class="comment">// the keyboard is not dismissed automatically when scrolling</span></span><br><span class="line"><span class="built_in">UIScrollViewKeyboardDismissModeNone</span>   </span><br><span class="line">    <span class="comment">// dismisses the keyboard when a drag begins </span></span><br><span class="line"><span class="built_in">UIScrollViewKeyboardDismissModeOnDrag</span>  </span><br><span class="line">    <span class="comment">// the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss </span></span><br><span class="line"><span class="built_in">UIScrollViewKeyboardDismissModeInteractive</span>  </span><br><span class="line">```  </span><br><span class="line">在storyboard中设置该属性值:  </span><br><span class="line">![<span class="built_in">UIScrollViewKeyboardDismissMode</span>](/images/<span class="built_in">UIScrollViewKeyboardDismissMode</span>.png)  </span><br><span class="line"><span class="meta">### UIKit使用[NSAttributedString]((http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/)显示HTML，[TextKit](http://)</span></span><br><span class="line">在app中使用Webviews有时会让人非常沮丧，即使只是显示少量的HTML内容 ,Webviews也会消耗大量的内存。</span><br><span class="line">现在提供了一种全新的简单易用的方式来展示HTML内容，适用于任意的`<span class="built_in">UIKit</span>`控件，如`<span class="built_in">UILabel</span>`或`<span class="built_in">UITextField</span>`等。   </span><br><span class="line"><span class="number">1.</span>用少量HTML片段，初始化`<span class="built_in">NSAttributedString</span>`对象:</span><br><span class="line"></span><br><span class="line">&#123;% codeblock lang:objc Time to be Awesome - awesome.rb %&#125;</span><br><span class="line"><span class="built_in">NSString</span> *html = <span class="string">@"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!"</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123;<span class="built_in">NSDocumentTypeDocumentAttribute</span>: <span class="built_in">NSHTMLTextDocumentType</span>&#125;;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line"></span><br><span class="line">``` objc 用少量HTML片段，初始化`<span class="built_in">NSAttributedString</span>`对象 http:<span class="comment">//developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/</span></span><br><span class="line"><span class="built_in">NSString</span> *html = <span class="string">@"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!"</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123;<span class="built_in">NSDocumentTypeDocumentAttribute</span>: <span class="built_in">NSHTMLTextDocumentType</span>&#125;;</span><br><span class="line"><span class="built_in">NSData</span> *htmlData = [html dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSAttributedString</span> *attrString = [[<span class="built_in">NSAttributedString</span> alloc] initWithData:htmlData</span><br><span class="line">                      options:options </span><br><span class="line">                       documentAttributes:<span class="literal">nil</span> </span><br><span class="line">                           error:<span class="literal">nil</span>];</span><br><span class="line">```   </span><br><span class="line"><span class="built_in">NSDocumentTypeDocumentAttribute</span>包括:</span><br><span class="line">&lt;!--https:<span class="comment">//gist.githubusercontent.com/huos3203/ecba275d5e4404678354/raw/1636f62209b056b4acbe07021f596e1ffd5ef301/%E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5</span></span><br><span class="line">--&gt;</span><br><span class="line"><span class="built_in">NSPlainTextDocumentType</span><span class="comment">//Plain text document.</span></span><br><span class="line">    <span class="built_in">NSRTFTextDocumentType</span><span class="comment">//Rich text format document.</span></span><br><span class="line">    <span class="built_in">NSRTFDTextDocumentType</span><span class="comment">//Rich text format with attachments document.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>相反，也可以将`<span class="built_in">NSAttributedString</span>`对象，解析成HTML片段：</span><br><span class="line"></span><br><span class="line">&#123;% gist ecba275d5e4404678354 %E8%A7%A3%E6%<span class="number">9</span>E%<span class="number">90</span>NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%<span class="number">8</span>C%E8%<span class="number">8</span>E%B7%E5%<span class="number">8</span>F%<span class="number">96</span>%E6%<span class="number">88</span>%<span class="number">90</span>HTML%E7%<span class="number">89</span>%<span class="number">87</span>%E6%AE%B5.m %&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">### NSLinkAttributeName让标签（UILabel,UITextView）支持超链接</span></span><br><span class="line"> </span><br><span class="line">首先，创建一个`<span class="built_in">NSAttributedString</span>`对象,然后，调用`addAttribute:value:range:`方法，添加 `<span class="built_in">NSLinkAttributeName</span>`属性并赋值，如下：  </span><br><span class="line">``` objc <span class="built_in">UITextView</span>支持超链接</span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *attributedString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@"This is an example by @marcelofabri_"</span>]; </span><br><span class="line">[attributedString addAttribute:<span class="built_in">NSLinkAttributeName</span> </span><br><span class="line">                         value:<span class="string">@"username://marcelofabri_"</span> </span><br><span class="line">                         range:[[attributedString string] rangeOfString:<span class="string">@"@marcelofabri_"</span>]]; </span><br><span class="line"><span class="built_in">NSDictionary</span> *linkAttributes = @&#123;<span class="built_in">NSForegroundColorAttributeName</span>: [<span class="built_in">UIColor</span> greenColor], </span><br><span class="line">                                 <span class="built_in">NSUnderlineColorAttributeName</span>: [<span class="built_in">UIColor</span> lightGrayColor], </span><br><span class="line">                                 <span class="built_in">NSUnderlineStyleAttributeName</span>: @(<span class="built_in">NSUnderlinePatternSolid</span>)&#125;;  </span><br><span class="line"><span class="comment">// assume that textView is a UITextView previously created (either by code or Interface Builder) </span></span><br><span class="line">textView.linkTextAttributes = linkAttributes; <span class="comment">// customizes the appearance of links </span></span><br><span class="line">textView.attributedText = attributedString; </span><br><span class="line">textView.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure></p><p>当然，也可以使用<code>UITextViewDelegate</code>新增的协议方法<font color="red"><strong>shouldInteractWithURL</strong></font>，来自定义点击事件：<br><figure class="highlight objc"><figcaption><span>协议方法shouldInteractWithURL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textView:(<span class="built_in">UITextView</span> *)textView shouldInteractWithURL:(<span class="built_in">NSURL</span> *)URL </span><br><span class="line">               inRange:(<span class="built_in">NSRange</span>)characterRange &#123; </span><br><span class="line">    <span class="keyword">if</span> ([[URL scheme] isEqualToString:<span class="string">@"username"</span>]) &#123; </span><br><span class="line">        <span class="built_in">NSString</span> *username = [URL host];  </span><br><span class="line">        <span class="comment">// do something with this username </span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">// let the system open this URL </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tint-images-with-UIImage-renderingMode"><a href="#Tint-images-with-UIImage-renderingMode" class="headerlink" title="Tint images with UIImage.renderingMode"></a>Tint images with <code>UIImage.renderingMode</code></h3><p>Tinting is a big part of the new look and feel of iOS 7, and you have control whether your image is tinted or not when rendered.<br>UIImage now has a read-only property named <code>renderingMode</code> as well as a new method <code>imageWithRenderingMode:</code> which uses the new enum <code>UIImageRenderingMode</code> containing the following possible values:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Use the default rendering mode for the context where the image is used</span><br><span class="line">UIImageRenderingModeAutomatic  </span><br><span class="line">// Always draw the original image, without treating it as a template</span><br><span class="line">UIImageRenderingModeAlwaysOriginal  </span><br><span class="line">// Always draw the image as a template image, ignoring its color information</span><br><span class="line">UIImageRenderingModeAlwaysTemplate</span><br></pre></td></tr></table></figure></p><p>The code below shows how easy it is to create an image with a given rendering mode:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myimage"</span>]; </span><br><span class="line">img = [img imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysTemplate</span>];</span><br></pre></td></tr></table></figure></p><p>The default value of renderingMode is UIImageRenderingModeAutomatic.<br>Whether the image will be tinted or not depends on where it’s being displayed as shown by the examples below:<br><img src="/images/uiimagerenderingmode.png" alt="image"></p><h3 id="Usage-of-tintColor-vs-barTintColor"><a href="#Usage-of-tintColor-vs-barTintColor" class="headerlink" title="Usage of tintColor vs barTintColor"></a>Usage of tintColor vs barTintColor</h3><p>In iOS 7 you can tint your entire app with a given color or even implement color themes to help your app stand out from the rest.Setting the tint color of your app is as easy as using the new property <code>tintColor</code> of <code>UIView</code>.<br>Does that property sound familiar? it should — some classes such as <code>UINavigationBar</code>, <code>UISearchBar</code>, <code>UITabBar</code> and <code>UIToolbar</code> already had a property with this name. They now have a new property: <code>barTintColor</code>.<br>In order to avoid getting tripped up by the new property, you should perform the following check if your app needs to support iOS 6 or earlier:</p><figure class="highlight objc"><figcaption><span>bar通过判断是否包含setBarTintColor:确定系统版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINavigationBar</span> *bar = <span class="keyword">self</span>.navigationController.navigationBar;</span><br><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([bar respondsToSelector:<span class="keyword">@selector</span>(setBarTintColor:)]) &#123; </span><br><span class="line"><span class="comment">// iOS 7+</span></span><br><span class="line">    bar.barTintColor = color;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// iOS 6 or earlier</span></span><br><span class="line">    bar.tintColor = color;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="meta">### Check which wireless routes are available</span></span><br><span class="line">The ability to customize a video player (and friends) has evolved throughout the past few iOS versions. As an example, prior to iOS <span class="number">6</span> you couldn’t change the AirPlay icon on a `<span class="built_in">MPVolumeView</span>`.  </span><br><span class="line">In iOS <span class="number">7</span>, you’re finally able to know <span class="keyword">if</span> a remote device is available via AirPlay, Bluetooth, or some other wireless mechanism. This allows your app to behave appropriately, such as hiding an AirPlay icon when that service isn’t available on other devices.  </span><br><span class="line">The following two new properties and notifications have been added to <span class="built_in">MPVolumeView</span>:  </span><br><span class="line"></span><br><span class="line">``` objc  </span><br><span class="line"><span class="comment">// is there a route that the device can connect to?</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> wirelessRoutesAvailable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is the device currently connected?</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> wirelessRouteActive;   </span><br><span class="line">  <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">MPVolumeViewWirelessRoutesAvailableDidChangeNotification</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">MPVolumeViewWirelessRouteActiveDidChangeNotification</span>;</span><br></pre></td></tr></table></figure><h3 id="NSArray-firstObject-的实现"><a href="#NSArray-firstObject-的实现" class="headerlink" title="-[NSArray firstObject]的实现"></a><code>-[NSArray firstObject]</code>的实现</h3><p><code>-[NSArray firstObject]</code>可能是Objective-C中被调用做多的API。 在iOS4.0中<code>firstObject</code>已经被使用，但是那时仅仅是一个私有方法。在iOS7以前，常用方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[]; </span><br><span class="line"><span class="keyword">id</span> item = [arr firstObject]; </span><br><span class="line"><span class="comment">// 前你需要做以下工作 </span></span><br><span class="line"><span class="keyword">id</span> item = [arr count] &gt; <span class="number">0</span> ? arr[<span class="number">0</span>] : <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure></p><p>因为上面的方式很常用，一般创建一个类别实现该方法<code>firstObject</code>增加到NSArray中。</p><p>这个方法的问题:<code>方法名</code>必须是唯一的，否则,这个方法所引发的问题无法预估。所以在<code>NSArray</code>中最好不要重载<code>firstObject</code>方法，是有风险的。</p><h3 id="UIButtonTypeRoundRect被UIButtonTypeSystem取代"><a href="#UIButtonTypeRoundRect被UIButtonTypeSystem取代" class="headerlink" title="UIButtonTypeRoundRect被UIButtonTypeSystem取代"></a>UIButtonTypeRoundRect被UIButtonTypeSystem取代</h3><p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2010/05/Rate.jpg" alt="alt text" title="UIButtonTypeRoundRect被UIButtonTypeSystem取代"></p><h4 id="UIPasteboard由共享变为沙盒化了"><a href="#UIPasteboard由共享变为沙盒化了" class="headerlink" title="UIPasteboard由共享变为沙盒化了"></a><code>UIPasteboard</code>由共享变为沙盒化了</h4><p>UIPasteboard过去是用来做app之间的数据分享的。开发者一般使用它来存储标识符，比如:OpenUDID。<br>但在在iOS7中，使用 <code>+[UIPasteboard pasteboardWithName:create:]</code>和 <code>+[UIPasteboard pasteboardWithUniqueName]</code>创建剪贴板，而且只对相同的app group可见，这样再和其他的相关app分享以前的OpenUDID等标识符时，就会出现问题。</p><h4 id="MAC地址-被统一化"><a href="#MAC地址-被统一化" class="headerlink" title="MAC地址:被统一化"></a><code>MAC地址</code>:被统一化</h4><p>在IOS7之前，生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。 一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。<br>然而，苹果并不希望有人通过MAC地址来分辨用户，在iOS7以上，查询MAC地址，它现在只会返回02:00:00:00:00:00。<br>目前，苹果推荐开发者使用以下两种方式，来获取作为框架和应用的唯一标示符：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *identifierForVendor = [[<span class="built_in">UIDevice</span> currentDevice].identifierForVendor UUIDString]; </span><br><span class="line"><span class="built_in">NSString</span> *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">``` </span><br><span class="line">`identifierForVendor`：由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</span><br><span class="line">`advertisingIdentifier`：返回给在这个设备上所有软件供应商公用的唯一值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</span><br><span class="line">  </span><br><span class="line"><span class="meta">####  app启动麦克风，需争征得用户同意  </span></span><br><span class="line">  </span><br><span class="line">  以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。</span><br><span class="line">  现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</span><br><span class="line">  以下的代码是用来查询用户是否允许app使用麦克风：  </span><br><span class="line">```objc</span><br><span class="line"><span class="comment">//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据 </span></span><br><span class="line"><span class="comment">// 其他时候调用方法的时候，则不会提醒用户 </span></span><br><span class="line"><span class="comment">// 而会传递之前的值来要求用户同意 </span></span><br><span class="line">[[<span class="built_in">AVAudioSession</span> sharedInstance] requestRecordPermission:^(<span class="built_in">BOOL</span> granted) &#123; </span><br><span class="line">    <span class="keyword">if</span> (granted) &#123; </span><br><span class="line">        <span class="comment">// 用户同意获取数据 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 可以显示一个提示框告诉用户这个app没有得到允许？ </span></span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure></p><p>如果没有经过用户同意，就调用麦克风，iOS系统自动弹出以下警示栏：<br><img src="/images/microphone.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在IOS中像SnapChat一样监控screenshots</title>
      <link href="/2014/06/11/iOS/%E5%9C%A8IOS%E4%B8%AD%E5%83%8FSnapChat%E4%B8%80%E6%A0%B7%E7%9B%91%E6%8E%A7screenshots/"/>
      <url>/2014/06/11/iOS/%E5%9C%A8IOS%E4%B8%AD%E5%83%8FSnapChat%E4%B8%80%E6%A0%B7%E7%9B%91%E6%8E%A7screenshots/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A <a href="http://stackoverflow.com/questions/2121970/notification-of-or-detecting-screenshot-being-taken/2122117" target="_blank" rel="noopener">number</a> of <a href="http://stackoverflow.com/questions/13484516/ios-detection-of-screenshot" target="_blank" rel="noopener">Stack</a>  <a href="http://stackoverflow.com/questions/10122212/iphone-screenshot" target="_blank" rel="noopener">Overflow</a>questions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.<br><a id="more"></a><br>The process is pretty simple, and relies on a quirk of iOS: taking a screenshot cancels all touches on the screen. Because of that, anything that you want to protect will require you to have the user to touch the screen to see. If that works for your purposes, the general solution is to simply intercept the touch cancellation, and quickly remove any sensitive information from the screen. If you’re also implementing a screenshot counter, as with SnapChat, you will also need to take into account the other cases when a touch might be cancelled: from a system gesture (Notification Center or the iPad’s multitasking gestures), or by activating other pieces of system UI (the power down menu, or the multitasking switcher).</p><p>On a technical level, the two basic pieces are UILongPressGestureRecognizer (or -touchesCancelled:withEvent:, if you want) and UIApplicationDelegate. In your long press handler, you should hide your sensitive information when the gesture recognizer’s state is UIGestureRecognizerStateCancelled, and if you want to track the number of screenshots, increment a counter. Then, in the UIApplicationDelegate, decrement that counter when you receive the -applicationWillEnterBackground: or -applicationDidResignActive: notification to account for the other possibilities for a cancelled touch. You might also need to handle other situations where a touch could be cancelled, if other parts of your app might cause that to happen.</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 截屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS7截屏问题</title>
      <link href="/2014/06/11/iOS/IOS7%E6%88%AA%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2014/06/11/iOS/IOS7%E6%88%AA%E5%B1%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="iOS-7截图最新变化-不再影响用户其他操作"><a href="#iOS-7截图最新变化-不再影响用户其他操作" class="headerlink" title="iOS 7截图最新变化: 不再影响用户其他操作"></a>iOS 7截图最新变化: 不再影响用户其他操作</h3><p>   在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。<br><a id="more"></a><br>　　用户在应用中打开 Snapchat 照片，查看照片时用户需要单指按在屏幕上让照片处于打开的状态。如果用户试图截图，那么照片马上就会关闭。这是 Snapchat 用来检测“非法”截图的办法。用户拍了照片发送给好友后，这些照片会根据用户所预先设定的时间按时自动销毁。如果接收方在此期间试图进行截图的话，用户也将得到通知。</p><p>   Snapchat在美国青少年群体中十分流行，因为它拥有一种独特的“阅后即焚”机制。用户通过该应用发送的照片将会在数秒内自动被删除，而且它还将采用一种特殊手段阻止照片接收者截屏，并将其截屏企图报告给发送者。在 iOS 6 中，截屏将打断触控操作，而用户观看 Snapchat 照片时，必须将手指按在屏幕上。</p><p>　　在 iOS 7 中截图的操作不会迫使 SnapChat 查看照片的窗口关闭，也就是说当用户截图时系统也不会发出提醒通知。截图不会影响用户在屏幕上的操作，照片不会关闭应用也无法识别截图的动作。如果一名 iOS 6 用户试图截图 iOS 7 用户会收到通知，而反过来的话 iOS 6 用户则不会受到通知。这对于 Snapchat 来说，绝对是个恶梦，因为该服务的风靡与阅后即焚机制关系很大。</p><p>　　虽然 iOS 7 的这个变化对于 iOS 7 Snapchat 用户来说有一定的意义，但是这也对 Snapchat 等应用提出更高的要求，他们必须研究出新的办法来检测截图操作，确保这个新特性不会对他们的应用产生影响。</p><p>　　所幸 iOS 7 beta 4 的发布可以让开发商放下心来。9to5Mac 的 Scott Buscemi 不久前宣布，新版本中新增了一个截屏侦测 API。开发者并未透露这个其具体特性，但他暗示说这个 API 对 Snapchat 来说非常至关重要.<br>　　<br><strong>UIApplication.h</strong></p><pre><code>// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)UIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0);</code></pre><p>　　据悉，iOS 7 beta 2 发布之后，此前一些无法实现的有趣操作也随之变得可行。由于 iOS 6 的截屏将取消触控操作，使得用户难以截取拉了半截的锁屏界面。而在 iOS 7 beta 2 中，一切变得容易起来（见下图）。  </p><p>　　<img src="http://resource.feng.com/resource/h027/h71/img201307301647042.jpg" alt="alt text" title="Snapchat福音 iOS 7 beta 4恢复截屏侦测"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 截屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步搭建Octopress</title>
      <link href="/2014/06/10/hexo/%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BAOctopress/"/>
      <url>/2014/06/10/hexo/%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BAOctopress/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="软件支持："><a href="#软件支持：" class="headerlink" title="软件支持："></a>软件支持：</h1><ol><li><strong>Github</strong>:后台新建项目，点击<a href="https://help.github.com/articles/set­up­git" target="_blank" rel="noopener">下载</a></li><li><strong>iTerm2</strong>:可以替代mac终端，相当强大。<a href="http://www.iterm2.com/#/section/home" target="_blank" rel="noopener">下载</a></li><li><strong>ruby</strong>:ruby安装包  <a href="http://ruby.taobao.org/mirrors/ruby/" target="_blank" rel="noopener">下载</a></li><li><strong>Mou</strong>:MarkDown编辑软件，可用于后期发布博客文章。<a href="http://mouapp.com/" target="_blank" rel="noopener">下载</a></li><li><strong>Xcode</strong>：它将帮助你安装好Unix环境需要的开发包。</li></ol><p>￼<!--显示文章缩略部分的标记方法--><br><a id="more"></a></p><h1 id="学习目的："><a href="#学习目的：" class="headerlink" title="学习目的："></a>学习目的：</h1><p>要求:搭建一个独立博客网站,首先要有台连接到英特网服务器,要有前端的页面和后端的数据库,以及域名等.</p><ol><li><p>github可以提供给我们的是,github一个免费的代码托管仓库,它支持用户html页面的显示,用户可以上传HTML文件,然后在远程像访问网页一样访问它。</p></li><li><p>这时，博客还缺具有管理能力的网站后台,github不提供数据库等，对于博客这种数据规模很小,便可返璞归真,用回静态页面。</p></li><li><strong>Octopress</strong>:能将易于编写的<strong>Markdown</strong>的文本，翻译成为繁琐的<strong>html</strong>页面，同时帮助用户管理<strong>html</strong>页面并发布到github page上。</li></ol><h1 id="搭建环境："><a href="#搭建环境：" class="headerlink" title="搭建环境："></a>搭建环境：</h1><ol><li><p><strong>Github</strong>:既然要托管到github,那么便要有github的环境. 检查本机的git环境,在命令行输入 <code>git--version</code></p></li><li><p><strong>Octopress</strong>:是基于Jekyll的,需要ruby的环境编译。检查本机ruby环境，命令行：<code>ruby-v</code>ruby的version1.9.3以上,新版的Mac,这些都是有装的。</p></li><li><strong>gcc</strong>和<strong>make</strong>,ruby的环境需要gcc,这个会通过安装xcode的command line tool来完成安装 检查本机gcc环境，命令行：<code>gcc -v</code></li></ol><h1 id="安装Octpress"><a href="#安装Octpress" class="headerlink" title="安装Octpress:"></a>安装Octpress:</h1><p>通过Git安装:</p><ul><li>下载<strong>Octopress</strong>：<code>gitclonegit://github.com/imathis/octopress.git octopress</code></li><li>进入<strong>Octopress</strong>目录：<code>cd octopress</code></li><li>安装必要的依赖包：<ul><li><code>gem install bundler</code></li><li><code>rbenv rehash</code> # If you use rbenv, rehash to be able to run the bundle command</li><li><code>bundle install</code></li></ul></li><li>最后安装Octopress:<code>rake install</code></li></ul><h2 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h2><ul><li>修改配置文件<strong>_config.yml</strong>：<ul><li>配置个人站点的信息：<strong>url</strong>:git远程库地址，<strong>title</strong>:博客题目,<strong>author</strong>:作者名,等。<ul><li>注意：最好将twitter相关的配置信息全部删掉,否则由于GFW的原因,将会造成页面load很慢。</li></ul></li></ul></li><li>修改定制文件：/source/_includes/custom/head.html把google的自定义字体去掉,原因同上。</li></ul><h2 id="写博客："><a href="#写博客：" class="headerlink" title="写博客："></a>写博客：</h2><p>博文是用markdown语法，另外扩充一些插件，网上相关介绍很多，例如：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">这个</a></p><ul><li><p>新建Markdown文件:          <code>rake new_post[&#39;文章名&#39;]</code>或 <code>rake new_page[&#39;404&#39;]</code></p></li><li><p>翻译Mardown为静态文件:   <code>rake generate</code></p></li><li><p>检测文件变化：            <code>rake watch</code></p></li><li><p>启动本机测试端口4000：  <code>rake preview</code></p></li><li><p>发布至git库：            <code>rake deploy</code></p></li></ul><h2 id="添加多说："><a href="#添加多说：" class="headerlink" title="添加多说："></a>添加多说：</h2><p>  需要在多说网注册个帐号，添加站点，获取站点 <font color="red">short_name</font>.</p><ul><li><p>######底部评论：</p><ul><li>在 <font color="red"> _config.yml</font>     中添加<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#duoshuo comments</span></span><br><span class="line"><span class="symbol">duoshuo_comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">duoshuo_short_name:</span> yourname</span><br></pre></td></tr></table></figure></li></ul></li><li>在<font color="red"><code>source/_layouts/post.html</code></font>中的<font color="red"> disqus</font>代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; % <span class="keyword">if</span> site.disqus_short_name and page.comments == <span class="literal">true</span> % &#125;</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;h1&gt;Comments&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"> &lt;div id="disqus_thread" aria-live="polite"&gt;&#123; % include post/</span>disqus_thread.html % &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br><span class="line">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure><p>下方添加 <font color="red">多说评论</font> 模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; % <span class="keyword">if</span> site.duoshuo_short_name and site.duoshuo_comments == <span class="literal">true</span> and  page.comments == <span class="literal">true</span> % &#125;</span><br><span class="line">&lt;section&gt;</span><br><span class="line"> &lt;h1&gt;Comments&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"> &lt;div id="comments" aria-live="polite"&gt;&#123; % include post/</span>duoshuo.html % &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>section&gt;</span><br><span class="line">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure><ul><li>然后就按路径创建一个<font color="red">source/_includes/post/duoshuo.html</font></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Duoshuo Comment BEGIN --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"ds-thread"</span> data-title=<span class="string">""</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> duoshuoQuery = &#123;<span class="attr">short_name</span>:<span class="string">""</span>&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    ds.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    ds.async = <span class="literal">true</span>;</span><br><span class="line">    ds.src = <span class="string">'http://static.duoshuo.com/embed.js'</span>;</span><br><span class="line">    ds.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]  || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- Duoshuo Comment END --&gt;</span></span><br></pre></td></tr></table></figure><p>随后，再修改 <font color="red">_includes/article.html </font>文件,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; % <span class="keyword">if</span> site.disqus_short_name and page.comments != <span class="literal">false</span> and post.comments !=<span class="literal">false</span> and site.disqus_show_comment_count == <span class="literal">true</span> % &#125;</span><br><span class="line"> | &lt;a href="&#123; % if index % &#125;&#123;&#123; root_url &#125;&#125;&#123;&#123; post.url &#125;&#125;&#123; % endif % &#125;#disqus_thread"&gt;Comments&lt;/a&gt;</span><br><span class="line">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure></p><p>下方添加如下<font color="red">多说评论链接路径</font>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; % <span class="keyword">if</span> site.duoshuo_short_name and page.comments != <span class="literal">false</span> and post.comments != <span class="literal">false</span> and site.duoshuo_comments == <span class="literal">true</span> % &#125;</span><br><span class="line">| <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123; % if index % &#125;&#123; % endif % &#125;#comments"</span>&gt;</span>Comments<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123; % endif % &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>######首页侧边栏插入最新评论</p><ul><li><p>首先在 _config.yml 中再插入如下代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">duoshuo_asides_num:</span> <span class="number">10</span>      <span class="comment"># 侧边栏评论显示条目数</span></span><br><span class="line"><span class="symbol">duoshuo_asides_avatars:</span> <span class="number">0</span>   <span class="comment"># 侧边栏评论是否显示头像</span></span><br><span class="line"><span class="symbol">duoshuo_asides_time:</span> <span class="number">0</span>      <span class="comment"># 侧边栏评论是否显示时间</span></span><br><span class="line"><span class="symbol">duoshuo_asides_title:</span> <span class="number">0</span>     <span class="comment"># 侧边栏评论是否显示标题</span></span><br><span class="line"><span class="symbol">duoshuo_asides_admin:</span> <span class="number">0</span>     <span class="comment"># 侧边栏评论是否显示作者评论</span></span><br><span class="line"><span class="symbol">duoshuo_asides_length:</span> <span class="number">18</span>   <span class="comment"># 侧边栏评论截取的长度</span></span><br></pre></td></tr></table></figure></li><li><p>再创建 <font color="red">_includes/custom/asides/recent_comments.html</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Recent Comments<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ds-recent-comments"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data-num-items</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-show-avatars</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-show-time</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">       <span class="attr">data-show-title</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-show-admin</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-excerpt-length</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   &#123; % if index % &#125;</span><br><span class="line"><span class="comment">&lt;!-- 多说js加载开始，一个页面只需要加载一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> duoshuoQuery = &#123;<span class="attr">short_name</span>:<span class="string">""</span>&#125;;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    ds.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="javascript">    ds.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    ds.src = <span class="string">'http://static.duoshuo.com/embed.js'</span>;</span></span><br><span class="line"><span class="javascript">    ds.charset = <span class="string">'UTF-8'</span>;</span></span><br><span class="line"><span class="javascript">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]  ||</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多说js加载结束，一个页面只需要加载一次 --&gt;</span></span><br><span class="line">   &#123; % endif % &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>最后修改：<font color="red">_config.yml </font>配置:</p><ul><li>方式一：在<font color="red"> blog_index_asides</font> 行或 <font color="red">page_asides </font>行或 <font color="red">post_asides </font>添加：</li></ul></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">blog_index_asides:</span>[custom/asides/recent_comments.html]</span><br><span class="line">或</span><br><span class="line"><span class="symbol">page_asides:</span>[custom/asides/recent_comments.html]</span><br><span class="line">或</span><br><span class="line"><span class="symbol">post_asides:</span>[custom/asides/recent_comments.html]</span><br></pre></td></tr></table></figure><ul><li><p>方式二：将路径添加到 default_asides:[…] 中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">default_asides:</span> [custom/asides/recent_comments.html, asides/recent_posts.html, ...]</span><br></pre></td></tr></table></figure></li><li><p>Update</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多说评论似乎升级了系统，无法自动获取到页面文章标题，所以手动在评论页插入 data-title。--2013.09.10</span><br></pre></td></tr></table></figure></li></ul><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h1><ul><li><h6 id="发布图文："><a href="#发布图文：" class="headerlink" title="发布图文："></a>发布图文：</h6></li></ul><p>如果在文章中上传图片：</p><pre><code>* 直接copy到/source/images目录即可。便可以以相对路径(/images/imgname.png)的形式，在文章中引用。* 或找一个图库站点，例如flickr之类，然后在文章中引用该图片远程路径即可。</code></pre><ul><li><h6 id="域名："><a href="#域名：" class="headerlink" title="域名："></a>域名：</h6>如果有自己的域名空间，可以将域名指向自己的博客，步骤如下：</li></ul><pre><code>* **配置DNS(需购买域名)**:在域名管理中，新建一个CNAME指向，将自己的域名指向yourname.github.com.* **给repo配置域名**:在source目录里，新建一个名为CNAME的文件，然后将自己的域名输入即可。* 将内容push到github后，大概需审核一个小时左右生效，然后就可以使用自己的域名访问该博客了。</code></pre><ul><li><h6 id="添加百度统计和google-analytics"><a href="#添加百度统计和google-analytics" class="headerlink" title="添加百度统计和google analytics"></a>添加百度统计和google analytics</h6><ul><li>从<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>获取脚本,然后添加到文件source/_includes/after_footer.html文件中。</li><li>从<a href="https://support.google.com/analytics/" target="_blank" rel="noopener">google analytics</a>获取跟踪ID,然后将这个ID添加到_config.yml文件的google_analytics_tracking_id后面即可。<!--![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "title text")--></li></ul></li><li><p><strong>Octopress</strong>目录结构，及之间的关系：</p></li></ul><p>￼<img src="/images/sourceFrame.png" alt="alt text" title="Octopress目录图解"></p><ul><li><h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><ul><li><p>Octopress版本库：</p><ul><li><p><strong>gh-pages</strong>分支：用于存放生成的最终网页。</p></li><li><p><strong>source</strong>分支:用于存放最初的markdown文件。</p></li></ul><p>职责详述：平时写作和提交都在<strong>source</strong>分支下，当需要发布时，<code>rake deploy</code> 命令会将内容生成到public这个目录，然后将这个目录中的内容push到<strong>gh-pages</strong>分支中。</p></li></ul></li></ul><ul><li><ul><li>其中<strong>sass</strong>和<strong>source</strong>:这是博客的源代码文件目录。发布时，需要把源代码也上传到github上,这样便可以多台机写博客了。</li></ul></li><li><ul><li><strong>_deploy</strong>:是通过octopress生成的静态页面的博客文件夹,我们可以看到它的里面也有.git的文件。<ul><li>cd进到该目录,使用<code>git remote ­v</code>查看<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin http:<span class="comment">//github.com/....github.io(fetch)</span></span><br><span class="line">origin http:<span class="comment">//github.com/....github.io(push)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>它会在我们使用<code>rake deploy</code>时自动push到该远程库的<strong>gh-pages</strong>分支。这时就不需要再手动push。只需要将博客源代码手动push到该远程库的<strong>source</strong>分支中.<br>  <strong>以上细节可参照Octopress根目录中Rakefile配置信息</strong></li><li><ul><li>使用多台电脑的同时写博客<ul><li><ol><li>需要先拿把<strong>source</strong> code拿下来 <code>git pull origin source</code></li></ol></li><li><ol start="2"><li><code>check in</code>更新,将本地 <strong>source</strong>分支上的代码，合并到远程仓库上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;yourmessage&apos;</span><br><span class="line">git push origin source</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li></ul><h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><p>你可以先去github上新建一个空的Repo（最好是private的，否则可能会被其他人拿到你的source），拿到repo的url，然后到octopress目录下执行下面这些操作：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为你是从octopress github上clone的，所以需要把origin这个branch换一个名字</span></span><br><span class="line">git remote rename origin octopress</span><br><span class="line">git remote add origin (your github url)</span><br><span class="line"><span class="comment"># 把你的github branch作为默认的branch</span></span><br><span class="line">git config branch.master.remote origin</span><br><span class="line"><span class="comment"># 把你的octopress导入到github上去</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>如果你新增加了博客或者修改了某些内容，你可以把你的改动commit到github上去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add source</span><br><span class="line">git commit -a -m &apos;new blog or edit some blog&apos;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>如果octopress有更新，你可以直接pull octopress这个branch进行更新即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull octopress master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> octopress </tag>
            
            <tag> blog </tag>
            
            <tag> github </tag>
            
            <tag> mou </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
