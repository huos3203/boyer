{"meta":{"title":"布衣男儿","subtitle":"不物喜，不己悲，善假物，易参行！","description":"不物喜，不己悲，善假物，易参行！","author":"iTBoyer","url":"https://huos3203.github.io"},"pages":[{"title":"","date":"2019-05-17T15:24:54.461Z","updated":"2019-04-24T23:21:29.795Z","comments":true,"path":"SUMMARY.html","permalink":"https://huos3203.github.io/SUMMARY.html","excerpt":"","text":"Summary Introduction 初步搭建Octopress gitBook协作Octopress IOS零碎问题 ios7截屏问题 UIImage三种渲染模式 ruby类工具集 calabash一款跨平台UI测试工具初探 项目管理 产品领导者的五种特质 猿题库架构学习 版本库管理 清除git历史记录大文件bfg git svn桥接命令的基础 Swift学习 Swift入门 OC与swift相互调用 Realm数据库引擎 个人总结 总结 惨痛经历 GTD工作效率 GTD入门 gitbook和Hexo合用流程 小程序开发 简易开发流程 Hexo学习 Hexo标签插件 Front-matter Docker学习 Docker使用"},{"title":"All categories","date":"2014-12-22T12:39:04.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"categories/index.html","permalink":"https://huos3203.github.io/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2014-12-22T12:39:04.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"tags/index.html","permalink":"https://huos3203.github.io/tags/index.html","excerpt":"","text":""},{"title":"每日打卡","date":"2017-10-21T12:39:04.000Z","updated":"2019-04-24T23:21:29.845Z","comments":false,"path":"trello/index.html","permalink":"https://huos3203.github.io/trello/index.html","excerpt":"","text":"每日任务卡day1(Swift) iOS Apps with REST APIs(一)https://www.jianshu.com/p/01ca73387481 day2启动fastlane自动化 day3使用heroku的docker部署swift服务器访问开发文档"},{"title":"关于","date":"2014-06-09T22:53:00.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"about/index.html","permalink":"https://huos3203.github.io/about/index.html","excerpt":"","text":"关于搭建Octopress那些不堪回首的蠢事… 博客合集精简版采用material主题，适配移动设备。清新版采用jacman主题专业版采用next主题"}],"posts":[{"title":"定制开源的CLImageEditor图片编辑工具","slug":"个人项目/电子巡查/定制开源的CLImageEditor图片编辑工具","date":"2019-06-13T22:19:57.000Z","updated":"2019-06-13T22:19:57.000Z","comments":true,"path":"2019/06/14/个人项目/电子巡查/定制开源的CLImageEditor图片编辑工具/","link":"","permalink":"https://huos3203.github.io/2019/06/14/个人项目/电子巡查/定制开源的CLImageEditor图片编辑工具/","excerpt":"文章已被加密,请联系博主索要密钥","text":"Please enter the password to read. Incorrect Password! No content to display! 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","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"电子巡查项目设计","slug":"个人项目/电子巡查/电子巡查项目设计","date":"2019-06-11T07:03:20.000Z","updated":"2019-06-11T07:03:20.000Z","comments":true,"path":"2019/06/11/个人项目/电子巡查/电子巡查项目设计/","link":"","permalink":"https://huos3203.github.io/2019/06/11/个人项目/电子巡查/电子巡查项目设计/","excerpt":"文章已被加密,请联系博主索要密钥","text":"Please enter the password to read. Incorrect Password! No content to display! U2FsdGVkX1+7+1efrvMmwaW/XVUVTqfxy6zR9OvVtlNdqhbYLcD6OUCUF8WXZCgLl0qZ4wN7P1QrXWGrDXqTifVOsoIi5QHqqso4/XU3CkL4WyBNSAWNJoX5dr+ZdusGGTmo6g2Dj3cz0MAvxypqO4BkLm24izvu27btTHUoqgEHsjJxtuJwzy3pweDa010vDUl5M271R/AC/52coyEZztgknAlLj+ylMIUT1QKI+uqI1y0v7cC1ifSrQSJ5k7k/GCsONiji+hqPmtVPT/nk5ghzTuKEynSqoW6spy116KdxAcoRvsZi8pN6F1JEAK/25oSDItFA+PNVGNgCDqw/ZltCRlNh/CN/OHJFtVYMqGVF7knXGawEn00rqAKARadrcNaJjoVc/KfYWN9Snh/96WMvV378GQzF6r88tpbvU427Z6hwJf1cv4N3j9xedpxPTxOu4R77fmZoHLhx6Ny2RyApGAwrHAs2JYVAXyHjZ7DBbK+sii0lzC7kCqnA/23SYb6j8DZHCaJ/TFIAkDQ0Y2TgRbVqd6ViTWuX3hYCRl6ceiVh4e36q3czSUGNhj+ziGe7LmKvWzODZZq7MhDNBqx6KIDF6skpPy0pB3g/AUiwhptNV0jdhRjctIqpZ889Vm8ZtSEmFSf/EtUwb1vUvDmIsAnFtwuqDCiCxOoiRPokuvJwxIYGl3Box6PqCOBO5z3OF/g+LX3tUP5mEZOlxwunrgO6cz6qzbA9U88CjrqoIqIpSYchzj3EW8Xpi6FrDZh81S1c5EFe+BYx+1Uehhgf0hpJDuAnJDPSnH+VRhqRLMImzN6fLMM/DGEgqmwVSL6tngtgpTJ1aUDkQ/9hzunBtQhczlAGrmI41Mq3P/+lBxkANKVz69EiCKv7nybjVHSBwef68xZyDDQofn/iaO+9oJhxX5lxWU/jQZS8qZ22naKGjdbavOqO5OuNTqpvpN1geYg0rpdA0DAr5iGG+HNpTT7zOAaCBV35T1+Ckfxj+MrS6CfyrBDB38WEL40LAJFdPTQKSx7qw6GRVE4colNZoc8mP+QHVyv356MwGvwV3LOvWG3WBCXhXux6qa4n8pRWXR45kYJdDVUv2vz+nJ2jPhw31NFgUBA7I6NGrqzpJVoyjO21//bRtiDE06BEl3MkQLMApFtXgZ6VIGY2IWCgINOlFIuYeQPd3jAnPIxSizw4lKxQ10d0hiEd/PVeYAlrSOUBRrEm16aXb2WgQUS/xBZd4rprOKnOHQDbU+IgLzXziWPAJVXjsdaEvynq7cJoYvFEv53hUB4BcT0Coz2UixjiNJwEoVj5oHwWmUj0iMlU4xBktRYQ0VS/GVmf+jX+/GJx6wZaaiQPczdZJG32Rnd5j/A3JbHEE1q2W7p0T27EvntyR0UmMYVzv5baa7mFFVzQ4Ktu5tNoi//4II5N21qjlGX15Y34runclJnx1NjJjku6OKAvdON8GsjUOQlZ69aeU/PafCqWRw4FypgeYzLVMMCFvT7y0G+nI6p6HaPKfGp6jPTLi39Up+vSUWNQkaw7UbcPbl32bCcVyoVyoFnpd2TSQu/mIik4Ak4/DmtBeymS5gvKr/9eWDcIj1DaPn0/PbP6WOQTbhyVymQw/v4xhG6G6bBQUTKy342Dvks3wwSmF+cT2WykFp63ufR8qtjiPaMjn3VZwnK1/gU9PPCHMBFCPgtefPBNVPlaPcB6cZN7LuC1jT2RBzmYkAzlV4cKIIe7vmIVFcAR2l4BfxtxgzqF32lLMadhjcicTWa3KImR9Fs2G4J0eQGp0NGdkbtJ0ZMqpaHPOXqwQJ23tcWZR0hgp6htdPg0CxVWITNb/3En+S1R1CbF0Fqoote+7OMnAcG8IbxegsYpvfGa41KbQQvU/cjgP6fde9TcXBVEgiJk1JZHBV66e1g7g8M7d0kbnPXJyUHTgHh0JwQsHefkcju35QEybXQ0lhHkHlK4OvvETpCNzCQdP5PG5gU6dvAKz9O24xdYkrlGXaxbDrLJxNtGexkvI1Tlalvn1mUKIm2e42OC8r++t7XLUocbI80ByaHUkaxrGGQJT3eaRf7H+b6wAm4aB29ufkpif4WbKHYJOgfZig+4rhtuf65F3H+to7HCm4Du6tE1YfEM7F54GDcfO5fkdvro7pNL9xPTndYjQGh0YxLLu/HdQS6JINRCFc/b7jbzkTs11NKxEVlE4KDFVSlHoKolR4W7HUUE3GZHpF5k70iJbxBTSrlr5rOnAze56fjd0JdU/yjMWW9B7A9X0ux8JbHJTSUmzUNiAUBQw/WZZUrPcac6uPM9rnppfmn9Jq6EMs/hT2ha5fFRZxtovy9x/W8NE4qYqAkVPiFLVo6EsMjaQD1GZyFDpyiszZ1JXo+COJTQIZYD+hOZCSOCpLmzwVMR0DP5NE53IgMyBbTIp3nJu1BtO5Doy9XJ2US4wDzmZR36A2kp5R3dkI/tu0ldN86BMp4F4exGYByXVY4NBRL0pBDU+ds2G5teONd+ra2GBylGWfRpyWsh69UEEVymqjqhdPS8x/QhfiHHyjaxwFyfDztzzWuBeBlnyke6ECBzqMV87iAsf3UoIwkq1tvUwNRGZCWfMVEfAYiUAKfkW1ipYBT3ZgK78YYe/m8RH9XdcAzR6mBvSQvfLTnv0H+hARcgv2Not5fHyogyNiG9xQB47+nDnnaracgg4NrwxZ/lBpQmZIZNq0OeDxlTpIPQvgHK8l9emf74tm/Vt66/leAZlno1JljOhM7Mk57XAtYppoksLuv6nw/O/N4e/jcK1/j4vj1S6QByBR0uJLaeuS7aV9SMdWS5xqrSPC3fWp2AdnF+RVvDvohMmtLOmNsm5Ij7cv36fh2W7dGlhepwhJLfRmKyj6GpqkqmDkMmjd7PywCBeHWaoZ5MAacYeg5NNWknEK+AE3eHh+S4p56zmVKO3YFv2sX0xzBOvgN6mzvgiIJTsTm6DgHoVNhHrDVMrfaWNXbctXOLRdunPMfRP7ZEJt5NJQDjICfjBLDWERIOETZnoQv30dSBCP3JiJ+Livkoo3GJs47+atCFSxR4VwJE2f8v+lEzPfULmwW9QrdSuNoFPJ9swO8xtR4de8NRSASChlRdjA/M5alJWGcyWiSiLmteAnhIwTQPzet3DalvW4Ui2O1LITRfvHaf1yRl/7EzJfhoAreeX3s8yepwRLyvi4/LRTqIs2NLXimKuPdcR14uW8vK4l91UM5GojDlRDj2I+WQfCS+xtUTLAkuxgsXTRXkEQDs4NYfmf9Tw9WvkAQrDYTnythjIkpMHlmevF6niGAPmKE1n++PRPQI3oCeTRwBRFBLo4SDF55ILq4V2641iusbn6qf35PqdriJ5PK5M8AOWmrXbawDNZxmZR9gkoFdJwLw6/cFm9mTOA8IVuoyGG0Sj9s436pioN/87UtkKTsWHB7IJp/3RWMXecjLag35jULEnAHEVEjY0ozJdc7hxW0wrfTOwbKu9kE5fRqcTF+NTKSN5XStHr2PYvssStuiFoBD9FJgwNz7BhN8tcmPSwLVVallccspdpWz2y+lsrqoCsimaTh83TDcrG9SITM7l/CK9Pf/DtaEU2HiUs9wb9cSkv7WdhsDliCqFWq8Lw/OrpSf8Va8hUP9lG089mevQWQnM85aSUlHy4y6YTLVIkr3gKMeLoqLsJ9mRExyIe+dYyed0wWV7VkHM6YJw+AnnmgsH9kxkjTCtezmDK/LXkrRKP39CQf29mZmO8PJS9kttl64drQnIJSDlRVdBc0lnAX3ux4sZvgQapjbV3Ni3Cxj9DDZ5BIzVC3OI90b35/dObQ3G2VrHPLlUwOitgHiEfzJg/sRFunxllPSUEUmf/QpKw/u/9drLsQA5sO7+ME6hBHqeOxImN4WHcWu5Mdz1LySbLSGQXkPEIlsGscL8eQh72Ajj4GT7oWhozndBFTPPDgtTwzdnx8lJ7m/2tLqDH4FHRWGMftMsqFldgLqcz7tnGQcjNa/yLCKw8V7bQDfy0qEb+LEgWlA/yppT7cHpyGWj8LJMbgOQV+HFxINqlA4XDbJNFCpRySZQRvMFTUKq6tb5hk9wv5egeKJxbCyAnhqDbCR3PLT+zFinI4GTCBA+izE+9CMcQK+gpaRnYhcB0wwmnwn5Nuuhenk7phh4vkfhVfxunUB1pAAUgpzynww78BUup4/hzjEAEcyW/BBfNCJ9k50beQfoQMUipKctkgX8eVUzUHPla9Kz7f/gT358UNLd/Rc5Jl3iPNAo6/UXLoGejd05dY25EepTqkRLCs4WOQ/3XZZdGQNHDly5w0zGWXNxRkExDa1Yz7cAAtsJmAzvySfUFN59UrjdJepAfQ54m0FYQcm1S9koJ4foCThvGfUIc1Bn74o3e+zhsZNspEdpp9hgMurIzF8a88Qbi/8nfKL1Y3GeagfL3ewQugnmZUFh1ep7bdyV3kn0yReraOZeFjrhAPPMt/781vwTGu/3SX3Gd5ZAT74s5wwdwG9WTLdkhKzebbynsOfJlZSrE1ne1Sg0ZhnzhwRRLH1k1w+GKJ9etmZdRgjZPBv8upR2jB3aqe2d9iRFzuusPTFRfdSow5e39E+QnTwcWTJOYNnmzuj5koUzvFm/zUBPln+ClVBddIsEjR7t0BekxPuk9YtDrdccKDZVhZneiIXRq+ZxRXDs/uJ7hap6npi5JzyocyUQa+J+4Yv3+JZhEqUif049W1AxB/9ER/yRGiKJiB+flrpvRl7yV0tIE7KHjhK2wWvwHCmk4jJl8X+pbbHs1K+NgUvhA/k5totlAGtlrpUbBG2eeF7qK56KBw9FhHk0vbePbKdKRdVBQABZnCdl/MC3o24BJsYdew17IK1IZq6CAI7j3leIfSaaXxY5sTGWCd72IS6y+qWNRXaql/dO39XbpyiiyW6o7fgNkl3bH/vUg5YQ3ru1NwfooEW0LRF8+ggLlWIL+2+bXWdFx/4lPYD4kRY4egnaObrVa/Y0CR1fcUzRpivrlDqAG0MJOY0XMMuSmsY4A+Rk+I6Sqa0Dt2sXPVxbHVt6NnAHhrfpNjLs2hTlZkXvvEpONG8yh7Jh+eIPgNNSBnf1o2GBEc/AWqwX5GMHQJlhdJ5Tpeg85g4cOP51Kxh0D7Rz9FaOacfBHDUkYfaoLMu1PvueBeynG/UpXp9FbYaMHgqoPyYN9mVPsUJaC+0Zc/NZYNw7EFDsPQpXFLg1MreHan+CLMmEyZr9zx4PtHOcE6FpEDcpH7KhBbBmSZ+PM9mhWiHEKNz2afteTs36yRazCrYfZwE4GgZXxr8IAtbcXmHp1r/Omfu1PtXHm1LeLqV1a2rYH6RwYVAZIzK95y5JnmXKOKYb7K4iYBFLtl/d7yNo8pYO3RhOCtWxd9sWsA5moWQJ+6HFjt367xRj1t6eRnwKitd3Pth/u6pb6JxHrf/zAMf2DgKUNRGtKl5GTzfM4SF/tzeHJCuINq8ows20QfyWBmEjw1+1K19HWmRBCXrx1KA1rrKMTmwAi65gftOObkVivT2QqnN3gAYPTbog61sMxWJSDnGQ8kz4MuvgpYXYqv7Jl6h8+7NlBUJHGBN9nDnDeeHqZuO4TnePDSQ+Wb26vR1+wPKYSsWk/8y+08w5IcXDgco4bktsau5PhOSUHETp5m2U4iR7yuCJG4JjGc+ZFUFr6WMQIHNQox53fh/Fp9a9nXxT1SZjCPq1dKref5WDNhULxtSQzTya8qS47C1UnuRLQhMdbGpkRp/tZHQ8gpJsDtsHAjs9v3z+iC6fNQApZa6FGkzBgDpDXsA6CetGxON6bvZEOsrFyCNxrlhySAXfp4eloeDul1k3HZIcHkeFvl7vi0oBUs+wGwwxlQOewsRgl0bJq0S/WFxN5aMmlMVVcjg/MSCT7vWdf+tUUUIqEKPSXK9px8NwLhI0ucEfDTR0KcmPhxsUFgqQNKR1pEKsAczAGPSa6K9FJFlQ67hu5ubZtDL+AIl6+/RWC1s58B5iXoVBSuoILwU1h48hgOy72yJ7svkbMm9gawrHVHzHIVGQJFvXvGE2voaJaOjzcIv7jsgvyO1y6M5x2FAVjddWRqJUm/cIEqU37GiAKjJ1WyeSutuOpNPUtDg/GGiu88pJi7518KcOpxYWvZTLuCCsDMfrCgemgGeuAiAGCIdPAtycXn+3OhstHgT0Bd/emrWLgPiolOlTUVgF/e6IFD2uUV1CQGWprnkckVlTLDZ2svNxsENSOyxG55R5TVQ8lduZSMYRbhU187MOIJ5TGaTwBYNIBLTsRypXv2pPoNFtP7cN87dmhAGQoiTNDZwWNXaeIQo/PEhxoqAeGtjbUvqZ/DGQrXLfo7jWhnHWsa3GgyJr+qQoeLNgZ0u5TaBGdQVISno1wlXEi4Qhkt7pi++fRo2g/ocvPftNoKX7xNSQy8kGEzipH4XqDpDvInmY6lhTj4+JlKVnZZVo3wXs5U7a2teC1Lnl+9pWsFOEAA8Jm6uyBsNKWDwUgTLonspsz7bEZsg3RHpq5q/RGVuM6NxYoTAZ2kBl3UB3D8Gi+UEk+szgIf8GsuGjPoqGKtvbJoRY4GVCUDhUW3SgZuUJqTzvdUKXmckKu6P7mlo9nljFwPG9Enb6gDeMY7SUi7U8BZLZhroTBp9GwbDzMHHXqtACv0UXaTGcpGk8cG2tD52YJDsbMXnYvY6QsHnri16tbJeht+AVBDEAP+cU5ZazEjIYXzokzw7aelaqCLBS+sltgT3oYTWorJn1RuPNEiwA57QNbbPDy2SA3AEXWfEKiENQRsREWHXNqbY9gTAhAl8P3raBlF0XI1QcoqZYrNYetz1SLJh7S/EFGYWn97ZmlG1x3xCjPDLygtU4TTF1WqSik2r7FWAPOUFZYDc+W3Vc9wdqMhiHxNKw4Wf4Kw4jEVAdb5/UyRDSfzsgEq5HdHRsx4jki720ErCgytTBkzbxLLdisucxC2ebpKdrT+C1R7sFgbBpUmWnQ7ApPgGGB6sPkLXADcEkqwWH9+cuxo6JqdvJo+qihGMrm2Dve8yci9E1TFTrNKY+gwIrMwbdBummsAbCMnGhQJmBsGdpOQUt+Grc0sFrjqoUdlItZ89A/t5v37goqDmKXGasKB/zwRJ6ddKGprk+Cel2N8C2wa2qmOAVORBgKygjJuuIJIam4Q1pt41Sfzp4C4YkU01I0a52Zzh0lHdEnLRhegrkOufCDTkWM5RhHvyPZ0hBtV+6nh60pFlhGcKBLvV515tIU8gU6Jy1b9ykz11BhBpOeEazxgQ4OM7D4FiSyw2DnQAe8nQFGIrxOYbI8QZNJi5vghM4oWXntwL1Rbtm151e4RBVJEdCmSuPlZwOjtyd+cqjwHtZy46t4kVFsMbsCb2V3/230a7u+NMvcxTAj6dqMhvvQ3FMic518q9RA7HmqCG5B4Ks0JZ7ozsPfNLe34/qP8Y9OQ4N5YvMYBxnA2O7Y12ij3ZiZudhgSOAzlfzrzG+CmzlWwTySF9ktX2TQWKiuybXPaaf8FY7qK2pDbO1z9kq38h7Wm4YpSyetPmQfZJ+W1vIA0tIaSbIS4qFZr9CjRXUOe5I19BL7HHZ0eV4bMMMCzWdJXKr3Aa6t7NdkvFb34fDCDHH4RzkxgCpIW+zJRyr1qtUeqep7HvjyvvyLNNvmmshuBCogaNQhjN46dAMOtP1fNyzrsEpoD5O38UiwvpggVK8eh2FphoXmU/nGMgr6r0jcBqcFem+JKeQjdGP1RahY0PkWhhMDTRZXMCKX5//bI8h3COe7YcxnbUPqLDdmeLKmQVv/IVMKqamqYmT2mhDAIWZsuzrSosD8IeVyKDFuhA/Un9O6ufawG0ejZmi8TL0Vf0vGlOTTX1/F4YslMkf+k7sqr0ZDFEhAtdqsHdE+IstOafhkxaK1y7SGgg/5t6FcYtwYx2x9TPQGajU5elb9ATDrGIbNBtAWQ2DMSjkoJyoWjTK2YNSM9Yo+D9DAVkFiNj2x/sIx03ORGp3TQpCKDhW6ntuc/5ZFBLQhVw6kEmW9ze8B4CNALhpWhZ4PSscc3eogIcgfF8AXG4bjdbrgCbKhXdt6uzE5732fXMh1/gOxI1xzCISuzvx/Hy3U9kqTzejML9AUWZjvisOQ3Jg7Jf+IJ1Cr9i1a0mFDCj/VanaNwq/qmVRCxMoOowqiJwJY7/mEBAYve9gp4fKB/5FB9dKnVZFX9grs/61aXozXW2GHKnj9suGOsm0FQaaB/MuAqGwAjr6U4303iitYNpdMtOrP6sr8Rn7/dKR4JFOSD/gcqcXhixXRsfguv/8sJ9oOZnWjEOjIqf7scPQWpxftqwjM7xOxKTsAtp8vhxpD3KoUwFKbTjcKr1NFVD9SQvLwg1FmUJGZ30hzNvve58uOxpX7BREdxr8MYb8TUL7ahpkB4ap83M/gqvs/sAAQFrwRvQt+lzKeMnyE34wlSFBj7FnlHYT69UFLwg3SyXY18E0KyCI9YcfPJTefYVfS0Gjjf0fxp9IR0591kTaZsrSnlPxsQUOV8XcyJ7CksTzo4rNI7SZKEEmMPjv/WKSA/Uhre0KEhVRsv11IgwC36FFVzX7LQe02ZRcjqtS706S5eEN3G+WKTb8HRQo6PkMGOMTkpQe/aRljxNzNX19rhjp+bi3/uiI2LTIpurMjnHdqsJ3j2MOL8RdV4JIURmKl3oP71sgmqdCFvll+pRLaA4/xDcUjmnpYqeT9IhRaMqSjPVC7EJQTBV47suM+r8d1VtgZntAtbfirOB3ZgF4Ut8IJaotT33n2Q/S3cSuPk9s1uIr3C4SUJmvxyHX+a4IcmFE6X3SnKBg4ILnPIQ4HvSCXPBqDLrigxcsbFkFkh/ByJfo+fZMy7CnvzuYlHO1Yg2DoK72MD+ANMQctzsW+ZYHsR0E9h863mw/4f3tVQ1OpsHU8UDWVXhWme4sUc+ZkUMzeTBZDHltJkWiIZhm2goDImPXLdfil23rEhl07WVRCnp6VjOeBm25Y2BxUV7QmbOF/6mnu3AAF4guDtF6fYMwHtHxlNg9LDChktcuR18j1Q6r13dbUpFjdA1/SfwkO62tG0hdQfryqUCjcYhA63F2N275XG0kzk8NxXvHlrubgdcEJv3F710G5RKcBZTgqvboAOzr7kbPFcM+e9qcm3Xl/2zgbcLsLLPgadhKpqk/+WpTG9CKCHd7zuCM30/PymkYhJxqW3M4YCj1L2qQtw7lHBJZym3KqORAhj1koe288LRB+l6HwP0Ul5Ks4va4SHuy5hmuQLJ+VTgCjp6C8lORLBgQW3Z4YwDjKVF/kGxp6ikXKCc2o3AmSii0ARpdkWjUQAIlPh6a00i3lEHdSV40GRRur5dsZkV6GbM4Cpu9mX4qmJ/2qI5mCzKxFqhJnUZ9DpchVNi0+l4/JX2Vwruv19EjXvz7e8Lotj+FraukFig7LUR8+2CqMFrvTD3N+DqNKkk0NTfmiNonkdvSC1XdPjRi7/CpZByDlwL5okZJbqpB70kK5Vrl7ThTUkIQYOXLqXSF+YimAblns7iLwAUf8GpTfVfsL6ykqjpcK+QqMFDsLdIw4JxeeFrtwcC4GnE3LVXIPi604S01vh05g0Nd0Zx1vTTTLAw0JsNF6WJqA1Eu2pIBpU6tJeZ3LfXeErgOByvGqbiTdXm3KCNMoc77Qw++PZgJO8gF/o9rRd47eqI8lBpEbQ/3qm19rPhqI9tAdCiOTa80UHA2n1ZSPL1YfRAUKBZPAeZfd7xVdXFF55G4ZDvXf/w9Z+emRLy/NYkJhbfCvDIi+gX8b2M7zbf7jbTVcI0WYbBTckHwSkJI0R+xsRJvtDiiyv7A072jLorGiyg5weaKe3xWKOpmBECnjRUYhoa0Z5Bh+GbjOfJ1D4G6ydFroeJlJO0BDl9RiUz4zVaJxViJjN2nkfKHUxaWPVTCB+W8YO65RZPrdbAWASH/O3EWwiyocVJnLKXhPRLAleidoMECbBj1X7HuVpDAU3LP54CZT+Vj0DJ5sdYMk11Tbzy/kK8N/VVPaHIbt/P6hAFJgC+0nw3O4Tm9QgN8WGP9vQLoZj/YsyyLXxjWERIN5PkeS/9N5H8zlxvI7Ga6CAqZi/g2xrA77S9BnZhX20ouPLSZM/5SKcghwOILspbyI6uIEuIFvKdPsl3lNT+sA6WcI2YLcfX8hCwLsoS2/sPwqom8bZokmaIKBHC+9zcmIgDiOV/tkHDffswzPl0weTl4Fpos04v3TiYkfzwtOyKZ2YAPQweAW33ykY5p7uYxpS9kIMgrjcZ/4nSno8TKAxG50jW1fqcYynPQVP3S2wx6IH8C4EiSRzvVIgHPC0RyJ5rm5b1SwkrAtDu33bvkdGcesSQjKdezxStA3NxRK8qSDGytBMDb38WUrcW/cr9fhQHJeShlnmmvYI1CH1GssEEsoUqjNBTzch17eZGY14ADEGe11LuxLVG/KJy2OsTQKTMu6+fiC1fFro8bCCQ8n+eKosI1S6hKebXKolNWRI8jiu+983HBS1yhWhaVCufuRPzdsnXvYumjYbDjHhxDqsQO/vroTHtDVtYEKov3EoyrpVJPs9RJWofinAl+LECn/26uh1EWLDhThl+UNpTEivAuzZeAQVCqffqtHeIgYeqlS7guhA9/MwxWrtYgMCKLg/7zjDNgT2Yy1KNwTNV2EslyMVUxJXaBCEPT3ajVJvirfzYjLy66GmsRJTtL1AkCma296Sh7lu6MUoSToN3P7oZL1Yk+g4YTLMniEZO4k6/YC+klGzlBzValQivk2e1stMeYxrJavECJEw3pWtQZRUo5UnN4kYxzuuHVzOyBgwfO7a2KbXc/MPxpN2ssvs5++mFaSPmxxw34Svz5gGybhKB1b+d35J0R9nSSPxIoW2dEG/epqIpQy7m3GnJmc+NbIPu9/op0g1lpsUd6Ub4ALgazcf/ZKlAv8KdxkL5fJnUhiiCOUEgb6fjtKFveUZYd7W5N4gQ119QWASWLFUUfqMJwesgU2p7jDPmjEjs/TiHju3YuIRpKbwiuZaw4f/M/jhHtnLiYqtQEvAwcnMajCclSdYr1OZj+lq/sr4LhDKcE6fLPjG8jP2Han2T+0k0sKJYF8bnS6kyrOeB+eEvRgQX1fE9PK85XlQQto6Rnve2TZZJz3nXiDySSrZhwZBlaaQQ7qv+h2vKSy/kK4ra//V3a+x7Xcz8KhEXJixDTBkgeVJWZwWGEXDBzMl+CHoSE2ye24Ueu0Vc07UNkRsvw5s+nQ1+au36FlS6LiOn/fqeqpk6Ku40MjCG4skHY6Vr6CYCoCazndaah+Ja56pITLNaRXV0c/0b3YbTz1QgzVgn7YnutpVuDU5wyD5DX2F6XYPoYvUv1roJQ0eEMF7NSKKQjVYF7sfUxNDDKMo54JUv+zQqEtJNpDkIU7Q8seJG+FuN55eGOOVhixBN6qA1tUjtdkt8ZCYqpKAbERIo/SySIiuf9qO186K0j8VZR6Lu5rHehaVY8OSKdKZE+gmKUCKzfTefkIKHVqlHmRTWKkoWiKt7iPqC/FIrLGtrbNGyxIZ+zeVI2s6WBZWKZ5MupVWkWxuTPtB3VYnFEZug496Ci8LAXff7XCW8Iedn7wlEUVVl5Wfpdxbe9H+i/S323iT8+vx3/uDq/2TOPDd1M864+t1LXMdhyT8/fMrmnylRY1I0qyBmotkqlORMfEHtjjrwKm++Ae7GlhLchwmV6eNTTY3QbLtMCInVRRpfZ3wnpBJX7vhUriZU5tGjdIVPnD9y+b/mavNE8ShQqhrpAHaVR6WoUqyveZKd8ERsIygkAPadlBaXXytQYtXZu9HuoiswBzkox0h+QTLNuhk5uY8dKDAJEyg67XSKa1LhctiC3CbXwQKCL/9BouVo/Ket6AIReO90AKXrtSyjsXT2I4SA7cT69Fb/EXDbGtk2nZwVR4kp5GXVzV5L/J69DOB611DtjRhFrnnyEawcLPCHB5v9ZaMW2ePz4AZRxaWZoBykXJpHzltrYd0leLKf/y+y4QRvXkDZhX+q2YvXe5KMuO/auI5mG+5CHsWWWqdRP9yoZSSVWiE+jlwjiCPsAQhrlty4wck6lGBKJuQe39FCXNKbivumZOUcuLFv59wSrjEpFLAYSE3+rvcHor8zbSHD0bbqbZw4YRJ6Fvlw/H+ImUm2ajedTO9JP0R2yKhEb34pYOAETKqWCb5Xuw+JQJi1/byilJO2SmepiOSShPIiX+T6cBpFDiLhLmRpbWfreUj19cjT1Sy8fuotcJ/Qg/0tcfBk2oR6cHJ1ZKnhYTRR7YNeAGd4YbPJ3EWeTs7WVp6ktZMGUeeIQ7+A6dW/zz7opMEcQgyFWlunwMEmfUOgFtTiK5p2oxvu7knXvpT/RPl/5u1Sgl+mr4IVCZ/kKaPsPKhFMjeWYhXqCVukqz5A6jHk+M5FKC6yjTBtEu4ytdQPuyng6xrxivIPBhdXaLq2Epx+ICB014ZrQAJY5HDbZZQsQ9fCkrxt2sVouzJljFdS57ePzaXi6YLNYRMJSTSCAMkxTQmduzGwNboAWtRPw7l2kHC6bKEIYh3LwLAQ5NrZXdz3iJWm/3tlWOdYpHjiL65OTm9GB1CA4sIZTqManHOiXeuFIEf7FhffwKf3OWDmgwm30smEX3jZRE/0hPquYP0iv++8tFEDKIaI3lcfG4yKCxqWY1XcHlxXf3vqn33tLSdpJdRpIoiXwcIzrRcV5Hj6HiT/gB/NP9Fv2J9WLITNidlnciAOavnVlX86AY2nvNqFcgBGtcOy/oDSlJdFLfEy4SBmCnHJ2Y3jvVouJ+DQWO0+D7icx3yc09s07rSbiHuOf1QBe+/sCg1nCMANusAi4eK5ibXW0QFjoHJifLARu3XK4SMhlL2sfLecxISPPp/m77OfsNOBZqsehklMmrR5ZcW/fB4tTBd/DiJs3mNilPXs66QGUQy0vuZLBA0OVDr8YSOWUJ8OjslmpALUPWlyeI8vNnc8r7WJWSbYxUnk1LPzi6TmEZg1UKfU8mbw4AoXzrtCI/HuLGMmcoCaj+Qk4I5MkgRL8+867xudl1tMRUiFKBT7QpF2Do8ehsrqzdrWmF3mJA0AQKwMaXaSymOMzHz2NkQwWKUP1uSqLetIc2mAeOR9lEgFkBv2C1BY5PiTpVOrKykwnL+LmQW17wnH0/n70XNYV+EHDyvo4Mju5Hmo3RHf+53vsDHjuUAkY10B2g38DtJu11Uzh5ZHVBq4QRs7Bd0B+WbfcagPI1ShDDgV47LyOmcrSVwZ1/bG6qIFp/0sCJolZRXiO+91R/i8kyji5tSC7NStPn/Uy5aSM7o2L7q/uBuvGfSLRPMqNB61lRibPcIDq7bmfcgYPMJ4E0IR3821E2EfL6KxtkEO03LYQOYHK7tNwwUa4NpDNQsinh4w99xU5BEM4dZglWOnJv1p99lvgXA2edwHlUHvmMZ5mkZdxAFIhmeksnGOGTyhN+vGRgXyA3FJ7pTKmnjse1NsT6gSEblV1U+YM810pyR3fFsIbInB2yujFEuI8HzdGXRWRmbe5TrBn70oHksKVbZd8WUYV1jogOKzS9RwokoHNKaQNkWjScVlDazEwWd8On6VejRs+e12ai9g37TwewM7FCyAj69nlsmMXqu9UZ54NPhWJpcNZV82m13kM3Hnuma4dPdIlh7I2VOoxd64vh1lI3xKl0/Ba1KdcR7WZSdVkzYvdWjtiXkOUQ8ip4/SbNxl+XZMWZHvYR/q4ltA0FMKz1EXWWmTACXYkowzW1fl0lcD2oYagn2/wspU7QN3eOlYLBL8+3bAVXlKOSLRclrTLALa4c4dVgJwKYqz0ZU+m5eFv9ulkZWtAoJFmzXGtlfdHRitXLjyaFRbd9mXS7RACRg0ewQEUcBL9yiwKXsWfDfZ1vDr0GAIWgSC7v34Ml4inaGOkbYpkx6JYl4e0pDR5Xc0mxYV7GVlD5KWAzYuU4YeR6BCufHoDRDWBUAQ3Vdf7ccOlnpLXghOF18S+VkFrn4Id3yytZVx7Be/+1X5t/k8K5f3F6fmLGnalPcmop1BvTr9C5ECJJGJaNGjaozj0htn6E8uUjWAnyA22ulFn95Duz8H+q3GFco1ZS4z4xBTeD3MhT2S5Xg6zox1GahNCeVDu7VNYVMxKvZqMEnjsian6JN/fKe+cTqeq7E0BADsnIZ/CL4aWec=","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"暂存机制时序图","slug":"个人项目/电子巡查/暂存机制时序图","date":"2019-05-30T18:46:15.000Z","updated":"2019-05-30T18:46:15.000Z","comments":true,"path":"2019/05/31/个人项目/电子巡查/暂存机制时序图/","link":"","permalink":"https://huos3203.github.io/2019/05/31/个人项目/电子巡查/暂存机制时序图/","excerpt":"","text":"UML时序图","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"},{"name":"电子巡查","slug":"个人项目/电子巡查","permalink":"https://huos3203.github.io/categories/个人项目/电子巡查/"}],"tags":[]},{"title":"SSH命令安装及使用","slug":"shell/SSH命令安装及使用","date":"2019-02-26T18:16:23.000Z","updated":"2019-02-26T18:29:38.000Z","comments":true,"path":"2019/02/27/shell/SSH命令安装及使用/","link":"","permalink":"https://huos3203.github.io/2019/02/27/shell/SSH命令安装及使用/","excerpt":"","text":"写下这篇文章的目的是为了更清楚的讲解和展现ssh的用法和操作，避免网上庞杂的文章和材料影响新手的学习过程。所以如果你是为老手，可以略过这篇文章了。 SSH介绍 安装使用 OpenSSH的安装 使用 配置和启动ssh服务 登录到远程主机 配置使用key登录ssh服务器ssh免密码登录 总结 本章总结 更多参考内容 SSH介绍 什么是ssh？ssh是“Secure Shell”的简写，Secure Shell协议是国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）制定的一个标准。目的是为了创建一个工作在应用层和传输层基础上的安全协议。避免数据的的明文传输。 什么是OpenSSH？前边说了，ssh是网络协议，而OpenSSH就是其中的一个具体实现。OpenSSH是由OpenBSD管理的项目之一，不过Openssh是跨平台的，支持linux、unix*，甚至windows。所以实际应用中，我们用到的ssh基本上都是Openssh。 OpenSSH有哪些功能？Secure Shell 是一个通信协议，在这个协议之上可以实现很多种应用层协议。从OpenSSH官网来看，OpenSSH提供了以下几个应用： 1、ssh，登录远程服务器、在远程服务器上执行命令。 2、scp，在两台主机之间实现文件拷贝。 3、sftp，基于openssh实现的类似ftp程序。 除此之外，OpenSSH还提供了几个命令行工具，用来方便进行ssh操作：1、ssh-add2、ssh-keysign3、ssh-keyscan4、ssh-keygen 安装使用下文将讲述这些命令的实际用法。 OpenSSH的安装大部分linux发行版都默认包含了OpenSSH客户端和服务器端，一些linux桌面发行版没有安装openssh服务器端。如果没有安装，我们可以通过linux发行版的软件包管理工具进行安装。简单来说就是：apt-get系列：1sudo apt-get install openssh openssh-server yum系列：1sudo yum install openssh openssh-server 其他系列：自己百度下。备注：openssh是客户端、openssh-server是服务器端。不同的发行版名称可能不同，需要自己确认一下。安装完毕之后，系统中就应该会有ssh命令了。这个时候就可以使用ssh来进行远程主机的管理了。 使用配置和启动ssh服务在使用之前我们需要对ssh服务进行配置，在大多数linux系统中，ssh服务的配置文件为：/etc/ssh/sshd_config使用vim进行编辑：1vim /etc/ssh/sshd_config 以下地方根据实际情况进行修改（yes为允许、no为禁止）：1234PermitRootLogin yes #是否允许root账户登录PasswordAuthentication yes #是否允许使用密码校验登录RSAAuthentication yes PubkeyAuthentication yes #是否允许使用key登录 然后使用系统服务管理命令启动服务，在大部分linux系统下，命令为：service 或者 systemctl启动ssh服务命令：1~# service sshd restart 或者1~# systemctl restart sshd 登录到远程主机命令格式为：ssh 用户名@远程主机的ip地址:远程主机端口示例：1ssh root@192.168.0.1:22 或者：1ssh -p 22 root@192.168.0.1 注：ssh默认端口为22，远程主机为默认端口时，可省略端口号。 执行上述命令之后，首次登陆会询问是否保存秘钥，输入yes即可。然后会提示输入密码，输入该用户对应的远程主机密码即可。 配置使用key登录ssh服务器ssh免密码登录使用key登录，需三个步骤： 修改ssh服务配置文件允许key登录：1~# vim /etc/ssh/sshd_config 找到PubkeyAuthentication这一行，改成：1PubkeyAuthentication yes 重启ssh服务：1~# service sshd restart 或者1~# systemctl restart sshd 使用ssh-keygen命令在本地机器上生成Rsa公钥对：1~# ssh-keygen -t rsa 执行上述命令后，会提示输入要保存的文件路径，默认为：~/.ssh/id_rsa. 输入文件名，点回车，会提示输入秘钥的密码（会提示输入两遍），即可生成秘钥文件： 查看秘钥文件 将公钥文件上传到服务上：12~# ssh-copy-id -i /home/zhao/.ssh/id_rsa_leilei.pubroot@192.168.0.1 -i 是用来指定公钥文件，执行命令之后，按提示输入远程密码即可。 然后即可使用私钥文件登录服务器：1~# ssh -i /home/zhao/.ssh/id_rsa_leilei root@192.168.0.1 注意：如果在第3步时为秘钥设置了密码，则使用秘钥登录服务器时，需要输入秘钥密码。 总结 如果想实现免密登录，则只需要在第三步生成密钥对时不要设置秘钥密码。 如果使用秘钥文件使用默认文件名（id_rsa），则在使用ssh的过程中就不需要再使用-i开关来指定秘钥文件了。 拷贝文件到远程主机：ssh中提供了scp命令用来拷贝文件到远程主机，使用方式为： 1~# scp -i /home/zhao/.ssh/id_rsa_miyao a.tar.gz root@192.168.0.1:/home/zhao/ 就能将文件 a.tar.gz 拷贝到远程主机/home/zhao/下 在远程服务器上执行命令：直接将需要执行的命令追加到ssh命令后面即可，如：1~# ssh -i /home/zhao/.ssh/id_rsa_miyao root@192.168.0.1 &quot;ls -l&quot; 即可在远程服务器上执行“ls -l” 命令，结果将输出到本地控制台。但是在执行一些命令时，远程主机会提示无法找到该命令，这说明需要设置远程主机的环境变量，可在发送给远程主机的命令中增加source指令，如：1~# ssh -i /home/zhao/.ssh/id_rsa_miyao root@192.168.0.1 &quot;source ~/.bash_profile &amp;&amp; ls -l&quot; 本章总结 本文的命令示例中，均使用了 -i 开关来指定秘钥文件，如果使用默认秘钥文件：~/.ssh/id_rsa登录，则均可省略-i开关。 其他用法后续再补充吧。更多参考内容https://man.openbsd.org/ssh-add.1https://man.openbsd.org/?query=ssh-keygen&amp;sektion=1","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"iOS系统的shell工具blink","slug":"shell/iOS系统的shell工具blink","date":"2019-02-26T18:11:37.000Z","updated":"2019-02-26T18:29:38.000Z","comments":true,"path":"2019/02/27/shell/iOS系统的shell工具blink/","link":"","permalink":"https://huos3203.github.io/2019/02/27/shell/iOS系统的shell工具blink/","excerpt":"","text":"简介用于iOS的Blink Shell(为更多Shell util进行了编辑)Blink是第一个利用Mosh和SSH支持的专业桌面级iOS终端。因此，我们可以明确地保证稳定的连接、闪电般的速度和完整的配置。它可以而且应该是你一整天的工具。我们没有创建另一个终端来修复您的网站的运行。Blink从一开始就被打造为专业级产品。我们从分析什么是必须拥有的开始，我们最终基于以下三个概念: 快速呈现Unix服务器中的dmesg应该是即时的。我们等不及要渲染了。我们不需要重新发明轮子来实现这一点。我们只是简单地使用Chromium的HTerm来确保渲染是完美和快速的，即使是那些特殊的、复杂的编^码。 始终在线Mosh超越了SSH的可变性。Mosh克服了我们都与移动连接相关的不稳定和间歇性连接。您可以检查Safari，而不必担心重新启动SSH连接。感谢Mosh，你可以完美地从家里跳到火车上，然后跳到办公室。Blink是坚如磐石的连接方式。Mosh很容易获得，并且可以很容易地安装在服务器上。访问https://mosh.org。 完全可配置Blink热情拥抱蓝牙连接键盘。一些人喜欢在Vim上设置Esc，另一些人喜欢在Emacs上设置Ctrl。瞬目是它们的冠军。但还有更多，因为我们想要更多。您还可以添加自己的自定义主题和字体来闪烁。在你的日常工作中，你处于自己的状态。但是，眨眼更重要。请阅读:你应该命令你的终端，而不是导航它。Blink会把你直接跳到一个友好的shell中，这样你就可以清楚地看到如何滚动了。界面很简单。我们抛弃了所有的菜单，为您的终端打开了全屏。使用滑动在打开的连接之间移动，滑下来关闭它们，甚至捏来缩放!通过添加您自己的主机和RSA加密密钥来配置Blink连接。一切看起来都很熟悉，你很快就可以开始工作了! 使用我们已经合并了SplitView，用于那些必要的谷歌搜索和与同事聊天。更多信息，请访问Blink Shell。 添加新功能这个分支还包含一组shell实用程序，因此您可以添加/删除文件、列出它们等等。目前可用的命令有: 操作命令cd, setenv, ls, touch, cp, rm, ln, mv, mkdir, rmdir, df, du, chksum, chmod, chflags, chgrp, stat, readlink, compress, uncompress, gzip, gunzip， 环境命令pwd, env, printenv, date, uname, id, groups, whoami, uptimecat,grep, wc 访问命令curl(包括http、https、scp、sftp…)、scp、sftp tar 第三方项目：使用外部项目:Python、Lua和TeX您可以单独调用命令，或者使用python或lua使用script脚本。有重定向(“&gt;”、“&lt;”、“&amp; &gt;“…),但没有pipe工具。 所有这些命令都在ios_system.framework(预编译，用于工具)中。如果您想编辑源代码(以添加更多命令)，请参见:https://github.com/holzschu/ios_system。 编辑脚本文件我建议安装iVim (https://github.com/terrychou/iVim或https://itunes.apple.com/us/app/ivim/id1266544660?)mt=8)，使用ios11“edit-in-place”在Blink沙箱内编辑文件。 密钥访问方式curl可以打开与iPad之间的文件传输(ftp、http、scp、sftp…)。 它使用了BLINKSHELL的密钥管理(即“config”创建密钥)。 也可以指定键与路径: 1curl scp://host.name.edu/filename -o filename—key $SHARED/id_rsa—pass MyPassword 你也可以使用scp和sftp命令: scp user@host.name.edu:文件名 sftp localFilename user@host.name.edu: ~ / scp和sftp是通过curl实现的，通过重写参数来遵循curl语法。利:更轻的实现，更小的内存成本，更不可能有函数名冲突。弊:有些开关可能没有完全相同的含义。 第三方语言包语言包(Python、Lua和TeX)只提供等价的二进制文件。您可以使用包(/usr/local/texlive或/usr/lib/python2.7)传输目录，并将它们放到Blink应用程序的Library文件夹中。这是命令，如ls, rm, tar, mv…将是有用的。注意:所有框架(除了curl)都是动态框架，以减少应用程序内存占用。 环境变量在iOS中，由于沙箱限制，不能在~目录下写，只能在~/Documents/、~/Library/和~/tmp中写。大多数Unix程序假定配置文件位于$HOME中。因此，要么将$HOME重新定义为~/Documents/，要么将配置变量(使用setenv)设置为其他位置。我用Blink在MCPSession.m文件。定义了以下变量:123456setenv PATH = $PATH:~/Library/bin:~/Documents/binsetenv PYTHONHOME = $HOME/Library/setenv SSH_HOME = $HOME/Documents/setenv CURL_HOME = $HOME/Documents/setenv HGRCPATH = $HOME/Documents/.hgrc/setenv SSL_CERT_FILE = $HOME/Documents/cacert.pem 如果你想永久地改变它们，最好是编辑MCPSession.m文件。 使用Blink我们的UI非常直观，并优化了触摸设备的体验，这是非常重要的部分，terminal终端。您将直接跳到一个非常简单的shell中，因此您将知道如何操作。这里还有一些技巧:键入help在shell中查找信息。新建shell命令：用两个手指轻敲创建一个新的shell。移动shell命令：通过用手指移动两行shell命令。新建连接/重连/退出：您可以退出会话并回到shell打开一个新连接。关闭session：两个手指向下拖动来关闭会话。缩放文本：使用缩放手势来增加或减少文本的大小。您也可以使用Cmd+或Cmd-如果使用键盘。复制和粘贴：通过选择文本点击屏幕。运行“config”来设置密钥。通过ssh-copy-id将它们安装到服务器。在SmartKeys栏上的Ctrl和Alt修改器允许连续按下，就像在真正的键盘上一样。 支持python命令holzschu/blinkholzschu/pyhon_iOS 配套使用的iVim工具iVimreadme介绍了，如何在真机上运行以及集成python环境。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"Guaka快速创建swift命令行CLI的工具","slug":"macOS/Guaka快速创建swift命令行CLI的工具","date":"2018-11-18T19:10:49.000Z","updated":"2018-11-18T19:10:49.000Z","comments":true,"path":"2018/11/19/macOS/Guaka快速创建swift命令行CLI的工具/","link":"","permalink":"https://huos3203.github.io/2018/11/19/macOS/Guaka快速创建swift命令行CLI的工具/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-nsomar-Guaka-7d6135f\", \"nsomar\", \"Guaka\", \"7d6135f\", false); Guaka介绍通过 Guaka Framework 来实现 CLI(command-line interface)。该框架可以快速实现如下的效果：1git checkout -v &quot;url&quot; git 就是一个 CLI，checkout是这个CLI的子命令，并接受一个String 作为他的参数。 对应上述的命令可以为分为： git 主命令 checkout 子命令 -v/–v 命令所接收的 flag1234└── git ├── checkout -v └── push -f └── ... 在 Guaka 中代码表现基本就是这样子的：12345let flag = Flag(longName: \"v\", value: false, description: \"Show verbose\")let command = Command(usage: \"git\", flags: [flag]) &#123; flags, args in let showVerbose = flags.getBool(name: \"v\") // args the positional arguments passed to the command&#125; 上面就是 git 的 -v 指令，是否打印过程. Guaka快速上手 安装 1&gt; brew install oarrabi/tap/guaka 新建工程假设我们要建立一个 papa 的CLI指令 12cd 到需要建立工程的目录guaka create papa 会生成如下路径├── Package.swift└── Sources ├── main.swift ├── root.swift └── setup.swift 增加指令给 papa 增加个子命令叫做 check1guaka add check 增加 flag增加 flag 就要去 Source 下面对应的 Swift 文件中修改。 编译执行 Swift build1swift build // 会编译生成可执行文件// .build/debug/papa –help 运行papa可执行文件1.build/debug/papa check 增加逻辑就在对应的 Swift 文件中增加.","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用swift命令行抓取WWDC字幕","slug":"macOS/使用swift命令行抓取WWDC字幕","date":"2018-11-18T19:10:49.000Z","updated":"2018-11-18T19:10:49.000Z","comments":true,"path":"2018/11/19/macOS/使用swift命令行抓取WWDC字幕/","link":"","permalink":"https://huos3203.github.io/2018/11/19/macOS/使用swift命令行抓取WWDC字幕/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-WWDC-Subtitles-84878dc\", \"huos3203\", \"WWDC-Subtitles\", \"84878dc\", false); 平时没有那么大段的时间能去看这些 session 的视频，想先通过字幕能了解到 session 中的内容，所以搜罗了网上大牛抓取WWDC字幕的相关实现。 原理WWDC客户端作者分享的一个开源项目jonyfive是把他WWDC项目中抓取字幕文件逻辑抽取出来，就是使用 swift 做的爬虫，可以结合项目做些有趣的东西。这边我对该项目进行了一些修改，之前下载的直接就是 vtt 的文件，并没有对文本文件进行处理，我把vtt格式调整了正常阅读的模式，方便大家阅读。 不支持2108下载 安装123$ git clone https://github.com/Danny1451/WWDC-Subtitles.git$ cd WWDC-Subtitles$ swift build 抓取字幕获取 2017 年 204 session 的字幕，保存到当前目录的 2017 文件夹1./wwwww subtitle -s 204 -v -y 2017 获取 2016 年 204 session 的 meta 信息，以 json 格式并且保存在当前目录的 sessions.json 文件中1./wwwww meta -s 204 -v -y 2016 如何下载中文如何支持2018下载WWDC 2017 字幕抓取 &amp; Guaka 介绍 WWDCHelper - 帮你更好下载 WWDC 中文字幕","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"Swift的动态性","slug":"swift/Swift的动态性","date":"2018-11-10T09:14:55.000Z","updated":"2018-11-10T09:14:55.000Z","comments":true,"path":"2018/11/10/swift/Swift的动态性/","link":"","permalink":"https://huos3203.github.io/2018/11/10/swift/Swift的动态性/","excerpt":"","text":"FoundationFoundation 框架实现了基于运行时一个特性的两个API： 键值编码 (key-value-coding, KVC) 键值观察 (key-value observing, KVO)KVC 和 KVO 允许我们将 UI 和数据进行绑定，这也是 Rx 以及其他响应式框架实现的基础。KVCKVC 的工作方式如下所示：1234@property (nonatomic, strong) NSNumber *number;[myClass valueForKey:@\"number\"];[myClass setValue:@(4) forKey:@\"number\"]; 例如，假设我们有这个 number 属性，您可以将属性名称作为键，来获取属性值或者设置属性值。这个功能可以用在此前我们所看到的获取变量列表、协议列表，以及危险的混淆功能当中。 KVO通常所说的 Objective-C 「动态性」，往往都是指 KVO。虽然还有其余的函数，但是这些是最常见、最常用的。这也就是人们所说的，Swift 缺失的部分。 使用KVO对状态的变化进行注册1234567891011[myClass addObserver:selfforKeyPath:@\"number\"options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNewcontext:nil];- (void)observeValueForKeyPath:(NSString *)keyPathofObject:(id)objectchange:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)changecontext:(void *)context&#123;// Respond to observation.&#125; 在观察的值发生变更之后，KVO 会调用此方法立即通知观察者。通过这个方法，我们便可以按需更新 UI。 弊端：难以调试KVO这些操作都存有隐患。比方说 KVO，特别是当我们对某个不是自己所创建的类进行观察时，往往会发现有出乎意料的变化发生。通常而言，这些问题是非常难以调试的，也很难去理解为什么出错。在实际产品当中，我并不建议使用它们，尽管它们非常好用。但是在实际产品当中，我会很谨慎地去使用这些功能。 Apple 也是如此认为的，因此它们在视图控制器当中添加了这个私有方法，可以使用 class-dump 来查看。 (void) attentionClassDumpUser:yesItsUsAgain:althoughSwizzlingAndOverridingPrivateMethodsIsFun:itWasntMuchFunWhenYourAppStoppedWorking:pleaseRefrainFromDoingSoInTheFutureOkayThanksBye: 的确，很让人抓狂。 SwiftSwift 是一种强类型语言。即默认类型是安全的静态类型。如果需要的话，不安全类型也是存在的，但是 Swift 仍然是尽力推动我们使用安全的静态类型。Swift 中的动态性可以通过 Objective-C 运行时来获得。 本来这是很好的，但是 Swift 开源并迁移到 Linux 之后，由于 Linux 上的 Swift 并不提供 Objective-C 运行时，事情就大条了。社区的关键点在于，让 Swift 未来能够自己配备动态性，而不是依赖于 Apple。 Swift中的两个动态修饰符 @objc: 将Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。 @dynamic:动态功能修饰符，它隐含添加了 @objc功能。 Swift中运行时方法回到我们的动态特性当中，让我们来看一看 Swift 当中这些动态特性是什么样的。假设我们需要使用内省机制、转发方法、替换和绑定方法。 方法转发12345678910111213// 1override class func resolveInstanceMethod(_ sel: Selector!)-&gt; Bool &#123;// 添加实例方法并返回 true 的一次机会，它随后会再次尝试发送消息&#125;// 2override func forwardingTarget(for aSelector: Selector!) -&gt;Any? &#123;// 返回可以处理 Selector 的对象&#125;// 3 - Swift 不支持 NSInvocation resolveInstanceMethod 同样会被调用，forwardingTarget 看起来似乎更贴近于 Swift 3 风格的 API。但是 NSInvocation 并不能在 Swift 当中使用。我们同样可以实现方法转发，因此看起来也不算太坏。 方法混淆load 在 Swift 不再会被调用，因此我们需要在 initialize 中进行混淆。在 Objective-C 当中使用的 dispatch_once，但是在 Swift 3 中被废弃。事情变得略为复杂。虽然对于特定类型的函数而言，我们仍然可以将其定义为动态函数，但是它会消除大部分混淆的功能。 内省机制1234567891011if self is MyClass &#123;// YAY&#125;let myString = &quot;myString&quot;;let mirror = Mirror(reflecting: myString)print(mirror.subjectType) // “String&quot;let string = String(reflecting: type(of:myString)) // Swift.String// No native method introspection is 替代了 isMemberOfClass，它同样也可以对 Swift 值类型:结构体、枚举以及其他 Swift 当中的新类型使用。此外还有一个新的映射 API，它主要针对于管道 (pipe) 和数据。 单元测试目前，我们没有原生的办法来实现内省。这也预示着这个功能未来可能会出现，但是目前我们还无法实现。这很令人沮丧，特别是当您想到我们此前所实现的 XCTestCase。如果您打算为 Linux 编写单元测试的时候，就无法自动遍历所有的函数。您必须实现 static var allTests，然后手动列出所有的测试函数。这很糟糕。 KVC/KVO功能的削弱KVO 的魅力在于，您可以在不是自己所创建的类当中使用它，也可以只对您想要监听变化的类使用。KVO 和 KVC 在 Swift 被极大地削弱了。两点要求： 被观察的对象必须要继承自 NSObject，并且使用一个 Objective-C 类型。 被观察的变量必须要声明为 @dynamic。您必须要对想要观察的事务了如指掌。问题是 Swift 并没有很好的替代方案。您可以使用 Rx 或者基于协议来观察对象。但是语言自身是没有原生的解决方案的。 总结总而言之，Objective-C 的动态性无疑是非常强大的、极其有用，虽然也存在危险性。Swift 目前没有足够的替代方案来解决这些问题，但是可以预见在不久的将来 Swift 的动态性将会出现，这是值得我们期待的。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"Chisel-xcodeproj框架的使用","slug":"调试/Chisel-xcodeproj框架的使用","date":"2018-11-09T13:05:46.000Z","updated":"2018-11-09T20:13:28.000Z","comments":true,"path":"2018/11/09/调试/Chisel-xcodeproj框架的使用/","link":"","permalink":"https://huos3203.github.io/2018/11/09/调试/Chisel-xcodeproj框架的使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-chisel-f331dc6\", \"huos3203\", \"chisel\", \"f331dc6\", false); 这个pull请求添加findinstances命令，该命令完成Add findinstances, and new support framework in Chisel.xcodeproj 和Add Makefile for installing framework的工作。用户可以运行help findinstances获取findinstances的详细信息。简要总结一下，findinstances可以找到给定class类或protocol协议的所有实例，并使用谓词表达式过滤这些结果。如果您有一个名为XXSocialUser的类，那么您可以通过运行findinstances XXSocialUser == &#39;curry&#39;来找到一个特定的用户。 Chisel.xcodeproj为新建findinstance提供了凿子框架支持。使用Chisel.xcodeproj支持新建chisel Framework通过本地代码实现command,findinstances等功能。也可以通过这种方式来实现更多chisel命令。 findinstance命令通过扫描iOS/macOSmalloc API。对于每个allocation分配，都会使用heuristics来识别可能的Objective-C实例。heuristics不调用对象上的method，而是依赖objc runtime运行时函数,基于class metadata类元数据来匹配到oc实例。这避免了在objc运行时机制下分配和有状态副作用。在第一次传递之后，候选对象将通过第二次传递，检查它们是否与可选的NSPredicate匹配。如果没有谓词，则输出对象的信息最少。如果有谓词，并且对象传递谓词，那么对象将输出更多细节，特别是谓词中查询的细节。1234567findinstances UIViewfindinstances *UIViewfindinstances UIScrollViewDelegatefindinstances UIView window == nil || hidden == true || alpha == 0 || layer.bounds.#size.width == 0 || layer.bounds.#size.height == 0 findinstances UIView subviews.@count == 0findinstances NSDictionary any @allKeys beginswith &apos;perf_&apos;findinstances NSArray @count &gt; 100 开发使用构建Xcode项目，并获得到Chisel Framework的路径。:1/Users/&lt;me&gt;/Library/Developer/Xcode/DerivedData/Chisel-&lt;stuff&gt;/Build/Products/Debug-iphonesimulator/Chisel.framework/Chisel 在lldb环境下执行：123$ lldb&gt;&gt;&gt; expr -l objc -- (void*)dlopen(&quot;/path/to/Chisel.framework/Chisel&quot;, 2)script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;&lt;classname&gt;&quot;, &quot;&lt;predicate&gt;&quot;)&apos;, o) &lt;classname&gt;:可以是class类名或protocol协议名&lt;predicate&gt;:是一个可由NSPredicate解析的字符串可以使用regex command 命令:(注意，findinstance后面必须换行)12command regex findinstancess/(\\S+) *(.*)/script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;%1&quot;, &quot;%2&quot;)&apos;, o)/ 或者，作为python命令，存储在path/to/findinstances.py中:123456789101112131415161718192021import lldbdef findinstances(debugger, command, exe_ctx, result, _):options = lldb.SBExpressionOptions()options.SetTrapExceptions(False)options.SetTryAllThreads(False)options.SetTimeoutInMicroSeconds(10*1000000)options.SetLanguage(lldb.eLanguageTypeObjC)frame = exe_ctx.frameif not exe_ctx.target.module[&apos;Chisel&apos;]:frame.EvaluateExpression(&apos;(void*)dlopen(&quot;/path/to/Chisel.framework/Chisel&quot;, 2)&apos;, options)args = command.split(&apos; &apos;, 1)typeName = args[0]predicate = args[1] if len(args) &gt; 1 else &apos;&apos;frame.EvaluateExpression(&apos;(void)PrintInstances(&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;)&apos;.format(typeName, predicate), options)def __lldb_init_module(debugger, _):debugger.HandleCommand(&apos;command script add -f findinstances.findinstances findinstances&apos;) 安装Add Makefile for installing frameworkThis allows you to run make install with optional environment variablesin order to build and install Chisel.framework.12345678910111213141516PREFIX ?= /usr/local/libexport INSTALL_NAME =ifneq ($(LD_DYLIB_INSTALL_NAME),) INSTALL_NAME = &quot;LD_DYLIB_INSTALL_NAME=$(LD_DYLIB_INSTALL_NAME)&quot;endifinstall: xcodebuild \\ -scheme Chisel \\ -configuration Release \\ -sdk iphonesimulator \\ install \\ $(INSTALL_NAME) \\ DSTROOT=/ \\ INSTALL_PATH=&quot;$(PREFIX)&quot;","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"makefile自动化编译工具","slug":"shell/makefile自动化编译工具","date":"2018-11-08T20:30:54.000Z","updated":"2018-11-08T20:30:54.000Z","comments":true,"path":"2018/11/09/shell/makefile自动化编译工具/","link":"","permalink":"https://huos3203.github.io/2018/11/09/shell/makefile自动化编译工具/","excerpt":"","text":"make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。 makefile的规则 在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。跟我一起写Makefile","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"配置Vim插件Python-mode开发python程序","slug":"python/配置Vim插件Python-mode开发python程序","date":"2018-11-07T20:45:31.000Z","updated":"2018-11-08T20:30:53.000Z","comments":true,"path":"2018/11/08/python/配置Vim插件Python-mode开发python程序/","link":"","permalink":"https://huos3203.github.io/2018/11/08/python/配置Vim插件Python-mode开发python程序/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-python-mode-python-mode-95fdf8\", \"python-mode\", \"python-mode\", \"95fdf8\", false); 安装vim插件python-mode依赖于space-Vim插件包工具 配置 初始化 1234function! UserInit() &quot; Add plugin via Plug command. Plug &apos;tpope/vim-pathogen&apos; Plug &apos;python-mode/python-mode&apos; 默认配置 12function! UserConfig() let g:pymode_python = &apos;python3&apos; 结果出现加载问题失败安装vim插件python-mode12345678$ vi test.py&gt;&quot;test.py&quot; [New File]Error detected while processing function pymode#init:line 2:E319: Sorry, the command is not available in this version: python3 import sys, vimline 3:E319: Sorry, the command is not available in this version: python3 sys.path.insert(0, vim.eval(&apos;a:plugin_root&apos;)) 最终采用space-Vim工具中的layer实现了。123let g:spacevim_layers = [ \\ &apos;python&apos;,\\ ] Vim插件之python-mode 设置 Python多版本管理","categories":[{"name":"python","slug":"python","permalink":"https://huos3203.github.io/categories/python/"}],"tags":[]},{"title":"使用Sphinx制作简洁而又美观的文档","slug":"hexo/使用Sphinx制作简洁而又美观的文档","date":"2018-11-07T12:27:56.000Z","updated":"2018-11-07T20:45:31.000Z","comments":true,"path":"2018/11/07/hexo/使用Sphinx制作简洁而又美观的文档/","link":"","permalink":"https://huos3203.github.io/2018/11/07/hexo/使用Sphinx制作简洁而又美观的文档/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); 使用 sphinx 制作简洁而又美观的文档 安装123456789$ easy_install sphinxSearching for sphinxReading http://pypi.python.org/simple/sphinx/Reading http://sphinx.pocoo.org/Best match: Sphinx 1.0.5Downloading http://pypi.python.org/packages/[...]Processing Sphinx-1.0.5-py2.5.egg[...]Finished processing dependencies for sphinx 创建工程123456$ sphinx-quickstart Welcome to the Sphinx 1.0.5 quickstart utility.Please enter values for the following settings (just press Enter toaccept a default value, if one is given in brackets).[...] 工作目录的列表12345├── Makefile├── _build├── _static├── conf.py└── index.rst 让我们详细研究一下每个文件。 Makefile：编译过代码的开发人员应该非常熟悉这个文件，如果不熟悉，那么可以将它看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。 _build：这是触发特定输出后用来存放所生成的文件的目录。 _static：所有不属于源代码（如图像）一部分的文件均存放于此处，稍后会在构建目录中将它们链接在一起。 conf.py：这是一个 Python 文件，用于存放 Sphinx 的配置值，包括在终端执行 sphinx-quickstart 时选中的那些值。 index.rst：文档项目的 root 目录。如果将文档划分为其他文件，该目录会连接这些文件。make生成文档以py-trello为例子1234567$ git clone py-trello$ cd py-trello/docs$ make html&gt;sphinx-build -b html -d _build/doctrees . _build/html正在运行的是 Sphinx v1.8.1创建输出目录…","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"swift混编及Framework和静态库的支持","slug":"swift/swift混编及Framework和静态库的支持","date":"2018-10-31T21:19:06.000Z","updated":"2018-10-31T21:19:06.000Z","comments":true,"path":"2018/11/01/swift/swift混编及Framework和静态库的支持/","link":"","permalink":"https://huos3203.github.io/2018/11/01/swift/swift混编及Framework和静态库的支持/","excerpt":"","text":"swift和OC混编OCoc调用swift framework/swift静态库oc静态库调用swift/oc的frameworkoc静态库调用swift/oc的静态库swiftswift调用oc/swift静态库swift framework调用oc/swift静态库swift静态库调用oc/swift静态库###","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"使用Fastlane持续集成开发","slug":"macOS/使用Fastlane持续集成开发","date":"2018-10-24T12:45:30.000Z","updated":"2018-10-24T13:45:36.000Z","comments":true,"path":"2018/10/24/macOS/使用Fastlane持续集成开发/","link":"","permalink":"https://huos3203.github.io/2018/10/24/macOS/使用Fastlane持续集成开发/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); 持续集成在框架开发中，一个优秀的持续集成环境是至关重要的。CI 可以保证潜在的贡献者在有保障的情况下对代码进行修改，减小了框架的维护压力。大部分 CI 环境对于开源项目都是免费的，得益于此，我们可以利用这个星球上最优秀的 CI 来确保我们的代码正常工作。 就 iOS 或者 OSX 开发来说，Travis CI, CircleCI, Coveralls，Codecov 等都是很好的选择。 开发总是有趣的，但是发布一般都很无聊。因为发布流程每次都一样，非常机械。无非就是跑测试，打 tag，上传代码，写 release log，更新 podspec 等等。虽然简单，但是费时费力，容易出错。对于这种情景，自动化流程显然是最好的选择。而相比于自己写发布脚本，在 Cocoa 社区我们有更好的工具，那就是 fastlane。 fastlane 是一系列 Cocoa 开发的工具的集合，包括跑测试，打包 app，自动截图，管理 iTunes Connect 等等。 不单单是 app 开发，在框架开发中，我们也可以利用到 fastlane 里很多很方便的命令。 使用 fastlane 做持续发布很简单，建立自己的合适的 Fastfile 文件，然后把你想做什么写进去就好了。比如这里是一个简单的 Fastfile 的例子：123456789101112131415161718192021# Fastfiledesc &quot;Release new version&quot;lane :release do |options| target_version = options[:version] raise &quot;The version is missed.&quot; if target_version.nil? ensure_git_branch # 确认 master 分支 ensure_git_status_clean # 确认没有未提交的文件 scan # 运行测试 sync_build_number_to_git # 将 build 号设为 git commit 数 increment_version_number(version_number: target_version) # 设置版本号 version_bump_podspec(path: &quot;Kingfisher.podspec&quot;, version_number: target_version) # 更新 podspec git_commit_all(message: &quot;Bump version to #&#123;target_version&#125;&quot;) # 提交版本号修改 add_git_tag tag: target_version # 设置 tag push_to_git_remote # 推送到 git 仓库 pod_push # 提交到 CocoaPodsend$ fastlane release version:1.8.4 AFNetworking 在 3.0 版本开始加入了 fastlane 做自动集成和发布，可以说把开源项目的 CI 做到了极致。在这里强烈推荐大家有空可以看一看这个项目，除了使用 fastlane 简化流程以外，这个项目里还介绍了一些发布框架时的最佳实践。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"cocoapods如何自动化管理项目依赖","slug":"macOS/cocoapods如何自动化管理项目依赖","date":"2018-10-23T20:29:21.000Z","updated":"2018-10-23T20:29:21.000Z","comments":true,"path":"2018/10/24/macOS/cocoapods如何自动化管理项目依赖/","link":"","permalink":"https://huos3203.github.io/2018/10/24/macOS/cocoapods如何自动化管理项目依赖/","excerpt":"","text":"通过介绍项目相关的属性配置，来了解cocoapods如何自动化管理项目依赖的。最后会通过自定义ruby脚本来演示。 cocoapods偶现问题pod install安装依赖，主要是对build settings中的新增依赖配置等，当cocopad 集成失败时，可以通过以下几步排查 ，也可以尝试清除项目中pod相关的信息，重新pod install，了解以下步骤都是很重要的。 添加宏Preprocessor Macros 12Debug：$(inherited) COCOAPODS=1Release：$(inherited) COCOAPODS=1 设置Other C Flags 12Debug：$(inherited) -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small/Small.framework/Headers&quot; -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive/ZipArchive.framework/Headers&quot;Release：$(inherited) -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small/Small.framework/Headers&quot; -iquote &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive/ZipArchive.framework/Headers&quot; 设置Framework Search Paths 12Debug：$(inherited) &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small&quot; &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive&quot;Release：$(inherited) &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/Small&quot; &quot;$&#123;PODS_CONFIGURATION_BUILD_DIR&#125;/ZipArchive&quot; Add User-Defined setting,新加三个参数 PODS_CONFIGURATION_BUILD_DIRDebug: ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)Release: ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)PODS_PODFILE_DIR_PATH: ${SRCROOT}/../.. PODS_ROOT : ${SRCROOT}/../../Pods 使用脚本自动设置Small-subprojects.rb编辑项目配置文件，动态设置插件库的Framework search path.在项目中run shellScript添加ruby Small-subprojects.rb命令: 当old_fsp为空时，会执行失败。 使用./Small-subprojects.rb，有时出现权限问题，替换为ruby Small-subprojects.rb。 编码问题：在头部添加# encoding: utf-8：如invalid byte sequence in US-ASCII (ArgumentError)1234567891011121314151617181920212223242526272829303132333435#!/usr/local/bin ruby# encoding: utf-8require &apos;xcodeproj&apos;require &apos;xcodeproj/project/object/target_dependency&apos;project_path = &quot;#&#123;Dir.pwd&#125;/#&#123;Dir[&apos;*.xcodeproj&apos;][0]&#125;&quot;puts &quot;项目位置：#&#123;project_path&#125;&quot;project = Xcodeproj::Project.open(project_path)project.native_targets.each do |target| puts &quot;项目target：#&#123;target&#125;&quot; target.dependencies.each do |dep| puts &quot;项目dep：#&#123;dep&#125;&quot; if (dep.name != nil) changed = false sub_project = dep.target_proxy.proxied_object.project puts &quot;sub_project：#&#123;sub_project&#125;&quot; sub_project.native_targets.each do |sub_target| sub_target.build_configurations.each do |config| old_fsp = &quot;ddd&quot;#config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;] puts &quot;旧old_fsp：#&#123;config.build_settings&#125;&quot; if (!(old_fsp.include? &quot;$(CONFIGURATION_BUILD_DIR)/**&quot;)) changed = true puts &quot;更新-----&quot; #config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;] &lt;&lt; &quot;$(CONFIGURATION_BUILD_DIR)/**&quot; # puts &quot;Small: Add framework search paths for &apos;#&#123;dep.name&#125;&apos;&quot; end end end if (changed) sub_project.save end end endend 打印信息如下：123456789101112131415161718192021222324Showing All Messages:-1: 项目位置：/Users/admin/hsg/hexo/XcodeTool/iSmallApp/iSmallApp.xcodeproj:-1: 项目target：iSmallApp:-1: 项目dep：IntelDecision:-1: sub_project：#&lt;Xcodeproj::Project&gt; path:`/Users/admin/hsg/hexo/XcodeTool/iSmallApp/bundles/IntelDecision/IntelDecision.xcodeproj` UUID:`84C839BA217F28A500541D4D`:-1: 旧old_fsp：&#123;&quot;CODE_SIGN_IDENTITY&quot;=&gt;&quot;&quot;, &quot;CODE_SIGN_STYLE&quot;=&gt;&quot;Automatic&quot;, &quot;DEFINES_MODULE&quot;=&gt;&quot;YES&quot;, &quot;DEVELOPMENT_TEAM&quot;=&gt;&quot;9CA5KUE8T7&quot;, &quot;DYLIB_COMPATIBILITY_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_CURRENT_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_INSTALL_NAME_BASE&quot;=&gt;&quot;@rpath&quot;, &quot;INFOPLIST_FILE&quot;=&gt;&quot;IntelDecision/Info.plist&quot;, &quot;INSTALL_PATH&quot;=&gt;&quot;$(LOCAL_LIBRARY_DIR)/Frameworks&quot;, &quot;LD_RUNPATH_SEARCH_PATHS&quot;=&gt;[&quot;$(inherited)&quot;, &quot;@executable_path/Frameworks&quot;, &quot;@loader_path/Frameworks&quot;], &quot;PRODUCT_BUNDLE_IDENTIFIER&quot;=&gt;&quot;com.clcw.IntelDecision&quot;, &quot;PRODUCT_NAME&quot;=&gt;&quot;$(TARGET_NAME:c99extidentifier)&quot;, &quot;SKIP_INSTALL&quot;=&gt;&quot;YES&quot;, &quot;SWIFT_VERSION&quot;=&gt;&quot;4.2&quot;, &quot;TARGETED_DEVICE_FAMILY&quot;=&gt;&quot;1,2&quot;&#125;:-1: 更新-----:-1: 旧old_fsp：&#123;&quot;CODE_SIGN_IDENTITY&quot;=&gt;&quot;&quot;, &quot;CODE_SIGN_STYLE&quot;=&gt;&quot;Automatic&quot;, &quot;DEFINES_MODULE&quot;=&gt;&quot;YES&quot;, &quot;DEVELOPMENT_TEAM&quot;=&gt;&quot;9CA5KUE8T7&quot;, &quot;DYLIB_COMPATIBILITY_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_CURRENT_VERSION&quot;=&gt;&quot;1&quot;, &quot;DYLIB_INSTALL_NAME_BASE&quot;=&gt;&quot;@rpath&quot;, &quot;INFOPLIST_FILE&quot;=&gt;&quot;IntelDecision/Info.plist&quot;, &quot;INSTALL_PATH&quot;=&gt;&quot;$(LOCAL_LIBRARY_DIR)/Frameworks&quot;, &quot;LD_RUNPATH_SEARCH_PATHS&quot;=&gt;[&quot;$(inherited)&quot;, &quot;@executable_path/Frameworks&quot;, &quot;@loader_path/Frameworks&quot;], &quot;PRODUCT_BUNDLE_IDENTIFIER&quot;=&gt;&quot;com.clcw.IntelDecision&quot;, &quot;PRODUCT_NAME&quot;=&gt;&quot;$(TARGET_NAME:c99extidentifier)&quot;, &quot;SKIP_INSTALL&quot;=&gt;&quot;YES&quot;, &quot;SWIFT_VERSION&quot;=&gt;&quot;4.2&quot;, &quot;TARGETED_DEVICE_FAMILY&quot;=&gt;&quot;1,2&quot;&#125;:-1: 更新-----:-1: 项目target：iSmallAppTests:-1: 项目dep：TargetDependency:-1: 项目target：iSmallAppUITests:-1: 项目dep：TargetDependency","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"将Playground作为项目的单元测试","slug":"swift/将Playground作为项目的单元测试","date":"2018-10-22T16:52:33.000Z","updated":"2018-10-22T18:39:30.000Z","comments":true,"path":"2018/10/23/swift/将Playground作为项目的单元测试/","link":"","permalink":"https://huos3203.github.io/2018/10/23/swift/将Playground作为项目的单元测试/","excerpt":"","text":"在Perfect项目中增加playground： 新建Perfect.xcodeproj和PerfectPlayground 新建一个Xcode工程Perfect 1swift package generate-xcodeproj 设置include路径在Xcode工程的build settings中设置SWIFT_INCLUDE_PATH 路径为 ${PROJECT_DIR}并设置recursive（递归）选项。 在同一工程目录下创建一个PerfectPlayground。 新建Perfect.workspace 新建一个工作空间：Perfect.workspace,在工作空间中添加工程和操场：Perfect.xcodeproj和PerfectPlayground。 编译Perfect.xcodeproj，这样就激活了PerfectPlayground的PerfectLib函数库功能。12345678910import PerfectLiblet json = \"&#123;\\\"name\\\": \\\"tom\\\"&#125;\"do &#123; let name = try json.jsonDecode() print(name)&#125;catch&#123;&#125;let u = UUID()print(u.string) 原文Perfect-Playground","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"新组件开发流程及打包证书配置","slug":"个人项目/新组件开发流程及打包证书配置","date":"2018-10-22T16:52:33.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/10/23/个人项目/新组件开发流程及打包证书配置/","link":"","permalink":"https://huos3203.github.io/2018/10/23/个人项目/新组件开发流程及打包证书配置/","excerpt":"欢迎光顾，输入码阅读","text":"欢迎光顾，输入码阅读 Incorrect Password! No content to display! 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","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"Swift访问REST服务开发TrelloAPI","slug":"macOS/Swift访问REST服务开发TrelloAPI","date":"2018-10-22T08:30:26.000Z","updated":"2018-10-22T08:30:26.000Z","comments":true,"path":"2018/10/22/macOS/Swift访问REST服务开发TrelloAPI/","link":"","permalink":"https://huos3203.github.io/2018/10/22/macOS/Swift访问REST服务开发TrelloAPI/","excerpt":"","text":"(Swift) iOS Apps with REST APIs(一)https://www.jianshu.com/p/01ca73387481","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用screen在后台运行进程","slug":"shell/使用screen在后台运行进程","date":"2018-10-21T22:42:59.000Z","updated":"2018-10-21T22:42:59.000Z","comments":true,"path":"2018/10/22/shell/使用screen在后台运行进程/","link":"","permalink":"https://huos3203.github.io/2018/10/22/shell/使用screen在后台运行进程/","excerpt":"","text":"screen 支持会话恢复 当我们开启screen后，只要screen进程没有终止，其内部运行的会话都可以恢复。网络连接中断临时，用户也可以进入开启的screen中，对中断的会话的进行控制(恢复或删除)。通常的用法是在暂时离开的时候，让在screen中运行的会话保持正常运行并将Screen切换到后台。 支持多窗口 当使用screen时，可以开启多个窗口，让每个会话都独立运行到不同的窗口，并拥有各自的编号、名称等。用户可以通过这些编号及名称进入不同的窗口。 会话共享 Screen可以让一个或多个用户从不同终端登录一个会话，并共享会话。使用户登陆同一会话的用户看到同一会话内容。 同时它可以提供窗口访问权限的设置，对窗口进行密码保护。screen参数123456789101112-A 将所有的视窗都调整为目前终端机的大小-d 将指定的screen作业离线-h 指定视窗的缓冲区行数-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业-r 恢复离线的screen作业-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业-s 指定建立新视窗时，所要执行的shell-S 指定screen作业的名称-v 显示版本信息-x 恢复之前离线的screen作业-ls或-list 显示目前所有的screen作业-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业 screen命令 自定义shell脚本启动一个进程 123456screen_name=\"ngrok\" # 创建了一个名为 my_screen 的窗screen -dmS $screen_namecmd=\"ngrok tcp 22\";screen -x -S $screen_name -p 0 -X stuff \"$cmd\"screen -x -S $screen_name -p 0 -X stuff '\\n' 退出进程 1screen -S session_name -X quit 其他1234567891011C-a ? 显示所有键绑定信息C-a w 显示所有窗口列表C-a C-a 切换到之前显示的窗口C-a c 创建一个新的运行shell的窗口并切换到该窗口C-a n 切换到下一个窗口C-a p 切换到前一个窗口(与C-a n相对)C-a 0..9 切换到窗口0..9C-a a 发送 C-a到当前窗口C-a d 暂时断开screen会话C-a k 杀掉当前窗口C-a [ 进入拷贝/回滚模式 退出screen退出screen的作业时，有两种方式：123Crtl + a +d 保存进程并退出作业(程序在screen中继续运行，screen -ls 可查看)Crtl + alt + a + d 进入后台运行进程exit 退出作业和进程(程序终止，screen -ls 不可查看) 什么是MoshMosh表示移动Shell(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。它能用于SSH连接，但是比Secure Shell功能更多。它是一个类似于SSH而带有更多功能的应用。程序最初由Keith Winstein 编写，用于类Unix的操作系统中，发布于GNU GPL V3协议下。Mosh最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的UDP方式。 会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行。 会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"基于Chisel自定义python调试命令","slug":"调试/基于Chisel自定义python调试命令","date":"2018-10-21T09:03:35.000Z","updated":"2018-10-21T09:03:35.000Z","comments":true,"path":"2018/10/21/调试/基于Chisel自定义python调试命令/","link":"","permalink":"https://huos3203.github.io/2018/10/21/调试/基于Chisel自定义python调试命令/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-chisel-56d0e0d\", \"huos3203\", \"chisel\", \"56d0e0d\", false); 管理.lldbinit.lldbinit每次启动Xcode 都会加载lldb环境，故当自定义命令写好之后，可以通过这里加载。1script fblldb.loadCommandsInDirectory(&apos;/magical/commands/&apos;) 现在将lldbinit原文件放在自己便于管理的地方，便于导入python命令123456789101112#!/bin/sh# installChisel.sh# HexoDeploy## Created by admin on 2018/10/21.# Copyright © 2018年 boyer. All rights reserved.basepath=$(cd `dirname $0`; pwd)echo \"当前cd的目录名：\"`basename $(pwd)`echo \"sh脚本文件的绝对路径：$basepath\"ln -fs $basepath/lldbinit ~/.lldbinitecho \"done\" 创建加载自定义命令无论是本地使用还是提交到Chisel贡献，工作流程都是一样的。 在便于管理的目录下，新建python文件 vi example.py，在chisel会通过该目录路径来加载新命令： 1234567891011121314151617181920#!/usr/bin/python# Example file with custom commands, located at /magical/commands/example.pyimport lldbimport fblldbbase as fbdef lldbcommands(): return [ PrintKeyWindowLevel() ]class PrintKeyWindowLevel(fb.FBCommand): def name(self): return &apos;pkeywinlevel&apos;def description(self): return &apos;An incredibly contrived command that prints the window level of the key window.&apos;def run(self, arguments, options): # It&apos;s a good habit to explicitly cast the type of all return # values and arguments. LLDB can&apos;t always find them on its own. lldb.debugger.HandleCommand(&apos;p (CGFloat)[(id)[(id)[UIApplication sharedApplication] keyWindow] windowLevel]&apos;) 加载新建的命令可以使用Chisel提供的函数loadCommandsInDirectory加载，在fblldb.py中声明的方法。在~/.lldbinit新增如下： 1234# ~/.lldbinit...command script import /path/to/fblldb.pyscript fblldb.loadCommandsInDirectory(&apos;/magical/commands/&apos;) 更方便的方式：命令文件直接放在chisel源码中的mcommands目录中，这样会自动加载，就不用在lldbinit中配置了。因为内置的支持，新命令也可以轻松使用arguments参数和options选项的相关功能。请参阅border和pinvocation命令的用法。 开发调试命令的流程无论是本地使用还是提交到Chisel贡献，都是相同的工作流。 启动LLDB 拦截断点(或者通过Xcode的调试栏中的pause按钮暂停执行，或者直接process interrupt进程中断) 执行命令source ~/.lldbinit，在LLDB中提供命令源 运行您正在执行的命令 修改命令 重新加载脚本script reload(modulename) 重复3-6步骤，直到自定义命令达到预期效果。","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"fork印象笔记SDK支持pod安装","slug":"macOS/fork印象笔记SDK支持pod安装","date":"2018-10-21T00:12:20.000Z","updated":"2018-10-21T09:03:35.000Z","comments":true,"path":"2018/10/21/macOS/fork印象笔记SDK支持pod安装/","link":"","permalink":"https://huos3203.github.io/2018/10/21/macOS/fork印象笔记SDK支持pod安装/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-evernote-sdk-mac-fd5da70\", \"huos3203\", \"evernote-sdk-mac\", \"fd5da70\", false); 制作pod支持 fork 并clone代码 1git clone https://github.com/evernote/evernote-sdk-mac.git 创建pod spec索引文件 12$ cd evernote-sdk-mac$ pod spec create EvernoteSDK https://github.com/huos3203/evernote-sdk-mac.git 编写配置文件设置支持的平台，源码目录位置，指定忽略的文件等配置。 123456789101112....spec.osx.deployment_target = &quot;10.7&quot;...# ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #spec.source_files = &quot;EvernoteSDK&quot;, &quot;EvernoteSDK/**/*.&#123;h,m&#125;&quot;spec.exclude_files = &quot;EvernoteSDK/internal/ENOAuthViewController*&quot;# ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― ##spec.requires_arc = true#spec.xcconfig = &#123;&quot;WARNING_CFLAGS&quot; =&gt; &apos;-Wno-nullability-completeness&apos;&#125;# spec.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;end 验证EvernoteSDK.podspec需要用参数：–allow-warnings ，由于源码验证过程中的警告提示问题，导致验证失败 1$ pod lib lint --allow-warnings 发布到私库中先在本地添加私库 123$ pod repo add PodRepo https://github.com/huos3203/PodRepo.git#输出：&gt; Cloning spec repo `PodRepo` from `https://github.com/huos3203/PodRepo.git` 开始发布过程中，也会验证，出现警告问题，需要添加--allow-warnings1$ pod repo push podRepo EvernoteSDK.podspec --allow-warnings 在项目中使用编辑podfile文件1234#加载私库source &apos;https://github.com/huos3203/PodRepo.git&apos;#依赖库pod &apos;EvernoteSDK&apos;, &apos;~&gt; 1.2.0&apos; 在执行pod install 即可。 API调用在objc中调用直接引入#import &lt;EvernoteSDK/EvernoteSDK.h&gt;12345678910#import &lt;EvernoteSDK/EvernoteSDK.h&gt;@implementation hello-(void)test&#123; NSString *EVERNOTE_HOST = BootstrapServerBaseURLStringSandbox; NSString *CONSUMER_KEY = @\"your key\"; NSString *CONSUMER_SECRET = @\"your secret\"; [EvernoteSession setSharedSessionHost:EVERNOTE_HOST consumerKey:CONSUMER_KEY consumerSecret:CONSUMER_SECRET];&#125;@end 在swift中调用 创建工程名-Bridging-Header.h引入框架库 1#import &lt;EvernoteSDK/EvernoteSDK.h&gt; 在main.swift 调用 12345import Foundationlet EVERNOTE_HOST = BootstrapServerBaseURLStringSandboxlet CONSUMER_KEY = \"\"let CONSUMER_SECRET = \"\"EvernoteSession.setSharedSessionHost(EVERNOTE_HOST, consumerKey: CONSUMER_KEY, consumerSecret: CONSUMER_SECRET)","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"config配置个人文档库专栏","slug":"hexo/config配置个人文档库专栏","date":"2018-10-20T13:54:16.000Z","updated":"2018-10-20T13:54:16.000Z","comments":true,"path":"2018/10/20/hexo/config配置个人文档库专栏/","link":"","permalink":"https://huos3203.github.io/2018/10/20/hexo/config配置个人文档库专栏/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-blogDocs-978ed39\", \"huos3203\", \"blogDocs\", \"978ed39\", false); 忽略配置文档库主要整理kindle读书笔记，jazzy文档相关html页面，放在hexo中不需要经过md转换html过程。故需要通过hexo的skip_render配置机制，来屏蔽一些目录/文件等。1skip_render: [&quot;*.html&quot;,&quot;docs/*/*&quot;] 这样，在hexo g过程，跳过这些文件，目录的编辑过程，直接拷贝到public中发布。skip_render参考 docs配置 位置考虑docs放在在source目录下，目录结构：1234567├── souce ├── _post //博客 ├── tags //标签 ├── categories //分类 ├── docs //文档库 ├── index.md └── kindle笔记 其他配置可以按照tag,categories相关配置，显示在网页中。 版本控制考虑docs文档库的容量递增，选择git submodule来管理docs文档库，集成到hexo主库中。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"安装ruby及chruby版本管理","slug":"shell/安装ruby及chruby版本管理","date":"2018-10-19T15:58:23.000Z","updated":"2018-10-19T16:16:34.000Z","comments":true,"path":"2018/10/19/shell/安装ruby及chruby版本管理/","link":"","permalink":"https://huos3203.github.io/2018/10/19/shell/安装ruby及chruby版本管理/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-postmodern-ruby-install-ea2b8bb\", \"postmodern\", \"ruby-install\", \"ea2b8bb\", false); 安装工具ruby-install1$ brew install ruby-install 安装指定 Ruby 版本方式一：使用Homebrew安装12$ ruby-install ruby 2.4.1$ ruby-install --system ruby #覆盖系统版本 但Mac最新系统安装Xcode时已经没有Command Line工具，需要单独安装。安装命令行：xcode-select --install 安装chruby管理工具1$ brew install chruby 管理ruby版本 预览安装的版本 1234$ chruby ruby-1.9.3-p392 jruby-1.7.0 rubinius-2.0.0-rc1 切换为使用版本 12345$ chruby 1.9.3 #切换操作$ chruby* ruby-1.9.3-p392 #当前使用的版本 jruby-1.7.0 rubinius-2.0.0-rc1 智能切换支持让chruby在cd不同项目目录时，自动切换Ruby的当前版本，load auto.sh in ~/.bashrc or ~/.zshrc: 12source /usr/local/share/chruby/chruby.shsource /usr/local/share/chruby/auto.sh OSX does not automatically execute ~/.bashrc, instead try adding to /etc/bashrc. 设置默认的ruby通过设置启动项来设置默认的ruby版本，在 ~/.bash_profile or ~/.zprofile设置:1chruby ruby-1.9 如果终端已经设置自启动项切换 chruby.sh and/or auto.sh , 只需要在~/目录新建.ruby-version:1echo &quot;ruby-1.9&quot; &gt; ~/.ruby-version","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"用Hexo做个人Wiki知识管理系统","slug":"hexo/用Hexo做个人Wiki知识管理系统","date":"2018-10-18T20:51:48.000Z","updated":"2018-10-18T20:57:50.000Z","comments":true,"path":"2018/10/19/hexo/用Hexo做个人Wiki知识管理系统/","link":"","permalink":"https://huos3203.github.io/2018/10/19/hexo/用Hexo做个人Wiki知识管理系统/","excerpt":"","text":"起始知识是自己构建出来的，不是别人灌输的，也不是看了各种资料背住就完了。所谓构建，是指接受信息输入之后，通过信息整理加工，消化转变为自己理解的内容，并分类记录在脑部对应类别的不同层次区域。 就像一个帝国的建立和发展过程，不断的累积资本，转化为力量。通过知识加工这个二次学习的过程，能让我们更加牢固的记住关键知识和产生更加深入的理解。 一直希望寻找一种相对优雅、我比较喜欢的方式来做知识管理，帮助知识积累构建；经过尝试了手写笔记本、OneNote 、 Evernote 、为知笔记等之后，最终选择用 个人 Wiki 系统 来做自己的知识管理。然而天下 Wiki 千千万，选择困难症患者到底该选哪一种呢？ 我试了时下好几个流行的、推荐者比较多的 Wiki 系统，但是多少都有些小细节让我不是很满意。在我的 Wiki 首页 可以看到我对知识管理和这几个 Wiki 系统的一些简单的看法，以及为此自己开坑了个 Wiki 的轮子。 轮子先放上上我经过了这些使用之后，整理出自己对 个人 Wiki 系统的需求： 界面简洁，排版整齐，有些留白，不要太满 （要求很宽泛） 部署简单，不需要后台与数据库 （最好静态页面） 支持多级分类 （满足知识的分类性） 分类目录可展开和收缩 展开分类时可直接看到该分类下所有条目 支持全文搜索 使用 Markdown 书写 适合单人的修改与更新内容 最好支持查看历史版本嗯，所以以上这些也是我自己 Wiki 系统的特性了吧~~ 借用 Hexo 博客系统的框架，仿照 Wikitten 的样式，写了一个针对于个人 Wiki 的主题 hexo-theme-Wikitten。先放上两个链接：我的个人 Wiki 地址：https://wiki.zthxxx.me/Wikitten 主题地址：https://github.com/zthxxx/hexo-theme-Wikitten再放一个预览的截图：嘛，样式是跟 victorstanciu 的 Wikitten 一样的（人家有 MIT LICENSE 的，并且我提到时也都有注明出处），之所以选择 Wikitten ，是因为我觉得这个 Wiki 系统最接近我自己对个人 Wiki 的需求，并且样式也很简洁。不过相比起来，代码就完全不一样了；人家是 PHP ，我这是 Hexo 的主题，不需要后台，可以直接挂在 Github Pages 上，省去了服务器；原本只支持搜索标题的，我也给改到支持全文搜索了。转","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"同步印象笔记到hexo博客","slug":"hexo/同步印象笔记到hexo博客","date":"2018-10-18T20:25:49.000Z","updated":"2018-10-19T16:16:34.000Z","comments":true,"path":"2018/10/19/hexo/同步印象笔记到hexo博客/","link":"","permalink":"https://huos3203.github.io/2018/10/19/hexo/同步印象笔记到hexo博客/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-everblogjs-everblog-adaptor-hexo-3c081de\", \"everblogjs\", \"everblog-adaptor-hexo\", \"3c081de\", false); loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-everblogjs-everblog-b1832a6\", \"everblogjs\", \"everblog\", \"b1832a6\", false); Everblog ——使用 Evernote 写博客印象笔记+hexo搭建自己的个人博客申请印象笔记token邮件申请：123欢迎使用印象笔记开发者Token功能，麻烦你回复这封邮件，在收到你的确认邮件后，我们会为你开启开发者Token权限，谢谢。注：回复邮件的邮箱需要和帐户的注册邮箱地址保持一致，如果当前地址不是帐户注册邮箱，建议使用帐户注册邮箱直接发送邮件到 online-help@yinxiang.com ，并说明需要开启Token即可。 使用 Hexo 主题图文步骤如下：在印象笔记操作创建 _config.yml创建一些笔记在hexo中执行运行 DEBUG=* everblog start 构建并打开构建成功后的主页使用 Hexo 主题完整步骤如下：123456789$ npm i hexo-cli -g # 全局安装 hexo-cli$ hexo init myblog # 初始化一个 hexo 项目$ cd myblog &amp;&amp; npm i # 安装依赖$ npm i everblog -g # 全局安装 everblog$ npm i everblog-adaptor-hexo --save # 在当前 hexo 项目下安装 adaptor$ echo &quot;module.exports = require(&apos;everblog-adaptor-hexo&apos;)&quot; &gt; index.js # 在当前 hexo 项目下创建 index.js ，引入 adaptor$ DEBUG=* everblog build # 使用 everblog 构建 hexo 所需文件$ hexo server # 启动 hexo$ open http://localhost:4000/ # 浏览器打开博客主页 需要安装node8+详见issue-371806541","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"如何选择人生第一辆车型","slug":"旅行/如何选择人生第一辆车型","date":"2018-10-17T21:02:56.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2018/10/18/旅行/如何选择人生第一辆车型/","link":"","permalink":"https://huos3203.github.io/2018/10/18/旅行/如何选择人生第一辆车型/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); var ap = new APlayer({ element: document.getElementById(\"aplayer-JZNJGgyK\"), narrow: false, autoplay: false, showlrc: false, music: { title: \".png\", author: \"autoplay\", url: \"width:70%\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 掌握状况图解法找出相似案例找出差异图分析总结检讨对策图解法分解要素找出相关性图检讨对策总结","categories":[{"name":"旅行","slug":"旅行","permalink":"https://huos3203.github.io/categories/旅行/"}],"tags":[]},{"title":"在我的插件中配置多种类型菜单的步骤","slug":"个人项目/在我的插件中配置多种类型菜单的步骤","date":"2018-10-17T21:01:49.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/10/18/个人项目/在我的插件中配置多种类型菜单的步骤/","link":"","permalink":"https://huos3203.github.io/2018/10/18/个人项目/在我的插件中配置多种类型菜单的步骤/","excerpt":"欢迎光顾，输入码阅读","text":"欢迎光顾，输入码阅读 Incorrect Password! No content to display! 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","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"xcode调试中引用python脚本","slug":"调试/xcode调试中引用python脚本","date":"2018-10-17T19:47:15.000Z","updated":"2018-10-17T19:47:48.000Z","comments":true,"path":"2018/10/18/调试/xcode调试中引用python脚本/","link":"","permalink":"https://huos3203.github.io/2018/10/18/调试/xcode调试中引用python脚本/","excerpt":"","text":"Xcode集成了LLDB，进一步简化了程序调试流程。虽然LLDB很强大，但是它的命令很有限。所幸的是，lldb包含了对python的支持，使得lldb的拓展成为可能。本人在开发过程中很喜欢使用image lookup 命令，但是苦于每次只能执行一条，相当耗时，因此一直想要找到一种批量执行的方法 问题批量执行image lookup -aoptparse和shlex是用于解析参数的两个重要的库。通过optparse来生成解析器 编写python脚本(layne_command.py)，代码如下：123456789101112131415161718192021222324252627282930313233343536373839#coding=utf-8 #自定义lldb命令 import lldbimport commandsimport optparseimport shlex#批量执行`image lookup`命令的函数，也是自定义的新的lldb命令的名称def layne_imagelookup(debugger, command, result, internal_dict): target = debugger.GetSelectedTarget() process = target.GetProcess() thread = process.GetSelectedThread() command_args = shlex.split(command) parser = create_custom_parser() try: (options, args) = parser.parse_args(command_args) except: result.SetError (\"option parsing failed\") return if args: for address in args: print(\"*************************************\") debugger.HandleCommand('image lookup -a %s'%(address))def create_custom_parser(): usage = \"usage: %prog [options]\" description = '''Parse Symbols to Human-readable Format.''' #生成解析器 parser = optparse.OptionParser(description=description, prog='print_frame',usage=usage) # parser.add_option('-p','--parse',type='string',dest = 'parse',help='parse symbols.'); return parser#运行脚本入口def __lldb_init_module(debugger, internal_dict): debugger.HandleCommand('command script add -f layne_command.layne_imagelookup layne_imagelookup') print('The \"layne_imagelookup\" python command has been installed and is ready for use.') 然后保存为文件layne_command.py,放到如下目录(自己指定)：~/Python/lldb/layne_command.py说明:①#coding=utf-8指定python脚本编码，否则运行时注释中的中文将会报错。②运行脚本时入口为__lldb_init_module(debugger,internal_dict) 。debugger.HandleCommand是python中执行lldb命令的主要方式。③layne_imagelookup是批量执行image lookup命令的函数，也是自定义的新的lldb命令的名称。④optparse和shlex是用于解析参数的两个重要的库。通过optparse来生成解析器。","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/tags/调试/"},{"name":"python","slug":"python","permalink":"https://huos3203.github.io/tags/python/"}]},{"title":"CommandLineTool使用pod依赖库开发","slug":"macOS/CommandLineTool使用pod依赖库开发","date":"2018-10-16T17:08:15.000Z","updated":"2018-10-16T17:08:15.000Z","comments":true,"path":"2018/10/17/macOS/CommandLineTool使用pod依赖库开发/","link":"","permalink":"https://huos3203.github.io/2018/10/17/macOS/CommandLineTool使用pod依赖库开发/","excerpt":"","text":"问题#37071dyld: Library not loaded: @rpath/FilesProvider.framework/Versions/A/FilesProvider 结论：cocoa pods不支持Command Line Tool项目 Cocoapods + Command Line Tool - dyld: Library not loaded: @rpath/Realm.framework/Versions/A/Realmcocoa pods不支持Command Line Tool项目Command Line Tool + CocoaPods frameworks breaks 采用SPM来管理依赖库 使用SPM创建可执行模版 12$ mkdir SPMCmdLineTool$ swift package init --type=executable 配置Package.swift 1234567891011121314151617import PackageDescriptionlet package = Package( name: \"SPMCmdLineTool\", dependencies: [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \"1.0.0\"), .package(path: \"/Users/admin/hsg/FileProvider\") ], .target( name: \"SPMCmdLineTool\", dependencies: [\"FilesProvider\"]), .testTarget( name: \"SPMCmdLineToolTests\", dependencies: [\"SPMCmdLineTool\"]), ]) 使用workspace管理先生成一个Xcode工程文件：SPMCmdLineTool.xcodeproj 1$ swift package generate-xcodeproj 再把SPMCmdLineTool.xcodeproj拖入现有的workspace中来管理。 每次执行swift build ，须重新生成xcodeproj工程文件，再重新打开workspace即可。 命令行的单元测试赏析123456789101112131415161718192021222324252627282930313233343536373839404142434445final class SPMCmdLineToolTests: XCTestCase &#123; func testExample() throws &#123; // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct // results. // Some of the APIs that we use below are available in macOS 10.13 and above. guard #available(macOS 10.13, *) else &#123; return &#125; // 运行可执行文件 let fooBinary = productsDirectory.appendingPathComponent(\"SPMCmdLineTool\") let process = Process() // 指定可执行文件 process.executableURL = fooBinary let pipe = Pipe() process.standardOutput = pipe //开始运行 try process.run() process.waitUntilExit() let data = pipe.fileHandleForReading.readDataToEndOfFile() let output = String(data: data, encoding: .utf8) XCTAssertEqual(output, \"Hello, world!\\n\") &#125; /// Returns path to the built products directory. var productsDirectory: URL &#123; #if os(macOS) for bundle in Bundle.allBundles where bundle.bundlePath.hasSuffix(\".xctest\") &#123; return bundle.bundleURL.deletingLastPathComponent() &#125; fatalError(\"couldn't find the products directory\") #else return Bundle.main.bundleURL #endif &#125; static var allTests = [ (\"testExample\", testExample), ]&#125;","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"swift调用pngquant批量压缩图片","slug":"macOS/swift调用pngquant批量压缩图片","date":"2018-10-15T20:51:45.000Z","updated":"2018-10-15T20:51:45.000Z","comments":true,"path":"2018/10/16/macOS/swift调用pngquant批量压缩图片/","link":"","permalink":"https://huos3203.github.io/2018/10/16/macOS/swift调用pngquant批量压缩图片/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-amosavian-FileProvider-b597244\", \"amosavian\", \"FileProvider\", \"b597244\", false); 安装FilesProvider使用FilesProvider来做文件处理，通过SPM管理库依赖 配置Package.swift 123456789dependencies: [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \"1.0.0\"), 指定版本。giturl .package(path: \"/Users/admin/hsg/FileProvider\") //源码clone本地，指定路径], .target( name: \"SPMCmdLineTool\", dependencies: [\"FilesProvider\"]),] swift build 单元测试 FilesProvider异步处理：需要XCTestExpectation辅助测试 FilesProvider在处理文件（拷贝/重命名/删除）时，不能使用绝对路径，应采用文件相对于documentsProvider.baseURL的相对路径。否则，在当给定的路径包含root目录时，例如/Users/nam/file.png会提示失败。 在swift调用shell时，目前只能使用Process.launchedProcess类方法执行shell脚本命令。 有可能在单元测试环境，导致其他两种调用shell的失败。 测通可运行的代码片段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import FilesProvidervar documentsProvider:LocalFileProvider!var pngexpectation: XCTestExpectation! = niloverride func setUp() &#123; // Put setup code here. This method is called before the invocation of each test method in the class. documentsProvider = LocalFileProvider(for: .userDirectory, in: .allDomainsMask) pngexpectation = self.expectation(description: \"BLDownloadImageNotification\")&#125;func testExample() &#123; // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. //创建文件夹 documentsProvider.create(folder: \"testPng\", at: \"admin/hsg/\") &#123; (err) in print(\"新建目录成功\") //拷贝图片到目录 self.documentsProvider.contentsOfDirectory(path: \"admin/Desktop\", completionHandler: &#123; (contents, error) in for file in contents &#123; let png = file.path.hasSuffix(\"png\") if png&#123; print(\"文件路径:\\(file.path)\") let thePath:NSString = file.path as NSString let toFile = \"admin/hsg/testPng/\\(thePath.lastPathComponent)\" self.documentsProvider.copyItem(path: file.path, to: toFile, overwrite: true, completionHandler: &#123; (err) in //调用shell工具压缩图片 self.testProcessRunShellScript(filePath: toFile) print(\"Name: \\(file.name)\") print(\"Size: \\(file.size)\") print(\"路径: \\(file.path)\") &#125;) &#125; &#125; &#125;) &#125; waitForExpectations(timeout: 40, handler: nil)&#125;//可用func testProcessRunShellScript(filePath:String) &#123; let sub = \"_temp.png\" let pngquantFile = \"/Users/\"+filePath let tmpFilePath = filePath.replacingOccurrences(of: \".png\", with: sub) let exePath = \"/Users/admin/hsg/hexo/GitSubmodules/hsgTool/pngquant/pngquant\" Process.launchedProcess(launchPath: exePath, arguments: [\"--ext\",sub,\"--speed=3\",pngquantFile]) // 删除旧文件// documentsProvider.removeItem(path: filePath) &#123; (error) in// //重命名压缩过的tmp文件// print(\"ddddddderr:\\(error?.localizedDescription)\")// self.documentsProvider.moveItem(path: tmpFilePath, to: filePath, overwrite: true, completionHandler: &#123; (error) in// self.pngexpectation.fulfill()// &#125;)// &#125;&#125;","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用swift开发自己的命令行工具","slug":"swift/使用swift开发自己的命令行工具","date":"2018-10-15T19:30:26.000Z","updated":"2018-10-15T19:54:51.000Z","comments":true,"path":"2018/10/16/swift/使用swift开发自己的命令行工具/","link":"","permalink":"https://huos3203.github.io/2018/10/16/swift/使用swift开发自己的命令行工具/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-Panagram_Final-8023350\", \"huos3203\", \"Panagram_Final\", \"8023350\", false); Command Line Programs on macOS Tutorialswift编写命令行工具 更新7/21/17:macOS教程上的命令行程序已经更新为Xcode 9和Swift 4。 前言典型的Mac用户使用图形用户界面(GUI)与计算机交互。gui，顾名思义，是基于用户通过输入设备(如鼠标)与计算机进行视觉交互，通过选择或操作屏幕元素(如菜单、按钮等)。不久前，在GUI出现之前，命令行接口(CLI)还是与计算机交互的主要方法。CLIs是基于文本的接口，用户可以在其中输入要执行的程序名，后面跟着参数。尽管gui很流行，命令行程序仍然在当今的计算世界中扮演着重要的角色。命令行程序(如ImageMagick或ffmpeg)在服务器世界中非常重要。事实上，大多数形成Internet的服务器只运行命令行程序。甚至Xcode也使用命令行程序!当Xcode构建项目时，它调用xcodebuild，它执行实际的构建。如果构建过程被嵌入到Xcode产品中，持续集成解决方案将很难实现，如果不是不可能的话! 开始对于创建命令行程序来说，Swift似乎是一个奇怪的选择，因为C、Perl、Ruby或Java等语言是更传统的选择。但是，有一些很好的理由可以根据您的命令行需求选择Swift: Swift既可以用作解释脚本语言，也可以用作编译语言。这给了您脚本语言的优势，例如零编译时间和易于维护，以及选择编译应用程序以提高执行时间或将其捆绑销售。 你不需要学习其他语言。许多人说程序员应该每年学一门新语言。这不是一个坏主意，但是如果你已经习惯了Swift和它的标准库，你可以通过坚持使用Swift来减少时间投资。 样例介绍在macOS教程中的命令行程序中，您将编写一个名为Panagram的命令行实用程序。根据传入的选项，它将检测给定输入是回文还是字谜。它可以从预定义的参数开始，或者在交互模式下运行，提示用户输入所需的值。通常，命令行程序是从嵌入在工具应用程序(比如macOS中的Terminal)中的shell中启动的。为了简单易学，在本教程中，大部分时间您将使用Xcode来启动Panagram。在本教程的最后，您将学习如何从终端启动Panagram。Open Xcode and go toFile/New/Project. Find the macOS group, select Application/Command Line Tool and click Next:For Product Name, enter Panagram. Make sure that Language is set to Swift, then click Next.In the Project Navigator area you will now see the main.swift file that was created by the Xcode Command Line Tool template.Many C-like languages have a main function that serves as the entry point — i.e. the code that the operating system will call when the program is executed. This means the program execution starts with the first line of this function. Swift doesn’t have a main function; instead, it has a main file.When you run your project, the first line inside the main file that isn’t a method or class declaration is the first one to be executed. It’s a good idea to keep your main.swift file as clean as possible and put all your classes and structs in their own files. This keeps things streamlined and helps you to understand the main execution path. The Output StreamCommand-Line ArgumentsAnagrams and PalindromesHandle Input InteractivelyXcode中测试Launching Outside XcodeNormally, a command-line program is launched from a shell utility like Terminal (vs. launching it from an IDE like Xcode). The following section walks you through launching your app in Terminal.There are different ways to launch your program via Terminal. You could find the compiled binary using the Finder and start it directly via Terminal. Or, you could be lazy and tell Xcode to do this for you. First, you’ll learn the lazy way. Launch your app in Terminal from XcodeCreate a new scheme that will open Terminal and launch Panagram in the Terminal window. Click on the scheme named Panagram in the toolbar and select New Scheme: Name the new scheme Panagram on Terminal: Ensure the Panagram on Terminal scheme is selected as the active scheme. Click the scheme and select Edit Scheme… in the popover.Ensure that the Info tab is selected and then click on the Executable drop down and select Other. Now, find the Terminal.app in your Applications/Utilities folder and click Choose. Now that Terminal is your executable, uncheck Debug executable.Your Panagram on Terminal scheme’s Info tab should look like this: Note: The downside is that you can’t debug your app in Xcode this way because now the executable that Xcode launches during a run is Terminal and not Panagram. Next, select the Arguments tab, then add one new argument:${BUILT_PRODUCTS_DIR}/${FULL_PRODUCT_NAME}Finally, click Close.Now, make sure you have the scheme Panagram on Terminal selected, then build and run your project. Xcode will open Terminal and pass through the path to your program. Terminal will then launch your program as you’d expect. 终端启动命令行APPOpen Terminal from your Applications/Utilities folder.In the Project Navigator select your product under the Products group. Copy your debug folder’s Full Path from Xcode’s Utility area as shown below (do not include “Panagram”):Open a Finder window and select the Go/Go to Folder… menu item and paste the full path you copied in the previous step into the dialog’s text field:Click Go and Finder navigates to the folder containing the Panagram executable:Drag the Panagram executable from Finder to the Terminal window and drop it there. Switch to the Terminal window and hit Return on the keyboard. Terminal launches Panagram in interactive mode since no arguments were specified:","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"Swift直接调用Python函数库","slug":"swift/Swift直接调用Python函数库","date":"2018-10-15T17:22:37.000Z","updated":"2018-10-15T17:22:37.000Z","comments":true,"path":"2018/10/16/swift/Swift直接调用Python函数库/","link":"","permalink":"https://huos3203.github.io/2018/10/16/swift/Swift直接调用Python函数库/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-PerfectlySoft-Perfect-Python-63589be\", \"PerfectlySoft\", \"Perfect-Python\", \"63589be\", false); Perfect - Python本项目提供了在Swift服务器应用上直接引用Python 2.7函数库的简便方法。 本项目采用Swift Package Manager 软件包管理器编译，是Perfect 项目的一部分，但是也可以独立运行 在使用之前请准备好最新的Swift 4.1.2 工具链 Linux 编译事项首先请确保 libpython2.7-dev 已经在 Ubuntu 16.04 上正确安装： 1$ sudo apt-get install libpython2.7-dev MacOS 编译事项请确定 Xcode 9.0 以上版本已经正确安装 快速上手首先在Package.swift中增加依存关系： 1234567.package(url: \"https://github.com/PerfectlySoft/Perfect-Python.git\", from: \"3.2.0\")// 注意在编译目标段落需要追加：.target(// name: \"your project name\",dependencies: [\"PerfectPython\", \"PythonAPI\"]), 然后将下列头文件导入Swift源代码： 12import PythonAPIimport PerfectPython 请注意在任何程序调用之前，必须调用Py_Initialize()函数初始化python嵌入环境： 1Py_Initialize() 导入Python函数库模块使用 PyObj 类对象用于导入python模块。下列参考范例中，一个名为/tmp/clstest.py的脚本被动态导入到当前Swift运行环境： 1let pymod = try PyObj(path: \"/tmp\", import: \"clstest\") 访问Python变量导入模块后，您可以使用PyObj.load()函数加载任何一个变量；也可以反过来用 PyObj.save()命令保存当前变量为一个新的值。 比如，以下python脚本中有个叫做 stringVar 的字符串变量： 1stringVar = 'Hello, world' 那么要取得这个字符串的值只需要这样做： 1234if let str = pymod.load(\"stringVar\")?.value as? String &#123;print(str)// 会打印变量的字符串值 \"Hello, world!\"&#125; 此时您还可以为该变量直接写入新的字符串值： 1try pymod.save(\"stringVar\", newValue: \"Hola, 🇨🇳🇨🇦！\") 注意 目前，Perfect-Python仅支持如下Swift / Python数据类型自动转换： Python 类型 Swift 类型 备注 int Int float Double str String list [Any] 递归转换 dict [String:Any] 递归转换 比如，您可以把一个字符串 String 转换为 PyObj，通过 let pystr = &quot;Hello&quot;.python() 或者 let pystr = try PyObj(value:&quot;Hello&quot;) 完成转换。 反过来，如果要把 PyObj 类转换为Swift数据类型，比如字符串，则仍然有两种方法：let str = pystr.value as? String 和 let str = String(python: pystr)。 执行Python函数方法 PyObj.call() 用于带参数执行某个python函数。以如下python脚本为例： 12def mymul(num1, num2):return num1 * num2 Perfect-Python 可以用下列方法封装并调用以上函数，您所需要注意的仅仅是其函数名称以及参数。其中函数名称用字符串代替，而参数用一个数组表达： 1234if let res = pymod.call(\"mymul\", args: [2,3])?.value as? Int &#123;print(res)// 结果为 6&#125; Python类对象请同样使用 PyObj.load() 函数用于家在Python类对象，但是注意后面一定要紧跟一个PyObj.construct() 用于初始化类对象实例。该方法同样支持用一个任意类型的数组作为参数进行对象构造。 假设如下脚本的典型python类对象 Person，该类有两个属性姓名name 和年龄age，还有一个名为“自我介绍”的类对象方法intro(): 1234567class Person:def __init__(self, name, age):self.name = nameself.age = agedef intro(self):return 'Name: ' + self.name + ', Age: ' + str(self.age) 在Swift中初始化上述类对象的方法需要进行以下两步走： 1234if let personClass = pymod.load(\"Person\"),let person = personClass.construct([\"rocky\", 24]) &#123;// person is now the object instance&#125; 之后就可以访问类实例的属性变量和方法了，如同上文所提到的普通变量和函数调用的方法一样： 12345if let name = person.load(\"name\")?.value as? String,let age = person.load(\"age\")?.value as? Int,let intro = person.call(\"intro\", args: [])?.value as? String &#123;print(name, age, intro)&#125; 回调函数参考以下python代码，此时如果执行 x = caller(&#39;Hello&#39;, callback) 则可以将函数作为参数进行回调: 12345def callback(msg):return 'callback: ' + msgdef caller(info, func):return func(info) 在Swift中等效的代码平淡无奇，只不过将待调函数作为参数而已：: 123456if let fun = pymod.load(\"callback\"),let result = pymod.call(\"caller\", args: [\"Hello\", fun]),let v = result.value as? String &#123;print(v)// 结果是 \"callback: Hello\"&#125; 你没看错：Swift可以直接调用Python函数库","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"Swift调用AppleScript脚本和Shell脚本","slug":"swift/Swift调用AppleScript脚本和Shell脚本","date":"2018-10-15T17:22:37.000Z","updated":"2018-10-15T21:08:17.000Z","comments":true,"path":"2018/10/16/swift/Swift调用AppleScript脚本和Shell脚本/","link":"","permalink":"https://huos3203.github.io/2018/10/16/swift/Swift调用AppleScript脚本和Shell脚本/","excerpt":"","text":"当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是AppleScript作为互通的桥梁。 NSTask调用AppleScript用Process(原NStask)进行调用main.scpt脚本 swift两种方式123456789101112//方式一：let process = Process()process.launchPath = \"/usr/bin/osascript\"process.arguments = [\"~/Desktop/main.scpt\"]process.launch()//方式二let bundle = NSBundle.mainBundle()if let scriptPath = bundle.pathForResource(\"main\", ofType: \"scpt\")&#123; let paths = [scriptPath] Process.launchedProcess(launchPath: \"/usr/bin/osascript\", arguments: paths)&#125; NSAppleScript调用AppleScriptNSAppleScript语法：do shell script &quot;shell语句&quot;，必须在on run {变量名称，逗号隔开} 以end run结束的闭包里运行。调用APPleScript脚本片段样例：1234567891011121314let bundle = NSBundle.mainBundle()let videoPath = bundle.pathForResource(\"BigBuck\", ofType: \"m4v\")//https://developer.apple.com/library/mac/technotes/tn2084/_index.html//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器let myAppleScript = \"on run\\ndo shell script \\\"open -na /Applications/mpv.app \\(videoPath!)\\\"\\ntell application \\\"mpv\\\" to activate\\n end run\"print(myAppleScript)var error: NSDictionary?if let scriptObject = NSAppleScript(source: myAppleScript) &#123; if let output: NSAppleEventDescriptor = scriptObject.executeAndReturnError(&amp;error) &#123; print(output.stringValue) &#125; else if (error != nil) &#123; print(\"error: \\(error)\") &#125;&#125; oc调用AppleScriptCan you execute an Applescript script from a Swift Application AppleScript调用shell在NSAppleScript语法中调用shell语句1do shell script &quot;shell语句&quot;` 例：运行shell命令open -na /Applications/mpv.app (videoPath!)12345on run do shell script \"open -na /Applications/mpv.app (videoPath!)\" tell application \"mpv\" to activateend run 终端osascript调用AppleScript参考 语法1osascript -e 'applescript command' #单引号 打开Finder窗口1osascript -e 'tell app \"Finder\" to make new Finder window' 打开某个程序同时弹出”Hello World”提示框1osascript -e 'tell app \"applicationname\" to display dialog \"Hello World\"' 设置音量，音量大小范围（0-7）1osascript -e \"set volume number\" c语言调用shell可以用c语言的#include system函数库：include&lt;stdlib.h&gt;函数说明:system()会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命&gt;令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。返回值:123=-1:出现错误 =0:调用成功但是没有出现子进程 &gt;0:成功退出的子进程的id 如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值&gt;。如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno来确认执行成功。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"批量压缩png图片工具","slug":"其他/批量压缩png图片工具","date":"2018-10-15T15:21:53.000Z","updated":"2018-10-15T15:21:53.000Z","comments":true,"path":"2018/10/15/其他/批量压缩png图片工具/","link":"","permalink":"https://huos3203.github.io/2018/10/15/其他/批量压缩png图片工具/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); pngquant使用pngquant批量压缩png 编写批量处理脚本vi compresspng.py12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-# vim:fenc=utf-8## Copyright © 2018 admin &lt;admin@bogon&gt;## Distributed under terms of the MIT license.import os# 获取指定路径下所有指定后缀的文件# dir 指定路径# ext 指定后缀，链表&amp;不需要带点 或者不指定。例子：['xml', 'java']def GetFileFromThisRootDir(dir, ext = None): allfiles = [] needExtFilter = (ext != None) for root,dirs,files in os.walk(dir): for filespath in files: filepath = os.path.join(root, filespath) extension = os.path.splitext(filepath)[1][1:] if needExtFilter and extension == ext in ext: allfiles.append(filepath)return allfilesif __name__ == '__main__': PngquantExe=\"/Users/admin/Downloads/pngquant/pngquant\" srcDir=\".../resource/images\" imgFiles=GetFileFromThisRootDir(srcDir, 'png') suffix=\"_temp.png\" for f in imgFiles: cmd = \"\\\"\" + PngquantExe + \"\\\"\" + \" --ext \" + suffix + \" --force --speed=3 \"+ f # 更多命令https://pngquant.org os.system(cmd) # 执行压缩命令 os.remove(f) # 删除旧文件 newfile=f.replace(\".png\", suffix) os.rename(newfile, f) # 重命名压缩过的tmp文件 PngquantExe：指定pangquant程序路径srcDir：指定图集路径 运行：python compresspng.py 参考使用pngquant批量压缩png tinypnghttps://tinypng.com/developerspython 脚本批量处理","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"自动生成icon@2x@1x","slug":"其他/自动生成icon@2x@1x","date":"2018-10-15T15:21:53.000Z","updated":"2018-10-15T17:22:37.000Z","comments":true,"path":"2018/10/15/其他/自动生成icon@2x@1x/","link":"","permalink":"https://huos3203.github.io/2018/10/15/其他/自动生成icon@2x@1x/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-rickytan-RTImageAssets-cf0a641\", \"rickytan\", \"RTImageAssets\", \"cf0a641\", false); 自动生成所有所需的应用程序图标https://github.com/rickytan/RTImageAssetsiOS开发工具：自动生成@2x,@3x图片 IconMaker程序生成icon 通过原始1024X1024图片来生成各种iphone ios icon，包含Content.json IconMaker使用说明： 默认生成到当前目录: 12$ IconMaker 1024.png #默认放在当前目录$ IconMaker 1024.png ~/Desktop/icon/ #生成在指定目录icon中 生成结果自动结构如下：|—Images.xcassets/|——AppIcon.appiconset/|———Content.json|------------con-60@3x.png 拖入xcode即可","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"Zsh插件之github使用","slug":"git/Zsh插件之github使用","date":"2018-10-15T08:26:32.000Z","updated":"2018-10-15T08:26:32.000Z","comments":true,"path":"2018/10/15/git/Zsh插件之github使用/","link":"","permalink":"https://huos3203.github.io/2018/10/15/git/Zsh插件之github使用/","excerpt":"","text":"github插件This plugin supports working with GitHub from the command line. It provides a few things: Sets up the hub wrapper and completions for the git command if you have hub installed. Completion for the github Ruby gem. Convenience functions for working with repos and URLs. Functions empty_gh - Creates a new empty repo (with a README.md) and pushes it to GitHub new_gh - Initializes an existing directory as a repo and pushes it to GitHub exist_gh - Takes an existing repo and pushes it to GitHub git.io - Shortens a URL using git.io","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"Android安装BusyBox","slug":"其他/Android安装BusyBox","date":"2018-10-15T08:10:09.000Z","updated":"2018-10-15T08:26:32.000Z","comments":true,"path":"2018/10/15/其他/Android安装BusyBox/","link":"","permalink":"https://huos3203.github.io/2018/10/15/其他/Android安装BusyBox/","excerpt":"","text":"大家是否有过这样的经历，在命令行里输入adb shell，然后使用命令操作你的手机或模拟器，但是那些命令都是常见Linux命令的阉割缩水版，用起来很不爽。是否想过在Android上使用较完整的shell呢？用BusyBox吧。不论使用adb连接设备使用命令行还是在手机上直接用terminal emulator都可以。 什么是BusyBox ？BusyBox 是标准 Linux 工具的一个单个可执行实现。BusyBox 包含了一些简单的工具，例如 cat 和 echo，还包含了一些更大、更复杂的工具，例如 grep、find、mount 以及 telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。（摘自百度百科） 在Android上安装BusyBox准备： 先要把手机给Root了，具体教程这里就不提供了，网上有很多。 下载BusyBox的binary，打开这个地址 http://www.busybox.net/downloads/binaries ，选择最新版本，然后下载对应你的设备架构的版本，这里我下载了busybox-armv6l，下面将以这个文件名为示例。[Android] 为Android安装BusyBox —— 完整的bash shell","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"了解手机处理器ARM","slug":"其他/了解手机处理器ARM","date":"2018-10-15T08:04:57.000Z","updated":"2018-10-15T08:26:32.000Z","comments":true,"path":"2018/10/15/其他/了解手机处理器ARM/","link":"","permalink":"https://huos3203.github.io/2018/10/15/其他/了解手机处理器ARM/","excerpt":"","text":"Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。 Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。 iOS armv7, armv7s, arm64区别与应用32位、64位配置为什么手机多用arm？","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"Docker安装在android系统","slug":"其他/Docker安装在android系统","date":"2018-10-14T23:47:06.000Z","updated":"2018-10-15T08:26:32.000Z","comments":true,"path":"2018/10/15/其他/Docker安装在android系统/","link":"","permalink":"https://huos3203.github.io/2018/10/15/其他/Docker安装在android系统/","excerpt":"","text":"Using Docker on Android - Stack OverflowInstalling, running, using docker on armhf (ARMv7)devices","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"package_json文件配置说明","slug":"shell/package_json文件配置说明","date":"2018-10-14T23:47:05.000Z","updated":"2018-10-14T23:47:05.000Z","comments":true,"path":"2018/10/15/shell/package_json文件配置说明/","link":"","permalink":"https://huos3203.github.io/2018/10/15/shell/package_json文件配置说明/","excerpt":"","text":"npm 与 package.json 快速入门教程每个项目的根目录下一般都有一个package.json文件，定义项目所需要的各种模块，以及项目的配置信息。npm install则是根据这个配置文件，自动下载所需要的模块，也就是配置项目所需的运行和开发环境。package.json文件可以手工编写，也可以用npm init命令自动生成，除了项目名称和项目版本是必填的，其他都是选填的。 最简单的package.json1234&#123;&quot;name&quot;:&quot;aaa&quot;, //项目名称&quot;version&quot;:&quot;0.0.0&quot; //项目版本(大版本.次要版本.小版本)&#125; package是一个JSON对象，对象的每个成员就是当前项目的一项设置。 script字段script指定运行脚本命令的npm命令行缩写。123456&quot;script&quot;:&#123; &quot;start&quot;:&quot;node index.js&quot;, &quot;test&quot;:&quot;tap test/*.js&quot;&#125;//运行npm run start时，执行node index.js命令//运行npm run test时，执行tap test/*.js命令 dependencies，devDependenciesdependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围 –save参数表示将该模块写入dependencies属性，–save-dev表示将该模块写入devDependencies属性。1234567&#123; &quot;devDependencies&quot;:&#123; &quot;browserify&quot;:&quot;~13.0.0&quot;, &quot;babel-core&quot;:&quot;^6.5.0&quot; &#125;&#125;//模块名：对应的版本 对应的版本指定版本: 比如1.2.2，安装时只安装指定版本1.2.2 波浪号(tilde) + 指定版本：比如~1.2.2，表示安装不低于1.2.2的1.2.x最新版本，但是不会安装1.3.x，等于只会影响小版本的版本号。 插入号(caret) + 指定版本 : 比如^1.2.2，表示安装不低于1.2.2的1.x.x最新版本，但是不会安装2.x.x，等于不会影响大版本号。如果大版本号为0，则插入号和波浪号效果一样，不会改变次要版本号。 latest:安装最新的版本 如果一个模块不在package.json文件汇总，则可以单独安装这个模块，并使用相应的参数将其写入package.json中。12$ npm install express --save$ npm install express --save-dev 例如安装上面的express模块，–save表示将模块写入dependencies属性，–save-dev表示将模块写入devDependencies属性。 注释问题package.json就是一个json文件，json本身只是一种数据格式，而不是程序语言，一般程序语言都会支持注释，但作为数据格式，它本身并不支持注释，所以只能通过其他方式绕过了。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"opkg在小米路由器的使用","slug":"智能设备/opkg在小米路由器的使用","date":"2018-10-14T23:27:01.000Z","updated":"2018-10-14T23:47:06.000Z","comments":true,"path":"2018/10/15/智能设备/opkg在小米路由器的使用/","link":"","permalink":"https://huos3203.github.io/2018/10/15/智能设备/opkg在小米路由器的使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-openwrt-openwrt-759f111\", \"openwrt\", \"openwrt\", \"759f111\", false); openwrt.io小米路由器固件信息 ## 路由器read-only file system怎么改权限1mount -o remount,rw / 新建配置 备份初始conf 1mv /etc/opkg.conf /etc/opkg.conf.bak 开始配置vim /etc/opkg.conf 123456789101112131415src/gz attitude_adjustment_base http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/basesrc/gz attitude_adjustment_packages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/packages/src/gz attitude_adjustment_luci http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/luci/src/gz attitude_adjustment_management http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/management/src/gz attitude_adjustment_oldpackages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/oldpackages/src/gz attitude_adjustment_routing http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/routing/src/gz openwrt_dist http://openwrt-dist.sourceforge.net/releases/ramips/packagessrc/gz openwrt_dist_luci http://openwrt-dist.sourceforge.net/releases/luci/packagesdest root /datadest ram /tmplists_dir ext /data/var/opkg-listsoption overlay_root /dataarch all 100arch ramips 200arch ramips_24kec 300 更新库 123$ opkg updateDownloading http://downloads.openwrt.org/..../generic/packages/packages/Packages.gz.Updated list of available packages in /data/var/opkg-lists/attitude_adjustment. 注：如果下载失败，请确认是否是http而非https。另外如果链接失效可能是更新了包，可以到https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/搜索libc_找到最新下载地址。 经过用上操作，opkg就可以正常使用了 opkg安装命令opkg install 软件包名:一律安装在/data/usr/bin目录中opkg upgrade 软件包名: 升级软件包opkg list-installed:查看已经安装的包opkg list-upgradable:查看可以升级的包opkg update 更新可以获取的软件包列表opkg remove 软件包名 卸载已经安装的指定的软件包opkg list 获取软件列表 安装基础包libc安装其他库的时候，经常会提示错误，缺少`libc`。这里他没办法直接安装，只能手工操作: 1$ opkg install http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/libc_0.9.33.2-1_ramips_24kec.ipk 接下来就可以安装一些自己需求的软件包:例如：安装git命令工具 1$ opkg install git 配置系统环境由于没有配置 /etc/profile,导致：运行命令时，提示no fond例如：#python no fond 12export PATH=/data/usr/bin:$PATH$ source /etc/profile //命令生效 OpenWRT基本知识整理","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"brew升级git版本","slug":"git/brew升级git版本","date":"2018-10-12T19:56:59.000Z","updated":"2018-10-12T19:56:59.000Z","comments":true,"path":"2018/10/13/git/brew升级git版本/","link":"","permalink":"https://huos3203.github.io/2018/10/13/git/brew升级git版本/","excerpt":"","text":"1234$ brew doctor$ brew install git $ brew link --overwrite gitLinking /usr/local/Cellar/git/2.19.1... 216 symlinks created","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"为Pod的库创建演示文件SwiftPlayground","slug":"macOS/为Pod的库创建演示文件SwiftPlayground","date":"2018-10-12T19:56:59.000Z","updated":"2018-10-12T19:56:59.000Z","comments":true,"path":"2018/10/13/macOS/为Pod的库创建演示文件SwiftPlayground/","link":"","permalink":"https://huos3203.github.io/2018/10/13/macOS/为Pod的库创建演示文件SwiftPlayground/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-asmallteapot-cocoapods-playgrounds-c54b492\", \"asmallteapot\", \"cocoapods-playgrounds\", \"c54b492\", false); issues 62 在playground中优雅的使用Pod This Could Be Us But You Playing Generates a Swift Playground for any Pod. Installation$ gem install cocoapods-playgrounds UsageCocoaPodsTo generate a Playground for a specific Pod:1$ pod playgrounds Alamofire To generate a Playground for a local development Pod:1$ pod playgrounds ../../../Sources/Alamofire/Alamofire.podspec To generate a Playground with multiple Pods:1$ pod playgrounds RxSwift,RxCocoa CarthageTo generate a Playground for a Carthage-enabled library:1$ carthage-play Alamofire/Alamofire Note: This currently assumes that libraries are hosted on GitHub. CLITo generate an empty Playground from the commandline:12$ playground --platform=ios YOLO$ open YOLO.playground","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"在playground中执行异步方法","slug":"swift/在playground中执行异步方法","date":"2018-10-12T19:56:59.000Z","updated":"2018-10-12T19:56:59.000Z","comments":true,"path":"2018/10/13/swift/在playground中执行异步方法/","link":"","permalink":"https://huos3203.github.io/2018/10/13/swift/在playground中执行异步方法/","excerpt":"","text":"PLAYGROUND 延时运行引入 Playground 的XCPlayground扩展包框架,其中就包括使 Playground 能延时执行的黑魔法，needsIndefiniteExecution(需要无限期执行)使 Playground 具有延时运行的功能.在实际使用和开发中，我们最经常面临的异步需求可能就是网络请求了，如果我们想要在 Playground 里验证某个 API 是否正确工作的话，使用 XCPlayground 的这个方法开启延时执行也是必要的：1234567let url = NSURL(string: \"http://httpbin.org/get\")!let getTask = URLSession.shared.dataTask(with: url as URL) &#123; (data, response, error) -&gt; Void in let dictionary = try! JSONSerialization.jsonObject(with: data!, options: []) print(dictionary)&#125;getTask.resume() 之前有30s限制，目前可以无限执行。~~可以通过 Alt + Cmd + 回车 来打开辅助编辑器。在这里你会看到控制台输出和时间轴，将右下角的 30 改成你想要的数字，就可以对延时运行的最长时间进行设定了。 ~~","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"安装Material主题","slug":"hexo/安装Material主题","date":"2018-10-12T19:33:01.000Z","updated":"2018-10-12T19:56:59.000Z","comments":true,"path":"2018/10/13/hexo/安装Material主题/","link":"","permalink":"https://huos3203.github.io/2018/10/13/hexo/安装Material主题/","excerpt":"","text":"Hexo + Material + Github 搭建博客与配置 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-viosey-hexo-theme-material-d93c5a8\", \"viosey\", \"hexo-theme-material\", \"d93c5a8\", false); 注意！ 在主题的开发迭代过程中，主题的配置文件模板 可能会改动。为了避免使用 git pull 更新主题的用户出现冲突，我们将 主题配置文件模板 命名为 _config.template.yml。配置主题时，你应该拷贝一份 _config.template.yml 并将其重命名为 _config.yml。 遇到的问题issues/688在主题文件夹下新建一个_config.yml文件，并将_config.template.yml里的配置复制到_config.yml文件。修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：123&lt;% &#125; else if(theme.comment.use.startsWith(&quot;disqus&quot;)) &#123; %&gt;// to&lt;% &#125; else if(theme.comment.use &amp;&amp; theme.comment.use.startsWith(&quot;disqus&quot;)) &#123; %&gt; 1234567891011121314151617181920212223ERROR /Users/kai/Code/hexoBlog/themes/material/layout/layout.ejs:31| 2| &lt;html style=&quot;display: none;&quot; &lt;% if(config.language !== null) &#123; %&gt;lang=&quot;&lt;%- config.language.substring(0,2) %&gt;&quot;&lt;% &#125; %&gt;&gt;3| &lt;%- partial(&apos;_partial/head&apos;) %&gt;4|5| &lt;% if(page.layout === &apos;gallery&apos;) &#123; %&gt;6|/Users/kai/Code/hexoBlog/themes/material/layout/_partial/head.ejs:2220|21|22| &lt;%- partial(&apos;_widget/dnsprefetch&apos;) %&gt;23|24| 25|/Users/kai/Code/hexoBlog/themes/material/layout/_widget/dnsprefetch.ejs:21|2| &lt;% if(theme.vendors.materialcdn) &#123; %&gt;3| 4| &lt;% &#125; %&gt;5| &lt;% if( (theme.leancloud.enable === true) || (theme.comment.use == &quot;valine&quot;) ) &#123; %&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"hexo作图插件","slug":"hexo/hexo作图插件","date":"2018-10-12T16:05:45.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2018/10/13/hexo/hexo作图插件/","link":"","permalink":"https://huos3203.github.io/2018/10/13/hexo/hexo作图插件/","excerpt":"","text":"12&quot;hexo-filter-flowchart&quot;: &quot;^1.0.4&quot;,&quot;hexo-filter-sequence&quot;: &quot;^1.0.3&quot;, 1234567891011121314#作图插件sequence:# webfont: https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js# snap: https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js# underscore: https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js# sequence: https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js# css: # optional, the url for css, such as hand drawn themeoptions:theme: simplecss_class:flowchart:# raphael: # optional, the source url of raphael.js# flowchart: # optional, the source url of flowchart.jsoptions: # options used for `drawSVG`","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"博客生成restful风格的json数据源","slug":"hexo/博客生成restful风格的json数据源","date":"2018-10-12T15:36:18.000Z","updated":"2018-10-12T15:36:18.000Z","comments":true,"path":"2018/10/12/hexo/博客生成restful风格的json数据源/","link":"","permalink":"https://huos3203.github.io/2018/10/12/hexo/博客生成restful风格的json数据源/","excerpt":"","text":"hexo-generator-restful1234567891011121314151617181920212223## API接口：以下为默认配置，属性值为 false 表示不生成。restful: #http://npm.taobao.org/package/hexo-generator-restful# site 可配置为数组选择性生成某些属性# site: [&apos;title&apos;, &apos;subtitle&apos;, &apos;description&apos;, &apos;author&apos;, &apos;since&apos;, email&apos;, &apos;favicon&apos;, &apos;avatar&apos;]site: false # hexo.config mix theme.configposts_size: 10 # 文章列表分页，0 表示不分页posts_props: # 文章列表项的需要生成的属性title: falseslug: falsedate: falseupdated: falsecomments: falsepath: falseexcerpt: falsecover: false # 封面图，取文章第一张图片content: falsekeywords: falsecategories: falsetags: falsecategories: false # 分类数据tags: false # 标签数据post: false # 文章数据pages: false # 额外的 Hexo 页面数据, 如 About","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"git-lfs命令工具使用","slug":"git/git-lfs命令工具使用","date":"2018-10-11T17:58:15.000Z","updated":"2018-10-11T17:58:15.000Z","comments":true,"path":"2018/10/12/git/git-lfs命令工具使用/","link":"","permalink":"https://huos3203.github.io/2018/10/12/git/git-lfs命令工具使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-git-lfs-git-lfs-45c4568\", \"git-lfs\", \"git-lfs\", \"45c4568\", false); git-lfs官网LFS其实是git的一个扩展，并没有改变git的工作方式，有点像耍了个小花招，把指定需要lfs管理的文件替换成了一个指针文件交给git进行版本管理；在pull/push等这些操作中，lfs又通过lfs服务器把这些文件的真身给下载或上传回来；通过这样的手段，使得本地仓库的体积大大减小，而不会出现随着这些文件的版本增多而体积剧烈膨胀的情况；个人觉得这种把存储负担转移给了服务器的做法，是不是有违git去中心化的理念，毕竟lfs这样做其实算是强依赖于这个lfs服务器了，本地仓库并不是一个完整的仓库 安装1brew install git-lfs 配置git库支持git-lfs Git命令行扩展工具git-lfs,您只需设置一次Git LFS。1234#设置库支持git lfs install#删除库支持git lfs uninstall 当使用gitee时，push远程库：WARNING: Authentication error: Authentication required: not a enterprise project 配置.gitattribute文件，添加需要Git LFS管理的文件类型。也可track命令添加其他类型123456# 添加git lfs track &quot;*.psd&quot;# 查看规则git lfs track# 查看跟踪的文件清单git lfs ls-files 确保跟踪.gitattributes 1git add .gitattributes 像往常一样提交并推送到GitHub。 123git add file.psdgit commit -m &quot;Add design file&quot;git push origin master","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"gist命令工具使用","slug":"git/gist命令工具使用","date":"2018-10-11T17:17:52.000Z","updated":"2018-10-11T17:58:15.000Z","comments":true,"path":"2018/10/12/git/gist命令工具使用/","link":"","permalink":"https://huos3203.github.io/2018/10/12/git/gist命令工具使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-defunkt-gist-8d86604\", \"defunkt\", \"gist\", \"8d86604\", false); 按照gist 安装gist1brew install gist 创建gist上传a.rb中的代码段：1gist a.rb 上传多个文件a.rb,b.rb,c.rb的代码段:12gist a b cgist *.rb 作为文件上传：获取STDIN数据，并使用-f指定文件名test.rb上传：1gist -f test.rb &lt;a.rb 直接从剪切板上传文本:1gist -P 设置隐私片段 -p:1gist -p a.rb 添加片段描述信息-d:1gist -d &quot;Random rbx bug&quot; a.rb 更新现有的片段 -u:123gist -u GIST_ID FILE_NAME例子：gist -u 42f2c239d2eb57299408 test.txt ‌If you’d like to copy the resulting URL to your clipboard, use -c.1gist -c &lt;a.rb ‌If you’d like to copy the resulting embeddable URL to your clipboard, use -e.1gist -e &lt;a.rb 打开浏览器访问片段 -o.1gist -o &lt;a.rb ‌To list (public gists or all gists for authed user) gists for usergist -l : all gists for authed usergist -l defunkt : list defunkt’s public gistsTo read a gist and print it to STDOUT1234gist -r GIST_ID例子：gist -r 374130` ‌See gist --help for more detail. 使用gist命令使用gistit快捷工具 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-jrbasso-gistit-99fc659\", \"jrbasso\", \"gistit\", \"99fc659\", false); 安装 1brew install gistit 使用说明 1234567891011121314151617181920212223242526# Creating a public gist from other app responsels | gistit# Creating a private gist from other app responsels | gistit -priv# Specifying the gist filenamels | gistit -i list.txt# Sending filesgistit file.txt# Sending multiple files in a private gistgistit -priv file1.txt file2.c# Setting gist descriptiongistit -d &quot;This is just a sample&quot; sample.txt# Setting gist description, private and with multiple filesgistit -d &quot;Sample&quot; -priv file1.txt file2.txt file3.txt# Helpgistit -h# Versiongistit -v","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"subtree拆分大的git库到多个独立git库","slug":"git/subtree拆分大的git库到多个独立git库","date":"2018-10-09T12:07:55.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2018/10/09/git/subtree拆分大的git库到多个独立git库/","link":"","permalink":"https://huos3203.github.io/2018/10/09/git/subtree拆分大的git库到多个独立git库/","excerpt":"","text":"Git 仓库拆拆拆 拆分一个子目录为独立仓库1234567891011121314# 这就是那个大仓库 big-project$ git clone git@github.com:tom/big-project.git$ cd big-project# 把所有 `codes-eiyo` 目录下的相关提交整理为一个新的分支 eiyo$ git subtree split -P codes-eiyo -b eiyo# 另建一个新目录并初始化为 git 仓库$ mkdir ../eiyo$ cd ../eiyo$ git init# 拉取旧仓库的 eiyo 分支到当前的 master 分支$ git pull ../big-project eiyo 清除一个子目录下所有内容和记录这个还是要用万能的 filter-branch：1234567891011121314# 还是那个大仓库 big-project$ git clone git@github.com:tom/big-project.git$ cd big-project# 清理 `master` 分支上所有跟 `codes-eiyo` 目录有关的痕迹$ git filter-branch --index-filter \"git rm -rf --cached --ignore-unmatch codes-eiyo\" --prune-empty master# 另建一个新目录并初始化为 git 仓库$ mkdir ../big-project-fresh$ cd ../big-project-fresh$ git init# 拉取 `big-project` 的 `master` 分支（到新仓库的 master 分支）$ git pull ../big-project master 推送给新的远端仓库12$ git remote add origin git://github.com:tom/fresh-project.git$ git push origin -u master git subtree 合并git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。 创建合并subtree add命令命令如下:12&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt; 两步走先fetch库再subtree add合并 先将依赖库fetch到本地仓库中 1234// 创建lib的远程版本库: git init --bare lib-rep#-f：远端库添加后立即执行fetch操作git remote add -f librepo ../lib-rep 通过git subtree命令将依赖库合并到主项目中 1git subtree add -P lib librepo master squash合并法--squash: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。1git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master subtree其他命令git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:1234'git subtree' pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;'git subtree' push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;'git subtree' merge -P &lt;prefix&gt; &lt;commit&gt;'git subtree' split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;] 从子树库中拉取最新代码:1git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master 将自己的代码发布到子树库:1git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master 相关参数：123456-q | --quiet-d | --debug-P &lt;prefix&gt; | --prefix=&lt;prefix&gt; 引用库对应的本地目录-m &lt;message&gt; | --message=&lt;message&gt; 适用于add/pull/merge子命令。设置产生的合并提交的说明文本--squash 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246 split子命令选项：12345--annotate=&lt;annotation&gt; 创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。-b &lt;branch&gt; | --branch=&lt;branch&gt; 创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。--onto=&lt;onto&gt;--rejoin--ignore-joins 使用sourcetree管理 配置 subtree菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)在左边栏的SUBTREES(子树)中显示： 拉取依赖库的最新代码在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：第二步的功能代码如下:1git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"zsh插件之gi使用说明","slug":"git/zsh插件之gi使用说明","date":"2018-10-09T12:04:55.000Z","updated":"2018-10-15T08:26:32.000Z","comments":true,"path":"2018/10/09/git/zsh插件之gi使用说明/","link":"","permalink":"https://huos3203.github.io/2018/10/09/git/zsh插件之gi使用说明/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-joeblau-gitignore.io-a09921d\", \"joeblau\", \"gitignore.io\", \"a09921d\", false); 配置zsh支持插件gi命令 先浏览oh-my-zsh/plugins目录下支持所有插件,找到gi命令的插件名称：gitignore,即目录名称。 把gitignore添加到zshrc.zsh-template的插件激活的清单中：12# 插件设置，如果添加太多启动速度会比较慢plugins=(git gitignore ruby autojump osx mvn) gi清单命令使用再次打开zsh窗口会激活gi命令 list命令打印出gitignore.io官网支持语种的所有模版： 1$ gi list 系统全局清单在.gitignore_global文件中添加，忽略当前操作系统中某个IDE工具的忽略清单: 1$ gi linux,eclipse &gt;&gt; ~/.gitignore_global Project项目忽略清单在.gitignore文件中添加，配置项目中使用的源码语言的相关忽略清单: 1$ gi java,python &gt;&gt; .gitignore","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"配置Podfile支持playground导入库","slug":"macOS/配置Podfile支持playground导入库","date":"2018-10-06T14:50:12.000Z","updated":"2018-10-06T14:50:12.000Z","comments":true,"path":"2018/10/06/macOS/配置Podfile支持playground导入库/","link":"","permalink":"https://huos3203.github.io/2018/10/06/macOS/配置Podfile支持playground导入库/","excerpt":"","text":"pod支持问题xcode-playground-with-cocoapodsYou could use ThisCouldBeUsButYouPlaying or add this to your Podfilexcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库 RxSwift资源案例在项目中使用RxSwift.Resources.total，提供所有Rx资源分配的计数，这对于在开发期间检测泄漏非常有用。在写入磁盘之前，修改一些工程的配置post_install hook:123456789101112131415target &apos;AppTarget&apos; do pod &apos;RxSwift&apos;endpost_install do |installer| installer.pods_project.targets.each do |target| if target.name == &apos;RxSwift&apos; target.build_configurations.each do |config| if config.name == &apos;Debug&apos; config.build_settings[&apos;OTHER_SWIFT_FLAGS&apos;] ||= [&apos;-D&apos;, &apos;TRACE_RESOURCES&apos;] end end end endend Run pod update.Build project (Product → Build). post_install 用法podfile hook语法post_install语法把玩CocoaPods post_install 和 pre_install","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用gem升级pod方法","slug":"shell/使用gem升级pod方法","date":"2018-10-06T14:50:12.000Z","updated":"2018-10-20T10:48:04.000Z","comments":true,"path":"2018/10/06/shell/使用gem升级pod方法/","link":"","permalink":"https://huos3203.github.io/2018/10/06/shell/使用gem升级pod方法/","excerpt":"","text":"升级cocopods123456sudo gem update --systemgem source -lpod setuppod repo update --verbosesudo gem install cocoapods --presudo gem cleanup gem source1234$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.com# 确保只有 gems.ruby-china.com 腾讯云：https://gems.ruby-china.com/淘宝：https://ruby.taobao.org/","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"设置环境变量的profile与bash_profile区别","slug":"shell/设置环境变量的profile与bash_profile区别","date":"2018-10-05T09:32:44.000Z","updated":"2018-10-05T21:42:35.000Z","comments":true,"path":"2018/10/05/shell/设置环境变量的profile与bash_profile区别/","link":"","permalink":"https://huos3203.github.io/2018/10/05/shell/设置环境变量的profile与bash_profile区别/","excerpt":"","text":"profile文件1.1 profile文件的作用profile(/etc/profile)，用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。当用户登录(login)时，文件会被执行。1.2 在profile中添加环境变量一般不建议在/etc/profile文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。当必须添加时，我们可以按以下方式添加：如，添加一个HOST值为linuxprobe.com的环境变量：1export HOST=linuxprobe.com 添加时，可以在行尾使用;号，也可以不使用。一个变量名可以对应多个变量值，多个变量值需要使用:进行分隔。添加环境变量后，需要重新登录才能生效，也可以使用source命令强制立即生效：1source /etc/profile 查看是否生效可以使用echo命令：12$ echo $HOSTlinuxprobe.com bashrc文件bashrc文件用于配置函数或别名。bashrc文件有两种级别：系统级的位于/etc/bashrc、用户级的位于~/.bashrc，两者分别会对所有用户和当前用户生效。bashrc文件只会对指定的shell类型起作用，bashrc只会被bash shell调用。Mac OS X上的终端bash不读取~/.bashrc，因为Mac OS X上的bash是通过login的方式运行的，而man bash中写着，通过login方式登录的bash不会读取~/.bashrc。解决方法：把下面的代码 添加到 ~/.bash_profile中:12&lt;!-- lang: shell --&gt;source ~/.bashrc bash_profile文件bash_profile只对单一用户有效，文件存储位于~/.bash_profile，该文件是一个用户级的设置，可以理解为某一个用户目录下的profile。这个文件同样也可以用于配置环境变量和启动程序，但只针对单个用户有效。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"vim一般模式下查找和替换命令","slug":"shell/vim一般模式下查找和替换命令","date":"2018-10-04T23:48:08.000Z","updated":"2018-10-04T23:48:08.000Z","comments":true,"path":"2018/10/05/shell/vim一般模式下查找和替换命令/","link":"","permalink":"https://huos3203.github.io/2018/10/05/shell/vim一般模式下查找和替换命令/","excerpt":"","text":"/,?查找命令 /word 向下查找word字符串 ?word向上查找word字符串组合查找n: 代表重复前一个查找的操作N:反向进行前一个查找操作 s/old/new/g替换命令 行间查找在第n1和n2行查找word1比替换为word21:n1,n2s/word1/word2/g 举例： ：100,200s/vbird/VBIRD/g 全文查找并替换1:1,$s/word1/word2/g 从第一行到最后一行查找字符串word1字符串，并将字符串word1替换为word2 用户确认替换提示1:1,$s/word1/word2/gc 从第一行到最后一行查找字符串word1，并将字符串word1替换为word2,在替换之前提示用户确认是否替换","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"shell脚本路径和执行的路径区别","slug":"shell/shell脚本路径和执行的路径区别","date":"2018-10-04T13:52:19.000Z","updated":"2018-10-04T13:52:19.000Z","comments":true,"path":"2018/10/04/shell/shell脚本路径和执行的路径区别/","link":"","permalink":"https://huos3203.github.io/2018/10/04/shell/shell脚本路径和执行的路径区别/","excerpt":"","text":"获取shell脚本文件的绝对路径basepath=$(cd dirname $0; pwd)echo “sh脚本文件的绝对路径：$basepath” 当前执行脚本的路径echo “当前执行脚本的路径也是cd路径打印方法:”pwdecho “当前cd的目录名：”basename $(pwd)","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"RxSwift应用登录验证","slug":"开源库/RxSwift应用登录验证","date":"2018-10-04T09:04:35.000Z","updated":"2018-10-06T14:50:13.000Z","comments":true,"path":"2018/10/04/开源库/RxSwift应用登录验证/","link":"","permalink":"https://huos3203.github.io/2018/10/04/开源库/RxSwift应用登录验证/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-SimpleValidation-fb7a58b\", \"huos3203\", \"SimpleValidation\", \"fb7a58b\", false); 使用RxSwift的优点RxSwift的目的是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用swift进行响应式编程 这是一个模拟用户登录的程序。 功能点 当用户输入用户名时，如果用户名不足 5 个字就给出红色提示语，并且无法输入密码，当用户名符合要求时才可以输入密码。 同样的当用户输入的密码不到 5 个字时也给出红色提示语。 当用户名和密码有一个不符合要求时底部的绿色按钮不可点击，只有当用户名和密码同时有效时按钮才可点击。 当点击绿色按钮后弹出一个提示框，这个提示框只是用来做演示而已。share(replay: 1)是用来做什么的？我们用 usernameValid 来控制用户名提示语是否隐藏以及密码输入框是否可用。shareReplay 就是让他们共享这一个源，而不是为他们单独创建新的源。这样可以减少不必要的开支。 第一个观察者passwordOutlet.rx_enabled订阅usernameValid时，调用map里的print函数，第二个观察者在订阅时(没有添加.shareReplay(1))时，又再次调用map里的print函数，以此类推，如果有很多观察者的话就要调用很多次，而从第二个观察者开始需要的只是map返回的一个序列，而不是让其徒劳地调用map里的函数，那么怎样解决在多个观察者订阅时多次重复调用执行的问题？使用shareReplay(bufferSize: Int)就ok了。shareReplay会返回一个新的事件序列，它监听底层序列(这里指的是map返回的序列)的事件，并且通知自己的订阅者们。不过和传统的订阅不同的是，它是通过『重播』的方式通知自己的订阅者，因此在这里通过shareReplay订阅的map并不会调用多次。// 参数bufferSize指的是重播的最大元素个数，因为usernameValid是一个只有一个元素的序列observable，因此shareReplay参数为1；假如对于一个有5个元素的序列，你只需要重复播报最后3个，那么就写成.shareReplay(3)，就酱紫。 disposed(by: disposeBag) 是用来做什么的？和我们所熟悉的对象一样，每一个绑定也是有生命周期的。并且这个绑定是可以被清除的。disposed(by: disposeBag)就是将绑定的生命周期交给 disposeBag 来管理。当 disposeBag 被释放的时候，那么里面尚未清除的绑定也就被清除了。这就相当于是在用 ARC 来管理绑定的生命周期。 这个内容会在 Disposable 章节详细介绍。 bindTO 简单使用我的理解就是将已经信号源去用一个UIBindingObserver去接受,当接收到的属性是true进行相应的操作为登录按钮写一个rx_click的拓展123456789101112131415///首先写一个UIBindingObservervar rx_click:AnyObserver&lt;Bool&gt; &#123;return UIBindingObserver.init(UIElement: self, binding: &#123; (lab, result) inlab.backgroundColor = result ? UIColor.blue:UIColor.gray&#125;).asObserver()&#125;//*bindto 信号合并处理 bindto发送信号// combineLatest(合并信号) bind(订阅)// observer -----------------------&gt;处理信号时间-------------&gt;处理信号///然后手机号11位 验证码 6位就可以用这一行代码解决let _ = Observable.combineLatest(phoneobser, passobserver, resultSelector: &#123;$0 &amp;&amp; $1&#125;).bind(to: canclik.rx_click)","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"自动初始化Gitalk和Gitment评论","slug":"hexo/自动初始化Gitalk和Gitment评论","date":"2018-10-03T16:16:25.000Z","updated":"2018-10-03T16:55:41.000Z","comments":true,"path":"2018/10/04/hexo/自动初始化Gitalk和Gitment评论/","link":"","permalink":"https://huos3203.github.io/2018/10/04/hexo/自动初始化Gitalk和Gitment评论/","excerpt":"","text":"Hexo添加Gitalk评论插件自动初始化 Gitalk 和 Gitment 评论Gitment/Gitalk自动初始化","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"Heroku部署web服务器","slug":"hexo/Heroku部署web服务器","date":"2018-10-03T12:29:51.000Z","updated":"2018-10-18T18:39:22.000Z","comments":true,"path":"2018/10/03/hexo/Heroku部署web服务器/","link":"","permalink":"https://huos3203.github.io/2018/10/03/hexo/Heroku部署web服务器/","excerpt":"","text":"安装Heroku CLI工具Mac端1brew install heroku/brew/heroku Heroku CLI 命令12heroku -hheroku login Creating Apps from the CLI 1234567$ mkdir example$ cd example$ git init$ heroku apps:create exampleCreating ⬢ example... donehttps://example.herokuapp.com/ | https://git.heroku.com/example.gitGit remote heroku added 查看现有APP信息 12heroku apps //所有应用列表heroku apps:info //查看所有应用的详细信息 在浏览器中访问APP页面 12345678910111213USAGE$ heroku apps:open [PATH]OPTIONS-a, --app=app (required) app to run command against-r, --remote=remote git remote of app to useEXAMPLES$ heroku open -a myapp# opens https://myapp.herokuapp.com$ heroku open -a myapp /foo# opens https://myapp.herokuapp.com/foo 用例：在heroku上部署gh-oauth-server服务issues:object ProgressEvent下载服务器源代码gh-oauth-server ,由于是nodejs写的所以需要安装nodejs环境 如何安装自己Google; 然后git clone 该项目并进入目录, 执行npm install 安装依赖, 依赖安装成功后执行npm start, 如果输出start on port 300表示开启成功,;为了支持ssl 可以安装nginx代理, 这个可以自己百度, 有很多教程的.12345git clone https://github.com/imsun/gh-oauth-servercd gh-oauth-serverheroku create gitment-hexo //创建herokua应用git push heroku master //会自动安装package.json依赖库。heroku open -a gitment-hexo //浏览器打开 进入heroku服务器命令行123456$heroku run bashRunning `bash` attached to terminal... up, run.3052~ $ lsProcfile README.md composer.json composer.lock vendor views web~ $ exitexit 参考Getting Started on Heroku with Node.js把已经存在的应用部署到heroku上learn how to prepare it for Heroku deployment.","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"hexo集成gitment评论系统","slug":"hexo/hexo集成gitment评论系统","date":"2018-10-03T00:54:35.000Z","updated":"2018-10-04T09:04:35.000Z","comments":true,"path":"2018/10/03/hexo/hexo集成gitment评论系统/","link":"","permalink":"https://huos3203.github.io/2018/10/03/hexo/hexo集成gitment评论系统/","excerpt":"","text":"安装gitment在package.json文件添加gitment依赖：1&quot;gitment&quot;: &quot;^0.0.3&quot; 安装1npm install 申请应用首先去New OAuth App为你的博客应用一个密钥:1234Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到. 配置下面就是配置Gitment,主要编辑在themes/next/_config.yml:123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 开通评论注意到这里基本上已经OK了,再看你的博客应该可以显示评论了.不过每篇博客都需要你手动初始化评论功能(如果你的历史博客很多那就一篇一篇去点吧，不过貌似有人写了批量处理脚本,没试过哈). 问题object ProgressEvent由于引入的 gitment.js 中有这样的一段代码：1234567891011_utils.http.post('https://gh-oauth.imsun.net', &#123; code: code, client_id: client_id, client_secret: client_secret &#125;, '').then(function (data) &#123; _this.accessToken = data.access_token; _this.update(); &#125;).catch(function (e) &#123; _this.state.user.isLoggingIn = false; alert(e);&#125;); 请求了一个服务接口，由于这个跨域服务接口是作者自己搭建的，已经停止了。有博主 fork 源作者的 repo ，在这个基础上改的，修改了一些地方接入自己通用的服务CORS-Proxy-Server.现在直接把这个文件 https://imsun.github.io/gitment/dist/gitment.browser.js 替换为 https://www.wenjunjiang.win/js/gitment.js 就可以了.原理：hexo 这个评论接了一个自己写的一个通用的跨域服务 https://cors.wenjunjiang.win/ github地址为：https://github.com/jjeejj/CORS-Proxy-Server，代替作者的 https://gh-oauth.imsun.net 这个接口地址，去请求 github的接口。 可以自己搭建，可以转发所有的前端跨域服务。要注意的是： 在向 github 请求 access_token时 需要带上Accept: application/json 或者Accept: application/xml请求头， 否则回报 406 的错误. 参考gitment评论模块接入hexohexo博客配置-添加评论系统-gitment和valine-需注册Gitment：使用 GitHub Issues 搭建评论系统","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"Instrument使用Signposts工具","slug":"调试/Instrument使用Signposts工具","date":"2018-10-02T23:19:55.000Z","updated":"2018-10-15T15:21:53.000Z","comments":true,"path":"2018/10/03/调试/Instrument使用Signposts工具/","link":"","permalink":"https://huos3203.github.io/2018/10/03/调试/Instrument使用Signposts工具/","excerpt":"","text":"引言性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。 我们知道开发更好的工具，并让开发者使用这些工具，是我们帮助您成为更高效的开发人员的方法之一。所以今天我们要谈谈其中的一个工具——Signposts（路标）。 介绍Signposts及历史Signposts是OSLog家族的新成员，我们正准备让它支持iOS和macOs。您可以在swift和C中使用它们，但最酷的是我们把它和Instruments集成在了一起。这就意味着Instruments可以获取Signposts所产生的数据，并且让深入你理解你的程序正在做什么。 首先要介绍一点历史，几年前我们介绍了OSLog。这是我们现代化的呈现日志记录的工具。这是我们从系统中获取调试信息的方法。它是在我们“效率”、“隐私”的目标下完成的。具体了解，请查看WWDC 2016 Unified Logging and Activity Tracing。 这里你可以看到一个OSLog的例子，创建一个简单的日志句柄，并且像它发送了一个Hello world。12let logHandle = OSLog(subsystem: &quot;com.example.widget&quot;, category: &quot;Setup&quot;)os_log(.info, log: logHandle, &quot;Hello, %&#123;public&#125;s!&quot;, world) Signposts扩展了OSLogAPI，但它们是为性能用例而做的。这意味着它们正在传达与性能相关的信息，并且它们与我们的开发工具集成在一起，您可以使用Signposts对代码进行标注，然后启动Instruments查看类似的内容。因此，Instruments向您展示了您的程序正在做的事情的可视化时间轴，以及Signposts展示在上面。然后底部有个表，统计汇总和分析Signposts数据，数据分成一块一块的，可以让您看到程序到底做了些什么。在文章中，我将谈谈如何在您的代码中使用Signposts，以及展示一下他们的作用。然后展示Instruments中Signposts的可视化界面，让您了解Instruments和Signpost是如何协同工作的。 使用Signposts Siginposts的两个函数:os_signpost(.begin, ...)和os_signpost(.end, ...). 日志句柄:日志句柄需要两个参数一个是子系统，一个是类别.让我们从一个非常基础的例子开始。想象一下这是你的应用。你要研究的就是一个接口特定部分刷新所需要的时间。你知道你需要加载一些图片并在屏幕上展示。所以，在这个简单、抽象的视图中，可能你需要做的就是获取图片资源。所有操作完成后，界面会刷新。Signposts允许我们在一系列工作的开始和结尾进行标记，然后将这两个时间点关联起来，同时这两个日志事件也会互相关联。这就需要调用Siginposts的两个函数。os_signpost(.begin, ...)和os_signpost(.end, ...)。图中b箭头代表开始，e箭头代表结束。然后我们将这两个时间点互相关联，让您了解这一段经过的时间。在代码中，有一个简单的算法实现，对于我们接口中的每个元素，我们将获取该资源，这正是我们想要去测量的。123for element in panel.elements &#123; fetchAsset(for: element)&#125; 因此，为了将Signposts代码加入到基本的代码中，我们需要导入import os模块，然后由于Siginposts是OSLog的一部分，所以我们需要创建一个日志句柄。这个日志句柄需要两个参数一个是子系统，一个是类别。 子系统: 在整个项目中可能都是相同的，它看起来很像您的app的包名。它代表了组件或者软件，或者是您正在使用的框架。 类别: 用于关联，将相关的操作或者Signposts绑定在一起。之后我们会讲到这么做的好处。 当我们拥有了日志句柄，我们只需要调用Siginposts的.begin和.end两个函数即可。参数中，我们将日志句柄传递过去，然后再传递一个Signpost的名字。名字是一个字符串，用来标识我们感兴趣的操作的时间间隔。123456789import os.signpostlet refreshLog = OSLog(subsystem: \"com.example.your-app\", category: \"RefreshOperations\")for element in panel.elements &#123; os_signpost(.begin, log: refreshLog, name: \"Fetch Asset\") fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \"Fetch Asset\")&#125; 所以返回之前的时间轴，它就变成了这个样子。在每次开始、结束获取资源时，我们都添加了一个路标。因为在开始和结束的路标的标识一样，所以我们可以将他们两者匹配在一起。但是，如果我们还想要测试整个操作的全部时间，整个刷新过程是怎样的，该如何去做呢？我们在代码中，只需要再添加一对新路标即可（新的名字）。1234567891011import os.signpostlet refreshLog = OSLog(subsystem: \"com.example.your-app\", category: \"RefreshOperations\")os_signpost(.begin, log: refreshLog, name: \"Refresh Panel\")for element in panel.elements &#123; os_signpost(.begin, log: refreshLog, name: \"Fetch Asset\") fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \"Fetch Asset\")&#125;os_signpost(.end, log: refreshLog, name: \"Refresh Panel\") 这时，我们的时间轴又发生了变化。 异步用例：测量异步任务的时间 Signpost IDs路标ID:区分重叠时间间隔的方法，将告诉系统哪些是相同类型的操作，但每个操作彼此不同。 上面是一个很简单的例子。如果你的应用顺序执行第一步、第二步、第三步等等，那么这样测量是非常有效的。但是我们会经常用到一些异步的工作，他们可能同时发生，他们之间也可能会有重叠或者交叉。在这种情况下，我们需要向系统提供一些额外的信息，以便系统可以将这些路标彼此区分开来。到现在为止，我们在调用方法的时候只用到了名字，通过名字将相同路标的绑定在一起。名字已经确定了时间间隔，但是没有给我们一种区分重叠时间间隔的方法，所以在这里引入了Signpost IDs。路标ID将告诉系统哪些是相同类型的操作，但每个操作彼此不同。在路标开始和结尾传递相同的id，则系统知道这两个是关联的。你可以通过日志句柄来得到一个路标ID。1234let spid = OSSignpostID(log: refreshLog)os_signpost(.begin, log: refreshLog, name: \"Fetch Asset\", signpostID: spid)// some code or even async...os_signpost(.end, log: refreshLog, name: \"Fetch Asset\", signpostID: spid) 同样你也可以通过一个对象来得到日志句柄。如果你有一些对象代表您正在尝试的工作，只要您使用该对象实例就会生成相同的路标ID。这就意味着您不用去存放路标ID，只需要通过对象去管理ID就好了。1let spid = OSSignpostID(log: refreshLog, object: element) 在视觉上，您可以将路标ID视为允许我们向每一个路标调用传递一些额外的上下文，这可以将特定操作的开始和结束标记互相关联。这很重要，因为这些操作不仅仅可以重叠，而且通常他们需要的时间也不同。我们现在把示例中的fetchAsset从同步调用改为异步调用。并且由于是异步的，这些时间间隔可能会相互重叠，所以我们还要在创建路标时加上路标ID。12345678910111213141516171819let refreshLog = OSLog(subsystem: \"com.example.your-app\", category: \"RefreshOperations\")let spidForRefresh = OSSignpostID(log: refreshLog)os_signpost(.begin, log: refreshLog, name: \"Refresh Panel\", signpostID: spidForRefresh)for element in panel.elements &#123; //通过对象去创建路标ID let spid = OSSignpostID(log: refreshLog, object: element) //通过ID去记录一个路标 os_signpost(.begin, log: refreshLog, name: \"Fetch Asset\", signpostID:spid) fetchAssetAsync(for: element) &#123; //每一个完成之后的回调 os_signpost(.end, log: refreshLog, name: \"Fetch Asset\", signpostID: spid) &#125; &#125;// 全部完成完成的回调notifyWhenDone &#123; os_signpost(.end, log: refreshLog, name: \"Refresh Panel\", signpostID: spidForRefresh)&#125; 这样就完成了，您可以将Signposts视为一种分类或等级制度。所有的操作都通过日志句柄相关联，这意味着日志分类。然后对我们感兴趣的每个操作，我们给它一个路标名字，如果可能有重叠，我们在给他们路标ID，告诉系统虽然名字相同了，但是我希望通过ID区分。 这个接口设计的特别灵活，所以你可以控制起始点和结束点的所有参数，日志句柄，路标名字及ID。只要传递的参数是一致的，起始点与结束点就可以对应上，即便他们写在了不同的方法或者文件中。我们之所以这样做是因为希望您能够将它应用到实际开发中。 在Signposts中添加元数据您可能希望在路标中传达一些额外的信息，额外的性能相关的信息。很巧，我们有一个方法来为路标添加元数据。下面是一个基本的路标。1os_signpost(.begin, log: log, name: \"Compute Physics\") 我们可以添加一个额外的字符串（OSLog格式化的）参数。这允许您向开始点与结束点添加一些上下文。我们可以通过%d来传递整数。当然也可以传递其他的格式化类型的参数。12os_signpost(.begin, log: log, name: \"Compute Physics\", \"%d %d %d %d\",x1, y1, x2, y2)os_signpost(.begin, log: log, name: \"Compute Physics\",\"%&#123;public&#125;s %.1f %.1f %.2f %.1f %.1f\", description, x1, y1, m, x2, y2) 至于字符串的长度，不用担心，您可以自由、随意的使用。该字符串也会全部渲染到Instruments的界面中，或者仍然可以在程序中访问附加的数据。 添加独立事件除了元数据之外，您可能还希望及时添加单独的时间点。这就表示，除了开始的路标以及结尾的路标外，你可能还有一个路标，该路标没有连接到特定的时间间隔，而是一些固定的时刻。为此，我们提供了一个带有事件类型的路标。用法与设置开始、结束的路标类似，只不过它标识一个单一的时间点。12os_signpost(.event, log: log, name: \"Fetch Asset\", \"Fetched first chunk, size %u\", size)os_signpost(.event, log: log, name: \"Swipe\", \"For action 0x%x\", actionCode) 您可以在间隔的上下文中使用该方法，或者一些您想追踪的与用户交互无关等时间间隔无关的内容。如果您真的在调查一个性能上的问题，您可能会大量使用它。 有条件启动Signposts 路标通常默认是开启如果你启用了一些路标，那么他们通常默认是开启的，但我想谈谈有条件的打开和关闭它们。首先我要强调一下，路标是轻量级的。这说明我们已经做了很多优化。我们通过编译器优化来完成这些工作，这些优化在编译时就做了，而不是在运行时完成的。我们还推迟了很多工作，以便他们在Instruments后端完成。这意味着路标应该占用很少的系统资源。我们之所有这样做是因为我们希望尽量减少对您代码的影响。我们也做到了这一点，因为我们确保即使您的时间跨度非常小，也可以发出许多路标来获取一些细粒度的测量结果。 关闭路标但您可能希望能够关闭路标。要做到一这点，我们将利用OSLog的功能，即禁用的日志句柄。禁用的日志句柄也是一个简单的句柄。它的作用是针对该句柄进行的每个OSLog和os_signpost调用都会几乎会变为无操作。事实上，如果你在C中采用这个，我们甚至会对你进行检查，然后我们甚至不会评估其余的参数。所以你可以在运行时更改这个句柄。 举个例子，让我们回到第一个示例的代码上。我以一个环境变量作为条件，来初始化。如果包含该变量，那么使用普通的os日志构造函数；如果不包含，那么将使用禁用的日志句柄。12345678910111213let refreshLog: OSLogif ProcessInfo.processInfo.environment.keys.contains(\"SIGNPOSTS_FOR_REFRESH\") &#123; refreshLog = OSLog(subsystem: \"com.example.your-app\", category: \"RefreshOperations\")&#125; else &#123; refreshLog = .disabled&#125;os_signpost(.begin, log: refreshLog, name: \"Refresh Panel\")for element in panel.elements &#123; os_signpost(.begin, log: refreshLog, name: \"Fetch Asset\") fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \"Fetch Asset\")&#125;os_signpost(.end, log: refreshLog, name: \"Refresh Panel\") 环境变量是您在调试程序时可以在Xcode scheme中设置的内容。现在我说你不必在调用中进行更改，但这种方式相当昂贵并且只适用于调试时。因此如果您有一些基于Instruments的特定的功能，你可以检查特定的日志句柄，查看它是否打开了siginposts enabled属性。然后试用该属性来控制添加该附加操作。123if refreshLog.signpostsEnabled &#123; let information = copyDescription() os_signpost(..., information)&#125; C语言中的Signposts上面我们所有示例都是swift的，但是C语言中也提供了路标。到目前为止，上述功能都是可用的：长句柄、使用不用的路标、以及管理路标标识符。那些对C语言中使用路标感兴趣的人，推荐你们阅读头文件中的文档。文档中包含了所有信息，都是从C语言开发人员的角度考虑的。 Instruments中使用路标现在介绍完如何在代码中应用路标，接下来很开心为大家介绍路标和Instruments是如何在一起工作的。向大家展示Instruments 10中三个重要的新功能，来帮助您使用路标数据。 路标工具:该工具允许您记录、查看和分析应用程序中所有的路标活动。 兴趣点:谈谈什么是兴趣点，以及何时您要设置一个兴趣点 自定义工具: 介绍新的自定义工具，以及如何将它与路标一起使用，以获得更精致的路标展示。路标接下来就看下例子吧。示例的app名叫开拓者，主要是展示一些风景。当我们滚动时，最初展示一个白色的背景，当图片下载完之后，会填充到白色背景区域。这是一种常见的设计，尽管这样设计可以提升一些用户体验，但很难分析它的性能，因为在这个过程中进行了很多异步的活动。如果用户快速滚动，那么有可能出现某个单元格还没有下载完毕之前，就已经要被重用了，那么就必须取消下载。如果不取消的话，可能会有几个并行下载，而展示出来的图也不一定是我们想要的（图和标题不对应）。接下来看看如何通过路标来分析这个应用吧。首先，在每个单元格中，有一个startImageDownload方法。当我们需要下载图片时会调用它，并传递要下载图片的名字。方法内部，有一个图片下载类，我们通过图片名字和设置自己为委托来初始化该类。在这种情况下，由于downloader对象代表正在进行的并发活动，因为下载是异步的，所以可以通过downloader来创建一个路标ID。接着在下载开始之前，调用os_signpost(.begin，...)方法，设置日志句柄、名称、ID、以及一些元数据。然后开始下载图片，并且将downloader设置为当前单元格正在运行的下载器。图片下载完毕的回调中将图片展示到屏幕上，然后调用os_siginpost(.end, ...方法，设置日志句柄、名称、ID、以及一些元数据。您会注意到，我们用xcode:size-in-bytes注释了这个参数。它的作用是告诉Xcode和Instruments这个参数应该被视为展示和分析字节大小。这种被称作为工程类型。可以Instruments开发人员帮助文档中找到他们的详细介绍。最后，我们下载完毕了，将下载器设置为空。当然下载除了成功以外，还有失败的情况，在单元格准备重用时，进行相关的路标设置。设置完之后，就可以来进行分析了。打开Instruments后，可以选择一个空白的文档。然后从右侧添加中选择os_signpost工具，并推动到轨迹中。接下来就可以在app中操作了，一阵操作猛如虎之后，我们回到Instruments来看一下。通过选择某一段时间，可以查看这段时间内的情况。我们可以看到左侧的路标名称Background Image，以及右侧的一些使用元数据来注释的时间段。现在再缩小然后看看其他未知的追踪，我们注意到我们最多只有五个并行下载图片的任务，这是一件好事，证明我们取消了。查看底部间隔的摘要，我们看到是按照类别、路标的名字、开始的消息和结束的消息来区分的。我们来看一共触发了93次的图片下载请求。其中location1触发了12次，7次取消，5次下载成功，下载成功时间共计3.04秒，3.31MB。并且可以查看每次请求时间的最小值、最大值和平均值。如果对某类数据感兴趣，可以点击进入查看详细内容。如果要查看元数据相关的内容，可以进行筛选，然后查看数据。这是一种很好的方式来查看您通过元数据传达的值的统计分析.兴趣点接下里，我们看看兴趣点。回到应用，我们我们在主页点击一个单元格，就会进入详情页面。如果现在我们每次都能追踪这些详情页面出现的时间就太好了，因为这样我们就可以知道用户正在做什么，并且我们知道用户在app中的哪个页面。当然可以通过路标完成这件事，但是你需要在Instruments中把它拖到轨迹中，并且记录所有的活动。这样有点淡化了导航事件的重要性。所以我们提供了兴趣点。 点在我们在详情页面的代码中查看viewDidAppear方法，我们通过os_signpost(.event, ...来创建一个路标事件。这个事件要发送到我们创建的称之为兴趣点的日志句柄中。类别设置为兴趣点，这正是Instruments寻找的一个特殊类别。我们回到再次打开Instruments选择时间分析，会发现自动有了兴趣点这一项。然后开始录制，从首页进入详情页，选择不同的单元格反复执行，然后返回Instruments，就可以看到这些兴趣点了。因此您可以在看到用户在哪个页面，并且将其与其他性能数据相关联。 自定义Instruments视频中，具体没有讲如何创建，如果想了解如何创建的话，可以参考一下WWDC 2018 Creating Custom Instruments。WWDC 2018 session 405转自使用日志记录来衡量性能","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"Xcode10新特性","slug":"xcode/Xcode10新特性","date":"2018-10-02T13:18:21.000Z","updated":"2018-10-03T16:55:41.000Z","comments":true,"path":"2018/10/02/xcode/Xcode10新特性/","link":"","permalink":"https://huos3203.github.io/2018/10/02/xcode/Xcode10新特性/","excerpt":"","text":"Xcode 10Xcode 10在macOS Mojave的黑暗模式下看起来非常棒，也让你很容易在macOS应用程序中采用新的外观。Xcode 10测试版包括Swift 4.2和beta sdk，适用于iOS 12、watchOS 5、tvOS 12和macOS Mojave。 Dark模式界面和Mac程序支持 全新的dark外观贯穿Xcode和Instruments在终端中输入命令，Xcode10开启dark mode: 1defaults write com.apple.dt.Xcode NSWindowDarkChocolate -bool true 使用低版本的macOS,使用此命令可能会造成Xcode interface损坏(测试系统 macOS High Sierra 10.13.4),只能使用macOS Mojave 10.14+才能使用暗黑模式 Asset catalogs为自定义colors assets 和 image assets 添加了深色和浅色变体，支持不同的图像与颜色assets的亮暗与高对比度表现。支持CarPlay assets.支持ARKit 3D ARReferenceObject assets.Asset目录与视图调试器(view debugger)的背景可以被明确设定成亮或暗，这样前景的元素就会明显看出来。 Interface Builder支持dark和light预览之间切换调试您的Mac应用程序在黑暗或光明的变种，而不改变OS设置Source Control 在共享服务器上的本地存储库或上游的更改直接在编辑器中突出显示。乍一看，你会发现:修改代码。 更改尚未推入共享存储库。 其他人已经做出了上游的改变。源编辑器(source editor)会显示出某个开发者做出的改变并展示其他开发者做出的还未添加到项目中的改变。 在承诺之前，你应该解决冲突。支持Atlassian Bitbucket提供的云托管和自托管Git服务器，以及与现有GitHub支持一起使用的GitLab。Xcode提供了在从存储库中提取最新版本的代码时重新设置更改的基础。如果需要，将生成SSH密钥，并将其上载到服务提供者。编辑器的改进 在代码编辑器中放置多个游标，以便同时进行许多更改。Xcode 10 Source Editor现在支持多光标编辑，允许你快速同时编辑多范围的代码。你可以通过多种方式放置额外的光标，包括鼠标点击方式⌃+⇧+Click，或通过选择列⌥+Click+Drag，或通过键盘的⌃+⇧+Up选择上一列，或⌃+⇧+Down选择下一列。 代码折叠带现在可以隐藏任何被大括号包围的代码块。 Over-scroll功能可以方便地将屏幕中间的最后几行代码居中。 库(Library)内容从Inspector区的底部移动到了一个重叠窗口中，这个窗口可以移动或调整大小，就像Spotlight search一样。在拖动物品时它会解除，但在拖动前按住Option键，它就会为一个额外的拖动保持开启。Playgrounds支持机器学习 REPL-like model 立即重新运行您现有的playground代码。 代码运行到指定的行，或键入shift-return来运行刚刚添加的代码。 importCreate ML Framework以交互式地培训新模型，然后在playground上编写代码的测试模型。完成后，将模型拖放到应用程序中。测试和调试 Debugging symbols从新设备下载的速度比以前快了五倍。 Xcode将生成一组完全相同的模拟器，以充分利用多核Mac的优势，并通过风扇测试并行运行，以更快的速度完成测试套件。 以随机或线性顺序运行测试。 Instruments工具会自动显示添加到代码中的OSLog路标。 构建并共享您自己的定制instruments package，为您自己的代码提供独特的数据可视化和分析。 Memory内存调试器使用紧凑的布局，以便更容易地研究内存图。 Metal shader调试器允许您轻松地检查顶点、片段、计算和平铺着色器代码的执行。 Metal dependency viewer可以预览在你的Metal-based应用程序中如何使用资源的详细图表。 Xcode的视图调试器添加了一个选项，可以选择亮暗canvas背景色。你可以改变你macOS应用运行时的外观，通过使用Debug &gt; View Debugging &gt; Appearance menu，或调试栏中的Override Appearance菜单，或接触栏(touch bar)检查器(inspector)中展示的已命名颜色在调试时会显示它们的名字以及它们是否为系统颜色。构建性能 默认情况下启用New build system，改进了整个系统的性能。Xcode 10使用了一个新的创建系统。新创建系统提供了更好的可靠性与创建性能，它可以获取项目配置问题，而legacy创建系统则不能。Legacy创建系统在Xcode 10中依旧可用。要想使用的话，在File &gt; Project/Workspace Settings页选择它。为legacy创建系统配置过的项目会在Activity View显示一个橘黄锤子标签 Swift编译器构建每个单独的文件要快得多。 使用incremental build setting增量构建设置时，用于调试的大型Swift项目的构建速度要快得多。《WWDC》Xcode 10也有暗黑模式，現在整合GitLab程式碼託管服務Xcode10新功能新内容（Beta版下载链接）","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[]},{"title":"SPM搭建Perfect模版服务器","slug":"macOS/SPM搭建Perfect模版服务器","date":"2018-10-02T11:13:35.000Z","updated":"2018-10-22T18:39:30.000Z","comments":true,"path":"2018/10/02/macOS/SPM搭建Perfect模版服务器/","link":"","permalink":"https://huos3203.github.io/2018/10/02/macOS/SPM搭建Perfect模版服务器/","excerpt":"","text":"Perfect简介 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-PerfectlySoft-Perfect-60e44e4\", \"PerfectlySoft\", \"Perfect\", \"60e44e4\", false); 目前比较流行服务端框架主要有Vapor、Perfect、Kitura和Zewo，他们各有长短，本人这次主要是使用Perfect来写的，因为Perfect的功能比较完善，在GitHub上具有1W+的星，而且有一个非常重要的原因提供了Perfect 中文文档。 Perfect 包括了您所期待的所有基本功能，包括路由、websockets 基于 HTTP 的网络套接字、TLS（SSL）通信加密、Mustache 模板和 Markdown 模板、JSON 结构化数据等等，以及全部其他所有 Swift 后台框架加在一起才有的 XML 结构化数据、苹果推送消息 APNS、MqTT 消息队列和 SMTP 邮件发送，甚至大数据也支持。Perfect 的数据库支持非常广泛，其原生SQL驱动包括 MySQL、SQLite、PostgreSQL 和 MariaDB，还支持 MongoDB、Redis、CouchDB 甚至还包括 FileMaker（苹果自己的数据库 Swift 都不支持，Perfect 反过来支持——译者注）。Perfect 据说还部分支持微软的 ODBC，即多种数据库的底层兼容界面——有点像 ORM，但是以 C 函数库为基础。提到 ORM 数据库对象关系自动化管理，Perfect有 StORM 并完整实现了 PostgreSQL、MySQL、CouchDB 和 SQLite。 Perfect文档生成器 搭建HTTP服务器 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-PerfectTemplate-20294e56\", \"huos3203\", \"PerfectTemplate\", \"20294e56\", false); 本章将引导您使用Swift和Perfect软件框架逐步设置一个简单的HTTP服务器。 创建Web应用原文 新建一个文件夹保存项目文件： 12$ mkdir iPerfect$ cd iPerfect 初始化项目，用SPM软件包管理器： 12345678$ swift package init --type=executableCreating executable package: iPerfectCreating Package.swiftCreating README.mdCreating .gitignoreCreating Sources/Creating Sources/iPerfect/main.swiftCreating Tests/ 配置依赖打开Package.swift文件进行编辑：该文件在要求Swift编译的最低版本为3.0.0，设置target编译依存库PerfectHTTPServer 12345678910111213141516// swift-tools-version:4.0// The swift-tools-version declares the minimum version of Swift required to build this package.import PackageDescriptionlet package = Package(name: \"iPerfect\", dependencies: [ .package(url: \"https://github.com/PerfectlySoft/Perfect-HTTPServer.git\", from: \"3.0.0\") ], targets: [ .target( name: \"iPerfect\", dependencies: [\"PerfectHTTPServer\"]), ]) 编码 12mkdir Sourcesecho &apos;print(&quot;您好！&quot;)&apos; &gt;&gt; Sources/iPerfect/main.swift 编译和运行现在项目就已经准备好，可以通过以下两个命令编译和运行： 12swift build.build/debug/iPerfect 成功之后，会打印：1你好！！！ 设置Perfect HTTPServer服务器注册路由和请求／响应句柄打开Sources/iPerfect/main.swift文件，把内容替换为以下程序：123456789101112131415161718import PerfectHTTPimport PerfectHTTPServer// 注册路由和请求／响应句柄var routes = Routes()routes.add(method: .get, uri: \"/\") &#123; request, response in response.setHeader(.contentType, value: \"text/html\") response.appendBody(string: \"&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;\") .completed()&#125;do &#123; // 启动HTTP服务器 try HTTPServer.launch(.server(name: \"www.example.ca\", port: 8181, routes: routes))&#125; catch &#123; fatalError(\"\\(error)\") // fatal error launching one of the servers&#125; 编译运行1234$ swift build$ .build/debug/iPerfect&gt;&gt;[INFO] Starting HTTP server www.example.ca on :::8181 在浏览器上打开http://127.0.0.1:8181/终止服务器：在终端控制台上用组合键control-c可以随时停止服务器。 使用Xcode调试服务器生成iPerfect.xcodeprojSwift软件包管理器（SPM）能够为您的项目iPerfect生成Xcode工程：1swift package generate-xcodeproj 递归编译设置 设置递归编译项目目录中的所有target打开iPerfect.xcodeproj，在检索项目软件库Library Search Paths字典中新增路径：$(PROJECT_DIR) ，路径属性修改为recursive。recursive：遍历该目录，non-recursive：默认路径设置；不遍历该目录。如果路径的属性为recursive，那么编译的时候在找库的路径的时候，会遍历该目录下的所有子目录的库文件。 PS：在搭建项目的时候，可以创建一个专门放库文件的文件夹并且设置其属性为recursive:即为$(PROJECT_DIR)/**，相当于遍历项目文件同级下的所有路径(不推荐使用，项目大的话，影响编译的速度)。 scheme运行在My Mac在Xcode打开项目之后，选择可执行目标为 My Mac，并选择正确的Swift工具链。 设置服务器的资源目录为了使服务器能够访问您工程文件夹下的目录，比如html静态网页。进入菜单命令 Product &gt; Scheme &gt; Edit Scheme…，设置工作目录 Use Custom Working Directory 为项目文件夹。 现在您就可以在Xcode中运行调试您的服务器了.","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用SPM管理依赖库","slug":"swift/使用SPM管理依赖库","date":"2018-10-01T23:57:27.000Z","updated":"2018-10-03T16:55:41.000Z","comments":true,"path":"2018/10/02/swift/使用SPM管理依赖库/","link":"","permalink":"https://huos3203.github.io/2018/10/02/swift/使用SPM管理依赖库/","excerpt":"","text":"概念概述Package Manager loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-PerfectTemplate-20294e56\", \"huos3203\", \"PerfectTemplate\", \"20294e56\", false); Modules模块在 Swift 中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外哪些部分的代码是可以被访问控制的。 一个程序可以将它所有代码聚合在一个模块中，也可以将它作为依赖关系导入到其他模块。除了少量系统提供的模块，像 OS X 中的 Darwin 或者 Linux 中的 Glibc 等的大多数依赖需要代码被下载或者内置才能被使用。 当你将编写的解决特定问题的代码独立成一个模块时，这段代码可以在其他情况下被重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的 app 或者 一个天气的 app 里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。 Packages包一个包由 Swift 源文件和一个清单文件组成。这个清单文件称为 Package.swift，定义包名或者它的内容使用PackageDescription 模块。一个包有一个或者多个目标，每个目标指定一个产品并且可能声明一个或者多个依赖。1234567891011121314151617181920import PackageDescriptionlet package = Package( name: \"DeckOfPlayingCards\", products: [ .library(name: \"DeckOfPlayingCards\", targets: [\"DeckOfPlayingCards\"]), .executable(name: \"Dealer\", targets: [\"Dealer\"]), ], dependencies: [ .package(url: \"https://github.com/apple/example-package-fisheryates.git\", from: \"2.0.0\"), .package(url: \"https://github.com/apple/example-package-playingcard.git\", from: \"3.0.0\"), ], targets: [ .target( name: \"DeckOfPlayingCards\", dependencies: [\"FisherYates\", \"PlayingCard\"]), .testTarget( name: \"DeckOfPlayingCardsTests\", dependencies: [\"DeckOfPlayingCards\"]), ]) Products产品一个target可能构建一个.library()库或者一个.executable()可执行文件作为其产品。.library(name: &quot;&quot;, targets: [])库:是包含用于其他Swift 代码导入该模块.executable(name: &quot;&quot;, targets: [])可执行文件:是一段可以被操作系统运行的程序。 Dependencies依赖Dependencies依赖是指Package中代码必须添加的Modules块。Dependencies由.package资源的绝对路径或相对 URL 和包的版本组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成了一个依赖相关图。 用例创建依赖库lib Package 建一个target表示标准的52张扑克牌的PlayingCard： 123mkdir PlayingCardcd PlayingCardswift package init 创建公共实现类PlayingCard定义PlayingCard类型，它由Suit枚举值(梅花、方块、红心、黑桃)和Rank枚举值(Ace、2、3、…、Jack、Queen、King)组成。 1234567891011121314public enum Rank : Int &#123; case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King&#125;public enum Suit: String &#123; case Spades, Hearts, Diamonds, Clubs&#125;public struct PlayingCard &#123; let rank: Rank let suit: Suit&#125; 按照约定，一个target所有的源文件都存在相应的Sources/&lt;target-name&gt;目录下，默认情况下，库模块使用public来声明类型和方法，这些类型和方法位于Sources/&lt;target-name&gt;中：1234567example-package-playingcard├── Sources│ └── PlayingCard│ ├── PlayingCard.swift│ ├── Rank.swift│ └── Suit.swift└── Package.swift PlayingCard因为不生成executable可执行文件，这种类型的target成为库，当构建一个模块可以被依赖导入使用。 运行swift build命令，将编译生成PlayingCard模块。 使用 #if #else #endif构建配置语句 创建fisher模块123mkdir fishercd fisherswift package init fisher与PlayingCard不同，此模块不定义任何新类型。相反，它扩展了现有的类型(特别是CollectionType和MutableCollectionType协议)，以添加shuffle()方法和它的变体副本shuffleInPlace()。 使用构建配置语句 #if #else #endifshuffleInPlace()的实现使用Fisher-Yates算法随机排列集合中的元素。因为Swift标准库不提供随机数生成器，所以该方法必须调用从系统模块导入的函数。为了使该函数与macOS和Linux兼容，代码使用构建配置语句。在macOS中，系统模块是Darwin，它提供了arc4random_uniform(_:)函数。在Linux中，系统模块为Glibc，它提供了random()函数:123456789101112131415161718192021#if os(Linux)import Glibc#elseimport Darwin.C#endifpublic extension MutableCollectionType where Index == Int &#123; mutating func shuffleInPlace() &#123; if count &lt;= 1 &#123; return &#125; for i in 0..&lt;count - 1 &#123; #if os(Linux) let j = Int(random() % (count - i)))) + i #else let j = Int(arc4random_uniform(UInt32(count - i))) + i #endif if i == j &#123; continue &#125; swap(&amp;self[i], &amp;self[j]) &#125; &#125;&#125; 依赖库导入及使用DeckOfPlayingCards包将前两个包组合在一起:它定义了一种桥牌类型，该类型在一个PlayingCard值数组上使用fisher()方法。要使用fisher和PlayingCards模块，必须在DeckOfPlayingCards模块的清单文件Package.swift中声明为它们package依赖项。123456789101112131415161718192021// swift-tools-version:4.0import PackageDescriptionlet package = Package( name: &quot;DeckOfPlayingCards&quot;, products: [ .library(name: &quot;DeckOfPlayingCards&quot;, targets: [&quot;DeckOfPlayingCards&quot;]), ], dependencies: [ .package(url: &quot;https://github.com/apple/example-package-fisheryates.git&quot;, from: &quot;2.0.0&quot;), .package(url: &quot;https://github.com/apple/example-package-playingcard.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target( name: &quot;DeckOfPlayingCards&quot;, dependencies: [&quot;FisherYates&quot;, &quot;PlayingCard&quot;]), .testTarget( name: &quot;DeckOfPlayingCardsTests&quot;, dependencies: [&quot;DeckOfPlayingCards&quot;]), ]) 每个依赖项指定源URL和from:版本号。源URL是解析到Git存储库的当前用户可以访问的URL。版本需求遵循语义版本控制(SemVer)约定，用于确定签出哪个Git标签并使用它来构建依赖关系。对于依赖项FisherYates ，将使用最新版本主版本为2(例如，2.0.4)。类似地，PlayingCard依赖项将使用最新版本主版本为3。当运行swift build命令时，包管理器下载所有依赖项，编译、并链接到包模块。这样DeckOfPlayingCards使用import语句来访问依赖模块中public类型的属性和方法。您可以在项目根目录下的.build/checkouts目录中看到下载的源代码，在项目根目录下的.build目录中看到中间的构建产品。 解决依赖传递关系构建Dealer模块,它依赖于DeckOfPlayingCards包，而DeckOfPlayingCards包又依赖于PlayingCard和fisher包。然而，由于Swift包管理器自动解析传递依赖项，您只需将DeckOfPlayingCards包声明为依赖项即可。123456789101112131415161718// swift-tools-version:4.0import PackageDescriptionlet package = Package( name: &quot;dealer&quot;, products: [ .executable(name: &quot;Dealer&quot;, targets: [&quot;Dealer&quot;]), ], dependencies: [ .package(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target( name: &quot;Dealer&quot;, dependencies: [&quot;DeckOfPlayingCards&quot;]), ]) 依赖传递关系也体现在Swift源文件代码import导入一个模块，就可以使用该某块下所有依赖库的类型。例如Dealer模块的main.swift文件。在DeckOfPlayingCards中的Deck类型和PlayingCard中的PlayingCard类型。尽管Deck类型的shuffle()方法在内部使用了fisher模块，但该模块不需要在main.swift中导入。123456789101112131415import PlayingCardimport DeckOfPlayingCardslet numberOfCards = 10var deck = Deck.standard52CardDeck()deck.shuffle()for _ in 1...numberOfCards &#123; guard let card = deck.deal() else &#123; print(&quot;No More Cards!&quot;) break &#125; print(card)&#125; 构建并运行可执行文件根据约定，一个target的根目录中包含一个名为main.swift文件，可以构建成一个可执行文件。运行swift build命令，然后运行.build/debug目录下的Dealer可执行文件。123456789101112$ swift build$ ./.build/debug/Dealer♠︎6♢K♢2♡8♠︎7♣︎10♣︎5♢A♡Q♡7 两个坑1swift package generate-xcodeproj 每次更新或添加库或框架，xcodeproj就需要重新创建一次，不然无法引用到新库或新框架； 在source文件夹如果发生任何改动，库或框架的更新就会失败。这就是为什么我要专门建一个工程来管理这些框架或者库（这是我踩的最恶心的坑）。为了解决这个大坑，就再创建一个项目工程，然后使用workspace来管理今天开始用swift写服务器(一)","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"Swift单文件相关命令行工具","slug":"swift/Swift单文件相关命令行工具","date":"2018-10-01T21:02:49.000Z","updated":"2018-10-01T23:57:27.000Z","comments":true,"path":"2018/10/02/swift/Swift单文件相关命令行工具/","link":"","permalink":"https://huos3203.github.io/2018/10/02/swift/Swift单文件相关命令行工具/","excerpt":"","text":"直接用 swift 命令执行xcrun swift可以直接将一个 .swift文件作为命令行工具的输入，这样里面的代码也会被自动地编译和执行。我们甚至还可以在 .swift 文件最上面加上命令行工具的路径，然后将文件权限改为可执行，之后就可以直接执行这个 .swift 文件了： hello.swift 12#!/usr/bin/env xcrun swift println(\"hello\") 终端设置为可执行权限，并运行打印： 1234&gt; chmod 755 hello.swift &gt; ./hello.swift // 输出： hello 这些特性与其他的解释性语言表现得完全一样 swiftc相对于直接用 swift 命令执行，Swift 命令行工具的另一个常用的地方是直接脱离 Xcode 环境进行编译和生成可执行的二进制文件。我们可以使用 swiftc 来进行编译，比如下面的例子： MyClass.swift 123456class MyClass &#123; let name = \"XiaoMing\" func hello() &#123; println(\"Hello \\(name)\") &#125; &#125; main.swift 12let object = MyClass() object.hello() 终端编译运行，将生成一个名叫 main 的可执行文件： 12&gt; xcrun swiftc MyClass.swift main.swift&gt; ./main //运行main文件 利用这个方法，我们就可以用 Swift 写出一些命令行的程序了。 最后想说明的一个 Swift 命令行工具的使用案例是生成汇编级别的代码。有时候我们想要确认经过优化后的汇编代码实际上做了些什么。swiftc 提供了参数来生成 asm 级别的汇编代码：1swiftc -O hello.swift &gt; hello.asm Swift 的命令行工具还有不少强大的功能，对此感兴趣的读者不妨使用 xcrun swift --help 以及 xcrun swiftc --help 来查看具体还有哪些参数可以使用。 swiftc -g支持lldb调试","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"swift在终端使用LLDB调试","slug":"swift/swift在终端使用LLDB调试","date":"2018-10-01T21:02:49.000Z","updated":"2018-10-17T19:47:48.000Z","comments":true,"path":"2018/10/02/swift/swift在终端使用LLDB调试/","link":"","permalink":"https://huos3203.github.io/2018/10/02/swift/swift在终端使用LLDB调试/","excerpt":"","text":"Using the LLDB Debugger使用LLDB调试器一步一步地运行Swift程序，通过设置断点调试运行状态。 创建一个名Factorial.swift，定义了一个factorial(n:)函数，并打印调用该函数的结果: 1234567func factorial(n: Int) -&gt; Int &#123; if n &lt;= 1 &#123; return n &#125; return n * factorial(n: n - 1)&#125;let number = 4print(\"\\(number)! is equal to \\(factorial(n: number))\") swiftc命令运行swiftc命令-g选项生成swift调试信息,在目录中生存可执行的Factorial文件： 12345$ swiftc -g Factorial.swift$ lsFactorial.dSYMFactorial.swiftFactorial* 使用lldb启动Factorial文件通过LLDB调试器命令lldb运行: 123$ lldb Factorial(lldb) target create \"Factorial\"Current executable set to 'Factorial' (x86_64). 设置断点使用breakpoint set (b) 命令在factorial(n:)函数的第2行中设置一个断点，每次执行函数时中断进程: 12(lldb) b 2Breakpoint 1: where = Factorial`Factorial.factorial (Swift.Int) -&gt; Swift.Int + 12 运行调试使用run (r)命令运行进程。进程在factorial(n:)函数的调用位置停止。 123456789101112(lldb) rProcess 40246 resumingProcess 40246 stopped* thread #1: tid = 0x14dfdf, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2 1 func factorial(n: Int) -&gt; Int &#123;-&gt; 2 if n &lt;= 1 &#123; return n &#125; 3 return n * factorial(n: n - 1) 4 &#125; 5 6 let number = 4 7 print(\"\\(number)! is equal to \\(factorial(n: number))\") Use the print (p) command to inspect the value of the n parameter.12(lldb) p n(Int) $R0 = 4 The print command can evaluate Swift expressions as well.12(lldb) p n * n(Int) $R1 = 16 Use the backtrace (bt) command to show the frames leading to factorial(n:) being called.123456(lldb) bt* thread #1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1 * frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -&gt; Swift.Int + 12 at Factorial.swift:2 frame #1: 0x0000000100000daf Factorial`main + 287 at Factorial.swift:7 frame #2: 0x00007fff890be5ad libdyld.dylib`start + 1 frame #3: 0x00007fff890be5ad libdyld.dylib`start + 1 Use the continue (c) command to resume the process until the breakpoint is hit again.123456789101112(lldb) cProcess 40246 resumingProcess 40246 stopped* thread #1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -&gt; Swift.Int + 12 at Factorial.swift:2, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -&gt; Swift.Int + 12 at Factorial.swift:2 1 func factorial(n: Int) -&gt; Int &#123;-&gt; 2 if n &lt;= 1 &#123; return n &#125; 3 return n * factorial(n: n - 1) 4 &#125; 5 6 let number = 4 7 print(\"\\(number)! is equal to \\(factorial(n: number))\") Use the print (p) command again to inspect the value of the n parameter for the second call tofactorial(n:).12(lldb) p n(Int) $R2 = 3 取消断点Use the breakpoint disable (br di) command to disable all breakpoints and the continue (c) command to have the process run until it exits.123456(lldb) br diAll breakpoints disabled. (1 breakpoints)(lldb) cProcess 40246 resuming4! is equal to 24Process 40246 exited with status = 0 (0x00000000)","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/tags/调试/"}]},{"title":"SPM相关命令工具","slug":"swift/SPM相关命令工具","date":"2018-10-01T14:52:23.000Z","updated":"2018-10-01T23:57:27.000Z","comments":true,"path":"2018/10/01/swift/SPM相关命令工具/","link":"","permalink":"https://huos3203.github.io/2018/10/01/swift/SPM相关命令工具/","excerpt":"","text":"概念概述getting-started loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-PerfectTemplate-20294e56\", \"huos3203\", \"PerfectTemplate\", \"20294e56\", false); 使用Swift编译系统Swift 编译系统为编译库、可执行文件和在不同工程之间共享代码提供了基本的约定。 swift 工具 swift package swift package generate-xcodeproj swift run swift build swift test swift package创建一个HelloSPM 创建Hello目录，目录名会作为SPM名称： 12$ mkdir Hello$ cd Hello swift package初始化为SPM工程 12345678910$ swift package init├── Package.swift // 依赖清单文件├── README.md├── Sources // 源码目录│ └── Hello│ └── Hello.swift└── Tests├── HelloTests│ └── HelloTests.swift└── LinuxMain.swift 每个包在其根目录下都必须拥有一个命名为Package.swift清单文件。如果清单文件为空，那包管理器将会使用常规默认的方式来编译包。 swift build编译SPM编译会先解析Package.swift项目配置和下载依赖库等环境，然后编译源码 12$ swift build #编译可执行文件Compile Swift Module 'Hello' (1 sources) swift test运行SPM的单元测试 1234567891011121314$ swift testCompile Swift Module 'HelloTests' (1 sources)Linking ./.build/x86_64-apple-macosx10.10/debug/HelloPackageTests.xctest/Contents/MacOS/HelloPackageTestsTest Suite 'All tests' started at 2016-08-29 08:00:31.453Test Suite 'HelloPackageTests.xctest' started at 2016-08-29 08:00:31.454Test Suite 'HelloTests' started at 2016-08-29 08:00:31.454Test Case '-[HelloTests.HelloTests testExample]' started.Test Case '-[HelloTests.HelloTests testExample]' passed (0.001 seconds).Test Suite 'HelloTests' passed at 2016-08-29 08:00:31.455.Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.001) secondsTest Suite 'HelloPackageTests.xctest' passed at 2016-08-29 08:00:31.455.Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.001) secondsTest Suite 'All tests' passed at 2016-08-29 08:00:31.455.Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.002) seconds 创建一个可执行的SPM可运行的SPM必须包含main.swift文件。SPM会把main.swift编译成可执行文件的二进制文件。在本例中，SPM将生成一个名为Hello的可执行文件，输出“Hello, world!” 创建 123$ mkdir Hello$ cd Hello$ swift package init --type executable 两种运行方式2.1 先编译在运行 123456$ swift buildCompile Swift Module &apos;Hello&apos; (1 sources)Linking ./.build/x86_64-apple-macosx10.10/debug/Hello$ .build/x86_64-apple-macosx10.10/debug/HelloHello, world! 2.2 swift run直接运行1234$ swift run HelloCompile Swift Module 'Hello' (1 sources)Linking ./.build/x86_64-apple-macosx10.10/debug/HelloHello, world! 多个源文件协作下一步，让我们在新的资源文件里定义一个新的方法 sayHello(_:) 然后直接用 print(_:) 替换执行调用的内容。在 Sources/ 目录下创建一个新文件命名为 Greeter.swift 然后输入如下代码：123func sayHello(name: String) &#123; print(\"Hello, \\(name)!\")&#125; sayHello(_:) 方法带一个单一的字符串参数，然后在前面打印一个 “Hello”，后面跟着函数参数单词 “World”。 现在打开 main.swift， 然后替换原来的内容为下面代码：123456if Process.arguments.count != 2 &#123; print(\"Usage: hello NAME\")&#125; else &#123; let name = Process.arguments[1] sayHello(name)&#125; 跟之前的硬编码不同，main.swift 现在从命令行参数中读取。替代之前直接调用 print(_:)， main.swift 现在调用 sayHello(_:) 方法。因为这个方法是 Hello 模块的一部分，所以不需要使用到 import 语句。 运行 swift build 并尝试 Hello 的新版本：12$ swift build$ .build/debug/Hello 'whoami' 目前为止，你已经能够运用开源 Swift 来运行一些你想要的程序了 。要了解Swift包管理器，包括如何构建模块、导入依赖项和映射系统库，请参阅网站的Swift包管理器部分。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"利用JavaScript构建OSX原生应用","slug":"macOS/利用JavaScript构建OSX原生应用","date":"2018-09-29T18:35:50.000Z","updated":"2018-09-29T18:35:50.000Z","comments":true,"path":"2018/09/30/macOS/利用JavaScript构建OSX原生应用/","link":"","permalink":"https://huos3203.github.io/2018/09/30/macOS/利用JavaScript构建OSX原生应用/","excerpt":"","text":"利用JavaScript构建OSX应用Example OS X applications written in JavaScript.JavaScript for Automation Cookbook廖雪峰的JavaScript教程W3Cschool javascript教程JavaScript快速入门 使用场景UIAutomation的简单使用方法如何使用UIAutomation进行iOS 自动化测试（Part I）JavaScript for OS X Automation by ExampleJavaScript For AutomationiOS 程序员效率提升利器之 AppleScriptNumbers入门 — 附录：脚本 AppleScript 与 Numbers","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"修改Mac用户名导致丢失管理员权限问题修复","slug":"macOS/修改Mac用户名导致丢失管理员权限问题修复","date":"2018-09-25T19:16:53.000Z","updated":"2018-09-25T19:41:17.000Z","comments":true,"path":"2018/09/26/macOS/修改Mac用户名导致丢失管理员权限问题修复/","link":"","permalink":"https://huos3203.github.io/2018/09/26/macOS/修改Mac用户名导致丢失管理员权限问题修复/","excerpt":"","text":"出现的问题主要有两点 数据恢复问题1）修改用户名后，mac系统认为是创建了一个新的用户，这时候，之前管理员账号的数据在当前用户的finder里是看不到的。这时候可以去到桌面，点击又上角的“前往” 。 管理员权限问题虽然数据问题恢复了，但是另外一个更严重的问题又出现了。新的用户名账号只是一个普通用户账号，没有管理员权限没有管理员权限了。在需要管理员权限的操作中输入具有管理员权限的前用户名和密码也不认了。解决办法： 创建一个新的具有管理员权限的用户第一步：重启电脑，并长按组合键：command+s进入Single User Model模式，出现像DOS一样的提示符 。第二步：在命令行顺序输入命令： 1234fsck -ymount -uaw /rm /var/db/.AppleSetupDonereboot 苹果电脑会重启，并且在开机后出现新装机时的欢迎界面。重新建立一个新的管理员账号。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"自定义Xcode支持Vim快捷键","slug":"xcode/自定义Xcode支持Vim快捷键","date":"2018-09-20T21:12:51.000Z","updated":"2018-09-20T21:12:51.000Z","comments":true,"path":"2018/09/21/xcode/自定义Xcode支持Vim快捷键/","link":"","permalink":"https://huos3203.github.io/2018/09/21/xcode/自定义Xcode支持Vim快捷键/","excerpt":"","text":"使用了Vim之后，被其强大的文本编辑能力吸引, 于是每天都在寻找 Vim 插件, 试图用 Vim 代替 Xcode 进行日常开发. 直到有一天突然发现, 我想要的就是一个拥有强大文本编辑能力的 Xcode.分享一个自定义快捷键完整版 常用操作Xcode虽然没有 Vim 的模式切换, 但是也可以使用大部分文本操作, 这里主要用到的是: 删除: 完全删除单行, 删除单行到行首, 删除词组, 删除单词, 删除段落 替换: 替换单行, 替换词组 复制: 复制行尾词组, 复制词组, 复制单行.另外还有向前删除单行, 向后删除单行, 全局替换, 剪切单行, 格式化粘贴单行等. 系统自带快捷操作首先 Xcode 原生自带的快捷键就非常实用了, CMD+, 打开Preferences-&gt;Code Binding-&gt;Text可以看到常用的选择, 删除, 搜索等快捷操作, 如 Move Word Right =&gt; ⌥+→ : 光标向右按单词移动. 自定义快捷操作实际使用时发现系统提供的删除只可以删除单词或词组某一方向的字符:系统快捷键演示： 自定义快捷键所以, 决定自行添加快捷操作, 而 Xcode 本身就是一个OSX 应用程序, 所以我们可以找到相关文件去配置快捷操作。 了解并编辑IDETextKeyBindingSet.plistApplication-&gt;Xcode.app-&gt;Contents-&gt;Frameworks-&gt;IDEKit.framework-&gt;Resources-&gt;IDETextKeyBindingSet.plist使用编辑器打开IDETextKeyBindingSet.plist, 自行添加快捷操作:12&lt;key&gt;Delete Current Word&lt;/key&gt;&lt;string&gt;moveLeft:, moveWordRight:, deleteWordBackward:&lt;/string&gt; 自定义快捷键演示其中Cut Current Line 是显示在 Xcode 偏好设置内的快捷操作.moveToEndOfLine 是编辑器的文本操作相关的 编辑器API, 可以组合类似的 API 自定义操作. 更新到xcode设置快捷键编辑完成后, 重新打开 Xcode-&gt;Preferences-&gt;Key Bindings-&gt;Customized, 为自定义的快捷操作添加快捷键.分享一个自定义快捷键完整版","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[]},{"title":"巡查自查整合类图","slug":"个人项目/巡查自查整合类图","date":"2018-09-13T19:22:55.000Z","updated":"2018-09-14T19:19:10.000Z","comments":true,"path":"2018/09/14/个人项目/巡查自查整合类图/","link":"","permalink":"https://huos3203.github.io/2018/09/14/个人项目/巡查自查整合类图/","excerpt":"","text":"","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"在Codeanywhere上使用zsh终端及高亮样式","slug":"shell/在Codeanywhere上使用zsh终端及高亮样式","date":"2018-09-13T11:25:14.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/09/13/shell/在Codeanywhere上使用zsh终端及高亮样式/","link":"","permalink":"https://huos3203.github.io/2018/09/13/shell/在Codeanywhere上使用zsh终端及高亮样式/","excerpt":"","text":"检查是否安装：1chsh 打印： 安装Debian / Ubuntu 安装：1$ sudo apt-get install zsh zsh直接启动：1zsh 安装oh-my-zsh样式工具在hexoDeploy项目根目录执行：1sh Util/oh-my-zsh/installTemplate.sh 会提示sed文件修改失败的错误：1sed: can&apos;t read s#export ZSH=.*#export ZSH=&apos;/home/cabox/workspace/huos3203.github.io/Util/oh-my-zsh&apos;#g: No such file or directory 暂时通过手动来修改：1vi ../oh-my-zsh/templates/zshrc.zsh-template 修改如下：1export ZSH=&apos;/home/cabox/workspace/huos3203.github.io/Util/oh-my-zsh&apos; 安装space-vim工具 执行1sh Util/space-vim/Manualinstall.sh 创建替身失败的提示：123/home/cabox/workspace/huos3203.github.io已经存在Util/space-vim/Manualinstall.sh: 18: Util/space-vim/Manualinstall.sh: Syntax error: &quot;(&quot; unexpected 手动解决创建替身的：12$ ln -fs /home/cabox/workspace/huos3203.github.io/Util/space-vim/init.vim ~/.vimrc$ ln -fs /home/cabox/workspace/huos3203.github.io/Util/space-vim/init.spacevim ~/.spacevim 安装vim插件启动vim工具，终端自动安装相关插件。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"Hexo开发文档及使用教程","slug":"hexo/Hexo开发文档及使用教程","date":"2018-09-07T15:08:22.000Z","updated":"2018-09-07T15:08:22.000Z","comments":true,"path":"2018/09/07/hexo/Hexo开发文档及使用教程/","link":"","permalink":"https://huos3203.github.io/2018/09/07/hexo/Hexo开发文档及使用教程/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-hexojs-hexo-0b26940\", \"hexojs\", \"hexo\", \"0b26940\", false); 开始之前请遵守以下准则： 遵守 Google JavaScript 代码风格。 使用 2 个空格缩排。 不要把逗号放在最前面。工作流程 Fork hexojs/hexo 把库（repository）复制到电脑上，并安装所依赖的插件: 1234$ git clone https://github.com/&lt;username&gt;/hexo.git$ cd hexo$ npm install$ git submodule update --init 新增一个功能分支: 1$ git checkout -b new_feature 开始开发。 推送（push）分支: 1$ git push origin new_feature 建立一个新的合并申请（pull request）并描述变动. 注意事项不要修改 package.json 的版本号。只有在测试通过的情况下您的合并申请才会被批准，在提交前别忘了进行测试。 1$ npm test","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"Hexo插件开发","slug":"hexo/Hexo插件开发","date":"2018-09-07T15:08:22.000Z","updated":"2018-09-07T15:08:22.000Z","comments":true,"path":"2018/09/07/hexo/Hexo插件开发/","link":"","permalink":"https://huos3203.github.io/2018/09/07/hexo/Hexo插件开发/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-hexojs-site-e1839be\", \"hexojs\", \"site\", \"e1839be\", false); Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件： 脚本（Scripts）如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。 插件（Packages）如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 node_modules 文件夹中建立文件夹，文件夹名称开头必须为 hexo-，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。 文件夹内至少要包含 2 个文件：一个是主程序，另一个是 package.json，描述插件的用途和所依赖的插件。123.├── index.js└── package.json package.json 中至少要包含 name, version, main 属性，例如：123456package.json&#123;&quot;name&quot;: &quot;hexo-my-plugin&quot;,&quot;version&quot;: &quot;0.0.1&quot;,&quot;main&quot;: &quot;index&quot;&#125; 工具您可以使用 Hexo 提供的官方工具插件来加速开发：hexo-fs：文件 IOhexo-util：工具程式hexo-i18n：本地化（i18n）hexo-pagination：生成分页资料 发布当您完成插件后，可以考虑将它发布到 插件列表，让更多人能够使用您的插件。发布插件的步骤和 更新文件 非常类似。 Fork hexojs/site 把库（repository）复制到电脑上，并安装所依赖的插件： 123$ git clone https://github.com/&lt;username&gt;/site.git$ cd site$ npm install 编辑 source/_data/plugins.yml，在档案中新增您的插件，例如： 1234567- name: hexo-serverdescription: Server module for Hexo.link: https://github.com/hexojs/hexo-servertags:- official- server- console 推送（push）分支. 建立一个新的合并申请（pull request）并描述改动。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"一周膳食计划","slug":"健康/一周膳食计划","date":"2018-09-05T19:07:39.000Z","updated":"2018-09-05T19:07:39.000Z","comments":true,"path":"2018/09/06/健康/一周膳食计划/","link":"","permalink":"https://huos3203.github.io/2018/09/06/健康/一周膳食计划/","excerpt":"","text":"一周计划","categories":[{"name":"健康","slug":"健康","permalink":"https://huos3203.github.io/categories/健康/"}],"tags":[]},{"title":"zeroTier内网穿透","slug":"智能设备/zeroTier内网穿透","date":"2018-09-05T18:29:50.000Z","updated":"2018-09-22T21:19:01.000Z","comments":true,"path":"2018/09/06/智能设备/zeroTier内网穿透/","link":"","permalink":"https://huos3203.github.io/2018/09/06/智能设备/zeroTier内网穿透/","excerpt":"","text":"zeroTier\b内网穿透","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"git-log的使用","slug":"git/git-log的使用","date":"2018-09-05T15:52:33.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/09/05/git/git-log的使用/","link":"","permalink":"https://huos3203.github.io/2018/09/05/git/git-log的使用/","excerpt":"","text":"trello 卡片git log使用 查看提交历史来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：12345678$ git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" \\--before=\"2008-11-01\" --no-merges -- t/5610e3b - Fix testcase failure when extended attributeacd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;()f563754 - demonstrate breakage of detached checkout wid1a43f2 - reset --hard/read-tree --reset -u: remove un51a94af - Fix \"checkout --track -b newbranch\" on detacb0ad11e - pull: allow \"git pull origin $something:$cur Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。 gitk图形工具","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"Jazzy生成Swift文档工具","slug":"macOS/Jazzy生成Swift文档工具","date":"2018-09-05T15:52:33.000Z","updated":"2018-10-20T10:48:04.000Z","comments":true,"path":"2018/09/05/macOS/Jazzy生成Swift文档工具/","link":"","permalink":"https://huos3203.github.io/2018/09/05/macOS/Jazzy生成Swift文档工具/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-realm-jazzy-6932e5e\", \"realm\", \"jazzy\", \"6932e5e\", false); demo loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-appcoda-SwiftDocSample-24c1649\", \"appcoda\", \"SwiftDocSample\", \"24c1649\", false); 使用 Jazzy 产生代码文档Jazzy 是一款可以为 Swift 和 Objective-C 代码产生具有 Apple 风格的代码文档工具。事实上，Jazzy 会为你创建一个链接所有代码文档的独立网页。它是一款命令行工具，但还是很容易使用的。在 Xcode 中使用 Markdown 生成 Swift 代码文档 安装1$ sudo gem install jazzy gem source不稳定常会导致无法找到jazzy1234$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.com# 确保只有 gems.ruby-china.com 腾讯云：https://gems.ruby-china.com/淘宝：https://ruby.taobao.org/ 使用使用 cd 命令将目录切换到工程对应的目录：12cd path_to_project_folderJazzy 输入 Jazzy 之后敲回车,会将标注为 public 的结构写入代码文档。如果你想要包含所有的实体，就输入一下：1jazzy --min-acl internal 默认输出的文件夹位于工程的根目录（你也可以更改输出路径），叫 docs。当jazzy不支持swift版本时，会导致错误：12Could not parse compiler arguments from `xcodebuild` output.Please confirm that `xcodebuild` is building a Swift module. 这是就需要在build settings中设置swift Language Version版本号。 生成指定的swift版本如果不是 Swift 的最新版本，发现使用 Jazzy 后没有效果的话，需要先指定 Xcode 支持的 Swift 版本：1jazzy --swift-version 2.1.1 --min-acl internal 帮助jazzy -help查看使用 Jazzy 时可能使用到的参数。当然，你完全可以根据自己的喜好来得到最终的结果。 集成Xcode在项目中添加运行脚本，或创建 其他–&gt;Aggregate在build phases下添加New run script phase 12345678910111213141516171819202122author=&quot;iTBoyer&quot;;author_url=&quot;http://huos3203.github.io&quot;;github_url=&quot;https://github.com/huos3203&quot;;sdk=&quot;iphone&quot;;output=&quot;docs/swift_output&quot;; #生成的文档地址docSetDir=&quot;/Users/admin/Library/Developer/Shared/Documentation/DocSets/&quot;jazzy \\--objc \\--clean \\--author &quot;$&#123;author&#125;&quot;\\--author_url &quot;$&#123;author_url&#125;&quot; \\--github_url &quot;$&#123;github_url&#125;&quot; \\--module-version 0.96.2 \\--xcodebuild-arguments -scheme,&quot;$&#123;PROJECT_NAME&#125;&quot; \\--module &quot;$&#123;PROJECT_NAME&#125;&quot; \\--sdk &quot;$&#123;sdk&#125;&quot; \\--output &quot;$&#123;output&#125;&quot; \\#拷贝到xcode文档目录中echo &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot;pwdcp -r &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot; &quot;$&#123;docSetDir&#125;&quot; 安装到Xcode，在编写代码时，可以快速查看帮助。1234#拷贝到xcode文档目录中echo &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot;pwdcp -r &quot;$&#123;output&#125;/docsets/$&#123;PROJECT_NAME&#125;.docset&quot; &quot;$&#123;docSetDir&#125;&quot; 工具推荐 appledoc工具install 方法和更新方法相同 123git clone git://github.com/tomaz/appledoc.gitcd ./appledocsudo sh install-appledoc.sh dash插件的使用 下载","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"swift支持的正则（textKit）","slug":"swift/swift支持的正则（textKit）","date":"2018-09-05T15:52:33.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/09/05/swift/swift支持的正则（textKit）/","link":"","permalink":"https://huos3203.github.io/2018/09/05/swift/swift支持的正则（textKit）/","excerpt":"","text":"swift支持的正则（textKit） 正则表达式语法.aspx)iOS开发之详解正则表达式原文：NSRegularExpression Tutorial: Getting Startednshipster文章NSPredicateiOS中的谓词（NSPredicate）使用 谓词和正则表达式的区别及适用场景 谓词的对象可以是字符串，集合，同时支持sql语法和正则表达式 正则表达式，对字符串 正则表达式简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。正则表达式的通用用例： 执行搜索：高亮显示搜索和替换 UITextView的NSAttributedString属性来高亮显示搜索的结果 用text kit来实现高亮的功能 验证用户输入","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"LaunchPad打击垫学习","slug":"智能设备/LaunchPad打击垫学习","date":"2018-09-05T15:52:33.000Z","updated":"2018-09-22T21:19:00.000Z","comments":true,"path":"2018/09/05/智能设备/LaunchPad打击垫学习/","link":"","permalink":"https://huos3203.github.io/2018/09/05/智能设备/LaunchPad打击垫学习/","excerpt":"","text":"trello卡片LaunchPad学习 第二期：Chain的选择与设置/页数的映射 分轨和音频采样 音频轨道拖拽音频文件或视频文件到Simple采样轨道中，视频格式会生成asd格式的新文件文件，加载到轨道中。 MIDI轨道可以为Lights1.1 灯光轨道1.2 鼓点设置 鼓点音色映射设置，来输出不同的音乐片段 拖动IB控件到MIDI模块 鼓点灯光映射设置 拖进MIDI Effects rack控件1.1 点击黄色选项：展开Key:vel:chain:Hide页面1.2 右击蓝色条，选择map selecter1.3 选中右上角的MIDI切换到设置MIDI映射键模式。1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置1.5 新建八个chain，错位蓝色条，完成页数映射的设置1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件 第三期：关于分轨和音频采样reddit.combeatport.comsplice.com选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。 第四期：基础灯光效果制作 Arpeggiator （A效果器）设置纵横方向的属性变化效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围 rate速度：1/1一拍移动一下最慢，1/128最快。 Gate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光 style：纵向变化的方向：up/down/upDown/DownUp… Hold激活不用长按，即可厂量 repeats：设置走马灯的循环次数 A效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。 Chord （和弦） 拖拽到Key列表中的一个垫子的灯光效果包上。 chord提供六个属性shift1，shift2….shift6，来设置和弦灯光错位，融合等效果第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。以此类推一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮 MIDI Effect Rack在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。设置灯光效果包 选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果 选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置 新建Velocity（力度感应） 新建chord（和弦） 新建Arpeggiator（A效果器） Note LengthPitchRandomScale Velocity：力度感应 拖到刚才的chain上，即在该键上添加力度感应属性设置。 设置灯光颜色：Out Hi的表盘参数，参考MIni支持的灯光色值","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"敏捷开发歌诀","slug":"管理/敏捷开发歌诀","date":"2018-09-05T15:52:33.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/09/05/管理/敏捷开发歌诀/","link":"","permalink":"https://huos3203.github.io/2018/09/05/管理/敏捷开发歌诀/","excerpt":"","text":"trello卡片敏捷开发歌诀及宣言 敏捷开发歌诀迭代开发，价值优先分解任务，真实进度站立会议，交流畅通用户参与，调整方向结对编程，代码质量测试驱动，安全可靠持续集成，尽早反馈自动部署，一键安装定期回顾，持续改进不断学习，提高能力 敏捷开发宣言 个体和交互，胜过过程和工具 可工作的软件，胜过面面俱到的文档 客户协作，胜过合同谈判 响应变化，胜过遵循计划 虽然右项也有\b价值，左项具有更大的价值。 迭代和增量式的学习每天计划用一段时间来学习新技术，它不需要很长时间，但需要经常进行。记下那些你想学习的东西–当你听到一些不熟悉的术语或者短语时，简要地把它记录下来。然后在计划的时间中深入研究它。了解最新行情。互联网上有大量关于学习新技术的资源。阅读社区讨论和邮件列表，可以了解其他人遇到的问题，以及他们发现的很酷的解决方案。选择一些公认的优秀技术博客，经常去读一读，以了解那些顶尖的博客作者们正在关注什么（最新的博客列表请参考pragmaticprogrammer.com）。参加本地的用户组活动。Java、Ruby、Delphi、.NET、过程改进、面向对象设计、Linux、Mac，以及其他的各种技术在很多地区都会有用户组。听讲座，然后积极加入到问答环节中。 跟踪技术变化。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。 切身感受你能嗅到将要流行的新技术，知道它们已经发布或投入使用。如果必须要把工作切换到一种新的技术领域，你能做到。 平衡的艺术 许多新想法从未变得羽翼丰满，成为有用的技术。即使是大型、热门和资金充裕的项目也会有同样的下场。你要正确把握自己投入的精力。 你不可能精通每一项技术，没有必要去做这样的尝试。只要你在某些方面成为专家，就能使用同样的方法，很容易地成为新领域的专家。 你要明白为什么需要这项新技术——它试图解决什么样的问题？它可以被用在什么地方？ 避免在一时冲动的情况下，只是因为想学习而将应用切换到新的技术、框架或开发语言。在做决策之前，你必须评估新技术的优势。开发一个小的原型系统，是对付技术狂热者的一剂良药。 当开发项目的时候，你需要使用一些术语或者隐喻来清晰地传达设计的概念和意图。如果团队中的大部分成员不熟悉这些，就很难进行高效地工作。再比如你参加了一个课程或者研讨班之后，所学的知识如果不用，往往就会忘记。所以，你需要和其他团队成员分享所学的知识，把这些知识引入团队中。 找出你或团队中的高手擅长的领域，帮助其他的团队成员在这些方面迎头赶上（这样做还有一个好处是，可以讨论如何将这些东西应用于自己的项目中）。 “午餐会议”是在团队中分享知识非常好的方式。在一周之中挑选一天，例如星期三（一般来说任何一天都可以，但最好不要是星期一和星期五）。事先计划午餐时聚集在一起，这样就不会担心和其他会议冲突，也不需要特别的申请。为了降低成本，就让大家自带午餐。 每周，要求团队中的一个人主持讲座。他会给大家介绍一些概念，演示工具，或者做团队感兴趣的任何一件事情。你可以挑一本书，给大家说说其中一些特别内容、项目或者实践。①无论什么主题都可以。 从每周主持讲座的人开始，先让他讲15分钟，然后，进行开放式讨论，这样每个人都可以发表自己的意见，讨论这个主题对于项目的意义。讨论应该包括所能带来的益处，提供来自自己应用程序的示例，并准备好听取进一步的信息。 这些午餐会议非常有用。它促进了整个团队对这个行业的了解，你自己也可以从其他人身上学到很多东西。优秀的管理者会重用那些能提高其他团队成员价值的人，因此这些活动也直接有助于你的职业生涯。","categories":[{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/categories/管理/"}],"tags":[]},{"title":"heroku的SSH终端命令","slug":"hexo/heroku的SSH终端命令","date":"2018-09-05T14:03:39.000Z","updated":"2018-10-21T22:42:59.000Z","comments":true,"path":"2018/09/05/hexo/heroku的SSH终端命令/","link":"","permalink":"https://huos3203.github.io/2018/09/05/hexo/heroku的SSH终端命令/","excerpt":"","text":"启动heroku 终端Heroku Exec (SSH Tunneling))每个Heroku exec连接最多持续一个小时。一小时后，您可能需要重新连接。Heroku exec在对Shield Private Spaces是不限制的。 先在该目录初始化环境1heroku create myhexo 创建 1heroku ps:exec bash 1234heroku run bash//Heroku ps:stop run #停止所有的dynos再执行heroku run bash 查看正在运行的bash 1Heroku run:detached ls 退出 1Heroku dyno:kill dyno 重启 1Heroku dyno:restart [dyno]","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"使用LLDB独立调试APP","slug":"调试/使用LLDB独立调试APP","date":"2018-09-05T14:03:39.000Z","updated":"2018-11-09T20:13:29.000Z","comments":true,"path":"2018/09/05/调试/使用LLDB独立调试APP/","link":"","permalink":"https://huos3203.github.io/2018/09/05/调试/使用LLDB独立调试APP/","excerpt":"","text":"参考lldb官方文档苹果文档LLDB调试器使用简介 南峰子译调试：案例学习系统翻译文章Debugging iOS binaries with LLDB高级LLDB调试LLDB中使用python概览 善用LLDB如果想断点到某种场景，不是先随意打个断点然后一直单步到出问题的那行代码，最佳的做法是充分利用LLDB的特性以一次性定位到你所感兴趣的代码。 自定义数据类型因为LLDB默认是只输出系统类型的，而并不认识自定义的数据类型，所以需要告诉LLDB你所关注的自定义数据类型及其数据，实现对数据的查看。 合理开销为了避免重新构建所带来的时间开销，你需要学会编写调试代码，以改变应用的执行路径，并修改数据，比如初始化还未初始代的数据。你所输入并执行的表达式会改变应用原本的执行路径，所以对此所带来的副作用你需要有清晰的把控。 正确的调试过程 想通过LLDB获取什么信息？ 断点到可疑的代码块 在正在执行的代码中一步步执行 观察数据并验证猜想 LLDB的使用时机和作用什么时候用LLDB,LLDB能在调试的时候怎样帮助你 debug-Only assertion它能帮助你知道应用中的运行异常，以及各组件之间传递的参数是否与约定的一致。但是不要在assertion中做对应用逻辑有影响的操作，因为一旦构建发布版本，这些assertion都会被屏幕，你在其中执行的操作也就不会进行了。所以，当发现bug时，LLDB并不是你的第一选择，而应该是debug-Only assertion。 log apple system log(ASL)而对于在运行中各处都看起来很正常，最终却呈现了错误的结果的情况，log会是一个非常有用的工具。而此处的log指的并不是NSLog，而是apple system log(ASL)，其可以通过console观察到。 levelASL可以通过log的level来区分log的严重程序，比如ASL_LEVEL_EMERG和ASL_LEVEL_DEBUG。 tag同时还可以附带使用hash tag以方便log的查找，比如为特定的业务添加特定的业务字符串等。而鉴于log可能被滥用，所以ASL可以通过开关提供某些log是否应该进行。正常的开关方式可以是可以使用NSUserDefaults等，或者也可以在shell中设置一个变量，程序在运行的时候读取此值以决定是否进行log。 Xcode 静态代码分析器Xcode可以为程序做的，-Weverything和静态代码分析器可以在代码运行前的编译阶段即发现可能存在的问题。可以在之前的session： What’s New In LLVM和What’s New In the LLVM Compiler中找到相关内容。而在运行期间可以通过Guard Malloc发现堆上缓存overrun的问题，通过zombie objects获取对释放了的对象进行方法调用的问题。具体可以参见Advanced Memory Analysis with Instruments LLDB的正确打开方式 两种启模式：一种是通过Xcode上的按钮，另一种是通过console中的lldb调试语言。 三种命令表达式：discoverable,abbreviated及alias形式，discoverable格式: expression –object-description – fooabbreviated格式: e -0 – fooalias格式: po foo同一个命令三种方式，书写繁琐程度递减，而且可以定义自己的alias 形式的命令。 设置断点行号断点：b MyCode.m:4（breakpoint set --file MyCode.m --line 4）方法断点：b &quot;-[MyClass method:]&quot;（breakpoint set --name &quot;-MyClass method:]&quot;）selector断点: b method:（breakpoint set --selector method:） 省时的命令鉴于在app及Xcode之间因为多次中断而进行的多次切换，可以在断点发生之后执行特定的命令，比如希望查看的数据之后再立即恢复执行123456b &quot;-[MyClass method:]&quot;br co a/breakpoint command add&gt;p rect/expression rect&gt;bt/thread backtrace&gt;c/process continue&gt;DONE 这些命令也可以在Xcode面板中通过点击及输入完成同样的功能。 条件断点如果不希望断点频繁触发，可以通过条件断点来达到此目的，比如想在某个特定对象析构的消息处断点，可以这样：123p id $myModel = self/expression id $myModel = selfb &quot;-[MyClass dealloc]&quot;/breakpoint set &quot;-[MyClass dealloc]&quot;br m -c &quot;self == $myModel&quot;/breakpoint modify --condition &quot;self == $myModel&quot; 通过watchpoint监控特定内存空间watchpoint的应用场景在于有人会修改某个变量值，你对此很关心但只知道变量的地址，其行为方式是如果变量被访问则watchpoint会暂停app的运行，设置watchpoint的方式是1w s v self-&gt;_needsSynchronization/watchpoint set variable self-&gt;_needsSynchronization 受限于CPU的支持程度，在intel平台上，提供了4个slot供watchpoint使用，所以同时只可设置最多4个watchpoint，arm上是2个watchpoint也可以在Xcode的控制面板中进行操作，只需要在变量区域中右击某变量选择菜单中的watchpoint选项即可 避免不断单步的高招LLDB可以在两种场景下暂停程序的执行： 执行到程序的具体某行代码的时候这种场景的实用命令是thread until linenum，避免一步步单步执行到希望的行，在xcode中这个功能对应的操作是右击代码行选择continue to this line。 函数返回之后 LLDB中手动执行代码很多时候你可能会发现，要想让你希望执行的代码执行一遍会很困难，比如单元测试的时候某个用例就是无法进行测试，这种情况下你需要用Clang([‘kl^n])直接调用这份代码，调用方式是直接在命令行表达式中输入你希望执行的代码并执行，比如12b &quot;-[ModelDerived removeDuplicates]&quot;e -i false -- [self removeDuplicates]/expression --ignore-breakpoints false -- [self removeDuplicates] 先在方法上打断点，然后在LLDB中执行此函数，选择不要忽略断点，你会发现执行此expression之后会断点到removeDuplicates，接着即可对其进行执行。然而有一点需要特别注意的是，通过LLDB执行的表达式代码是在你的进程中执行的，所以需要对此所带来的后果有自己的认知。 检查数据以找寻事情的缘由在上述的操作之后，我们已经可以断点到我们希望断点的位置了，接着就是检查数据寻找事情发生的原因了，这部分有3方面内容： 在LLDB命令行中检查数据查看局部变量：frame variable执行任意代码： expression (x+35) 其会通过app使用的编译器进行编译并在你的app中执行p @&quot;hello&quot; 兼容expression的语法，执行表达式并输出结果po @&quot;hello&quot; 执行任意代码并输出结果的description LLDB实用数据格式需要先搞清楚raw data和data的区别，raw data:是内存中所存储的数据，但它并不易读，对你来说可能太复杂，或者并不是你理解的数据类型，又或者它的数据量很大。解析：如果想对raw data有个直观的印象，只需要在Xcode的变量区域选择show raw values就可以在观察任意一个栈帧的时候看到raw data了，而此时切换到show types就可以看到规整而有意义的数据呈现形式了，这就是 LLDB 数据格式所要达到的目的。对于内置的系统库STL,CoreFoundation,Foundation，其中的数据都已经添加了Data formatter，在调试的时候显示都很规整对于程序员自定义的数据类型的data formatter，苹果构建了可扩展的data formatter子系统，这意味着程序员也可以为自定义的类型添加data formatter。 自定义data formatter数据类型的data formatter包括两部分：综述summary，用于呈现数据的关键描述；所组成的子数据即synthetic children以使用python定义summary为例，summary会将一种数据类型与一个python函数映射起来，基础的映射是通过类型名，更多其它规则可以参见这个python函数会在此类型的数据在展示的时候被调用，LLDB会将一个SBValue传递给它，SBValue是LLDB对象模型的一部分，可以将其简单地想象成为一个变量，这个python函数最终会返回一个字符串，这个字符串即会被当做summary SBValue之前提到SBValue可以当做一个变量来对待，可以询问其name,data type,summary(如果有的话),是否有children,有多少children,是否可以详述每个child的信息,每个child的信息其实也是一个SBvalue，所以整个是一个递归的过程。如果值是一个比如数字这样的标量，整数，浮点数等，也可以询问其value。对自定义类进行summary12345678def MyClass_Summary(value,unused)://其中value是一个SBValue//由于是自己定义的数据，可先获取其中的成员变量，成员变量也是SBValuemember1 = value.GetChildMemberWithName(&quot;_member1&quot;)member2 = value.GetChildMemeberWithName(&quot;_member2&quot;)member1Summary = member1.GetSummary()member2Summary = member2.GetSummary()#当然也可以做任何你想做的事情，这里仅仅只是简单地组合两个成员的summaryreturn member1Summary + &quot; &quot; + member2Summary 完成了这个python函数之后，变量区域中仍然不能正确显示MyClass的自定义数据类型，因为你还需要在LLDB中执行：1ty su a MyClass -F MyClass_Summary/type summary add MyClass --python-function MyClass_Summary 审视不透明的数据先介绍下用于数据分析的expression，可以通过如下形式定义一个持久有效的结构体：1expression struct $NotOpaque&#123;int item1;float item2;char* item3;&#125; 对于第3方库提供的对象，你可能连其数据类型都不知道，更不会知道其中成员变量的定义，可能通过google之后，可以发现其具体的定义，这时候，就需要使用上述expression再结合summary，即可以在展示的时候使用自定义的data formatter了. 扩展LLDB自定义LLDB命令通过python脚本，可以为调试器添加新特性，实现自定义的操作/自动化的操作过程比如计算递归的层数，想想LLDB怎么也算是个强大的程序，数数对它来说应该不是什么难事，更加说相比于你手工一个栈帧一个栈帧地数了。 LLDB 对象模型LLDB的强大在于它所使用的LLDB对象模型，我们称其为”SB”(scripting bridge)，这是个python API，xcode用其来构建debugger的UI，这意味着对你可以完全地通过LLDB脚本使用SB的所有功能，同时其也有一套对调试session的描述：对于上述调试界面相信大家都比较熟悉，LLDB对象模型对其的描述是这样：SBTarget即是调试中的target，接着在点击了xcode中的运行按钮之后，这个target成为了一个活着的实体，对这个实体，你可以输入，点哪，点哪，点，这即是在机器底层上运行的进程称为SBProcess，进程有着很多用来完成任务的thread，即SBThread，而SBThread会不停地执行function，每个function都会而每次function调用都会对应栈上的一帧，即SBFrame，现在我们已经了解到了描述程序运行中的所有对象，接下来看看怎样完成我们想完成的任务。首先需要知道的是python命令是如何执行的呢，python函数是与LLDB中的命令一一对应的，LLDB看到这个命令的时候即会调用相应的python命令，python命令的原型是这样:1def MyCommand_Impl(debugger,user_input,result,unused): debugger:是一个SBDebuggeruser_input:是用户输入的python字符串result:是SBCommandReturnObject，是用来反馈给LLDB的，反馈执行成功与否等信息添加自定义的命令的方式如下：1co sc a foo -f foo/command script add foo --python-function foo 断点操作断点的痛点在于它会不停在中断程序的执行，条件断点会好一点，有了断点action，我们可以只在自己关注的场景停下来断点action是将断点与一个python函数联系起来，断点命中的时候会调用此python函数，而其可以返回false以勾选断点编辑界面中的continue选择框以让LLDB继续运行此python函数的原型是1def break_on_deep_traversal(frame,bp_loc,unused): frame类型:为SBFramebp_loc类型:为SBBreakpointLocation绑定python函数的命令是1br co a -s p -F foo 1 /breakpoint command add --script python --python-function foo 1 首先需要注意的是WWDC中python代码样例的函数function中常看到unused作为结尾参数，在实际使用python函数时如果未理解其深意，可能会不知其所以然。断点中的全局变量frame和bp_loc分别是断点栈帧的指针及断点处的代码描述信息，bp_loc打印出来类似于这样：12.1: where = YourApp`-[SomeViewController onDynamicMethod:paraList:] + 117 at SomeViewController.m:109, address = 0x000000010f9cf3d5, resolved, hit count = 4 在将function作为python命令添加时，命中断点之后lldb会为指定的断点命令函数传入3个参数即frame,bp_loc和internal_dict。 LLDB在设计之初即提供了两种范畴的脚本化方式：即可以在Unix环境的python应用中使用LLDB开启并进行一段不能进行交互的调试session；在LLDB中使用python脚本进行诸如监视数据，遍历容器或者决定断点是该暂停程序执行还是继续程序的执行。 在python中操作程序中的变量在实现这个目标之前，需要解决的一个问题是，程序中的变量需要转换成python可以访问的形式，这个时候就需要用到LLDB API，它是作为python的LLDB模块提供的。在LLDB中运行python时，LLDB会自动将当前帧对象通过lldb.frame这个python变量提供出来，其类型是SBFrame，可以通过FindVariable方法向帧对象询问其本地变量，通过此方法获得的对象是SBValue对象，可以通过SBValue.h中的方法，比如 GetChildMemberWithName(), GetSummary(), 及GetValue()等方法获取具体的信息。程序中的变量值最终是如何转换成python中任意取用的信息的呢？原来LLDB在捕获到程序作用域中的变量之后都是将其封装在SBValue对象中，通过SBValue的API即可获取到封装在其中的变量值的具体信息，对于对象类型的变量，可以通过GetChildMemberWithName获取其成员变量的值，若原本是一个字符串，则使用GetSummary获取字符串，通过GetValue获取数值相关的值等。 用断点命令script完成最终的临门一脚有了操作局部变量的神技，实战操作的时候就可以这么玩了，在可疑处打断点，读取临时变量的值检查与预期是否相符，此处的一个小tip是:将python脚本操作编写在一个python文件里面的function里面，通过import的形式导入并调用其中的function，以免在lldb中输入起来繁琐。断点命令script的奥义如果在lldb命令行中为某断点添加python脚本，比如通常是这样breakpoint command add -s python breakpointnum ，输入一到数行python脚本，则LLDB会自行将这数行代码封装成一个python函数并传递两个参数，即frame和bp_loc，断点命中时，即会调用此函数，并传入断点时当前帧对象frame及断点位置信息对象bp_loc。由此可知，在实际编写断点命令的时候，需要注意这样两点： 如果想访问你脚本之外创建的python变量，需要将其声明为global，否则其会被当做局部变量，即需要在断点命令脚本中显式声明，比如global variable 所有python断点命令脚本都能够访问到frame和bp_loc 举例在断点处的当前栈帧位于特定帧中时命中断点第一步通过import导入本地的脚本文件1command script import ~/lldb/inGivenFrame.py 第二步通过codeline添加断点，第三步添加断点命令1br comm add --script-type python -o &quot;inGivenFrame.inGivenFrame(frame,location,&apos;-[NSObjec givenfuncname]&apos;)&quot; 1 如果不需要传入第三个参数，则也可以使用-F选项，此时命令形式1br comm add --script-type python -F inGivenFrame.inGivenFrameF 1 此时在断点命中时，lldb传给inGivenFrameF函数的第三个参数的意义也有所变更，此时传入的是名为internal_dict的变量，包含额外的信息使用inGivenFrameF作为断点命令的操作步骤及执行结果如下： 问题现在想通过lldb来调试自己的iOS项目，官方提供了 12$ lldb /Projects/Sketch/build/Debug/Sketch.app (lldb) process launch 当按照这种方式指定到路径iOS项目时,打印： (lldb) target create “/Users/admin/Desktop/Recommend.app”Current executable set to ‘/Users/admin/Desktop/Recommend.app’ (arm64). 但是启动时出现问题： 12(lldb) run error: the platform is not currently connected 大神，有没有解决办法？","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/tags/调试/"}]},{"title":"shadowrocket无需越狱重签翻墙","slug":"智能设备/shadowrocket无需越狱重签翻墙","date":"2018-09-05T12:11:58.000Z","updated":"2018-09-22T21:19:00.000Z","comments":true,"path":"2018/09/05/智能设备/shadowrocket无需越狱重签翻墙/","link":"","permalink":"https://huos3203.github.io/2018/09/05/智能设备/shadowrocket无需越狱重签翻墙/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-WCShadowrocket-f101e23\", \"huos3203\", \"WCShadowrocket\", \"f101e23\", false); 一次讲透：IOS翻墙利器“小火箭（Shadowrocket）”上手、进阶、配合Workflow获取免费节点攻略 iOS版Shadowrocket 完美重签 无需付费 无需越狱~越狱手机砸壳工具 详见https://github.com/AloneMonkey/frida-ios-dump砸壳教程https://github.com/we11cheng/WCStudy/blob/master/frida-ios-dump.mddumpdecrypted砸壳https://github.com/we11cheng/WCStudy/blob/master/dumpdecrypted%20%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6.mdClutch砸壳https://github.com/we11cheng/WCStudy/blob/master/Clutch%E7%A0%B8%E5%A3%B3(%E8%8F%9C%E9%B8%A1%E7%89%88).md其他砸壳收集请戳https://github.com/we11cheng/WCCrackedCollect本repo使用方法如下:1、安装MonkeyDev(如已安装，跳过) 安装最新的theos 1sudo git clone --recursive https://github.com/theos/theos.git /opt/theos 安装ldid(如安装theos过程安装了ldid，跳过) 1brew install ldid 指定的Xcode 1sudo xcode-select -s /Applications/Xcode.app 执行安装命令 1sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot; 更新 1sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot; 卸载 1sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot; 2、运行工程 打开工程 WCShadowrocket.xcodeproj 选择证书：自动配置证书即可（相信大家都是没有问题的）。 选择设备(不可选择模拟器，且仅支持64位设备)运行。 本次测试机iphone6s 10.3.3 xcode 9.3（iOS11测试过可以运行,其他机型应该也没啥问题）。 版权及免责声明 iOS逆向实践，不可使用于商业和个人其他意图。一切问题均由个人承担，与本人无关。 感谢MonkeyDev的作者庆总https://github.com/AloneMonkey/MonkeyDev。 如内容对您的权利造成了影响，请issues, 我会在第一时间进行删除。 效果截图 华丽的分割线点右上角的 Star 可以领红包，不信你试试。重签付费应用就是这么容易，感谢MonkeyDev作者。 福利 提供免费付费软件砸壳，理论上支持越狱手机上所有软件砸壳，砸壳以后拖入MonkeyDev开始逆向之旅吧~。应用列表：Shu Thor Detour Kitsunebi Pythonista HyperApp JSBOx Surge Quantumult PPHub Tik Tok Mume Mume Red … 2018-5-29 添加自建vps ssr&amp;ss节点信息。虽然延迟有点高，但还是能用的。完全自己搭建，(有限制流量，不够再加)放心使用~ SS 链接 : ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAxSS 二维码 : http://doub.pw/qr/qr.php?text=ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAxSSR 链接 : ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdwSSR 二维码 : http://doub.pw/qr/qr.php?text=ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw规则详见https://github.com/lhie1/Rules，自行选择使用，更多规则https://github.com/h2y/Shadowrocket-ADBlock-Rules2018-6-26 新增ssr节点订阅模式(免费)。参考https://tool.ssrshare.xyz/tool/free_ssr如何订阅 打开shadowrocket 首页，点击右上角+号。模式选择Subscribe URL部分输入以下三个地址（一个或多选，多选表示订阅多个） 123456实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 所有(golbal)可用订阅:https://tool.ssrshare.xyz/tool/api/getGolSub?key=1529942400_8_xuo实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 中国(CN)可用订阅:https://tool.ssrshare.xyz/tool/api/getCnSub?key=1529942400_8_xuo非实时订阅链接（无密码）:https://raw.githubusercontent.com/ImLaoD/sub/master/ssrshare.com 点击完成，就能发现节点列表新增了我们订阅节点信息。选择一个可以的连接即可。 最后一个订阅地址是开源的(托管在git)。查看作者repo2018-7-17 更新添加了Capabilities下Person VPN Network Extensions 帮助https://github.com/we11cheng/WCStudy/blob/master/iOS%20Widget%20Extensions%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.md 添加节点的时候，遇到问题，还没解决..求大佬们一起解决它..12CoreData: annotation: Failed to load optimized model at path &apos;/var/containers/Bundle/Application/9D19C752-5139-426B-815E-2A68B632352F/WCShadowrocket.app/Shadowrocket.momd/Shadowrocket 7.omo&apos;*** Terminating app due to uncaught exception &apos;NSFileHandleOperationException&apos;, reason: &apos;*** -[NSConcreteFileHandle seekToFileOffset:]: Bad file descriptor&apos; 最新福利，谷歌云上搭建了一个App Engine 爬取ssr/ss节点，拿去不谢 https://sspy-210307.appspot.com/（已失效）2018-7-26 更新几个ssr订阅 逗比根据地 http://ss-ssshare.7e14.starter-us-west-2.openshiftapps.com/subscribe 香港节点 https://wepn.hk/link/idFgpbMYQQxvHjuK?mu=0 loremwalker https://prom-php.herokuapp.com/cloudfra_ssr.txt App Engine https://sspy-210307.appspot.com/subscribe,update可能需要科学上网。（已失效） 他人共享https://raw.githubusercontent.com/forpw2009/lpss2009/master/ssr/lpssr 作者github主页https://github.com/forpw2009 Heroku https://isspy.herokuapp.com/subscribe 2018-8-21 App Engine欠费关闭，改用Heroku部署，项目主页地址 https://isspy.herokuapp.com/ ss/ssr订阅地址 https://isspy.herokuapp.com/subscribe","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"playground运行慢问题解决办法","slug":"swift/playground运行慢问题解决办法","date":"2018-09-05T11:46:05.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/09/05/swift/playground运行慢问题解决办法/","link":"","permalink":"https://huos3203.github.io/2018/09/05/swift/playground运行慢问题解决办法/","excerpt":"","text":"在升级xcode之后，出现playground无法运行的情况，live view 不显示等问题。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"七个习惯附录一","slug":"阅读/七个习惯附录一","date":"2018-09-04T19:39:50.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/09/05/阅读/七个习惯附录一/","link":"","permalink":"https://huos3203.github.io/2018/09/05/阅读/七个习惯附录一/","excerpt":"","text":"七个习惯资源 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-7HabitFiles-ab2502a\", \"huos3203\", \"7HabitFiles\", \"ab2502a\", false); 下载习惯的评估矫正.pages下载七个习惯综合评估.numbers 生成markdown表格工具 你的生活中心 配偶 家庭 金钱 工作 财富 享乐 朋友 敌人 宗教 自我 原则 配偶 *满足需求的主要来源 维持现状 不太重要 *有夫妻共同维护 *让配偶衣食无忧所必须的 *挣钱养活配偶所必须的 *关爱、打动或支配配偶的手段 *一起活动或无足轻重 配偶是最好或唯一的朋友 只有“我们的”朋友才是朋友 *配偶捍卫我的利益或者共同的敌人令我们的婚姻稳固 共同的享受乐趣的生活 仅次于婚姻关系 由配偶决定自我价值 极易受到配偶态度和行为的影响 *与配偶建立并维持关系的理念 家庭 *家庭的一部分 *重中之重 *家庭经济的支柱 *达到某个目的的手段 *带给家庭安逸和机遇 *家庭活动或相对次要 家庭的朋友否则会引起斗争 稳固家庭生活的威胁 由家庭决定 家庭团结稳固的根源 *可能对家庭团结构成威胁 *求助的对象 *家庭的重要部分但地位次于家庭 保持家庭团结稳固的规则 次于家庭 金钱 *赚钱的资本或负担 *经济负担 *安全感和满足感的来源 *赚钱所必须的 *经济成功的证据 *经济负担或者经济压力的标志 *由于经济地位或者影响力而结交 经济上的竞争者 经济稳定的威胁 税金减免 花钱的地方 自我价值 由净资产决定 *赚取和管理钱财的有效方法 工作 *工作的助力或阻力 帮助或者干扰工作 培养家人的敬业精神 次要 辛勤工作的证据 满足感和成就感的主要来源 重中之重 提高工作效率的手段 工作的成果和证明 浪费时间 干扰工作 由于工作环境或者志趣相投而结交 基本不必要 *工作的效率障碍 对企业形象至关重要 占用时间 *建立职业关系网的机会 *由工作中的作用决定 让你在工作中获取成功的理念 适应工作环境所必须的 财富 主要财富 获取财富的帮手 可供使用、利用、支配、压制和控制的财富 炫耀 增加财富的关键 可供炫耀的财富 *获取地位、权势和承认的机会 *地位标志 *逛街、购物、加入俱乐部 个人所有 可供利用 掠夺者、强盗 拥有更多财富或者更高的声望的人 “我的”教堂地位的象征 不公正批判和生活美好事物的根源 由我拥有的财产决定 由社会地位和声望决定 *让你获取和增加财富的观念 享乐 *享受乐趣的同伴或阻碍 *载体或干扰 *增加享乐机会的手段 达到目的的手段 愿意从事有趣的工作 乐趣的客体 获取更多乐趣的手段 生活中至高无上的目标 满足感的主要来源 *共享乐趣的伙伴 过于认真的看待生活 带来罪恶感的人，破坏者 麻烦，娱乐的障碍 带来罪恶感 *享乐的工具 *必须得到满足的固有冲动的本能 朋友 可能是朋友可能是对手 社会地位的象征 朋友建立友谊的障碍 社会地位的象征 *良好经济和社会状况的根源 *社会机遇 收买友谊的手段 消遣或提供社交娱乐的手段 与朋友一起总是很快乐 以社交活动为主 对个人的快乐至关重要 归属感、得到接纳和受欢迎至关重要 社交圈以外 共同的敌人和巩固或缔结友谊 *社交聚会的场所 由社会决定 害怕尴尬或遭到排斥 *让你与别人和睦相处的基本法则 敌人 *同情替罪羊 *避难所（情感支持）或替罪羊 *对抗或证明高人一等的手段 *逃避方式或者发泄情绪的机会 斗争工具 争取盟友的手段 *逃避、寻找逃难所 *下一次战斗前的休息放松时间 情感上的支持者和同情者 可能由于共同的敌人而结下友谊 仇恨的对象 个人烦恼的根源 *自我保护和自我辩白的原因 *自我辩护的根源 受害 受制于敌人 指责敌人的理由 敌人错误的根源 宗教 为教堂服务的同伴或帮手 信仰的考验 贯彻宗教教义的榜样 信仰的考验 支持教会和家庭的手段 如果比为教会教义服务更重要，则是罪恶 *维持世俗生活所必须的 世俗财富毫不重要 名誉和形象极其可贵 “无害”的乐趣，是与其他教友聚会的机会 其他娱乐是有害的是浪费时间，应该禁止 *其他教友 *无信仰的人；不赞同宗教教义的人或者生活方式完全违背教义的人 *生活方向的最重要指引 *自我价值由宗教活动，对教会的贡献或按教义行事的表现决定 宗教信条 比宗教次要 自我 财富 令自己满足和快乐 财富 满足需求 *满足需求的来源 *“自行其是”的机会 *自我界定保护和提高的来源 应得的感官享受 我的权力 *我的需求 *我的支持者和供应者 *自我界定自我辩白的根源 *服务私利的手段 比别人优秀、聪明、正确 集中一起资源满足个人需求 辩白的根源 最能为我的利益服务的理念；可以根据需求不同作出调整 原则 在互利互赖的关系中的平等伙伴 朋友 服务、贡献和成就的机会 *改写几代人的行为模式和变革的机会 *完成要务和重要目标的资源 以富有成效的方式运用才华和能力的机会 获取经济资源的手段 *与其他时间投入相均衡的时间投入，与生活中的要务和价值观相一致 可供利用的资源 得到适当照顾的责任 *与人相比是次要的 目标明确的生活中几乎所有活动产生的乐趣 真正的娱乐是平衡而全面的生活方式的重要组成部分 相互依赖生活中的同伴 知心人—能倾吐心声，能提供服务和支持 *没有真正意义上的敌人；知识思维定势和考虑事项不同应该予以理解和关心 真正的原则的载体 服务和贡献的机会 *是诸多独特、有才华、富有创造力的个体当中的一个。 这些个体独立和互赖的工作能完成伟业 永恒的自然法则，一旦违反必受惩罚 得到遵守时，则能维护尊严，从而实现真正的成长和幸福","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"习惯三要事第一自我管理原则","slug":"阅读/习惯三要事第一自我管理原则","date":"2018-09-03T15:01:52.000Z","updated":"2018-09-03T15:01:52.000Z","comments":true,"path":"2018/09/03/阅读/习惯三要事第一自我管理原则/","link":"","permalink":"https://huos3203.github.io/2018/09/03/阅读/习惯三要事第一自我管理原则/","excerpt":"","text":"1）我的时间是怎样度过的1.很不同意2.不同意3.略不同意4.略微同意5.同意6.很同意 问题 态度 1.我花了很多时间在重要而且需要立刻关注的活动上，例如危机、紧迫问题、截止日期即将到期的项目。 打分 2.我觉得总是到处救火，不断处理危机 打分 3.我觉得自己浪费了好多时间。 打分 4.我花了很多时间在虽然紧迫但与我的最高优先毫无关系的事情上（诸如无端的干扰、不重要的会议，、非紧急的电话和电子邮件） 打分 5.我花了很多时间在重要但不紧迫的事务上，例如做计划、准备、防范、改善人际关系、恢复和休整 打分 6.我花了很多时间在繁忙的工作、强制性习惯、垃圾邮件、过多的电视节目、琐事和玩游戏上。 打分 7.我觉得由于防范得当、精心准备和周密计划，一切由我掌控。 打分 8.我觉得自己总是在处理对他人重要、但却对自己不重要的事情。 打分 以上表格的设计，是用来帮你快速评估自己花费在时间矩阵的每个象限中的时间和精力各有多少。对于上面的8个问题圈出你的反应，从1到6.得分操作指南： 对于这8个问题圈出相应于你的反应的数字，从1到6. 把你在每个象限中的得分相加。 在每个象限中用阴影涂画出四分之一圆，其中半径等于你在该象限的得分。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"习惯二以终为始自我领导原则","slug":"阅读/习惯二以终为始自我领导原则","date":"2018-09-03T14:26:21.000Z","updated":"2018-09-03T15:01:52.000Z","comments":true,"path":"2018/09/03/阅读/习惯二以终为始自我领导原则/","link":"","permalink":"https://huos3203.github.io/2018/09/03/阅读/习惯二以终为始自我领导原则/","excerpt":"","text":"1）检查你的愿景 现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。 2）制定一份个人使命宣言 为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。 步骤1：开动脑筋畅想 将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。步骤2：放松一下 现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。步骤3：整理你的思绪 回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语步骤4：写出初稿 现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。步骤5：完成你的使命宣言 周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。 步骤6：定期检查并加以评估 把你做本章开篇的参加葬礼心灵演练时的新的列表整理下来。 1）检查你的愿景现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。我现在的生活状况如何？它是否让我快乐？我是否有成就感？ 是什么在一直吸引着我？它是否与我目前正在做的事情有所不同？ 我少年时想做的是什么？这些事情仍然给我带来满足感吗？我目前是在做着其中的一些事情吗？ 目前最让我感兴趣的是什么？ 最让我的灵魂感到满足的是什么？ 我做什么事情最擅长？我的显著特点和优势是什么？ 2）制定一份个人使命宣言为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。 步骤1：开动脑筋畅想将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。1．标识一个对你有影响的人。确定一个对你的生活有积极影响的人。你最赞赏这个人的什么品质？你从这个人那里学到了什么品质？ 2．详细说明你想成为怎样的人。设想现在已是20年后，你已经达成了自己所希望的所有成就。你的成就清单是什么？你想拥有什么？你想成为怎样的人？你想成就怎样的事业？ 3．请确定，目前对你最重要的是什么？ 步骤2：放松一下现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。 步骤3：整理你的思绪回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语。 步骤4：写出初稿现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。 使命宣言初稿 步骤5：完成你的使命宣言周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。 我的使命宣言 步骤6：定期检查并加以评估每个月问自己下列问题：●我是否觉得这个使命宣言代表了最佳的自我？●当我回顾这个使命宣言的时候是否感到有了方向、目标、挑战和动力？●我的生活是否遵从了这个使命宣言中的理想和价值观？ 3）你的角色既然你已有了逐步进展中的个人使命宣言初稿，重要的是考虑你在生活中的角色和目标，以及它们与你的使命宣言有着怎样的关系。 在下页的空白处写下你的各个角色。别太在意一次把它们弄正确。只要写下你觉得正确的就行。尝试把列出的角色限制在七个以内。如果超过了七个，可以把若干职能归并为一个。在写下的角色旁边描述一下，你认为自己可能在该角色领域做出的最理想的业绩。例如：艺术家、护理者、同伴、指导者、激励者、朋友、祖父母、发明家、邻居、调解者、儿子、教师、训练员、志愿者、作家 角色 在角色领域的最理想的业绩 志愿者 在儿童中心服务两个小时 4）你的生活中心阅读本书附录一所列的各种生活中心，看看你的行为符合其中哪个类型？他们是否让你的日常行为有一定依据？你是否满意？ 5）告诉你自己怎么做设想近期内可能会从事的某个项目，用智力创造的原则，写下你的希望获得的结果与应采取的步骤。 向家人或者同事讲述本章的精华，并建议大家共同拟定家庭或者团队的使用宣言。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"习惯一积极主动个人愿景原则","slug":"阅读/习惯一积极主动个人愿景原则","date":"2018-09-03T13:53:19.000Z","updated":"2018-09-03T15:01:52.000Z","comments":true,"path":"2018/09/03/阅读/习惯一积极主动个人愿景原则/","link":"","permalink":"https://huos3203.github.io/2018/09/03/阅读/习惯一积极主动个人愿景原则/","excerpt":"","text":"怎么在影响圈内,做到积极主动? 行动建议 花一整天，听听你自己和周围人的语言，你使用“但愿”、“我办不到”、“我不得不”等消极回答的频率有多高？ 根据以往的经历，想象一下将来遇到什么会让你变得消极。假如你关注的是影响圈，再考虑一下这个场景，你能怎样积极回应？用几分钟时间，在头脑里鲜活地描绘那个场景，设想你用一种积极方式进行回应。你只需要随时提醒自己被动刺激和主动回应之间的区别，不要忘记有自由选择的权利。1）多培养积极主动性 积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。2）你的圈子有多大 挑战/问题 圈子 回应 列出本周内所面临的各种挑战和问题。设法让自己的影响圈逐步扩大，选一个打算在下周改变应对方式以克服的挑战。3）采取积极主动 找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。4）试行“积极主动”原则30天，写下自己的影像圈有和变化。 1）多培养积极主动性积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。想想过去几周内自己以消极方式做出回应的两三件事情。描述一下自己是怎么说的。1231．____________________________2．____________________________3．____________________________ 现在，想想在同样情况下自己可以采取的几种积极的回应。请写在下面。1231．____________________________2．____________________________3．____________________________ 请记住，在下周仔细倾听自己使用的语言，你的语言是更积极了，还是更消极了？1______________________________ 2）你的圈子有多大写下你在本周内所面临的各种挑战和问题。它们分别归入哪个圈子？你的瞬间回应又是什么？ 挑战/问题 圈子 回应 _交通拥堵 关注圈 愤怒、咒骂 _ _ _ _ _ _ 你需要设法让自己的影响圈逐步扩大。这两个圈子中，从每个圈子选一个你本来打算在下周做出应对的挑战。你将怎样改变自己的回应以更有效地应对该挑战？1．影响圈1_________________________________ 2．关注圈 3）采取主动找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。 试行“积极主动”的原则30天，写下自己的影响圈有何变化？ 你是否有什么事情一直想做，但又觉得缺乏天赋、时间或能力？为了克服自己的弱点，你应当做些什么呢？作为一周伊始，你又能在本周做一件什么事呢？ 如果你能开发自己的一项新的才能，你想要什么？ 如果你能到世界任何一个地方去旅行，你想去哪里？ 如果你能改变自己生活中的某件事情，你想改变哪一件？ 制定让你实现上面三个愿望（对三个问题的回答）的计划，把它写下来。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"七个习惯概论","slug":"阅读/七个习惯概论","date":"2018-09-03T10:11:38.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2018/09/03/阅读/七个习惯概论/","link":"","permalink":"https://huos3203.github.io/2018/09/03/阅读/七个习惯概论/","excerpt":"","text":"七个习惯概论 高效能人士 低效能人士 习惯一：积极主动 积极主动积极主动的人绝不浅尝辄止。他们知道要为自己的抉择负责，做出的选择总是基于原则和价值观，而不是基于情绪或受限于周围条件。积极的人是变化的催生者。 消极被动消极的人不愿为自己的抉择负责，他们总是觉得自己是受害者—受到周围环境、自己的过去和他人的拖累。他们不把自己看作是生活的主人。 习惯二：以终为始 以终为始（先定目标后有行动）个人、家庭、团队、组织通过创造性的构思来设计自己的未来，他们对于任何项目，无论大小，也不管是个人的还是团队的，都下决心完成。他们标识并献身于自己生活中最重要的原则、人际关系和目标。 不定目标就行动他们缺乏个人愿景，没有目标。他们不思考生活的意义，也不愿制定使命宣言。他们的生活总是遵循社会流行的、而不是自己选择的价值观。 习惯三：要事第一 要事第一 以要事为先的人总是按照事务重要性的顺序来安排生活并付诸实践。无论情势如何，他们的生活总是遵循自己最珍视的原则。 不重要的事先做他们总是在应付各种危机。他们之所以无法关注最重要的事务，是因为他们总是纠缠于周围环境、过去的事情或人间是非。他们陷入成堆的琐事，被紧迫的事务弄得团团转。 习惯四：双赢思维 双赢思维有双赢思维的人能在交往中寻求双方获利、互相尊重。他们基于到处是机遇和富足的心态，基于“我们”而不是“我”，来进行思考。他们总是通过向感情账户存款来建立与他人的互信关系。 非赢即输他们抱的是匮乏心态，把生活看作是一场零和游戏。他们不善与他人沟通，总是从感情账户提款，结果是时时提防他人，陷入对抗的心理。 习惯五：知彼解己 知彼解己（先理解别人，再争取别人的理解） 当我们怀着理解对方的想法，而不是为了回答对方的问题去聆听时，我们就能进行真正的沟通并建立友谊。这时再坦述己见、争取理解就很自然，也容易多了。理解别人需要的是体谅，而争取别人理解需要的是勇气。效能在于这二者的平衡或适当的结合。 先寻求别人的理解 他们并未理解对方就先讲述自己的观点，完全基于自己的经验或动机。他们不先对问题做出诊断就盲目开出处方。 习惯六：统合综效 统合综效统合综效的人与对方合作，寻求第三变通方案。不是我的，也不是你的，而是第三种更好的解决方案。统合综效的基础是尊重、赞赏甚至庆贺彼此间的差异。它是某种创造性的合作，1＋1＝3，11，111，或者更多。 妥协、争斗或逃避 低效能人士相信总体小于部分之和。他们试图在自己的形象中克隆他人。他们把自己与他人的差异看作威胁。 习惯七：不断更新 不断更新（磨刀不误砍柴工） 高效能人士不断在生活的四个方面（身体、社会／情感、智力、精神）更新自己。这将增加他们实践其他有效习惯的能力。 把自己累得筋疲力尽低效能人士没有自我更新、自我改善的规划，最终失去了过去所拥有的锋利刀刃（竞争力）。 1）在七个习惯上给自己评分这个评估能帮你了解自己在实践七个习惯方面的现状。为了了解自己的进步，你可以在读完本书后重新进行一次评估。仔细阅读下列表格中的每句话，利用自己的最佳判断，圈出标识自己在每个习惯方面做得如何的数字（1表示极差，而6表示杰出）。 七个习惯上的评分 感情账户 1. 待人和蔼，体谅对方2.我信守诺言3. 我不在别人背后说他坏话。 评分：评分：评分： 产出/产能平衡 4. 我能在生活的各个方面（家庭、朋友、工作等）保持适当的平衡5.当我致力于某个项目时，总是想着业主的需求和厉害关系。6. 我努力工作，但绝不把自己累的精疲力尽。 评分：评分：评分： 习惯一：积极主动 7. 我能掌控自己的生活8. 我把关注集中于我能有所作为的事情上，而不是集中在我无法控制的事件上。9. 我敢于为自己的情绪负责，而不是埋怨环境、责备他人。 评分：评分：评分： 习惯二：以终为始 10. 我明白自己在生活中的追求什么。11. 我的生活和工作井然有序，很少陷入危急态势。12.我每周都有一个清晰的计划，注明我想完成的事情 评分：评分：评分： 习惯三：要事第一 13.我致力于完成自己的计划（避免延误、浪费时间等等）。14. 我不让日常琐事埋没了真正重要的事务。15. 我每天做的事情都是有意义的，有助于实现我的生活目标。 评分：评分：评分： 习惯四：双赢思维 16. 我关心别人的成功，就像关心自己的成功一样。17. 我能与别人合作。18. 遇到矛盾时，我努力寻求有利于各方的解决方案。 评分：评分：评分： 习惯五：知彼知己 19. 我对他人的感觉也很敏感。20. 我尽力理解对方的观点。21. 倾听时，我试图从对方的角度，而不仅从自己的角度来观察问题。 评分：评分：评分： 习惯六：统合综效 22. 我赞赏并力图了解他人的见解。23. 我竭力寻求新的、更好的想法和解决方案。24. 我鼓励他人表达他们的观点 评分：评分：评分： 习惯七：不断更新 25.我真系自己的身体和健康。26.我努力建立并改善与他人的关系。27. 我肯花时间追求生活的意义和乐趣。 评分：评分：评分： 你的习惯习惯是知识、技巧和意愿的交叉点。知识是做什么和为何做，技巧是如何做，而意愿是动力——想做。所有这三者必须集合在一起才能形成一个习惯。请列出你的两个习惯，一个好习惯，一个坏习惯。并写出关联于这两个习惯的知识、技巧和意愿。12 习惯有巨大的引力——比大多数人认识到的或愿意承认的还要大。打破一个根深蒂固的习惯需要做出极大的努力，而且一般还会涉及生活的重大变化。看看你写下的坏习惯。你愿意为了打破这个坏习惯做出一切必要的努力吗？若是，请写下三件为了打破这个习惯你将着手做的事情。请记录下你的进步过程。1231．2．3． 看一下图2-2七个习惯模型，你位于何处？花几分钟记录下你的现状及其原因。你的什么行为和态度让你处于目前这种状况？你开始看到自己最需要在哪方面做出努力了吗？12","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"七个习惯题由内而外全面造就自己","slug":"阅读/七个习惯题由内而外全面造就自己","date":"2018-09-03T10:11:38.000Z","updated":"2018-09-04T19:39:51.000Z","comments":true,"path":"2018/09/03/阅读/七个习惯题由内而外全面造就自己/","link":"","permalink":"https://huos3203.github.io/2018/09/03/阅读/七个习惯题由内而外全面造就自己/","excerpt":"","text":"由内而外全面造就自己你是否有过这种经验，做出推测时发现自己的判断过于匆忙？请对这种经验加以描述。1答: 你当时做出的推测是什么？1答: 想一下你做过的其他推测。本周你将对其中某一项采取什么行动？1答: 1）检验你的思维定式你曾经到过其他国家，或本国其他地区吗？你觉得哪些事情是陌生的或奇怪的？1答: 人们的行为是否如你预期？你对他们的行为有何看法？1答: 回想你的旅游经验，你认为当地人对你的看法如何？你是否认为他们对你的看法与你对他们的看法可能很类似？1答: 如果你有机会在旅途中认识当地人，你对他们的看法或推测会有什么改变？1答: 2）转换你的思维定式回想一下通往你的工作场所或你的家的不同途径。是否有些途径比其他的更复杂？是否有时其中一条比其他的更方便？为什么方便，为什么不方便？1答: 你是否发现过一条你以前不知道的新途径？走不同途径的新鲜感又是什么？1答: 现在想一下你与他人打交道的方式。与他们打交道是否有好几种途径？你还有可能会尝试哪些新的方式？1答: 3）影响你生活的五个原则请列出影响你的日常生活的五个原则。它们以怎样的方式影响你？它们是以积极的，还是消极的方式影响你的生活？","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"MPMoviePlayerController遇到的坑","slug":"个人项目/MPMoviePlayerController遇到的坑","date":"2018-08-31T16:58:22.000Z","updated":"2018-08-31T16:58:22.000Z","comments":true,"path":"2018/09/01/个人项目/MPMoviePlayerController遇到的坑/","link":"","permalink":"https://huos3203.github.io/2018/09/01/个人项目/MPMoviePlayerController遇到的坑/","excerpt":"","text":"问题 [MPMoviePlayerController播放过程中自动暂停的问题]在使用系统播放器MPMoviePlayerController的过程中，会出现播放器自动暂停的情况，有两种解决办法：参看1.1 在播放开始的时候，设置useApplicationAudioSession ＝ NO;1.2 重启手机，也可以恢复 why does MPMovieLoadState have state 5?1234567The playState is a bitmask. Any number of bits can be set, such asMPMovieLoadStatePlaythroughOK | MPMovieLoadStatePlayableCheck for states like this:MPMovieLoadState state = [playerController loadState];if( state &amp; MPMovieLoadStatePlaythroughOK ) &#123;NSLog(@&quot;State is Playthrough OK&quot;);&#125; 问题2投影不全屏现象：投影仪\b页面未同步现象，全屏查看视频，横屏全屏\b显示，但投影在大屏的画面没有同步 \b\b隔离业务代码，编写demo复现投影问题。ALMoviePlayerControllerGit库 demo问题解决办法：\b注释掉：- (id)initWithContentURL:(NSURL *)url方法。demo正常播放小插曲：遇到Setting device discovery mode to DiscoveryMode_None，排查之后不影响播放。故没有继续\b研究。。。 教训：必须深入代码联调测试中，本可以通过\b断点排查，查处url为nil导致demo无法的播放的原因。却长时间纠结在不必要的日志中。 通过\b在投影仪上联调测试不影响播放 1VAALMoviePlayerController[7438:3348866] [] &lt;&lt;&lt;&lt; AVOutputDeviceDiscoverySession (FigRouteDiscoverer) &gt;&gt;&gt;&gt; -[AVFigRouteDiscovererOutputDeviceDiscoverySessionImpl outputDeviceDiscoverySessionDidChangeDiscoveryMode:]: Setting device discovery mode to DiscoveryMode_None (client: VAALMoviePlayerController) 通过百度有两种方式：1.在viewwillapear中添加player=nilAVPlayer is not playing in iOS 11AVPlayerViewController black screen when swiping on iOS 11 2.将工程设置为arc=YES MP4音频不同步\b\b现象：视频播放到待定的时间点，画面卡顿，拖动进度条，声音画面不同步，复现：《视频美国儿童思维导图特训营》第一课：21:00时长复现","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"Thisdeviceisnotcurrentlyonline","slug":"调试/Thisdeviceisnotcurrentlyonline","date":"2018-08-31T16:58:22.000Z","updated":"2018-08-31T16:58:22.000Z","comments":true,"path":"2018/09/01/调试/Thisdeviceisnotcurrentlyonline/","link":"","permalink":"https://huos3203.github.io/2018/09/01/调试/Thisdeviceisnotcurrentlyonline/","excerpt":"","text":"参考 you can restart your device! then connect your device to your mac-&gt;open Xcode-&gt;press command + i I’ve encountered this issue today. The record button is disabled and the tooltip says “This device is not currently online”. However my iPhone is connecting with my Mac and can be debugged with Xcode without any problem.","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"使用Instruments的工具","slug":"调试/使用Instruments的工具","date":"2018-08-31T16:58:22.000Z","updated":"2018-08-31T16:58:22.000Z","comments":true,"path":"2018/09/01/调试/使用Instruments的工具/","link":"","permalink":"https://huos3203.github.io/2018/09/01/调试/使用Instruments的工具/","excerpt":"","text":"\b检测app内存爆增\b代码，优化性能Instruments工具使用办法整理Demo，列出几种常用instrument的场景。来熟悉具体操作demo 集成归档模块代码，测试内存上升问题","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"解决Xcode代码高亮提示功能失效","slug":"xcode/解决Xcode代码高亮提示功能失效","date":"2018-08-31T16:20:20.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/09/01/xcode/解决Xcode代码高亮提示功能失效/","link":"","permalink":"https://huos3203.github.io/2018/09/01/xcode/解决Xcode代码高亮提示功能失效/","excerpt":"","text":"方法一 打开失效的项目，选择菜单：Xcode-&gt;File-&gt;Project Settings -&gt; Advanced..， 删除图上所示的位置目录，重启xcode。方式二 cd进入~/Library/Developer/Xcode/DerivedData 找到你的项目所用的目录（一般以你的项目名开头） cd 目录名 rm -r Index 删除掉你的项目所用的索引文件夹方法三 退出 Xcode 重启电脑 找到 这个 DerivedData 文件夹 删除 (路径: ~/Library/Developer/Xcode/DerivedData) 删除这个 com.apple.dt.Xcode 文件 (路径: ~/Library/Caches/com.apple.dt.Xcode) 运行 Xcode 就好了~~ (1) 原文表示删除 ~/Library/Developer/Xcode/DerivedData下所有的文件，我尝试发现只需要删除当前项目相关的索引文件即可(2) DerivedData从字面上理解应该是收集到的数据，应该是Xcode针对这个项目缓存的一些数据，不会影响项目本身的完整性","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[]},{"title":"Chisel-LLDB命令插件","slug":"调试/Chisel-LLDB命令插件","date":"2018-08-31T16:20:20.000Z","updated":"2018-10-17T19:47:48.000Z","comments":true,"path":"2018/09/01/调试/Chisel-LLDB命令插件/","link":"","permalink":"https://huos3203.github.io/2018/09/01/调试/Chisel-LLDB命令插件/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-facebook-chisel-56d0e0d\", \"facebook\", \"chisel\", \"56d0e0d\", false); LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(这里有一个关于调试器如何工作的总体的解释。) Chisel 为lldb提供了新增的便捷命令，是非常实用的命令。 pviews这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription] 。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。123456789(lldb) pviews view&lt;TestView: 0x18df8070; baseClass = UIControl; frame = (144 9; 126 167); layer = &lt;CALayer: 0x18df8150&gt;&gt;| &lt;UIView: 0x18df81d0; frame = (0 0; 126 126); userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df8240&gt;&gt;| &lt;UIImageView: 0x18df8330; frame = (0 0; 126 126); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df83b0&gt;&gt;| &lt;UILabel: 0x18df8460; frame = (0 135; 126 14); text = &apos;haha&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x18df7fb0&gt;&gt;| | &lt;_UILabelContentLayer: 0x131a3d50&gt; (layer)| &lt;UILabel: 0x18df8670; frame = (0 155; 126 12); text = &apos;hahaha&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x18df8730&gt;&gt;| | &lt;_UILabelContentLayer: 0x131bea10&gt; (layer)| &lt;UIImageView: 0x18df88d0; frame = (0 9; 28 27); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x18df8ba0&gt;&gt; pvc这个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy] 同样的效果。1234567891011121314(lldb) pvc&lt;TabBarController: 0x13772fd0; view = &lt;UILayoutContainerView; 0x151b3a30&gt;; frame = (0, 0; 414, 736)&gt;| &lt;UINavigationController: 0x1602b800; view = &lt;UILayoutContainerView; 0x1b00aca0&gt;; frame = (0, 0; 414, 736)&gt;| | &lt;FirstViewController: 0x16029c00; view = &lt;UIView; 0x1b01e1c0&gt;; frame = (0, 0; 414, 736)&gt;| &lt;UINavigationController: 0x138c5200; view = &lt;UILayoutContainerView; 0x1316a080&gt;; frame = (0, 0; 414, 736)&gt;| | &lt;SecondViewController: 0x16030400; view = &lt;UIView; 0x2094b370&gt;; frame = (0, 0; 414, 736)&gt;| | | &lt;SecondChildViewController: 0x15af6000; view = &lt;UIView; 0x18d4e650&gt;; frame = (0, 64; 414, 628)&gt;| &lt;UINavigationController: 0x1383ca00; view = &lt;UILayoutContainerView; 0x13180070&gt;; frame = (0, 0; 414, 736)&gt;| | &lt;ThirdViewController: 0x138ddc00; view = &lt;UIView; 0x18df6650&gt;; frame = (0, 0; 414, 736)&gt;| | | &lt;ThirdChild1ViewController: 0x1393fe00; view = &lt;UIView; 0x131ec000&gt;; frame = (0, 0; 414, 672)&gt;| | | &lt;ThirdChild2ViewController: 0x138dce00; view = &lt;UIView; 0x204075a0&gt;; frame = (414, 0; 414, 672)&gt;| | | &lt;ThirdChild3ViewController: 0x138a8e00; view = &lt;UIView; 0x20426250&gt;; frame = (828, 0; 414, 672)&gt;| &lt;UINavigationController: 0x160eca00; view = &lt;UILayoutContainerView; 0x152f7d90&gt;; frame = (0, 0; 414, 736)&gt;| | &lt;FourViewController: 0x13157cc0; view not loaded&gt; visualize这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。1(lldb) visualize imageView fv &amp; fvcfv 和 fvc 这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。123456789(lldb) fv scrollView0x18d3b8c0 UIScrollView0x137d0c50 UIScrollView0x131b1580 UIScrollView0x131b2070 UIScrollView(lldb) fvc Home0x1393fe00 HomeFeedsViewController0x138a8e00 HomeFeedsViewController(lldb) show &amp; hide这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。例, 其中 $122 即是目标UIView：1234(lldb) p view(long) $122 = 140718754142192(lldb) e (void)[$122 setBackgroundColor:[UIColor greenColor]](lldb) caflush bmessage使用场景：我们想在 [MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear: 方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点：(lldb) bmessage -[MyViewController viewWillAppear:] 上面命令会在其父类的 viewWillAppear:方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]]. Chisel-LLDB命令插件，让调试更Easy","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/tags/调试/"},{"name":"插件","slug":"插件","permalink":"https://huos3203.github.io/tags/插件/"}]},{"title":"LLDB命令使用","slug":"调试/LLDB命令使用","date":"2018-08-31T16:20:20.000Z","updated":"2018-10-17T19:47:48.000Z","comments":true,"path":"2018/09/01/调试/LLDB命令使用/","link":"","permalink":"https://huos3203.github.io/2018/09/01/调试/LLDB命令使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); help最简单命令是 help，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 help 来了解更多细节，例如 help print 或者 help thread。如果你甚至忘记了 help 命令是做什么的，你可以试试 help help。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。 打印变量可以给 print 指定不同的打印格式。它们都是以 print/&lt;fmt&gt; 或者简化的 p/&lt;fmt&gt; 格式书写。下面是一些例子：默认的格式:12(lldb) p 1616 十六进制:12(lldb) p/x 160x10 二进制 (t 代表 two)：1234(lldb) p/t 160b00000000000000000000000000010000(lldb) p/t (char)160b00010000 你也可以使用 p/c 打印字符，或者 p/s 打印以空终止的字符串 (译者注：以 ‘\\0’ 结尾的字符串)。这里是格式的完整清单。 完全在调试器内运行在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 C/Objective-C/C++/Swift 的命令。唯一的缺点就是不能创建新函数… 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/tags/调试/"}]},{"title":"RxSwift爬虫工具","slug":"个人项目/RxSwift爬虫工具","date":"2018-08-28T12:03:26.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/08/28/个人项目/RxSwift爬虫工具/","link":"","permalink":"https://huos3203.github.io/2018/08/28/个人项目/RxSwift爬虫工具/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-ReptileTool-60cac75\", \"huos3203\", \"ReptileTool\", \"60cac75\", false); 目的 实践大话设计模式/swift基础语法/函数响应式开发 正则表达式语法.aspx)iOS开发之详解正则表达式原文：NSRegularExpression Tutorial: Getting Startednshipster文章NSPredicateiOS中的谓词（NSPredicate）使用 简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。正则表达式的通用用例： 执行搜索：高亮显示搜索和替换 UITextView的NSAttributedString属性来高亮显示搜索的结果 用text kit来实现高亮的功能 验证用户输入 先来看看网络爬虫的基本原理：一个通用的网络爬虫的框架如图所示： 网络爬虫的基本工作流程如下： 首先选取一部分精心挑选的种子URL； 将这些URL放入待抓取URL队列； 从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。网络数据抓取 概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。 今天先来介绍一下第一种：正则表达式","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"使用Safari浏览器调试WebView","slug":"调试/使用Safari浏览器调试WebView","date":"2018-08-23T13:34:25.000Z","updated":"2018-08-28T12:03:26.000Z","comments":true,"path":"2018/08/23/调试/使用Safari浏览器调试WebView/","link":"","permalink":"https://huos3203.github.io/2018/08/23/调试/使用Safari浏览器调试WebView/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-width-=\", \"huos3203\", \"width\", \"=\", false); 使用RxSwift开发爬虫工具设置真机 首先打开模拟器或者真机设置中”Safari浏览器”→”高级”→”Web检查器”的开关。 然后我们打开Mac电脑的Safari浏览器,打开系统偏好设置(快捷键 commond + ,)，点击菜单中的”高级”,然后勾选”在菜单栏中显示”开发”菜单”.方便我们进行快速的调试。 这时候真机连接上数据线.或者开启模拟器就能在菜单栏”开发”选项中找到我们的设备或者是模拟器. 接下来我们只需要跑起我们的工程进入对应的WebView页面即可进行调试.","categories":[{"name":"调试","slug":"调试","permalink":"https://huos3203.github.io/categories/调试/"}],"tags":[]},{"title":"RxSwift函数响应式开发","slug":"开源库/RxSwift函数响应式开发","date":"2018-08-23T09:56:38.000Z","updated":"2018-10-05T21:42:36.000Z","comments":true,"path":"2018/08/23/开源库/RxSwift函数响应式开发/","link":"","permalink":"https://huos3203.github.io/2018/08/23/开源库/RxSwift函数响应式开发/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-beeth0ven-RxSwift-Chinese-Documentation-cbbc87e\", \"beeth0ven\", \"RxSwift-Chinese-Documentation\", \"cbbc87e\", false); RxSwift学习RxSwift 中文文档 更多示例 RxExample 中包含许多具有代表性的示例。它们都是很好的学习材料。这里我们取出其中几个示例来展示如何应用 RxSwift ：演示RxExample的两种方式 clone库，在根目录执行：1open Rx.xcworkspace 然后，选择想要演示的schemes (RxExample-iOS, RxExample-OSX) and hit Run。 使用pod工具创建RxExample项目1pod try RxSwift ImagePicker - 图片选择器 TableViewSectionedViewController - 多层级的列表页 Calculator - 计算器 有兴趣的同学还可以研究一下 RxExample 中其他的示例。","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"GitBook编辑器使用","slug":"hexo/GitBook编辑器使用","date":"2018-08-22T19:51:19.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2018/08/23/hexo/GitBook编辑器使用/","link":"","permalink":"https://huos3203.github.io/2018/08/23/hexo/GitBook编辑器使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-GitbookIO-gitbook-6efbb70\", \"GitbookIO\", \"gitbook\", \"6efbb70\", false); GitBook Editor个人中心 制作书籍 在github找到文档库，fork为自己的库 登录GitBook个人中心，点击+ New新建book 在建库页面，选择导入git hub现有库 Import and sync an existing GitHub repository. 进入Personal settings，进入github设置面板 点击Configure按钮，进入github授权gitbook页面GitBook does not have the permissions to access every GitHub repositories linked to your books. Please add them to your configuration to continue editing your books. github中设置 Repository access All repositories This applies to all current and future repositories. Only select repositories gitbook终端命令行命令行文档GitBook 制作 Kindle 电子书详细教程（命令行版） 安装 1$ npm install gitbook-cli -g 创建电子书项目新建一个目录，并进入该目录使用 gitbook 命令初始化电子书项目。举个例子，现在要创建一个名为“MyFirstBook”的空白电子书项目，如下所示： 123$ mkdir MyFirstBook$ cd MyFirstBook$ gitbook init 预览电子书内容电子书内容编写完毕后可以使用浏览器预览一下。先输入下面的命令据 .md 文件生成 HTML 文档： 1$ gitbook build Error: Couldn’t locate plugins “jsbin, anchors, video, ga, toggle-chapters, editlink, include-codeblock, splitter, github-buttons, chart, todo, quiz, include-highlight, tonic”, Run ‘gitbook install’ to install plugins from registry.执行安装插件命令：1gitbook install 生成完毕后，会在电子书项目目录中出现一个名为“_book”的文件夹。进入该文件夹，直接用浏览器打开“index.html”，或先输入下面的命令：1$ gitbook serve 然后在浏览器中输入“http://localhost:4000”即可预览电子书内容，预览完毕后按 Ctrl + C 结束。 生成电子书文件确定电子书没有问题后，可以通过输入以下命令生成 mobi 电子书：1$ gitbook mobi ./ ./MyFirstBook.mobi error: error while generating page “introduction.md”: InstallRequiredError:”svgexport” is not installed. Install it using: “npm install svgexport -g”执行安装命令：1npm install svgexport -g 如果出现以下错误提示，说明您还未安装 Calibre。由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以请先点击这里下载安装 Calibre。123Error: Need to install ebook-convert from Calibre//或者使用命令安装brew install homebrew/cask/calibre Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：1$ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 再次运行转换命令，即可生成 mobi 格式电子书。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"SwiftLint检查代码使用","slug":"shell/SwiftLint检查代码使用","date":"2018-08-21T17:02:47.000Z","updated":"2018-10-19T16:16:34.000Z","comments":true,"path":"2018/08/22/shell/SwiftLint检查代码使用/","link":"","permalink":"https://huos3203.github.io/2018/08/22/shell/SwiftLint检查代码使用/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-realm-SwiftLint-8deb453\", \"realm\", \"SwiftLint\", \"8deb453\", false); 安装配置swiftlint语法矫正工具安装包方式brew install swiftlint 或下载[swiftlint.pkg][https://github.com/realm/SwiftLint/releases/latest] Xcode项目支持在Xcode build Phase新增 “Run Script Phase”:12345if which swiftlint &gt;/dev/null; thenswiftlintelseecho \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"fi 单个项目安装swiftlint 通过cocoapods对单个项目安装swiftlint 1pod &apos;SwiftLint&apos; 项目中添加支持 1&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot; 注意：pod服务器上有时并不是最新版本，尝试:=&gt; githuburl无用。这种情况智能使用安装包方式。 规则配置文件.swiftlint.yml让 SwiftLint 在做代码规范检查时，不想检查某些源码，可以隔离规则，来自动忽略，例如： CocoaPods、Carthage、SPM 引入的第三方库文件。在项目中新建 .swiftlint.yml 的配置文件：12345$ cd your-project$ vi .swiftlint.ymlexcluded: - Pods excluded： 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件。支持嵌套：.swiftlint.yml 配置文件支持嵌套，可以给每个文件夹下的代码单独指定不同的规则，每个文件会匹配距离自己层级最近的父文件夹中的配置文件嵌套的配置文件中的 excluded 和 included 配置会被忽略。 终端插件集成swiftLint支持vim编辑器：keith/swift.vim 安装 syntastic使用vim-pathogen安装syntastic， 第一步安装 pathogen.vim12mkdir -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \\curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 设置~/.vimrc配置项：1execute pathogen#infect() 第二步将syntastic 作为 Pathogen bundle的资源方式安装12cd ~/.vim/bundle &amp;&amp; \\git clone --depth=1 https://github.com/vim-syntastic/syntastic.git 终端集成使用在vimrc中添加配置，当启动vim即可使用：1let g:syntastic_swift_checkers = ['swiftpm', 'swiftlint'] 终端支持Package.swift当存在Package.swift的swift目录中启动vim，swiftpm将自动可用。 终端支持.swiftlint.yml当存在.swiftlint.yml的swift目录中启动vim，且SwiftLint已安装，自动启用swiftlint。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"终端支持swift自动补齐","slug":"shell/终端支持swift自动补齐","date":"2018-08-21T15:48:24.000Z","updated":"2018-08-21T17:46:05.000Z","comments":true,"path":"2018/08/21/shell/终端支持swift自动补齐/","link":"","permalink":"https://huos3203.github.io/2018/08/21/shell/终端支持swift自动补齐/","excerpt":"","text":"终端支持swift自动补齐keith/sourcekittendaemon.vim：这个插件提供了Vim集成SourceKittenDaemon。这意味着你可以在vim中开发swift项目需要两步：安装sourcekitten, 第一步安装sourcekitten 安装方式一：brew install sourcekitten方式二：clone源码 ,运行swift build方式三：clone 源码，运行 make install方式三：pkg安装包 执行sourcekitten help验证安装成功。 第二步安装:SourceKittenDaemon 安装SourceKittenDaemon环境安装并设置SourceKittenDaemon方式一：pkg安装包方式二: 1. Clone the repository 2. 安装 make install 执行SourceKittenDaemon help验证安装成功。 使用启动后台驻守服务HTTP：参考Protocol.org1SourceKittenDaemon start --port 44876 --project /private/tmp/abcde/abcde.xcodeproj --port: 服务使用的端口号，默认为8081，vim目前不支持指定SourceKittenDaemon端口，使用默认的8081。--project=: 指定服务将要加载的.xcodeproj文件路径，不支持指定.xcworkspaces文件路径 使用get方法请求后驻服务：12345/complete # X-Offset|X-Path|X-File/stop # 停止后驻服务. 一般用于为其他target提供服务时，重新启动服务。/ping # ping后驻服务，运行正常 return OK/project # 打印当前加载的project文件路径。/files # 打印一个当前加载的project中包含的所有swift文件列表","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"markdown-preview实现md预览","slug":"shell/markdown-preview实现md预览","date":"2018-08-21T10:40:31.000Z","updated":"2018-08-21T10:40:31.000Z","comments":true,"path":"2018/08/21/shell/markdown-preview实现md预览/","link":"","permalink":"https://huos3203.github.io/2018/08/21/shell/markdown-preview实现md预览/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-iamcco-markdown-preview.vim-c09a1ca\", \"iamcco\", \"markdown-preview.vim\", \"c09a1ca\", false); nisha 命令行使用12345MarkdownPreview\" open preview window in markdown bufferMarkdownPreviewStop\" close the preview window and server 插件运行效果预览","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"图文组件及多媒体组件类图","slug":"个人项目/图文组件及多媒体组件类图","date":"2018-08-18T14:36:18.000Z","updated":"2018-08-22T20:52:16.000Z","comments":true,"path":"2018/08/18/个人项目/图文组件及多媒体组件类图/","link":"","permalink":"https://huos3203.github.io/2018/08/18/个人项目/图文组件及多媒体组件类图/","excerpt":"","text":"","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"iCompleteMe支持swift语法提示","slug":"shell/iCompleteMe支持swift语法提示","date":"2018-08-10T16:40:19.000Z","updated":"2018-08-10T18:42:08.000Z","comments":true,"path":"2018/08/11/shell/iCompleteMe支持swift语法提示/","link":"","permalink":"https://huos3203.github.io/2018/08/11/shell/iCompleteMe支持swift语法提示/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-jerrymarino-iCompleteMe-ad0e1fe\", \"jerrymarino\", \"iCompleteMe\", \"ad0e1fe\", false); iCompleteMe是基于YouCompleteMe。在花了一年多的时间试图实现对YouCompleteMe的快速支持之后，发现在YCM无法支持swift自动补齐。iCompleteMe实现的行为对于Swift的补齐提示。iCompleteMe的核心子系统只与Swift一起工作。代码基占用的空间要小得多，这使得在CI上更容易安装、更容易理解和更稳定(理论上)。 在space-vim中添加插件支持1Plugin &apos;jerrymarino/iCompleteMe&apos; 安装：123cd ~/.vim/plugged/iCompleteMe/brew install cmake./install.py 然后 &lt;Leader&gt; f R 使配置生效，并执行 :PlugInstall进行安装.","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"SwiftPlayground命令操作","slug":"shell/SwiftPlayground命令操作","date":"2018-08-10T15:50:21.000Z","updated":"2018-09-29T15:26:30.000Z","comments":true,"path":"2018/08/10/shell/SwiftPlayground命令操作/","link":"","permalink":"https://huos3203.github.io/2018/08/10/shell/SwiftPlayground命令操作/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-jerrymarino-SwiftPlayground.vim-f603700\", \"jerrymarino\", \"SwiftPlayground.vim\", \"f603700\", false); 执行环境在playgrounds后缀的目录中执行swift文件 熟悉vim快捷键用法空格 + fs 保存文件：此时插件会自动运行playgrounds，显示效果shift + H ：行头shift + L：行尾:copen : AsyncRun显示运行日志:AsyncRun shell命令 支持结构*.playgroud/Contents.swift不支持包含：Pages页面的playground。","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"FSCalendar支持自定义的日历开源库","slug":"开源库/FSCalendar支持自定义的日历开源库","date":"2018-07-17T17:59:05.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/07/18/开源库/FSCalendar支持自定义的日历开源库/","link":"","permalink":"https://huos3203.github.io/2018/07/18/开源库/FSCalendar支持自定义的日历开源库/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-FSCalendar-1a026a4c\", \"huos3203\", \"FSCalendar\", \"1a026a4c\", false); 自定义日历控件，日期图标 FSCalendarFSCalendar是一款开源iOS日历控件，支持横向、纵向滑动模式，全屏模式，带有子标题、事件设置等功能。以下是项目截图：Use Interface Builder1、 Drag an UIView object to ViewController Scene 2、 Change the Custom Class to FSCalendar3、 Link dataSource and delegate to the ViewController4、 Finally, implement FSCalendarDataSource and FSCalendarDelegate in your ViewController 预览效果","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"高效人士的七个习惯","slug":"阅读/高效人士的七个习惯","date":"2018-07-03T12:30:31.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2018/07/03/阅读/高效人士的七个习惯/","link":"","permalink":"https://huos3203.github.io/2018/07/03/阅读/高效人士的七个习惯/","excerpt":"","text":"豆瓣导图豆瓣总结 前言 如何善用本书第一部分 重新探索自我第一章 由内而外全面造就自己第二章 七个习惯——概论第二部分 个人的成功：从依赖到独立第三章 习惯一：积极主动——个人愿景的原则第四章 习惯二：以终为始——自我领导的原则个人使命宣言以终为始最有效的方法，就是撰写一份个人使命宣言，即人生哲学或基础信念。宣言：主要说明自己想成为怎样的品行的人。成什么样的事业，及为此奠基的价值观和原则。家庭第一借重宗教的力量在诚信问题上决不妥协念及相关的每个人未听取正反双方的意见，不妄下断语征求他人意见维护不在场的人诚恳但立场坚定每年掌握一种新技能今天计划明天的工作利用等待的空闲时间态度积极保持幽默感生活与工作有条不紊别怕犯错，怕的是不能吸取教训协助属下成功多请教别人专注于当前的工作，不为下一次任务或提升操心 定期储蓄或利用部分收入做投资 一个人的应变能力取决于他对自己的本性，人生目标以及价值观的不变的信念。只要心中秉持着恒久不变的真理，就能屹立于动荡的环境中。 标记疗法的基础原理：许多心智或情感疾病，都是由于失落感或空虚感作祟，而标记疗法可以帮助病人找回生命的意义与使命感，以祛除这些感觉。 第五章 习惯三：要事第一——自我管理的原则豆瓣笔记 第三部分 公众的成功：从独立到互赖第六章 你不是一座孤岛第七章 习惯四：双赢思维——人际领导的原则第八章 习惯五：知彼知己——同理心交流的原则第九章 习惯六：统合综效——创造性合作的原则第四部分 全面观照生命第十章 习惯七：不断更新——平衡的自我更新的原则第十一章 再次由内而外造就自己附录一、你是哪种类型的人？——生活重心面面观二、第四代时间管理——高效能人士的一天","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"程序员跳槽全攻略","slug":"阅读/程序员跳槽全攻略","date":"2018-07-02T19:52:08.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2018/07/03/阅读/程序员跳槽全攻略/","link":"","permalink":"https://huos3203.github.io/2018/07/03/阅读/程序员跳槽全攻略/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"书都不会读还想成功","slug":"阅读/书都不会读还想成功","date":"2018-07-02T13:59:35.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2018/07/02/阅读/书都不会读还想成功/","link":"","permalink":"https://huos3203.github.io/2018/07/02/阅读/书都不会读还想成功/","excerpt":"","text":"处境人到中年，职场受排挤降级，情场被抛弃不如意，怨天尤人，自怨自艾，却不思进取，死扛着压力勉强养家糊口残喘于世。 心态转折 红皇后的故事：寓意为什么在现实生活中不进则退的境地，见贤思齐，善于发现同事优点，定位榜样学习实线。读书习惯 100天33本书: 从量到质达到，培养读书习惯的目的。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"Framework实现使用swift开发","slug":"swift/Framework实现使用swift开发","date":"2018-06-23T16:41:58.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/06/24/swift/Framework实现使用swift开发/","link":"","permalink":"https://huos3203.github.io/2018/06/24/swift/Framework实现使用swift开发/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-JHHomeAPP-813e4b\", \"huos3203\", \"JHHomeAPP\", \"813e4b\", false); 在静态库组件中使用swift开发基于静态库的开发，实现封装静态库/Framework并使用swiftOC混编开发 创建三个角色 主项目：JHHomeAPP 静态库组件：FirstPlug SwiftInStaticLib(包含Swift源码实现的静态库) 动态库secondFramework 静态库：问题1当静态库组件中存在swift源码时，依赖该组件的主工程会报错：12345678ld: warning: Auto-Linking library not found for -lswiftDispatchld: warning: Auto-Linking library not found for -lswiftCoreFoundationld: warning: Auto-Linking library not found for -lswiftObjectiveCld: warning: Auto-Linking library not found for -lswiftDarwinld: warning: Auto-Linking library not found for -lswiftFoundationld: warning: Auto-Linking library not found for -lswiftCoreGraphicsld: warning: Auto-Linking library not found for -lswiftCoreld: warning: Auto-Linking library not found for -lswiftSwiftOnoneSupport 联想方法：设置 Always Embed Swift Standard Libraries: YES结果无效。 适用的解决方法在主工程中新建一个空的swift源文件，不需要自动新建$(SWIFT_MODULE_NAME)-Swift.h映射文件和JHHomeAPP/JHHomeAPP-Bridging-Header.h头文件。使用方法2，问题1就不存在了，证明了在静态库中可以使用swift源码文件进行开发,同样证明了静态库可以封装包含swift源码的静态库。 Framework：问题2 在动态库中objc源码方法可以封装到静态库，并在可执行文件中调用。 当在Framework中新建swift源文件时，第一次编译运行出现崩溃问题：123dyld: Library not loaded: @rpath/libswiftCoreImage.dylibReferenced from: .../../Debug-iphonesimulator/SecondFramework.framework/SecondFrameworkReason: image not found 解决办法：需要在ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES设置为YES.再次编译出现问题3。 Framework: 问题3当在oc源码文件中用引用-Swift.h头文件时，出现一下问题:123&apos;SecondFramework-Swift.h&apos; file not found#import &quot;SecondFramework-Swift.h&quot;^~~~~~~~~~~~~~~~~~~~~~~~~ 结果将：Install Objective-C Compatibility Header : NO可以正常调用swift方法了。 验证：framework可以封装到静态库中，当有swift源码实现时需要设置ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES 总结 Product Module Name: 该项默认为项目名或自定义的名称 Defines Module: 设置为YES （framework默认为YES，静态库默认为NO） Embedded Content Contains Swift: 设置为YES Install Objective-C Compatibility Header：设置为YES （如上题说：在framework中设置为NO，才能正常运行，在静态库中似乎不影响） Objective-C Bridging Header: 自定义需要桥接到Swift中的OC头文件（EX：$(SRCROOT)/Swift-Bridging-Header.h）","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"使用CocoaPods开发静态库","slug":"macOS/使用CocoaPods开发静态库","date":"2018-06-21T21:37:16.000Z","updated":"2018-10-04T23:48:07.000Z","comments":true,"path":"2018/06/22/macOS/使用CocoaPods开发静态库/","link":"","permalink":"https://huos3203.github.io/2018/06/22/macOS/使用CocoaPods开发静态库/","excerpt":"","text":"Cocoapods作为OS X和iOS开发平台的类库管理工具，已经非常完善和强大。通常我们用pod来管理第三方开源类库，但我们也极有可能会开发一个用pod管理依赖关系的静态类库给其他人使用，而又不愿意公开源代码，比如一些SDK，那么就需要打包成.a文件。本文将以一个依赖于ASIHTTPRequest的静态类库，来演示如何创建使用了CocoaPods的静态类库以及打包的过程。 开发静态库（Static Library）搭建pod静态库项目不基于pod手动创建(deprecated) 在Xcode中创建一个Cocoa Touch Static Library； 创建Podfile文件； 执行pod install完成整个项目的搭建； 如果需要demo，手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行pod install完成示例项目的搭建。 基于pod自动创建只需要输入pod lib命令即可完成初始项目的搭建，下面详细说明具体步骤，以JHLib作为项目名演示。1.执行命令pod lib create JHLib。在此期间需要确认下面4个问题。 打包类库需要使用一个cocoapods的插件cocoapods-packager来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。 安装打包插件终端执行以下命令 1sudo gem install cocoapods-packager 打包命令很简单，执行 1pod package BZLib.podspec --library --force 其中--library指定打包成.a文件，如果不带上将会打包成.framework文件。--force是指强制覆盖。最终的目录结构如下123|____BZLib.podspec|____ios| |____libBZLib.a 需要特别强调的是，该插件通过对引用的三方库进行重命名很好的解决了类库命名冲突的问题。比如你的类库使用了ASI，然后打包成静态库.a文件。外部调用的项目也使用了ASI，那么不会造成冲突。因为在打包的时候，你的类库里的ASI被重命名为项目+ASI的前缀。 如何打造一个让人愉快的框架使用CocoaPods开发并打包静态库iOS动态库,静态库以及framework","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"使用tag管理多个相关组件的版本发布","slug":"git/使用tag管理多个相关组件的版本发布","date":"2018-06-20T17:22:37.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"2018/06/21/git/使用tag管理多个相关组件的版本发布/","link":"","permalink":"https://huos3203.github.io/2018/06/21/git/使用tag管理多个相关组件的版本发布/","excerpt":"","text":"tag标签自增新建脚本123456#!/bin/shtag=$(git describe --tags `git rev-list --tags --max-count=1`)version=$&#123;tag##*.&#125;let \"version+=1\"newTag=$&#123;tag%.*&#125;.$&#123;version&#125;echo 'Create New Tag '$newTag 修改tag版本号的方法方法一：覆盖 已有v1.0.2.8要覆盖该版本 1git tag -f v1.0.2.8 服务器已有v1.0.2.8，强制推到服务器 1git push origin -f v1.0.2.8 同步服务器：获取服务器刚刚的v1.0.2.8 1git fetch -–tag 方法：删除分支 删除本地版本 1git tag -d v1.0.2.8 删除服务器上的分支(用空版本覆盖) 1git push origin :v1.0.2.8 服务器获取刚刚的v1.0.2.8 1git fetch –-tag","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"弧形表盘进度仪表","slug":"个人项目/弧形表盘进度仪表","date":"2018-06-20T15:31:52.000Z","updated":"2018-06-25T20:51:24.000Z","comments":true,"path":"2018/06/20/个人项目/弧形表盘进度仪表/","link":"","permalink":"https://huos3203.github.io/2018/06/20/个人项目/弧形表盘进度仪表/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-ArcProgressUI-4b9bc85\", \"huos3203\", \"ArcProgressUI\", \"4b9bc85\", false); ArcProgressUIExampleTo run the example project, clone the repo, and run pod install from the Example directory first. RequirementsInstallationArcProgressUI is available through CocoaPods. To installit, simply add the following line to your Podfile: 1pod 'ArcProgressUI' API使用独立进度表盘加载12345#import \"ArcProgressView.h\"NSArray *viewArr = [[NSBundle mainBundle] loadNibNamed:@\"ArcProgressView\" owner:nil options:nil];UIView *arcView = viewArr.lastObject;arcView.backgroundColor = [UIColor redColor];[self.view addSubview:arcView]; 完整控制器页面12345678910#import \"PatrolScoreViewController.h\"+(PatrolScoreViewController *)withStoryboard:(PatrolScoreStyle)style&#123;NSBundle *podbundle = [NSBundle bundleForClass:[PatrolScoreViewController class]];NSURL *bundleURL = [podbundle URLForResource:@\"ArcProgressUI\" withExtension:@\"bundle\"];NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];UIStoryboard *story = [UIStoryboard storyboardWithName:@\"PatrolScore\" bundle:bundle];PatrolScoreViewController *VC = [story instantiateViewControllerWithIdentifier:@\"PatrolScoreViewController\"];VC.scoreViewStyle = style;return VC;&#125; 静态库开发：设想：通过cocoapod管理静态库的依赖关系。在项目调用静态库 主工程：prj 一级静态库: first.a ：组件 二级静态库：组件依赖的静态库 sec.a : 二级静态库.a pod.a ：包含二级静态库的集合 其他经验：通过pod来开发一级静态库即组件。会生成组件的工作空间：workspace 将prj主工程拖入工作空间，来协作开发。 坑：当再次切换prj主工程,关联.a组件依赖时，例如：libJHPatrol.a的other linker tag 路径一定要更新。 结果： 手动配置一级静态库组件，依赖的二级静态库可用资源bundle文件直接添加到主工程资源拷贝列表中，在代码中会正常映射出IBoutlet相应的UI实例。参见 上述使用说明 -ObjC设置在主工程build setting 配置的Other linker ：-ObjC：表示尽可能的加载所有依赖静态库中的objc源码资源。解决的问题：可以解决通过资源（xib/storyboard）初始化实例式1this class is not key value coding-compliant for the key ibReviewLabel 解决在storyboard中使用源码自定义UI控件时，无效果的问题。 在封装静态库中，storyboard/xib中的控件不要设置model属性。 使用pod来一级静态库组件，管理依赖的二级静态库libpod.a无效 Authorhuo3203@hotmail.com, 724987481 LicenseArcProgressUI is available under the MIT license. See the LICENSE file for more info.","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"storyboard的几种方式","slug":"iOS/UI/storyboard的几种方式","date":"2018-06-20T14:49:37.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2018/06/20/iOS/UI/storyboard的几种方式/","link":"","permalink":"https://huos3203.github.io/2018/06/20/iOS/UI/storyboard的几种方式/","excerpt":"","text":"通过IB（xib/storyboard）创建View的周期方法 loadView：加载View方法，UI是通过代码绘制时，初始化控制器的视图时，会调用该方法。优先级高于IB视图，当重载时，会直接覆盖IB中的视图,因为无论nib也好，xib也好，最终在执行UIViewController生命周期函数loadView之前，都会转化成可执行的nib文件。 initWithNibName：是类的构造器方法，通过IB创建的类：简称IB类，IB类需要通过这个构造器来实例化对象。 initWithCoder：当IB类实例化时会调用该方法，即通过initWithNibName构造器实例化对象时，会调用该方法来分配IB对象的内存空间。 awakeFromNib：当实例化IB视图类时执行，即当IB文件被加载的时候，会发送一个awakeFromNib的消息到IB文件中的每个的对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。 帮助记忆：一开始经过initWithCoder创建出来的控件是死的，然后通过awakeFromNib来唤醒，所以这会有一个先后的调用顺序 viewDidLoad：当view对象被加载到内存后就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad 。 加载xib方法加载视图方法一123456 NSArray* nibView = [[NSBundle mainBundle] loadNibNamed:@\"xibfileName\" owner:nil options:nil]; UIView *xibView = nibView.lastObject;//======= // 这里的bundle参数是nil,(这里nil默认就是mianBundle) UINib *nib = [UINib nibWithNibName:@\"xib文件名\" bundle:nil]; NSArray *views = [nib instantiateWithOwner:nil options:nil]; 方法二owner:xib中的fileObject参数12345//加载所有xib文件NSArray* objects = [[NSBundle mainBundle] loadNibNamed:nibName owner:self options:nil];//加载指定xib文件ContactsTableViewCell *cell = [[[NSBundle mainBundle]loadNibNamed:@\"ContactsTableViewCell\" owner:nil options:nil] objectAtIndex:0]; 加载控制器对象1self = [super initWithNibName:@\"xibName\" bundle:nibBundleOrNil]; 加载storyboard加载控制器对象12345678910// 加载storyboardUIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Two\" bundle:nil];// 创建storyboard里面灰色的控制器 //找到shtoryboard里面设置的初始控制器 // UIViewController *vc = [storyboard instantiateInitialViewController]; // 从storyboard里面找出绑定标识的控制器 MJTwoViewController *vc = [storyboard instantiateViewControllerWithIdentifier:@\"pink\"]; self.window.rootViewController = vc;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"使用curl命令管理远程github库","slug":"git/使用curl命令管理远程github库","date":"2018-06-20T11:14:00.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2018/06/20/git/使用curl命令管理远程github库/","link":"","permalink":"https://huos3203.github.io/2018/06/20/git/使用curl命令管理远程github库/","excerpt":"","text":"使用curl命令管理远程github库 新建远程仓库 在本地准备工作进入一个目录，这个目录是本地仓库的目录；在本地建立仓库 1git init &amp;&amp; git add . &amp;&amp; git commit -m 'some information' 新建一个API token打开此链接，generate new token，写入description，选择scopes（设置此token持有者的权限）。记住personal access token（也就是那一串字符和数字）！这一串东西只出现一次，下次查看不到。 基础命令这是最直接的一种形式，直接把参数写到命令行搞定：12curl -u git账号 -d &apos;&#123;&quot;name&quot;:&quot;新库名&quot;,&quot;description&quot;:&quot;库描述&quot;&#125;&apos; https://api.github.com/user/reposcurl -u &quot;$username:$token&quot; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos; 注：这里需要把$username和$token分别换成实际的用户名和刚才记住的personal access token，把$repo_name换成任何想要的repo name。 bash 形式我们可以把命令行写成bash脚本，下次只要执行里面的简单命令就可以执行以上整条命令。 把username和token写入(apend或者修改)~/.gitconfig，形式如下： 123[github] user = your user name token = the token you get 把如下 bash code写入（append）~/.bash_profile文件 123456789101112131415161718192021222324252627282930313233343536373839github-create() &#123; repo_name=$1 dir_name=`basename $(pwd)` if [ \"$repo_name\" = \"\" ]; then echo \"Repo name (hit enter to use '$dir_name')?\" read repo_name fi if [ \"$repo_name\" = \"\" ]; then repo_name=$dir_name fi username=`git config github.user` if [ \"$username\" = \"\" ]; then echo \"Could not find username, run 'git config --global github.user &lt;username&gt;'\" invalid_credentials=1 fi token=`git config github.token` if [ \"$token\" = \"\" ]; then echo \"Could not find token, run 'git config --global github.token &lt;token&gt;'\" invalid_credentials=1 fi if [ \"$invalid_credentials\" == \"1\" ]; then return 1 fi echo -n \"Creating Github repository '$repo_name' ...\" curl -u \"$username:$token\" https://api.github.com/user/repos -d '&#123;\"name\":\"'$repo_name'\"&#125;' &gt; /dev/null 2&gt;&amp;1 echo \" done.\" echo -n \"Pushing local code to remote ...\" git remote add origin git@github.com:$username/$repo_name.git &gt; /dev/null 2&gt;&amp;1 git push -u origin master &gt; /dev/null 2&gt;&amp;1 echo \" done.\"&#125; 也可以将脚本保存在github-create.sh文件中，让后在~/.bash_profile添加导入语句 1. &quot;$HOME/your path/github-create.sh&quot; 也可以导入到oh-my-zsh配置文件zshrc.zsh-template中，每次创建myzsh窗口时，github-create方法会初始化在环境中： 1. &quot;$HOME/hsg/hexo/Util/tool/github-create.sh&quot; 重新打开或新启动一个终端窗口，或者也可以在当前Terminal下运行如下命令 1Source ~/.bash_profile 然后就可以用如下命令创建远程仓库了 1github-create [repo name] 如果你不想用默认repo name（也就是当前目录名）创建repo可以重新输入另一个名字，否则直接按回车执行。 bash形式–简化版 把如下bash code写入（append）~/.bash_profile文件。第十行按照形式一处理一下。 12345678910111213simple-create() &#123; if [ $1 ] then repo_name=$1 else echo &quot;Repo name?&quot; read repo_name fi curl -u &apos;$username:$token&apos; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos; git remote add origin git@github.com:efatsi/$repo_name.git git push -u origin master&#125; 重新打开或新启动一个终端窗口，或者也可以在当前Terminal下运行如下命令 1Source ~/.bash_profile 执行命令 1simple-create [repo name] 查询现有库1curl -u git账号 https://api.github.com/repos/账号/库名 初始化远程仓库找到仓库路径的字段clone_url或者1234git remote add origin clone_url//或者使用ssh,避免输入密码//git remote add origin ssh_urlgit push origin master 删除远程仓库1234567githubDelRepo()&#123; if [[ $# != 2 ]] ; then echo \"Needs username and repo-name as args 1 and 2 respectively.\" else curl -X DELETE -u \"$&#123;1&#125;\" https://api.github.com/repos/\"$&#123;1&#125;\"/\"$&#123;2&#125;\" fi&#125;","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"MacOS系统下运行exe小程序","slug":"macOS/MacOS系统下运行exe小程序","date":"2018-06-19T18:09:18.000Z","updated":"2018-06-19T19:44:09.000Z","comments":true,"path":"2018/06/20/macOS/MacOS系统下运行exe小程序/","link":"","permalink":"https://huos3203.github.io/2018/06/20/macOS/MacOS系统下运行exe小程序/","excerpt":"","text":"场景例如，当急需在Mac系统上，安装abletonLive，涉及到破解机exe小程序，使用文中提到的两种方法，就解了燃眉之急。 方法一crossover Wrappe[k]小应用这款软件适用于一些小型exe程序，其他，推荐方法一下载 密码: khqa参看","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"在GarageBand中使用LaunchPad","slug":"智能设备/在GarageBand中使用LaunchPad","date":"2018-06-19T15:39:56.000Z","updated":"2018-09-22T21:19:01.000Z","comments":true,"path":"2018/06/19/智能设备/在GarageBand中使用LaunchPad/","link":"","permalink":"https://huos3203.github.io/2018/06/19/智能设备/在GarageBand中使用LaunchPad/","excerpt":"","text":"Garageband不支持控件表面，因此无法使用Launchpad/LaunchKey的全部功能。 在Garageband中，仅可以使用Launchpad来演奏虚拟乐器。原因：Faders和Knobs将为输出MIDI CC消息(详细介绍)到支持手动操作的MIDI设备的插件。此外，打击垫还将发送固定的Note数据。然而，Garageband本身没有传输、卷或Pan控件，不支持Launchpad的Volume or Pan Control。因此，只能在支持HUI Protocol的DAW的DAW，或者选择Ableton Live，Launchpad才能发挥最大的作用。原文","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"AbletonLive10安装使用","slug":"智能设备/AbletonLive10安装使用","date":"2018-06-19T14:23:13.000Z","updated":"2018-09-22T21:19:00.000Z","comments":true,"path":"2018/06/19/智能设备/AbletonLive10安装使用/","link":"","permalink":"https://huos3203.github.io/2018/06/19/智能设备/AbletonLive10安装使用/","excerpt":"","text":"launchPad设备官网 官方教程资源官方工程试听资源支持下载 ableton live 软件官网下载中国社区ABLETON LIVE 10.0.1 SUITE 破解版下载 WINDOWS &amp; MACABLETON LIVE10.0.1破解机下载 下载安装 灯光第二期：Chain的选择与设置/页数的映射 音频轨道拖拽音频文件或视频文件到Simple采样轨道中，视频格式会生成asd格式的新文件文件，加载到轨道中。 MIDI轨道可以为Lights1.1 灯光轨道1.2 鼓点设置 鼓点音色映射设置，来输出不同的音乐片段 拖动IB控件到MIDI模块 鼓点灯光映射设置 拖进MIDI Effects rack控件1.1 点击黄色选项：展开Key:vel:chain:Hide页面1.2 右击蓝色条，选择map selecter1.3 选中右上角的MIDI切换到设置MIDI映射键模式。1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置1.5 新建八个chain，错位蓝色条，完成页数映射的设置1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件 第三期：关于分轨和音频采样reddit.combeatport.comsplice.com选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。 第四期：基础灯光效果制作Arpeggiator （A效果器）设置纵横方向的属性变化效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围 rate速度：1/1一拍移动一下最慢，1/128最快。 Gate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光 style：纵向变化的方向：up/down/upDown/DownUp… Hold激活不用长按，即可厂量 repeats：设置走马灯的循环次数 A效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。 Chord （和弦） 拖拽到Key列表中的一个垫子的灯光效果包上。 chord提供六个属性shift1，shift2….shift6，来设置和弦灯光错位，融合等效果第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。以此类推一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮 MIDI Effect Rack在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。设置灯光效果包 选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果 选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置 新建Velocity（力度感应） 新建chord（和弦） 新建Arpeggiator（A效果器） Note Length延迟灯光时间PitchRandomScale Velocity：力度感应 拖到刚才的chain上，即在该键上添加力度感应属性设置。 设置灯光颜色：Out Hi的表盘参数，参考MIni支持的灯光色值","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"LaunchPadMini说明书","slug":"智能设备/LaunchPadMini说明书","date":"2018-06-19T14:23:13.000Z","updated":"2018-09-22T21:19:00.000Z","comments":true,"path":"2018/06/19/智能设备/LaunchPadMini说明书/","link":"","permalink":"https://huos3203.github.io/2018/06/19/智能设备/LaunchPadMini说明书/","excerpt":"","text":"工程demo官方资源 ##Launchpad几种模式视频教程 硬件设置 贴纸：确保标签与相应的按钮对齐。 使用USB连接线将你的Launchpad Mini连接到你的Mac或PC上的USB端口。Ableton Live支持最多6台同时连接的设备。 配置设备在Ableton Live中的配置 打开Live偏好设置,选中MIDI/Sync选项卡，在Input中选择Launchpad Mini所连接的端口以及窗口顶部的Output选择器 在Control Surface控制面板中选择自己的设备。 在MIDI Ports下，开启 Track和Remote选项.PRODUCT OVERVIEW: ABLETON LIVESession 模式当选择Launchpad作为活动控制面时，会话视图上会出现一个圆环，用于指示当前由pad矩阵控制的哪个部分。按下一个剪辑启动板，就会在相应的剪辑插槽中触发该剪辑。在没有武装的轨道上点击一个空的剪辑槽将停止在这个轨道上播放的剪辑。如果跟踪是武装到记录，按下按钮记录一个新的剪辑。方向箭头和会话按钮通过在场景和跟踪中导航会话视图，增加了8×8网格的范围。你也可以使用Launchpad Mini的右手边的按钮来触发水平的剪辑(场景)。Session概述黄色:表示当前选定的剪辑块，它将被软件中的戒指所包围。绿色:在那块剪辑中有一些剪辑在播放(虽然那可能不是被选中的剪辑块)。红色:在这个范围内没有剪辑。未激活色:在这个范围内没有音轨或场景。USER 模式User1模式:说明在Lives中的MIDI音轨中可以使用drum racks鼓架(如果没有分配的话)制造)，或在lives的MIDI可分配参数中自由分配Launchpad Mini的按钮。User2模式:说明可以作为一个方便的地方来访问Max for Live预设配置(如果没有学习任务的话)，或者自由地分配给Live中的任何参数。Mixer混合器模式底部的四行垫子提供了对每个轨道的直接访问控制，包括:停止、跟踪激活器、solo和跟踪臂。右下角的四个按钮为每个轨道提供额外的控制:•stop：停止按钮，将停止当前播放的所有剪辑(可通过重新分配功能来避免)•trk on：音轨激活器按钮，将打开所有轨道(非静音)•solo：“独奏”按钮，将不再独奏所有曲目。•arm: “音轨操作臂”按钮,will un-arm all armed tracksTHE VOLUME / PAN / SNDA / SNDB PAGES当Mixer模式激活时，按VOL/PAN/SNDA或SNDB按钮输入卷、PAN或发送页面，其中列的所有八个焊盘变成各自控制的连续轨迹“FADDER”。VOLUME:音量pan:sndA:sndB: launchPad APP for iOS键盘功能映射iPad兼容（Low Power）vs全功率模式手机端节能模式设置 在连接USB过程中，同时按住按钮5, 6, 7和8,开启设置节能 选择一种电源模式（左为高，右为低），参考pdf图文 完成设置后，按下绿色按钮退出 在全功率模式下，Launchpad mini需要使用单独供电的USB集线器与iPad链接，否则无法正常工作。 键位功能说明 F键位：Filters过滤器，8个垫子的每一列都变成一个滤光片:向上移动以除去低音，向下移动以除去高音。按D或E行的垫子重置Filter过滤器。 G键位：Volume音量，8个垫子的每一层都变成了一个音量调节器。按下B行垫子重置音量。 H键位：Trigger Sounds &amp; FX","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[]},{"title":"Git如何永久删除文件(包括历史记录)","slug":"git/Git如何永久删除文件(包括历史记录)","date":"2018-06-11T20:32:02.000Z","updated":"2018-06-11T20:32:02.000Z","comments":true,"path":"2018/06/12/git/Git如何永久删除文件(包括历史记录)/","link":"","permalink":"https://huos3203.github.io/2018/06/12/git/Git如何永久删除文件(包括历史记录)/","excerpt":"","text":"有些时候不小心上传了一些敏感文件(例如密码), 或者不想上传的文件(没及时或忘了加到.gitignore里的), 而且上传的文件又特别大的时候, 这将导致别人clone你的代码或下载zip包的时候也必须更新或下载这些无用的文件, 因此, 我们需要一个方法, 永久的删除这些文件(包括该文件的历史记录). 首先, 可以参考 github帮助 使用bfg工具bfg官网 创建bfg别名 下载bfg 到本地soft/bfg目录下。 创建别名sudo vi ~/.bash_profile 添加如下： 1alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot; 常用命令 克隆仓库 1git clone --mirror git@github.com:OpenFibers/openfibers.github.com.git 移除目标文件然后就可以执行下面的任意一个或者多个操作。 从历史纪录中删除所有文件名是 id_rsa 或 id_dsa 的文件：1$ bfg --delete-files id_&#123;dsa,rsa&#125; my-repo.git 从历史纪录中删除所有大于1M的二进制文件 :1$ bfg --strip-blobs-bigger-than 1M my-repo.git 从文件中删除所有列出的密码：1$ bfg --replace-text passwords.txt my-repo.git 删除目录及目录下文件:demo:删除的目录--no-blob-protection命令，可以解除保护12345$ cd $ bfg --delete-folders demo --delete-files demo --no-blob-protection//上述命令将demo索引状态重置为`add`的状态，需要执行reset即可$ git reset HEAD demo$ rm -fr demo 使用 filter-branch命令步骤一: 从资料库中清除文件1$ git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch path-to-your-remove-file' --prune-empty --tag-name-filter cat -- --all 其中, path-to-your-remove-file 是要删除的文件的相对路径(相对于git仓库的跟目录), 替换成你要删除的文件即可. 这里的文件或文件夹，都不能以 ‘/‘ 开头，否则文件或文件夹会被认为是从 git 的安装目录开始。 删除文件夹在 git rm --cached 命令后面添加 -r 命令，表示递归的删除（子）文件夹和文件夹下的文件，类似于 rm -rf 命令:1$ git filter-branch --force --index-filter 'git rm --cached -r --ignore-unmatch path-to-your-remove-folder' --prune-empty --tag-name-filter cat -- --all 支持通配符如果当要删除的文件很多, 文件或路径里有中文, 由于MinGW或CygWin对中文路径设置比较麻烦, 你可以使用通配符号, 例如: `sound/music_.mp3, 这样就把sound目录下以music_开头的mp3文件都删除了. 使用通配符*`删除目录下的所有文件：1$ git filter-branch --force --index-filter 'git rm --cached -r --ignore-unmatch path-to-your-remove-folder/*' --prune-empty --tag-name-filter cat -- --all 成功的日志：12345Ref 'refs/heads/master' was rewrittenRef 'refs/remotes/origin/master' was rewrittenWARNING: Ref 'refs/remotes/origin/master' is unchangedWARNING: Ref 'refs/tags/v0.9.0' is unchangedv0.9.0 -&gt; v0.9.0 (2694a7834dada67cf8768ef27e2d7c3d777f5472 -&gt; 2694a7834dada67cf8768ef27e2d7c3d777f5472) Ref &#39;refs/heads/master&#39; was rewritten:表示成功；xxxxx unchanged: 说明在当前分支里没有找到该文件. 步骤二: 推送我们修改后的repo分支同步通过步骤一，需要以强制覆盖的方式推送你的repo, 命令如下:1$ git push --force origin master 这个过程其实是重新上传我们的repo, 比较耗时, 虽然跟删掉重新建一个repo有些类似, 但是好处是保留了原有的更新记录, 所以还是有些不同的. 如果你实在不在意这些更新记录, 也可以删掉重建, 两者也差不太多, 也许后者还更直观些. tag同步为了能从打了 tag 的版本中也删除你所指定的文件或文件夹，您可以使用这样的命令来强制推送您的 Git tags：1$ git push origin master --force --tags 步骤三: 清理和回收空间虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间. 执行命令，再查看.git目录空间会明显变小:12345678910111213141516171819202122$ rm -rf .git/refs/original/$ git reflog expire --expire=now --all$ git gc --prune=nowCounting objects: 2437, done.# Delta compression using up to 4 threads.# Compressing objects: 100% (1378/1378), done.# Writing objects: 100% (2437/2437), done.# Total 2437 (delta 1461), reused 1802 (delta 1048)$ git gc --aggressive --prune=nowCounting objects: 2437, done.# Delta compression using up to 4 threads.# Compressing objects: 100% (2426/2426), done.# Writing objects: 100% (2437/2437), done.# Total 2437 (delta 1483), reused 0 (delta 0)","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"5个图表解决工作中的12大难题","slug":"阅读/5个图表解决工作中的12大难题","date":"2018-06-11T19:43:53.000Z","updated":"2018-06-11T19:43:53.000Z","comments":true,"path":"2018/06/12/阅读/5个图表解决工作中的12大难题/","link":"","permalink":"https://huos3203.github.io/2018/06/12/阅读/5个图表解决工作中的12大难题/","excerpt":"","text":"导图","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"执法巡查开发状态总结","slug":"个人项目/执法巡查开发状态总结","date":"2018-06-05T10:18:33.000Z","updated":"2018-06-08T12:11:07.000Z","comments":true,"path":"2018/06/05/个人项目/执法巡查开发状态总结/","link":"","permalink":"https://huos3203.github.io/2018/06/05/个人项目/执法巡查开发状态总结/","excerpt":"","text":"UML状态图使用状态图，查漏补觉，梳理相关业务流程。建议：优化流程，使用流程图（活动图）/时序图来完善流程","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"uml活动图常用语法","slug":"导图/uml活动图常用语法","date":"2018-06-04T21:27:15.000Z","updated":"2018-09-22T21:18:58.000Z","comments":true,"path":"2018/06/05/导图/uml活动图常用语法/","link":"","permalink":"https://huos3203.github.io/2018/06/05/导图/uml活动图常用语法/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031start:ClickServlet.handleRequest();:new page;if (Page.onSecurityCheck) then (true):Page.onInit();if (isForward?) then (no):Process controls;if (continue processing?) then (no)stopendifif (isPost?) then (yes):Page.onPost();else (no):Page.onGet();endif:Page.onRender();endifelse (false)endifif (do redirect?) then (yes):redirect process;elseif (do forward?) then (yes):Forward request;else (no):Render page template;endifendifstop title uml模型图题目支持MDcenter header在此处添加标头endheaderstart ‘开始’‘&gt;&gt;&gt;&gt;&gt; 活动关系模块 支持嵌套，条件/循环/并行&gt;&gt;&gt;&gt;&gt;&gt;’if(环境条件) then (分流线名):分支1活动;-[颜色]-&gt; 线备注;note left活动备注end noteelseif(分流线名):分支2活动;else (分流线名):分支3活动;endif repeat:循环活动;repeat while (环境条件) while (环境条件):循环活动;endwhile fork:并行活动;fork again:并行活动;end fork ‘&amp;&amp;&amp;&amp;&amp; 活动图组合模块 &amp;&amp;&amp;&amp;&amp;&amp;’partition 活动组名{:单元活动名称;} |#颜色 | 泳道名称|:当前泳道活动; stop ‘结束／end关键字’center footer在此处添加脚注endfooter","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"uml用例图常用语法","slug":"导图/uml用例图常用语法","date":"2018-06-04T21:20:41.000Z","updated":"2018-09-22T21:18:59.000Z","comments":true,"path":"2018/06/05/导图/uml用例图常用语法/","link":"","permalink":"https://huos3203.github.io/2018/06/05/导图/uml用例图常用语法/","excerpt":"","text":"1234567891011121314151617:Main Admin: as Admin(Use the application) as (Use)User -&gt; (Start)User --&gt; (Use)Admin ---&gt; (Use)note right of Admin : This is an example.note right of (Use)A note can also be on several linesend notenote &quot;This note is connected\\nto several objects.&quot; as N2(Start) .. N2N2 .. (Use) 效果图 title uml模型图题目支持MDcenter header在此处添加标头endheader ‘*** 声明用例模块 usecase ***‘(用例名称) as (别名) &lt;&lt;构造类型&gt;&gt; usecase 用例名称 as “ 描述一描述2描述3.. 描述标题 ..描述4“‘*** 声明角色模块 actor ***‘:角色名称: as 别名actor 角色名称 ‘—- 声明备注:用例线备注可以当做用例来参与到关系连接中—‘note “备注内容“ as 备注对象 ‘##### 备注模块 位置：left/right/top/bottom #####’note 位置 of 用例/角色: 描述信息 ‘&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 关系模块 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;’left to right dirction ‘指定布局方向’角色 –&gt; 用例:关系线描述 ‘—- 用例关系中的备注对象 —-‘角色 –&gt;备注对象备注对象 –&gt;用例 center footer在此处添加脚注endfooter","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"uml类图常用语法","slug":"导图/uml类图常用语法","date":"2018-06-04T20:49:36.000Z","updated":"2018-09-22T21:18:59.000Z","comments":true,"path":"2018/06/05/导图/uml类图常用语法/","link":"","permalink":"https://huos3203.github.io/2018/06/05/导图/uml类图常用语法/","excerpt":"","text":"123456789101112class BaseClassnamespace net.dummy #DDDDDD &#123;.BaseClass &lt;|-- PersonMeeting o-- Person.BaseClass &lt;|- Meeting&#125;namespace net.foo &#123;net.dummy.Person &lt;|- Person.BaseClass &lt;|-- Personnet.dummy.Meeting o-- Person&#125;BaseClass &lt;|-- net.unused.Person 效果图： title uml模型图题目支持MDcenter header在此处添加标头endheader ‘*** 类声明模块 ***‘‘类型:class,abstract,interface,annotation,enum’‘访问域:(-)私有,(#)保护,(~)包私有,(+)公有’ class 类名&lt;扩展对象&gt; as 类别名{– 属性组名 – ‘分隔符–,..,==,‘访问域修饰符 static/abstract 属性名称:类型 = 值1 函数组名 __访问域修饰符 func 函数名称(参数1:类型,参数2:类型)}‘显示/隐藏类,类方法属性等 关键字支持class,interface,enum’hide 类名/方法名 ‘—- 声明类关系线备注,可以当做用例来参与到关系连接中 —‘note “备注内容“ as 备注对象 ‘多行备注对象’note as 备注对象“备注内容“end note ‘###### 类备注模块 类声明末尾使用:note 位置: 备注#########’note left/right/top/bottom of object #颜色支持markdown语法加粗／斜体／删除线／下划线／波浪下划线 和HTMLend note ‘&amp;&amp;&amp;&amp;&amp;&amp; 类组合模块 类模块 &amp;&amp;&amp;&amp;&amp;&amp;&amp;’‘六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database’scale 750 width/heightpackage module名 &lt;&lt;模块样式&gt;&gt; #背景色{class 类名&lt;扩展对象&gt; as 类别名{– 属性组名 – ‘分隔符–,..,==,‘访问域修饰符 static/abstract 属性名称:类型 = 值1 函数组名 __访问域修饰符 func 函数名称(参数1:类型,参数2:类型)}} ‘@@@@@@@ 命名空间模块 关系模块 @@@@@@@@’namespace com.cn #空间背景色{ ‘关系节点符:(|&gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(–)实线 ，(..)虚线’类名/包名“基数“ 节点符 left/right..`[#线色]-节点符&quot;基数&quot;类名/包名:消息&gt; noteleft/right/top/bottomon link #颜色连接注释体`end note} ‘&gt;&gt;&gt;&gt;&gt;&gt; 类关系图及连接备注模块 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;’‘关系节点符:(|&gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(–)实线 ，(..)虚线’类名/包名“基数“ 节点符 left/right..`[#线色]-节点符&quot;基数&quot;类名/包名:消息&gt; noteleft/right/top/bottomon link #颜色连接注释体`end note center footer在此处添加脚注endfooter","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"在Mac安装Fiddler","slug":"macOS/在Mac安装Fiddler","date":"2018-05-31T16:38:52.000Z","updated":"2018-09-22T21:18:58.000Z","comments":true,"path":"2018/06/01/macOS/在Mac安装Fiddler/","link":"","permalink":"https://huos3203.github.io/2018/06/01/macOS/在Mac安装Fiddler/","excerpt":"","text":"安装MonoMac下需要使用.Net编译后的程序，首先需要用到跨平台的方案Mono(现阶段微软已推出跨平台的方案.Net Core，不过暂时只支持控制台程序)。下载地址 配置Mono环境 下载证书从Mozilla LXR上下载所有受信任的root证书，存于Mono的证书库里。root证书能用于请求https地址：12$cd /Library/Frameworks/Mono.framework/Versions/&lt;mono version&gt;/bin/$./mozroots --import --sync ./mozroots命令失效，./cert-sync新命令，暂时不知道怎么使用 配置Mono环境变量 在.bash_profile中加入如下内容12export MONO_HOME=/Library/Frameworks/Mono.framework/Versions/5.0.1export PATH=$PATH:$MONO_HOME/bin Fiddler官方文档 安装下载Fiddler-mac.zip压缩包，解压到非中文字符的路径下。 运行打开Terminal，进入到刚才解压的Fiddler路径，执行命令运行：1sudo mono Fiddler.exe 参看","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"hexo博文置顶方法","slug":"hexo/hexo博文置顶方法","date":"2018-05-31T11:44:33.000Z","updated":"2018-09-22T21:18:48.000Z","comments":true,"path":"2018/05/31/hexo/hexo博文置顶方法/","link":"","permalink":"https://huos3203.github.io/2018/05/31/hexo/hexo博文置顶方法/","excerpt":"","text":"修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123;var config = this.config;var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前:123456title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100 转：hexo的next主题个性化配置教程","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"+0800格式转NSDate","slug":"iOS/+0800格式转NSDate","date":"2018-05-30T18:42:20.000Z","updated":"2018-05-30T18:42:20.000Z","comments":true,"path":"2018/05/31/iOS/+0800格式转NSDate/","link":"","permalink":"https://huos3203.github.io/2018/05/31/iOS/+0800格式转NSDate/","excerpt":"","text":"1234NSString *timstr = [resData objectForKey:@\"Data\"];timstr = [timstr stringByReplacingOccurrencesOfString:@\"/Date(\" withString:@\"\"];timstr = [timstr stringByReplacingOccurrencesOfString:@\"+0800)/\" withString:@\"\"];model.time = [NSDate dateWithTimeIntervalSince1970:timstr.longLongValue/1000];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"高德地图API使用","slug":"iOS/高德地图API使用","date":"2018-05-30T14:40:56.000Z","updated":"2018-05-30T18:42:20.000Z","comments":true,"path":"2018/05/30/iOS/高德地图API使用/","link":"","permalink":"https://huos3203.github.io/2018/05/30/iOS/高德地图API使用/","excerpt":"","text":"引入头文件12#import &lt;AMapFoundationKit/AMapFoundationKit.h&gt;#import &lt;AMapLocationKit/AMapLocationKit.h&gt; 调用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354NSString *strKey = @\"2d8a96d668576584acebf2bab0ba0c08\";//默认值//配置里面取值NSString *strBundleKey = [[NSBundle mainBundle] infoDictionary][@\"IOSPostionkey\"];if (strBundleKey) &#123; strKey = strBundleKey;&#125;[AMapServices sharedServices].apiKey = strKey;// 带逆地理信息的一次定位（返回坐标和地址信息）self.GaodelocationManager = [[AMapLocationManager alloc] init];[self.GaodelocationManager setDesiredAccuracy:kCLLocationAccuracyHundredMeters];// 定位超时时间，最低2s，此处设置为2sself.GaodelocationManager.locationTimeout =10;// 逆地理请求超时时间，最低2s，此处设置为2sself.GaodelocationManager.reGeocodeTimeout = 10;//设置不允许系统暂停定位[self.GaodelocationManager setPausesLocationUpdatesAutomatically:NO];// //设置允许在后台定位// [locationManager setAllowsBackgroundLocationUpdates:YES];//设置允许连续定位逆地理[self.GaodelocationManager setLocatingWithReGeocode:YES];// [locationManager setDelegate:self];// [self.locationManager startUpdatingLocation];// // 带逆地理（返回坐标和地址信息）。将下面代码中的 YES 改成 NO ，则不会返回地址信息。[self.GaodelocationManager requestLocationWithReGeocode:YES completionBlock:^(CLLocation *gaodeLocation, AMapLocationReGeocode *regeocode, NSError *error) &#123; if (gaodeLocation==nil) &#123; NSLog(@\"高德没有返回地理位置,使用苹果官方定位经纬度\"); [self GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu]; return ; &#125; if (error) &#123; NSLog(@\"locError:&#123;%ld - %@&#125;;\", (long)error.code, error.localizedDescription); if (error.code == AMapLocationErrorLocateFailed) &#123; NSLog(@\"AMapLocationErrorLocateFailed高德没有返回地理位置,使用苹果官方定位经纬度\"); [self GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu]; return; &#125; &#125; NSLog(@\"使用高德location:%@\", gaodeLocation); NSString * gaodeWeidu = [NSString stringWithFormat:@\"%.9f\",gaodeLocation.coordinate.latitude]; NSString * gaodeJingdu = [NSString stringWithFormat:@\"%.9f\",gaodeLocation.coordinate.longitude]; if (regeocode) &#123; NSLog(@\"reGeocode:%@\", regeocode); self.theRealAdress = regeocode.formattedAddress; &#125; [self GetGISInfoByByLocationWithjingdu:gaodeJingdu AndWeidu:gaodeWeidu];&#125;];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"使用nvm或n管理node和npm版本","slug":"shell/使用nvm或n管理node和npm版本","date":"2018-05-29T12:06:24.000Z","updated":"2018-10-22T20:02:16.000Z","comments":true,"path":"2018/05/29/shell/使用nvm或n管理node和npm版本/","link":"","permalink":"https://huos3203.github.io/2018/05/29/shell/使用nvm或n管理node和npm版本/","excerpt":"","text":"问题123Fatal error in , line 0# Check failed: !value_obj-&gt;IsJSReceiver() || value_obj-&gt;IsTemplateInfo().#FailureMessage Object: 0x7ffeefbf25c0[1] 22749 illegal hardware instruction he 参考Fatal error in ../deps/v8/src/api.cc, line 1197 when gulp watch,需要降级node版本。 nvm工具nvm是node版本管理工具，参考官网nvm安装指南 安装 1$ brew install nvm 安装node 1234567$ nvm install versionnum //安装$ nvm use versionnum //使用指定版本$ nvm ls //查看本地node-&gt; v6.14.4 v8.12.0 system default -&gt; 8 (-&gt; v8.12.0) 使用npmnvm安装node之后，会安装对应版本npm工具，如：node 8 对应 npm v5，node 7 对应 npm v4 12npm -v //查看当前node对应的npm版本号npm version //查看当前目录使用的node详情，即node_modules安装时使用node版本号 注意：在hexo执行，npm install 之后，hexo g 失败时，需要降级npm版本，这是无论怎么使用nvm use 来设置当前node，都无效，必须删除node_modules目录，再使用nvm use切换低版本，重新安装package.json插件才行。 工具包升级nodeissue-431242848node有一个专门管理node.js的版本工具模块n首先安装n模块：npm install -g n升级node.js到最新稳定版1n stable","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"终端实现预览plantuml的插件","slug":"shell/终端实现预览plantuml的插件","date":"2018-05-29T11:32:04.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2018/05/29/shell/终端实现预览plantuml的插件/","link":"","permalink":"https://huos3203.github.io/2018/05/29/shell/终端实现预览plantuml的插件/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-weirongxu-plantuml-previewer.vim-bf4b3e5\", \"weirongxu\", \"plantuml-previewer.vim\", \"bf4b3e5\", false); 安装依赖123Plug 'huos3203/plantuml-syntax' \"plantuml语法高亮 Plug 'aklt/plantuml-syntax'Plug 'tyru/open-browser.vim'Plug 'weirongxu/plantuml-previewer.vim' \"在线工具：http://sujoyu.github.io/plantuml-previewer/ Graphviz下载地址1brew install graphviz 打开浏览器safari插件工具open-browser.vim 语法高亮插件aklt/plantuml-syntax (vim syntax file for plantuml) 使用创建uml文件1vi test.uml 预览uml图通过命令打开浏览器预览界面1:PlantumlOpen 在vi中执行保存命令:w,预览界面会自动刷新","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"GB乐理知识体系","slug":"作文作曲/GB乐理知识体系","date":"2018-05-29T11:32:04.000Z","updated":"2018-06-11T19:43:53.000Z","comments":true,"path":"2018/05/29/作文作曲/GB乐理知识体系/","link":"","permalink":"https://huos3203.github.io/2018/05/29/作文作曲/GB乐理知识体系/","excerpt":"","text":"使用puml来梳理乐理知识点相关概念 五度圈 表格 MD表格音 –&gt; 音质 —&gt; 高低 —&gt; 十二平均律(七键) —&gt;音级/音名/唱名/音组 —&gt;音 –&gt; 音质 —&gt; 长短 —&gt; 音符（全音/半音）五线谱 –&gt; 节拍 拍号，调号，调域 大音阶 12个调：7个大键 5个黑键 ： 全音/半音 音名：C Db D Eb E Fb F Gb G Ab A Bb B 音组：十二平均律 音性质：高低，强弱，长短，音色 音符时效：全音符，二分音符，四分音符，八分音符，十六分音符。 斧头/符干/符尾 书写方法：斧头下干居右，斧头上干居左，符尾永居右 节： 拍号： 乐速：BPM 五线谱： 音程： 度数：两个音符跨度的线和间的个数，音数：两个音符相差全音和半音的个数 音程名：音数和度数决定。纯一度，小二度，大二度… 节奏读法：短音符：嗒，二倍音符：嗒啊，三倍音符：嗒啊啊，休止符：嗯/嗯啊 调式/调域/音阶 调的主音+调式类别 C大调： 自然大调：全全半全全全半 的音级关系 自然小调：全半全全半半全全 关系（大/小）调：c大调是a小调的关系大调。a小调是c大调的关系小调，使用其关系（大/小）调的首调唱名方法。 和弦：以两个以上的音，按照三度的重叠关系，在纵向上加以结合，就是和弦。 顺阶和弦：根音/三音/五音 七个顺阶和弦：大三和弦（CFG）/小三和弦（m）/减三和弦（dim） 大三和弦：根音–大三度–三音—小三度—五音 小三和弦：根音–小三度–三音—大三度—五音 减三和弦：根音–小三度–三音—小三度—五音 调号：变音音符，为了让读者便于识别调式，同时方便写谱，五线谱就将相关调域自然大调音阶中出现的变音记号，按照一定的次序，记在谱号的后边，这些记号就是五线谱的调号。 123456789调试音阶调域固定唱名法/首调唱名法自然大调/自然小调和弦的---顺阶和弦调号五度圈大调中的主要和弦的功能与进行 C大调音阶 do 在C上 音名：C，D，E，F，G，A，B，C 指法：1 ，2，3，1，2，3，4，5 G大调音阶 音名：G，A，B，半音 C，D，E，全音F#，半音G 扫描事件动画处理 巡查录入，执法权限验证进行执法 筛选商业调试UI 巡查年度列表 配置平台组件","categories":[{"name":"作文作曲","slug":"作文作曲","permalink":"https://huos3203.github.io/categories/作文作曲/"}],"tags":[]},{"title":"pyenv切换python的版本","slug":"hexo/pyenv切换python的版本","date":"2018-05-29T10:33:30.000Z","updated":"2018-05-29T12:26:48.000Z","comments":true,"path":"2018/05/29/hexo/pyenv切换python的版本/","link":"","permalink":"https://huos3203.github.io/2018/05/29/hexo/pyenv切换python的版本/","excerpt":"","text":"问题引入在hexo 项目中使用npm 配置环境，出现错误：gyp ERR! configure error pyenv是python的多版本管理包，实现互相独立、互不干扰的python环境配置。 安装pyenv安装电脑是mac，所以理所当然的使用神器：homebrew1brew install pyenv 安装界面略过，安装结束后，系统提示如下：123456==&gt; CaveatsTo use Homebrew's directories rather than ~/.pyenv add to your profile:export PYENV_ROOT=/usr/local/var/pyenvTo enable shims and autocompletion add to your profile:if which pyenv &gt; /dev/null; then eval \"$(pyenv init -)\"; fi 根据此提示，在bash的配置文件（由于我的bash是oh my zsh，所以我的配置文件为~/.zshrc）中添加以下两行代码：12export PYENV_ROOT=/usr/local/var/pyenvif which pyenv &gt; /dev/null; then eval &quot;$(pyenv init -)&quot;; fi 使用pyenv安装指定版本的python显示所有可以安装的python版本软件，如2.1.3…3.5.1等。12pyenv install -lpyenv install 2.7.11 -v -v表示在显示安装过程。安装完成后，2.7.11版本在系统中的存放位置为：/usr/local/var/pyenv/versions/2.7.11 为项目配置python环境接下来进入开发项目的主文件夹，如~/Desktop/Python/TWD，输入如下命令：1pyenv local 2.7.11 即在当前文件夹下配置完成python的开发环境。接下来可通过pip安装开发过程中的各种包。 其他1.显示所有安装的python版本1pyenv versions 2.切换python版本要切换python 版本，可以使用如下命令：1pyenv global &lt;version&gt; 比如，我使用以上命令pyenv global 2.7.11后，系统默认的python版本即为2.7.11，在命令行输入python后，进入的就是2.7.11的shell，不再是system的shell。 3.切换python shell版本若不使用pyenv global命令实现python shell版本切换，可以使用如下命令：1pyenv shell &lt;version&gt; 比如，我使用pyenv shell 2.7.11后，在命令行输入python，进入的是2.7.11的shell。此时系统的默认python版本也变成了2.7.11，如下所示： 转自","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"雨夜","slug":"作文作曲/雨夜","date":"2018-05-17T10:58:36.000Z","updated":"2018-06-19T19:44:09.000Z","comments":true,"path":"2018/05/17/作文作曲/雨夜/","link":"","permalink":"https://huos3203.github.io/2018/05/17/作文作曲/雨夜/","excerpt":"","text":"雨夜12卧听风雨天窗跃，左耳贯注天籁音不闻春雷潜入夜，广厦飞瀑挂屋檐 滑板12心如止水毽如飞，晨练漂移划湖心夜雨不及暑气盛，黑云压城君汗蒸 哔哩哔哩 QQ视频 QQ音乐","categories":[{"name":"作文作曲","slug":"作文作曲","permalink":"https://huos3203.github.io/categories/作文作曲/"}],"tags":[]},{"title":"汉字拼音排序方法","slug":"iOS/汉字拼音排序方法","date":"2018-05-17T10:46:57.000Z","updated":"2018-09-22T21:18:48.000Z","comments":true,"path":"2018/05/17/iOS/汉字拼音排序方法/","link":"","permalink":"https://huos3203.github.io/2018/05/17/iOS/汉字拼音排序方法/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-sortChinese-2deab8b\", \"huos3203\", \"sortChinese\", \"2deab8b\", false); 方法一实现模型对象排序，当万条数据时，出现卡顿问题。 方法二实现字符串数组的排序，暂时没有验证大量排序情况，尝试优化第一种方法的排序卡顿问题。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"水关长城天漠行","slug":"旅行/水关长城天漠行","date":"2018-04-13T11:52:28.000Z","updated":"2018-04-24T11:49:45.000Z","comments":true,"path":"2018/04/13/旅行/水关长城天漠行/","link":"","permalink":"https://huos3203.github.io/2018/04/13/旅行/水关长城天漠行/","excerpt":"","text":"行程安排","categories":[{"name":"旅行","slug":"旅行","permalink":"https://huos3203.github.io/categories/旅行/"}],"tags":[]},{"title":"Git工具交互式暂存","slug":"git/Git工具交互式暂存","date":"2018-04-12T19:41:46.000Z","updated":"2018-04-12T19:41:46.000Z","comments":true,"path":"2018/04/13/git/Git工具交互式暂存/","link":"","permalink":"https://huos3203.github.io/2018/04/13/git/Git工具交互式暂存/","excerpt":"","text":"交互式暂存Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个互交命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：12345678910$ git add -istaged unstaged path1: unchanged +0/-1 TODO2: unchanged +1/-1 index.html3: unchanged +5/-1 lib/simplegit.rb*** Commands ***1: status 2: update 3: revert 4: add untracked5: patch 6: diff 7: quit 8: helpWhat now&gt; 可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。 在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。 暂存与取消暂存文件如果在 What now&gt; 提示符后键入 2 或 u，脚本将会提示想要暂存哪个文件：123456What now&gt; 2staged unstaged path1: unchanged +0/-1 TODO2: unchanged +1/-1 index.html3: unchanged +5/-1 lib/simplegit.rbUpdate&gt;&gt; 要暂存 TODO 与 index.html 文件，可以输入数字：123456Update&gt;&gt; 1,2staged unstaged path* 1: unchanged +0/-1 TODO* 2: unchanged +1/-1 index.html3: unchanged +5/-1 lib/simplegit.rbUpdate&gt;&gt; 每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update&gt;&gt; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：1234567891011Update&gt;&gt;updated 2 paths*** Commands ***1: status 2: update 3: revert 4: add untracked5: patch 6: diff 7: quit 8: helpWhat now&gt; 1staged unstaged path1: +0/-1 nothing TODO2: +1/-1 nothing index.html3: unchanged +5/-1 lib/simplegit.rb 现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 3 或 r（撤消）选项：123456789101112131415*** Commands ***1: status 2: update 3: revert 4: add untracked5: patch 6: diff 7: quit 8: helpWhat now&gt; 3staged unstaged path1: +0/-1 nothing TODO2: +1/-1 nothing index.html3: unchanged +5/-1 lib/simplegit.rbRevert&gt;&gt; 1staged unstaged path* 1: +0/-1 nothing TODO2: +1/-1 nothing index.html3: unchanged +5/-1 lib/simplegit.rbRevert&gt;&gt; [enter]reverted one path 再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：12345678*** Commands ***1: status 2: update 3: revert 4: add untracked5: patch 6: diff 7: quit 8: helpWhat now&gt; 1staged unstaged path1: unchanged +0/-1 TODO2: +1/-1 nothing index.html3: unchanged +5/-1 lib/simplegit.rb 如果想要查看已暂存内容的区别，可以使用 6 或 d（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff –cached 非常相似：12345678910111213141516171819*** Commands ***1: status 2: update 3: revert 4: add untracked5: patch 6: diff 7: quit 8: helpWhat now&gt; 6staged unstaged path1: +1/-1 nothing index.htmlReview diff&gt;&gt; 1diff --git a/index.html b/index.htmlindex 4d07108..4335f49 100644--- a/index.html+++ b/index.html@@ -16,7 +16,7 @@ Date Finder&lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; 通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。 暂存补丁Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 5 或 p（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：1234567891011121314diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex dd5ecc4..57399e0 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -22,7 +22,7 @@ class SimpleGitenddef log(treeish = &apos;master&apos;)- command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)+ command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)enddef blame(path)Stage this hunk [y,n,a,d,/,j,J,g,e,?]? 这时有很多选项。 输入 ? 显示所有可以使用的命令列表：1234567891011121314Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?y - stage this hunkn - do not stage this hunka - stage this and all the remaining hunks in the filed - do not stage this hunk nor any of the remaining hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help 通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：12345What now&gt; 1staged unstaged path1: unchanged +0/-1 TODO2: +1/-1 nothing index.html3: +1/-1 +4/-0 lib/simplegit.rb simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。 也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 git add -p 或 git add –patch 来启动同样的脚本。 更进一步地，可以使用 reset –patch 命令的补丁模式来部分重置文件，通过 checkout –patch 命令来部分检出文件与 stash save –patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"Otherlinkerflags设置ld命令执行的参数","slug":"xcode/Otherlinkerflags设置ld命令执行的参数","date":"2018-04-11T16:42:57.000Z","updated":"2018-04-11T19:16:17.000Z","comments":true,"path":"2018/04/12/xcode/Otherlinkerflags设置ld命令执行的参数/","link":"","permalink":"https://huos3203.github.io/2018/04/12/xcode/Otherlinkerflags设置ld命令执行的参数/","excerpt":"","text":"Other linker flags设置的值实际上就是ld命令执行时后面所加的参数。 3个常用参数：-ObjC：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中-all_load：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。-force_load：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载. 加载FrameWork加载静态库","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[]},{"title":"iOS插件化开发之Small","slug":"xcode/iOS插件化开发之Small","date":"2018-04-11T16:42:17.000Z","updated":"2018-10-24T01:18:37.000Z","comments":true,"path":"2018/04/12/xcode/iOS插件化开发之Small/","link":"","permalink":"https://huos3203.github.io/2018/04/12/xcode/iOS插件化开发之Small/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-SmallDemo-5931b43\", \"huos3203\", \"SmallDemo\", \"5931b43\", false); 官网small是android与iOS平台比较出名的轻巧的跨平台插件化框架，也正是被这一点吸引，决定将small应用到集团内部的应用引擎模块化方案中，本篇博文主要讲述本人基于small在iOS平台实现的定制化APP方案（运营自由配置、自由组合、自动打包）~特性与功能 基于iOS组件化基础iOS组件化基于Cocoa Touch Framework（以下简称CTF）通过NSBundle实现。 CTF首次公开在WWDC2014，要求Xcode6 beta以上版本。 CTF官方表示支持8.0以上系统，但在6.0、7.0上测试正常。 如果你的App包含了CTF，但是Deployment Target &lt; 8.0，上传二进制文件到App Store时会报警中断。受苹果官方限制，如果你的CTF没有签名，将无法实现代码级别更新。 Framework 模式无法上传到App Store。只能应用到企业版 使用Small模版新建l项目Small提供了Small-pods模版，安装Xcode模版创建空白的Small项目。 安装Xcode模板 123git clone https://github.com/wequick/Small.gitcd Small/iOScp -r Templates ~/Library/Developer/Xcode/Templates 新建项目File-&gt;New-&gt;Project...，选择Small-pods模板 库依赖配置文件podfile： 123456platform :ios, '7.0'use_frameworks!target 'SmallAPP' do pod \"Small\", :git =&gt; 'https://github.com/wequick/Small.git'end 路由文件bundle.json: 123456789&#123; \"version\": \"1.0.0\", \"bundles\": [ &#123; \"uri\": \"main\", \"pkg\": \"hsg.com.cn.SmallAPP.app.main\" &#125; ]&#125; 安装pod依赖123cd [your-project-path]pod install --no-repo-updateopen *.xcworkspace 解读插件路由配置插件路由:为了方便插件之间的跨平台调用，Small 提供了 bundle.json 来完成插件路由。bundle.json路由配置包括version:指定插件的版本号，bundles:插件注册的清单数组，其中插件清单的每个插件四个属性，来确定加载组件的方式：uri：指定加载插件的跟路径1234//获取控制器let VC = Small.controller(forUri: &quot;fixurl&quot;)//将VC.view直接设置为window根视图Small.openUri(&quot;fixurl&quot;, from: self) pkg：配置要求新建的Framework命名时必须包含.lib.、.app.，因为在加载组件过程中用它来判断你插件的类型：rules：规定页面的分发规则，可以通过rules来设置插件的多个入口，配和uri使用:openuri(uri/ruleskey),当不配置rules时，默认通过info.plist NSPrincipalClass来加载组件openuri(uri)。路由配置文件bundle.json部分内容如下：123456789101112131415161718&#123; \"version\": \"1.0.0\", \"bundles\": [ &#123; \"uri\": \"lib.utils\", \"pkg\": \"com.example.small.lib.utils\", \"rules\": &#123; //会覆盖掉`Principal class`默认的启动页配置 \"Storyboard\": \"storyboardName/controllerId\", \"xib\": \"controllerName\" &#125; &#125;, &#123; \"uri\": \"main\", \"pkg\": \"com.example.small.app.main\" &#125; ] ....&#125; small加载接口的相关方法12345678+ (void)openUri:(NSString *)uri fromView:(UIView *)view;+ (void)openURL:(NSURL *)url fromView:(UIView *)view;+ (void)openUri:(NSString *)uri fromController:(UIViewController *)controller;+ (void)openURL:(NSURL *)url fromController:(UIViewController *)controller;+ (UIViewController *)controllerForUri:(NSString *)uri;+ (UIViewController *)controllerForURL:(NSURL *)url; 支持Storyboard作为启动页的解析根据SMBundle路由配置信息，通过SMAppBundleLauncher的实例方法_controllerForBundle:加载Framework，支持storyboard加载。 路由rules字典123&quot;rules&quot;:&#123;&quot;&quot;:&quot;Main/MainViewController&quot;&#125; 空字串(&quot;&quot;)的value值两种格式类型： `&quot;$controllerName&quot;`: `SMAppBundleLauncher`通过反射，初始化controller `&quot;storyboardName/controllerId&quot;`:`SMAppBundleLauncher`会识别找到storyboard在更具id初始化controller 最终可以SMBundle实例变量target中得到该key(&quot;&quot;)的value值来定位插件包，在该过程通过对SMBundle的属性bundle.queryParams的处理，完成对插件对象的值传递1234567891011121314151617181920212223242526272829303132333435if ([bundle.target isEqualToString:@\"\"]) &#123; targetClazz = bundle.principalClass; &#125; else &#123; NSString *target = bundle.target; NSInteger index = [target rangeOfString:@\"/\"].location; if (index != NSNotFound) &#123; // Storyboard: \"$storyboardName/$controllerId\" NSString *storyboardName = [target substringToIndex:index]; targetBoard = [UIStoryboard storyboardWithName:storyboardName bundle:bundle]; targetId = [target substringFromIndex:index + 1]; &#125; else &#123; // Controller: \"$controllerName\" targetClazz = [bundle classNamed:target]; if (targetClazz == nil &amp;&amp; !SMStringHasSuffix(target, @\"Controller\")) &#123; targetClazz = [bundle classNamed:[target stringByAppendingString:@\"Controller\"]]; &#125; &#125;&#125;UIViewController *controller = nil;if (targetClazz != nil) &#123; //尝试获取xib资源 NSString *nibName = NSStringFromClass(targetClazz); NSString *nibPath = [bundle pathForResource:nibName ofType:@\"nib\"]; if (nibPath != nil) &#123; // 通过xib资源文件创建控制器实例 controller = [[targetClazz alloc] initWithNibName:nibName bundle:bundle]; &#125; else &#123; /// 通过反射类方式创建控制器实例 controller = [[targetClazz alloc] init];&#125;...// Initialize controller parametersif (bundle.queryParams != nil) &#123; [controller setValuesForKeysWithDictionary:bundle.queryParams];&#125; 参数传递使用 Query标准来传递参数，即在 uri 之后加上 ? 再带上键值对，多个键值对用&amp; 来分开。 传值方式 detail?id=1000&amp;title=test。 1[Small openUri:@&quot;detail?from=app.home&quot; fromController:controller]; 接收解析为属性值例如DetailController)定义两个属性，属性名称和uri键值名保持一致，因为是通过setValuesForKeysWithDictionary来给相应属性赋值。 1234567891011// DetailController.h@property (nonatomic, strong) NSString *id;// DetailController.mNSString *id = self.id;样例// Initialize controller parametersif (bundle.queryParams != nil) &#123; [controller setValuesForKeysWithDictionary:bundle.queryParams];&#125; 插件命名规则和入口设置路由配置对插件包的命名有严格要求，SMBundle主要通过pkg名称包含.app.(模块库)/.lib.(工具库)来定位插件包的，否则全部默认加载bundle包。模块命名规范 framework编译成功后，名称跟Product Name一样命名规则:123xx_xx_lib_xx【com_example_small_lib_utils】xx_xx_app_xxxx_xx_xx_xx 注意lib、app这些对查找framework文件相当重要，这所以会有_，是small对.做了替换12345678910NSString *bundlePath = nil;NSString *bundleSuffix = @\"bundle\"; //默认SMBundleType bundleType = SMBundleTypeAssets; if ([pkg rangeOfString:@\".app.\"].location != NSNotFound|| [pkg rangeOfString:@\".lib.\"].location != NSNotFound) &#123; bundleSuffix = @\"framework\"; bundleType = SMBundleTypeApplication;&#125;NSString *bundleName = [pkg stringByReplacingOccurrencesOfString:@\".\" withString:@\"_\"];bundleName = [bundleName stringByAppendingFormat:@\".%@\", bundleSuffix]; 设置加载模块的入口类 info.plist方式实现在 framework模块工程的info.plist文件中添加Principal class字段： 12&lt;key&gt;NSPrincipalClass&lt;/key&gt;&lt;string&gt;ESHomeController&lt;/string&gt; //指定入口类名 bundle.json路由方式实现通过设置bundle.json的rules字典，指定初始化库的入口 12345&quot;rules&quot;: &#123; &quot;&quot;: &quot;默认入口类名&quot; &quot;/Storyboard&quot;: &quot;storyboardName/controllerId&quot;, &quot;/xib&quot;: &quot;controllerName&quot;&#125; bundle.json中配置的入口，优先于info.plist中的Principal class的入口。 集成插件到主工程 插件集成就是将framework添加到主工程，不能以Linked方式进行添加，使用Build Phases中的Copy Bundle Resources 选项，将framework拖动添加其中即可，这样可以完成对framework编译完后的拷贝. 插件启动原理small框架会依次优先顺序检查Documents/temp（下载的zip）–&gt;/Documents/bundles(存放Framework)–&gt;/iSmallApp.app/(app根目录)，small规定插件Framework必须存放在这几个目录中，才能被small框架动态加载。具体实现 123456789101112131415161718192021222324NSString *bundleName = [pkg stringByReplacingOccurrencesOfString:@&quot;.&quot; withString:@&quot;_&quot;];bundleName = [bundleName stringByAppendingFormat:@&quot;.%@&quot;, bundleSuffix];NSString *documentBundlesPath = [SMFileManager documentBundlesPath];NSString *patchFilePath = [SMFileManager tempBundlePathForName:bundleName];//沙盒中查找插件包，一旦发现，解压加载if ([[NSFileManager defaultManager] fileExistsAtPath:patchFilePath]) &#123; // Unzip NSString *unzipPath = documentBundlesPath; ZipArchive *zipArchive = [[ZipArchive alloc] init]; [zipArchive UnzipOpenFile:patchFilePath]; [zipArchive UnzipFileTo:unzipPath overWrite:YES]; [zipArchive UnzipCloseFile]; [[NSFileManager defaultManager] removeItemAtPath:patchFilePath error:nil];&#125;NSString *patchPath = [documentBundlesPath stringByAppendingPathComponent:bundleName];///主工程目录下查找NSString *builtinPath = [[SMFileManager mainBundlesPath] stringByAppendingPathComponent:bundleName];NSArray *bundlePaths = @[patchPath, builtinPath];for (NSString *aBundlePath in bundlePaths) &#123; if ([[NSFileManager defaultManager] fileExistsAtPath:aBundlePath]) &#123; bundlePath = aBundlePath; break; &#125;&#125; 测试完成添加，进入测试。使用过程中，有可以模块更新代码后，主工程调用发现功能未更新，这时候需要清理工程，重新编译；或者修改编译包配置，从而时时更新。 small的两种开发模式的demo 使用者模式使用场景：作为第三方集成到自己的项目，包含两个特殊的文件podfile和Small-subprojects.rb安装脚本文件。podfile 123456platform :ios, &apos;7.0&apos;use_frameworks!target &apos;Sample&apos; do pod &quot;Small&quot;, :path =&gt; &quot;../../&quot;end Small-subprojects.rb安装脚本文件通过脚本来设置build settings中的FRAMEWORK_SEARCH_PATHS配置： 12config.build_settings[&apos;FRAMEWORK_SEARCH_PATHS&apos;] &lt;&lt; &quot;$(CONFIGURATION_BUILD_DIR)/**&quot;puts &quot;Small: Add framework search paths for &apos;#&#123;dep.name&#125;&apos;&quot; 开发者模式使用场景：需要对Small框架集成自己的功能需求时，可以使用该Demo快速部署对Small框架的开发环境 需要去除并行编译模式：Edit Scheme...-&gt;Build-&gt;Build Options-&gt; [ ] Parallelize Build 各个组件需要签名后才支持代码级别更新。示例中更新例子为xib内容更新。 使用Small创建iOS工程目录Small UI route文档","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[]},{"title":"当项目过大需要通过SSH方式Clone","slug":"git/当项目过大需要通过SSH方式Clone","date":"2018-04-04T17:44:24.000Z","updated":"2018-04-04T17:44:24.000Z","comments":true,"path":"2018/04/05/git/当项目过大需要通过SSH方式Clone/","link":"","permalink":"https://huos3203.github.io/2018/04/05/git/当项目过大需要通过SSH方式Clone/","excerpt":"","text":"设置全局提交信息12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 修改最后一次提交的用户名信息git git config user.name &#39;wangz&#39; git config user.email &#39;wangz@alib.com&#39; git commit --amend --author=wangz ` 项目过大问题 git clone 主工程出现 fatal: The remote end hung up unexpectedly3) 通常的解决办法： 设置提交缓存的大小为 1G：1048576000 git config http.postBuffer 1048576000 否则，需要配置github/gitlab的公钥 生成：ssh-keygen -t rsa -C &quot;$your_email&quot; 拷贝：pbcopy &lt; ~/.ssh/id_rsa.pub 创建SSHKey： 在github/gitlab新建公钥add SSH Key：粘贴到密钥文本框中即可。","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"A++审核问题总结","slug":"测试/A++审核问题总结","date":"2018-04-03T15:29:08.000Z","updated":"2018-09-22T21:18:56.000Z","comments":true,"path":"2018/04/03/测试/A++审核问题总结/","link":"","permalink":"https://huos3203.github.io/2018/04/03/测试/A++审核问题总结/","excerpt":"","text":"苹果审核规则答审核人员回访时提到的几个问题： 处理非法内容的预防措施答：我们平台会采取24小时内删除非法内容并将违规用户拉黑销号处理，通过后台运作实现有效的防范措施。 app完整及数据内容规范化答：我们对含有测试文本及敏感文字的数据进行清理，保证了功能完善内容规范。 经营模式举例说明：A有事想，通过发布任务给B，询问B是否有朋友可以帮忙，如果有并且愿意介绍，A愿意以红包的方式进行打赏B，这个红包是象征意义的红包，目前不会在APP内进行支付，会在线下支付，也可不支付。主要通过寻找朋友的人脉寻求帮助的场景建立起一个社交的应用场景。 通讯录权限描述不清晰答：我们重新校正了权限描述，让用户更清晰准确的理解APP使用通讯录的目的。 希望早日通过审核，Thanks。 规则1. 2 Safety: User Generated Content添加举报功能 规则5.1.2通讯录权限微信通讯录权限描述: \b登录之后弹出两个提示: 说明APP使用目的微信将上传手机通讯录至微信服务器以匹配及推荐朋友.\\n(上传通讯录仅用于匹配,不会保存资料,亦不会用作他用) 说明APP请求\b使用权限如果不允许,微信将无法推荐通讯录中的朋友给你.微信仅使用特征码用于匹配识别,不会保存你的通讯录内容. 规避封帐号的风险： \b总结常被拒的问题，每次发布时做好自查。 把\b被拒概率大的单独申请账号审核。 被苹果惩罚的原因（不做以下勾当就不会招来苹果惩罚）✕ 刷榜众所周知，刷榜绝对是开发者被苹果惩罚的最主要原因。✕ 诱导性运营活动引导用户评论以及消费都属于诱导性运营活动。✕ 被刷榜这边要说下这点。所谓“被刷榜”是指，被竞争对手恶意刷好评通过苹果机制强制下架。竞争对手采用这种方式陷害竞品，而目前苹果很难界定刷榜行为的主动和被动，所以这块开发者也要注意了。✕ 违规做热搜排名热搜排名在ASO优化中占据重要位置，但其实热搜带来的下载量并不多，并且这种行为很容易被苹果检测到，而一些开发者仍然乐意在这块冒险。✕ 加入非官方支付代码有些开发商为了方便玩家支付，擅自绕开苹果的支付体系，加入支付宝代码等，这种行为被苹果发现后绝对是会直接封号，毫不留情。✕ 涉政、违法这点大家应该都很清楚，如果应用的功能涉及侵犯他人的隐私滥用隐私权限或者存在与宗教、法律相悖的内容，也会遭到下架。 对策✓ 1.一旦你的产品被惩罚，第一时间，邮件，电话等等方式找苹果，表示自己毫不知情，是受害者，希望能够恢复。态度一定要诚恳，据说这招很灵，不妨一试。✓ 2.发动用户找苹果投诉，表示自己在App Store找不到喜欢的产品了，影响了用户体验。不过这招一定不能用力过猛，否则可能再给你的应用帮倒忙。✓ 3.没办法中的办法，就是重新申请一个开发者账号，重新申请一个新的应用，换一张皮，重新上架。原文：被苹果惩罚了之后怎么办？如何去规避风险呢","categories":[{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/categories/测试/"}],"tags":[]},{"title":"隐藏导航条底部黑线","slug":"iOS/隐藏导航条底部黑线","date":"2018-03-12T13:51:07.000Z","updated":"2018-03-13T18:00:23.000Z","comments":true,"path":"2018/03/12/iOS/隐藏导航条底部黑线/","link":"","permalink":"https://huos3203.github.io/2018/03/12/iOS/隐藏导航条底部黑线/","excerpt":"","text":"当需要导航条为透明色，与背景色一体时，需要去除底边线：如下代码：使用空图片设置背景图，并指定bar的样式。 self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.barStyle = UIBarStyleBlackTranslucent;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"千百度","slug":"podcast/千百度","date":"2018-01-05T21:37:53.000Z","updated":"2018-09-25T19:41:17.000Z","comments":true,"path":"2018/01/06/podcast/千百度/","link":"","permalink":"https://huos3203.github.io/2018/01/06/podcast/千百度/","excerpt":"这里就是简介的描写，千百度，很好听的歌曲","text":"这里就是简介的描写，千百度，很好听的歌曲 var ap = new APlayer({ element: document.getElementById(\"aplayer-CZxufwHR\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"千百度\", author: \"许嵩\", url: \"/images/qbd.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌词 [ti:千百度] [ar:梅朵] [00:02.41] 千百度 [00:04.08] 演唱：梅朵 [00:05.11] 作词：李红雨 [00:06.14] 作曲：刘牧 [00:22.55] 春色已满园 [00:26.53] 细雨缠绵桃花红 [00:30.61] 花蝶飞舞 [00:34.58] 伴着伊人轻入梦 [00:38.68] 秋风凛凛 [00:42.69] 冷雨纷飞枫叶红 [00:46.84] 鸿雁南飞 [00:50.86] 遥望伊人轻轻回 [00:55.00] 悄悄的来又轻轻的去 [00:59.12] 没留下一点你的消息 [01:03.17] 久久的等待苦苦的追寻 [01:07.09] 亲爱的人你在哪里 [01:13.34] 梦中寻你千百度 [01:17.27] 会不会痴心的错付 [01:21.31] 日思夜想想憔悴 [01:25.37] 曾想一生将你托付 [01:49.94] 春色已满园 [01:53.99] 细雨缠绵桃花红 [01:58.07] 花蝶飞舞 [02:02.07] 伴着伊人轻入梦 [02:06.23] 秋风凛凛 [02:10.18] 冷雨纷飞枫叶红 [02:14.24] 鸿雁南飞 [02:18.34] 遥望伊人轻轻回 [02:22.37] 悄悄的来又轻轻的去 [02:26.48] 没留下一点你的消息 [02:30.59] 久久的等待苦苦的追寻 [02:34.60] 亲爱的人你在哪里 [02:40.75] 梦中寻你千百度 [02:44.75] 会不会痴心的错付 [02:48.89] 日思夜想想憔悴 [02:52.95] 曾想一生将你托付 [02:59.05] 悄悄的来又轻轻的去 [03:03.09] 没留下一点你的消息 [03:07.23] 久久的等待苦苦的追寻 [03:11.24] 亲爱的人你在哪里 [03:17.43] 梦中寻你千百度 [03:21.51] 会不会痴心的错付 [03:25.44] 日思夜想想憔悴 [03:29.42] 曾想一生将你托付 [03:35.66] 曾想一生将你托付 var ap = new APlayer({ element: document.getElementById(\"aplayer-EVohlxfs\"), narrow: false, autoplay: true, showlrc: 2, music: { title: \"千百度\", author: \"许嵩\", url: \"/images/qbd.mp3\", pic: \"\", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 第一个播客测试了。","categories":[{"name":"podcast","slug":"podcast","permalink":"https://huos3203.github.io/categories/podcast/"}],"tags":[{"name":"test","slug":"test","permalink":"https://huos3203.github.io/tags/test/"},{"name":"audio","slug":"audio","permalink":"https://huos3203.github.io/tags/audio/"}]},{"title":"Objective-C的运行时库","slug":"swift/Objective-C的运行时库","date":"2017-09-25T20:01:36.000Z","updated":"2018-11-10T09:14:55.000Z","comments":true,"path":"2017/09/26/swift/Objective-C的运行时库/","link":"","permalink":"https://huos3203.github.io/2017/09/26/swift/Objective-C的运行时库/","excerpt":"","text":"Objective-C 运行时Objective-C 是一门基于运行时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立。这将给开发人员极高的灵活性，因为我们可以修改这些链接。而不同的是，Swift 绝大多数时候是一门面向编译时的语言。因此在 Swift 当中，灵活性受到了限制，不过您会因此得到更多的安全性。 runtime.h开源库Objective-C 的运行时本质上是一个库。它负责了 “Objective” 这个部分，因此您所知、所爱的面向对象编程，都是在这里实现的。如果您想要访问里面的函数的话，只需要导入这个库即可：1#import &lt;objc/runtime.h&gt; runtime.h开源库主要由 C 和汇编编写而成，其实现了诸如类、对象、方法调度、协议等面向对象编程这个部分。 成员结构体在运行时中对象和类本质上是一个非常简单的结构体，在运行时环境下，我们就可以创建，读取，修改这些属性方法等，例如：使用allocateClassPair函数创建类。 对象结构体对象结构体中仅提供一个isa属性，是关联类引用的指针。这也就是 Objective-C 当中的所有对象都需要实现的。在 runtime.h 当中对象的定义： 1234typedef struct objc_class *Class;struct objc_object &#123; Class isa;&#125;; 类结构体 123456789101112struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols;&#125;; isa属性：建立自身与 super_class 这个值进行关联。super_class:除了 NSObject 这个类之外，super_class 的值永远不会为 nil，因为 Objective-C 当中的其余类都是以某种方式继承自 NSObject 的。ivars：变量列表，methodLists：方法列表，protocols：协议列表，其他属性：name、version、info 之类的值。 变量结构体包含了变量类型和变量名称。偏移量 (offset) 则是内存管理方面的内容。 12345struct objc_ivar &#123; char *ivar_name; char *ivar_type; int ivar_offset;&#125; 方法结构体 12345struct objc_method &#123; SEL method_name; char *method_types; IMP method_imp;&#125; method_name： 方法名，使用Selector来表示方法编号，对应在 performSelector 当中所匹配的内容。method_types：方法类型，使用char字符来表示。method_imp：方法的实现，IMP是一个函数指针，方法实现的一种特定的表示方式，是方法混淆特性的根本所在。 成员函数运行时库提供一系列运行时函数，实现在运行时动态的对成员结构体（类/对象）进行创建，修改等相关操作，例如：创建类，在类别中添加存储属性 动态创建运行时类在制作库框架会大量运用使用到运行时函数。如果您无法知道用户将会创建什么样的数据，那么您就需要在运行时进行类的创建了。Core Data 就使用了这个功能。此外，如果您愿意的话，它还可以用在 JSON 解析当中。类的创建要用的 Objective-C 两个运行时函数：allocateClassPair和objc_registerClassPair123456//类函数的构造器Class myClass = objc_allocateClassPair([NSObject class], \"MyClass\", 0);// 在这里添加变量、方法和协议objc_registerClassPair(myClass);// 当类注册之后，变量列表将会被锁定[[myClass alloc] init]; //可见这个运行时类和Objective-C创建的类毫无区别 [NSObject class]：就是类结构体的属性isa要关联的类引用“MyClass”：指定类结构体的name属性值额外字节的定义：通常我们都直接赋值 0 即可 添加变量、方法以及协议 registerClassPair注册这个 ClassPair,注册之后，我们就无法修改变量列表了，不过其余的内容仍然可以修改。 为类别中新增存储属性类别可以在既有的类中添加函数、计算属性，无法添加存储属性。但是在运行时环境下，可以借助 setAssociatedObject 和 getAssociatedObject实现向既有的类当中添加存储属性。例如在NSObject新增一个Name存储属性：123456789@implementation NSObject (Name)@dynamic Name;- (void)setName:(id)object &#123; objc_setAssociatedObject(self, @selector(Name), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)Name &#123; return objc_getAssociatedObject(self, @selector(Name));&#125; 内省机制内省机制是用来判别这个类是否实现具备某项功能。当我们使用了一个带有可选方法的协议时，为了避免崩溃发生，可以借助这个内省机制来判断这个对象是否可以调用此可选方法。内省机制提供了两个运行时函数isMemberOfClass: 对比两者的 isa 是否相同。respondsToSelector:则封装了一个运行时函数：class_respondsToSelector，两个参数类和 Selector123456//类成员判断[myObject isMemberOfClass:NSObject.class];//类方法判断[myObject respondsToSelector:@selector(doStuff:)];//等价上一句class_respondsToSelector(myObject.class, @selector(doStuff:)); 使用运行时实现单元测试当我们在编写 XCTestCase 的时候，需要完成 setUp 和 tearDown 的设定，随后才能编写相关的 test 函数。当测试运行的时候，系统会自行遍历所有的测试函数，并自动运行。123456789101112unsigned int count;Method *methods = class_copyMethodList(myObject.class,&amp;count); //方法列表//Ivar *list = class_copyIvarList(myObject.class,&amp;count); //变量列表for(unsigned i = 0; i &lt; count; i++) &#123; SEL selector = method_getName(methods[i]); //获取到方法名 NSString *selectorString = NSStringFromSelector(selector); //转为字符串 if ([selectorString containsString:@&quot;test&quot;]) &#123; [myObject performSelector:selector]; &#125;&#125;free(methods); 单元测试的原理就是借助了运行时函数class_copyMethodList获取到方法名，然后将其转换为字符串，检查其是否包含有 “test”，如果有便可以运行。 运行时方法调度动态的向对象当中添加方法并调用新增的方法。方法转发，方法混淆：替换或交换 动态的为类新增方法了解到运行时的方法的结构体组成：方法名，SEL和IMP实现，需要三个运行时函数来新建一个运行时方法12345678//Method doStuff = class_getInstanceMethod(self.class, @selector(doStuff));//获取方法的实现IMP doStuffImplementation = method_getImplementation(doStuff);//获取方法的类型const char *types = method_getTypeEncoding(doStuff); //“v@:@\"class_addMethod(myClass.class, @selector(doStuff:), doStuffImplementation, types); class_getInstanceMethod:获取方法的SELmethod_getImplementation:方法的实现IMPmethod_getTypeEncoding: 获取方法的类型，char字符表示class_addMethod: 向对象当中添加方法的运行时函数。它所需的参数，即上述方法结构体当中的那三个值：Selector、方法实现和方法类型。 调用运行时方法我们可以使用 [self doStuff] 或者[self performSelector:@selector(doStuff)]来进行调用。实际上在运行时级别，它们都是借助 objc_msgSend 向对象发送了一个消息：1objc_msgSend(self, @selector(message)); 但是如果调用方法所在的对象为 nil 的时候，我们就会得到一个异常，应用便会崩溃。但事实证明，在崩溃之前会预留几个步骤，从而允许我们对某个不存在的函数进行一些操作：方法转发/替换等。 方法转发当桥接两个不同的框架的时候，可以将方法转发给其它目标，或者，当我们调用某个未实现的方法时，运行时有如下处理步骤：1234567891011// 1添加实例方法/类方法，如果 return YES，就会调用原始方法+(BOOL)resolveInstanceMethod:(SEL)sel;+(BOOL)resolveClassMethod:(SEL)sel;// 2 返回可以处理 Selector 的对象- (id)forwardingTargetForSelector:(SEL)aSelector;// 3 创建 NSInvocation- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;// 4 在您所选择的目标上调用 Selector- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:target];&#125; 3.1. 首先调用两个类方法：一个名为 resolveInstanceMethod/resolveClassMethod类方法，这时候我们便有机会来添加方法了，如果我们返回了 YES，就意味着原始方法将会再次被调用。3.2. forwardingTargetForSelector：当不要添加新方法时，可以直接返回需要调用方法的目标对象，之后这个对象就会调用 Selector。3.3. forwardInvocation：实现目标对象调用 Selector，所有的调用过程都被封装到 NSInvocation 对象当中。需要 通过methodSignatureForSelector函数创建。 动态特性方法混淆：替换或交换方法混淆是通过 class_replaceMethod 或者 method_exchangeImplementations 实现方法的替换。常用于日志记录和 Mock 测试。当类加载之后，会调用一个名为 load 的类函数。由于我们只打算混淆一次，因此我们需要使用 dispatch_once。接着我们便可以得到该方法，然后使用 class_replaceMethod 或者 method_exchangeImplementations 来替换方法。1234567891011121314151617181920212223242526+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(doSomething); SEL swizzledSelector = @selector(mo_doSomething); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class,swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"语法","slug":"swift/语法","permalink":"https://huos3203.github.io/categories/swift/语法/"}],"tags":[]},{"title":"MVVM介绍","slug":"iOS/MVVM介绍","date":"2017-09-24T19:26:28.000Z","updated":"2017-10-02T22:00:42.000Z","comments":true,"path":"2017/09/25/iOS/MVVM介绍/","link":"","permalink":"https://huos3203.github.io/2017/09/25/iOS/MVVM介绍/","excerpt":"","text":"MVVM所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM： 我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。 稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？ 这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。 在典型的 MVC 应用里，许多逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 NSDate 转换为一个格式化过的 NSString。我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间： 看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。 优点现在我们知道了什么是 MVVM，但为什么我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。 此处有三个重点是我希望你看完本文能带走的： MVVM 可以兼容你当下使用的 MVC 架构。 MVVM 增加你的应用的可测试性。 MVVM 配合一个绑定机制效果最好。 如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。 示例让我们看一个简单的 Person Model 以及相应的 View Controller：12345678910@interface Person : NSObject- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;@property (nonatomic, readonly) NSString *salutation;@property (nonatomic, readonly) NSString *firstName;@property (nonatomic, readonly) NSString *lastName;@property (nonatomic, readonly) NSDate *birthdate;@end 现在我们假设我们有一个 PersonViewController ，在 viewDidLoad 里，只需要基于它的 model 属性设置一些 Label 即可。12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; if (self.model.salutation.length &gt; 0) &#123; self.nameLabel.text = [NSString stringWithFormat:@\"%@ %@ %@\", self.model.salutation, self.model.firstName, self.model.lastName]; &#125; else &#123; self.nameLabel.text = [NSString stringWithFormat:@\"%@ %@\", self.model.firstName, self.model.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"EEEE MMMM d, yyyy\"]; self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];&#125; 这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。12345678910@interface PersonViewModel : NSObject- (instancetype)initWithPerson:(Person *)person;@property (nonatomic, readonly) Person *person;@property (nonatomic, readonly) NSString *nameText;@property (nonatomic, readonly) NSString *birthdateText;@end 我们的 View Model 的实现大概如下：1234567891011121314151617181920@implementation PersonViewModel- (instancetype)initWithPerson:(Person *)person &#123; self = [super init]; if (!self) return nil; _person = person; if (person.salutation.length &gt; 0) &#123; _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName]; &#125; else &#123; _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;]; _birthdateText = [dateFormatter stringFromDate:person.birthdate]; return self;&#125;@end 我们已经将 viewDidLoad 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 viewDidLoad 就会非常轻量：123456- (void)viewDidLoad &#123; [super viewDidLoad]; self.nameLabel.text = self.viewModel.nameText; self.birthdateLabel.text = self.viewModel.birthdateText;&#125; 所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来更轻量的 View Controllers。 可测试View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：123456789101112131415161718192021222324SpecBegin(Person)NSString *salutation = @&quot;Dr.&quot;;NSString *firstName = @&quot;first&quot;;NSString *lastName = @&quot;last&quot;;NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0];it (@&quot;should use the salutation available. &quot;, ^&#123; Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.nameText).to.equal(@&quot;Dr. first last&quot;);&#125;);it (@&quot;should not use an unavailable salutation. &quot;, ^&#123; Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.nameText).to.equal(@&quot;first last&quot;);&#125;);it (@&quot;should use the correct date format. &quot;, ^&#123; Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.birthdateText).to.equal(@&quot;Thursday January 1, 1970&quot;);&#125;);SpecEnd 如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Label 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。 响应式同步注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。 在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。 我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看这篇博客，它用更多细节解释了 MVVM 的好处，或者这一篇关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 C-41 ，它是开源的。去看看吧，如果你有任何疑问，请告诉我。 话题 #13 下的更多文章 原文 Introduction to MVVM","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"设计","slug":"iOS/设计","permalink":"https://huos3203.github.io/categories/iOS/设计/"}],"tags":[]},{"title":"线程安全类的设计","slug":"iOS/线程安全类的设计","date":"2017-09-24T19:06:03.000Z","updated":"2017-09-24T19:06:03.000Z","comments":true,"path":"2017/09/25/iOS/线程安全类的设计/","link":"","permalink":"https://huos3203.github.io/2017/09/25/iOS/线程安全类的设计/","excerpt":"","text":"这篇文章将专注于实用技巧，设计模式，以及对于写出线程安全类和使用 GCD 来说所特别需要注意的一些反面模式。 线程安全Apple 的框架首先让我们来看看 Apple 的框架。一般来说除非特别声明，大多数的类默认都不是线程安全的。对于其中的一些类来说，这是很合理的，但是对于另外一些来说就很有趣了。 就算是在经验丰富的 iOS/Mac 开发者，也难免会犯从后台线程去访问 UIKit/AppKit 这种错误。比如因为图片的内容本身就是从后台的网络请求中获取的话，顺手就在后台线程中设置了 image 之类的属性，这样的错误其实是屡见不鲜的。Apple 的代码都经过了性能的优化，所以即使你从别的线程设置了属性的时候，也不会产生什么警告。 在设置图片这个例子中，症结其实是你的改变通常要过一会儿才能生效。但是如果有两个线程在同时对图片进行了设定，那么很可能因为当前的图片被释放两次，而导致应用崩溃。这种行为是和时机有关系的，所以很可能在开发阶段没有崩溃，但是你的用户使用时却不断 crash。 现在没有官方的用来寻找类似错误的工具，但我们确实有一些技巧来避免这个问题。UIKit Main Thread Guard 是一段用来监视每一次对 setNeedsLayout 和 setNeedsDisplay 的调用代码，并检查它们是否是在主线程被调用的。因为这两个方法在 UIKit 的 setter （包括 image 属性）中广泛使用，所以它可以捕获到很多线程相关的错误。虽然这个小技巧并不包含任何私有 API， 但我们还是不建议将它是用在发布产品中，不过在开发过程中使用的话还是相当赞的。 Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。 为什么 UIKit 不是线程安全的？对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。将 non-atomic 的属性变为 atomic 的属性只不过是需要做的变化里的微不足道的一小部分。 通常来说，UI需要同时改变若干个属性，才能看到它所带来的结果。为了解决这个问题，苹果可能不得不提供像 Core Data 中的 performBlock: 和 performBlockAndWait: 那样类似的方法来同步变更。 绝大多数对 UIKit 类的调用其实都是以配置为目的的，这使得将 UIKit 改为线程安全这件事情更显得毫无意义了。 然而即使是那些与配置共享的内部状态之类事情无关的调用，其实也不是线程安全的。如果你做过 iOS 3.2 或之前的黑暗年代的 app 开发的话，你肯定有过一边在后台准备图像时一边使用 NSString 的 drawInRect:withFont: 时的随机崩溃的经历。值得庆幸的事，在 iOS 4 中 苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了后台线程可用。 但不幸的是 Apple 在线程安全方面的文档是极度匮乏的。他们推荐只访问主线程，并且甚至是绘图方法他们都没有明确地表示保证线程安全。因此在阅读文档的同时，去读读 iOS 版本更新说明会是一个很好的选择。 对于大多数情况来说，UIKit 类确实只应该用在应用的主线程中。这对于那些继承自 UIResponder 的类以及那些操作你的应用的用户界面的类来说，不管如何都是很正确的。 内存回收 (deallocation) 问题另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。Apple 在技术笔记 TN2109 中概述了这个问题，并提供了多种解决方案。这个问题其实是要求 UI 对象应该在主线程中被回收，因为在它们的 dealloc 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行。 因为调用者被其他线程持有是非常常见的（不管是由于 operation 还是 block 所导致的），这也是很容易犯错并且难以被修正的问题。在 AFNetworking 中也一直长久存在这样的 bug，但是由于其自身的隐蔽性而鲜为人知，也很难重现其所造成的崩溃。在异步的 block 或者操作中一致使用 __weak，并且不去直接访问局部变量会对避开这类问题有所帮助。 集合类Apple 有一个针对 iOS 和 Mac 的很好的总览性文档，为大多数基本的 foundation 类列举了其线程安全特性。总的来说，比如 NSArry 这样不可变类是线程安全的。然而它们的可变版本，比如 NSMutableArray 是线程不安全的。事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。要记住的是即使你申明了返回类型是不可变的，方法里还是有可能返回的其实是一个可变版本的集合类。一个好习惯是写类似于 return [array copy] 这样的代码来确保返回的对象事实上是不可变对象。 与和Java这样的语言不一样，Foundation 框架并不提供直接可用的集合类，这是有其道理的，因为大多数情况下，你想要的是在更高层级上的锁，以避免太多的加解锁操作。但缓存是一个值得注意的例外，iOS 4 中 Apple 添加的 NSCache 使用一个可变的字典来存储不可变数据，它不仅会对访问加锁，更甚至在低内存情况下会清空自己的内容。 也就是说，在你的应用中存在可变的且线程安全的字典是可以做到的。借助于 class cluster 的方式，我们也很容易写出这样的代码。 原子属性 (Atomic Properties)你曾经好奇过 Apple 是怎么处理 atomic 的设置/读取属性的么？至今为止，你可能听说过自旋锁 (spinlocks)，信标 (semaphores)，锁 (locks)，@synchronized 等，Apple 用的是什么呢？因为 Objctive-C 的 runtime 是开源的，所以我们可以一探究竟。 一个非原子的 setter 看起来是这个样子的：1234567- (void)setUserName:(NSString *)userName &#123; if (userName != _userName) &#123; [userName retain]; [_userName release]; _userName = userName; &#125;&#125; 这是一个手动 retain/release 的版本，ARC 生成的代码和这个看起来也是类似的。当我们看这段代码时，显而易见要是 setUserName: 被并发调用的话会造成麻烦。我们可能会释放 _userName 两次，这回使内存错误，并且导致难以发现的 bug。 对于任何没有手动实现的属性，编译器都会生成一个 objc_setProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) 的调用。在我们的例子中，这个调用的参数是这样的：12objc_setProperty_non_gc(self, _cmd,(ptrdiff_t)(&amp;_userName) - (ptrdiff_t)(self), userName, NO, NO);` ptrdiff_t 可能会吓到你，但是实际上这就是一个简单的指针算术，因为其实 Objective-C 的类仅仅只是 C 结构体而已。 objc_setProperty 调用的是如下方法：123456789101112131415161718192021222324252627static inline void reallySetProperty(id self, SEL _cmd, id newValue,ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:NULL]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:NULL]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)]; _spin_lock(slotlock); oldValue = *slot; *slot = newValue; _spin_unlock(slotlock); &#125; objc_release(oldValue);&#125; 除开方法名字很有趣以外，其实方法实际做的事情非常直接，它使用了在 PropertyLocks 中的 128 个自旋锁中的 1 个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作。 虽然这些方法没有定义在任何公开的头文件中，但我们还是可用手动调用他们。我不是说这是一个好的做法，但是知道这个还是蛮有趣的，而且如果你想要同时实现原子属性和自定义的 setter 的话，这个技巧就非常有用了。12345678910// 手动声明运行时的方法extern void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset,id newValue, BOOL atomic, BOOL shouldCopy);extern id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset,BOOL atomic);#define PSTAtomicRetainedSet(dest, src) objc_setProperty(self, _cmd,(ptrdiff_t)(&amp;dest) - (ptrdiff_t)(self), src, YES, NO)#define PSTAtomicAutoreleasedGet(src) objc_getProperty(self, _cmd,(ptrdiff_t)(&amp;src) - (ptrdiff_t)(self), YES) 参考这个 gist 来获取包含处理结构体的完整的代码，但是我们其实并不推荐使用它。 为何不用 @synchronized ？你也许会想问为什么苹果不用 @synchronized(self) 这样一个已经存在的运行时特性来锁定属？？你可以看看这里的源码，就会发现其实发生了很多的事情。Apple 使用了最多三个加/解锁序列，还有一部分原因是他们也添加了异常开解(exception unwinding)机制。相比于更快的自旋锁方式，这种实现要慢得多。由于设置某个属性一般来说会相当快，因此自旋锁更适合用来完成这项工作。@synchonized(self) 更适合使用在你需要确保在发生错误时代码不会死锁，而是抛出异常的时候。 你自己的类单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到竞态条件的困扰。看看下面的代码片段：12345if (self.contents) &#123; CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, (__bridge CFStringRef)self.contents, NULL); // 渲染字符串&#125; 我之前在 PSPDFKit 中就犯了这个错误。时不时地应用就会因为 contents 属性在通过检查之后却又被设成了 nil 而导致 EXC_BAD_ACCESS 崩溃。捕获这个变量就可以简单修复这个问题；123456NSString *contents = self.contents;if (contents) &#123; CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, (__bridge CFStringRef)contents, NULL); // 渲染字符串&#125; 在这里这样就能解决问题，但是大多数情况下不会这么简单。想象一下我们还有一个 textColor 的属性，我们在一个线程中将两个属性都做了改变。我们的渲染线程有可能使用了新的内容，但是依旧保持了旧的颜色，于是我们得到了一组奇怪的组合。这其实也是为什么 Core Data 要将 model 对象都绑定在一个线程或者队列中的原因。 对于这个问题，其实没有万用解法。使用 不可变模型是一个可能的方案，但是它也有自己的问题。另一种途径是限制对存在在主线程或者某个特定队列中的既存对象的改变，而是先进行一次拷贝之后再在工作线程中使用。对于这个问题的更多对应方法，我推荐阅读 Jonathan Sterling 的关于 Objective-C 中轻量化不可变对象的文章。 一个简单的解决办法是使用 @synchronize。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。 可行的线程安全设计在尝试写一些线程安全的东西之前，应该先想清楚是不是真的需要。确保你要做的事情不会是过早优化。如果要写的东西是一个类似配置类 (configuration class) 的话，去考虑线程安全这种事情就毫无意义了。更正确的做法是扔一个断言上去，以保证它被正确地使用：12345void PSPDFAssertIfNotMainThread(void) &#123;NSAssert(NSThread.isMainThread,@\"Error: Method needs to be called on the main thread. %@\",[NSThread callStackSymbols]);&#125; 对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 dispatch_queue 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。一旦你使用多个队列来给不同的部分上锁的话，整件事情很快就会变得难以控制了。 于是你也可以重新组织你的代码，这样某些特定的锁就不再需要了。看看下面这段实现了一种多委托的代码（其实在大多数情况下，用 NSNotifications 会更好，但是其实也还是有多委托的实用例子）的1234567891011121314151617181920212223242526// 头文件@property (nonatomic, strong) NSMutableSet *delegates;// init方法中_delegateQueue = dispatch_queue_create(&quot;com.PSPDFKit.cacheDelegateQueue&quot;,DISPATCH_QUEUE_CONCURRENT);- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123; dispatch_barrier_async(_delegateQueue, ^&#123; [self.delegates addObject:delegate]; &#125;);&#125;- (void)removeAllDelegates &#123; dispatch_barrier_async(_delegateQueue, ^&#123; self.delegates removeAllObjects]; &#125;);&#125;- (void)callDelegateForX &#123; dispatch_sync(_delegateQueue, ^&#123; [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123; // 调用delegate &#125;]; &#125;);&#125; 除非 addDelegate: 或者 removeDelegate: 每秒要被调用上千次，否则我们可以使用一个相对简洁的实现方式：1234567891011121314151617181920// 头文件@property (atomic, copy) NSSet *delegates;- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123; @synchronized(self) &#123; self.delegates = [self.delegates setByAddingObject:delegate]; &#125;&#125;- (void)removeAllDelegates &#123; @synchronized(self) &#123; self.delegates = nil; &#125;&#125;- (void)callDelegateForX &#123; [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123; // 调用delegate &#125;];&#125; 就算这样，这个例子还是有点理想化，因为其他人可以把变更限制在主线程中。但是对于很多数据结构，可以在可变更操作的方法中创建不可变的拷贝，这样整体的代码逻辑上就不再需要处理过多的锁了。 GCD 的陷阱对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。然后，GCD 中还是有不少陷阱，我们在这里探索一下其中的一些。 将 GCD 当作递归锁使用GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 @synchronized 有很大区别。 GCD队列并非是可重入的，因为这将破坏队列的特性。很多有试图使用 dispatch_get_current_queue() 来绕开这个限制，但是这是一个糟糕的做法，Apple 在 iOS6 中将这个方法标记为废弃，自然也是有自己的理由。123456// This is a bad idea.inline void pst_dispatch_sync_reentrant(dispatch_queue_t queue,dispatch_block_t block)&#123; dispatch_get_current_queue() == queue ? block() : dispatch_sync(queue, block);&#125; 对当前的队列进行测试也许在简单情况下可以行得通，但是一旦你的代码变得复杂一些，并且你可能有多个队列在同时被锁住的情况下，这种方法很快就悲剧了。一旦这种情况发生，几乎可以肯定的是你会遇到死锁。当然，你可以使用 dispatch_get_specific()，这将截断整个队列结构，从而对某个特定的队列进行测试。要这么做的话，你还得为了在队列中附加标志队列的元数据，而去写自定义的队列构造函数。嘛，最好别这么做。其实在实用中，使用 NSRecursiveLock 会是一个更好的选择。 用 dispatch_async 修复时序问题在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美：12345dispatch_async(dispatch_get_main_queue(), ^&#123; // Some UIKit call that had timing issues but works fine // in the next runloop. [self updatePopoverSize];&#125;); 千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的”时序问题”。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。 记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 performSelector:afterDelay: 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。 在性能关键的代码中混用 dispatch_sync 和 dispatch_async这个问题我花了好久来研究。在 PSPDFKit 中有一个使用了 LRU（最久未使用）算法列表的缓存类来记录对图片的访问。当你在页面中滚动时，这个方法将被调用非常多次。最初的实现使用了 dispatch_sync 来进行实际有效的访问，使用 dispatch_async 来更新 LRU 列表的位置。这导致了帧数远低于原来的 60 帧的目标。 当你的 app 中的其他运行的代码阻挡了 GCD 线程的时候，dispatch manager 需要花时间去寻找能够执行 dispatch_async 代码的线程，这有时候会花费一点时间。在找到合适的执行线程之前，你的同步调用就会被 block 住了。其实在这个例子中，异步情况的执行顺序并不是很重要，但没有能将这件事情告诉 GCD 的好办法。读/写锁这里并不能起到什么作用，因为在异步操作中基本上一定会需要进行顺序写入，而在此过程中读操作将被阻塞住。如果误用了 dispatch_async 代价将会是非常惨重的。在将它用作锁的时候，一定要非常小心。 使用 dispatch_async 来派发内存敏感的操作我们已经谈论了很多关于 NSOperations 的话题了，一般情况下，使用这个更高层级的 API 会是一个好主意。当你要处理一段内存敏感的操作的代码块时，这个优势尤为突出、 在 PSPDFKit 的老版本中，我用了 GCD 队列来将已缓存的 JPG 图片写到磁盘中。当 retina 的 iPad 问世之后，这个操作出现了问题。ß因为分辨率翻倍了，相比渲染这张图片，将它编码花费的时间要长得多。所以，操作堆积在了队列中，当系统繁忙时，甚至有可能因为内存耗尽而崩溃。 我们没有办法追踪有多少个操作在队列中等待运行（除非你手动添加了追踪这个的代码），我们也没有现成的方法来在接收到低内存通告的时候来取消操作、这时候，切换到 NSOperations 可以使代码变得容易调试得多，并且允许我们在不添加手动管理的代码的情况下，做到对操作的追踪和取消。 当然也有一些不好的地方，比如你不能在你的 NSOperationQueue 中设置目标队列（就像 DISPATCH_QUEUE_PRIORITY_BACKGROUND 之于 缓速 I/O 那样）。但这只是为了可调试性的一点小代价，而事实上这也帮助你避免遇到优先级反转的问题。我甚至不推荐直接使用已经包装好的 NSBlockOperation 的 API，而是建议使用一个 NSOperation 的真正的子类，包括实现其 description。诚然，这样做工作量会大一些，但是能输出所有运行中/准备运行的操作是及其有用的。 话题 #2 下的更多文章 原文 Thread-Safe Class Design","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"设计","slug":"iOS/设计","permalink":"https://huos3203.github.io/categories/iOS/设计/"}],"tags":[]},{"title":"GCD底层并发API","slug":"iOS/GCD底层并发API","date":"2017-09-24T18:21:38.000Z","updated":"2017-09-24T18:21:38.000Z","comments":true,"path":"2017/09/25/iOS/GCD底层并发API/","link":"","permalink":"https://huos3203.github.io/2017/09/25/iOS/GCD底层并发API/","excerpt":"","text":"这篇文章里，我们将会讨论一些 iOS 和 OS X 都可以使用的底层 API。除了 dispatch_once ，我们一般不鼓励使用其中的任何一种技术。 但是我们想要揭示出表面之下深层次的一些可利用的方面。这些底层的 API 提供了大量的灵活性，随之而来的是大量的复杂度和更多的责任。在我们的文章常见的后台实践中提到的高层的 API 和模式能够让你专注于手头的任务并且免于大量的问题。通常来说，高层的 API 会提供更好的性能，除非你能承受起使用底层 API 带来的纠结于调试代码的时间和努力。 尽管如此，了解深层次下的软件堆栈工作原理还是有很有帮助的。我们希望这篇文章能够让你更好的了解这个平台，同时，让你更加感谢这些高层的 API。 首先，我们将会分析大多数组成 Grand Central Dispatch 的部分。它已经存在了好几年，并且苹果公司持续添加功能并且改善它。现在苹果已经将其开源，这意味着它对其他平台也是可用的了。最后，我们将会看一下原子操作——另外的一种底层代码块的集合。 或许关于并发编程最好的书是 M. Ben-Ari 写的《Principles of Concurrent Programming》,ISBN 0-13-701078-8。如果你正在做任何与并发编程有关的事情，你需要读一下这本书。这本书已经30多年了，仍然非常卓越。书中简洁的写法，优秀的例子和练习，带你领略并发编程中代码块的基本原理。这本书现在已经绝版了，但是它的一些复印版依然广为流传。有一个新版书，名字叫《Principles of Concurrent and Distributed Programming》,ISBN 0-321-31283-X,好像有很多相同的地方，不过我还没有读过。 常用的GCD单例：dispatch_once或许GCD中使用最多并且被滥用功能的就是 dispatch_once 了。正确的用法看起来是这样的：123456789+ (UIColor *)boringColor;&#123; static UIColor *color; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; &#125;); return color;&#125; 上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用 dispatch_once_t 会使得测试变得非常困难（单例和测试不是很好配合）。 要确保 onceToken 被声明为 static ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。换句话说，不要把 dispatch_once_t 作为一个对象的成员变量，或者类似的情形。 退回到远古时代（其实也就是几年前），人们会使用 pthread_once ，因为 dispatch_once_t 更容易使用并且不易出错，所以你永远都不会再用到 pthread_once 了。 延后执行：dispatch_after它能使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。一般用法是这样的：12345678- (void)foo&#123;double delayInSeconds = 2.0;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;[self bar];&#125;);&#125; 第一眼看上去这段代码是极好的。但是这里存在一些缺点。我们不能（直接）取消我们已经提交到 dispatch_after 的代码，它将会运行。 时序性bug当人们使用 dispatch_after 去处理他们代码中存在的时序 bug 时，会存在一些有问题的倾向。一些代码执行的过早而你很可能不知道为什么会这样，所以你把这段代码放到了 dispatch_after 中，现在一切运行正常了。但是几周以后，之前的工作不起作用了。由于你并不十分清楚你自己代码的执行次序，调试代码就变成了一场噩梦。所以不要像上面这样做。 解决方案大多数的情况下，你最好把代码放到正确的位置。如果代码放到 -viewWillAppear 太早，那么或许 -viewDidAppear 就是正确的地方。通过在自己代码中建立直接调用（类似 -viewDidAppear ）而不是依赖于 dispatch_after ，你会为自己省去很多麻烦。 推荐场景如果你需要一些事情在某个特定的时刻运行，那么 dispatch_after 或许会是个好的选择。确保同时考虑了 NSTimer，这个API虽然有点笨重，但是它允许你取消定时器的触发。 队列GCD是一个很大抽象层级用户 API，提供管理线程池队列的管理。当使用 GCD 来完成并发的工作时，你不必考虑线程方面的问题，只需考虑队列和功能点（提交给队列的 block）。虽然往下深究，依然都是线程，但是 GCD 的抽象层级为你惯用的编码提供了更好的方式。隔离队列：默认情况下，它们是串行的，也就是说，任何给定的时间内，只能有一个单独的 block 运行。并行队列：同一时间内允许多个 block 一起执行。GCD 中一个基本的代码块就是队列。下面我们会给出一些如何使用它的例子。当使用队列的时候，给它们一个明显的标签会帮自己不少忙。在调试时，这个标签会在 Xcode (和 lldb)中显示，这会帮助你了解你的 app 是由什么决定的：12345678910111213- (id)init;&#123; self = [super init]; if (self != nil) &#123; NSString *label = [NSString stringWithFormat:@\"%@.isolation.%p\", [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@\"%@.work.%p\", [self class], self]; //创建一个队列 self.workQueue = dispatch_queue_create([label UTF8String], 0); &#125; return self;&#125; 解决扇出问题队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程，并且想要做一些并发的事情，我们很可能将我们的工作分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当我们处理这些功能点时，可能会调用一些函数作为功能的一部分。写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在，你有了 8 × 8 = 64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。 GCD中创建线程GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。 线程阻塞问题如果你的代码阻塞了许多线程，这会带来很大的问题。首先，线程消耗资源，此外，创建线程会变得代价高昂。创建过程需要一些时间。并且在这段时间中，GCD 无法以全速来完成功能点。有不少能够导致线程阻塞的情况，但是最常见的情况与 I/O 有关，也就是从文件或者网络中读写数据。正是因为这些原因，你不应该在GCD队列中以阻塞的方式来做这些操作。看一下下面的输入输出段落去了解一些关于如何以 GCD 运行良好的方式来做 I/O 操作的信息。 目标队列目标队列可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 lldb。(lldb) thread list 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。如果一个队列的目标队列是串行的（也就是非并发），那么实际上这个队列也会转换为一个串行队列。你能够为你创建的任何一个队列设置一个目标队列。这会是很强大的，并且有助于调试。 使用私有队列同样强调封装性。这时你自己的队列，你要自己决定如何使用它。 队列转发控制默认情况下，一个新创建的队列转发到默认优先级的全局队列中。我们就将会讨论一些有关优先级的东西。 你可以改变你队列转发到的队列——你可以设置自己队列的目标队列。以这种方式，你可以将不同队列链接在一起。你的 Foo 类有一个队列，该队列转发到 Bar 类的队列，Bar 类的队列又转发到全局队列。 当你为了隔离目的而使用一个队列时，这会非常有用。Foo 有一个隔离队列，并且转发到 Bar 的隔离队列，与 Bar 的隔离队列所保护的有关的资源，会自动成为线程安全的。 优先级你可以通过设置目标队列为一个全局队列来改变自己队列的优先级，但是你应该克制这么做的冲动。 在大多数情况下，改变优先级不会使事情照你预想的方向运行。一些看起简单的事情实际上是一个非常复杂的问题。你很容易会碰到一个叫做优先级反转的情况。我们的文章《并发编程：API 及挑战》有更多关于这个问题的信息，这个问题几乎导致了NASA的探路者火星漫游器变成砖头。 此外，使用 DISPATCH_QUEUE_PRIORITY_BACKGROUND 队列时，你需要格外小心。除非你理解了 throttled I/O 和 background status as per setpriority(2) 的意义，否则不要使用它。不然，系统可能会以难以忍受的方式终止你的 app 的运行。打算以不干扰系统其他正在做 I/O 操作的方式去做 I/O 操作时，一旦和优先级反转情况结合起来，这会变成一种危险的情况。 隔离隔离队列是 GCD 队列使用中非常普遍的一种模式。这里有两个变种。 资源保护多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。 我们在有关多线程技术的文章中讨论了资源在并发编程中意味着什么，它通常就是一块内存或者一个对象，每次只有一个线程可以访问它。 串行队列读写共享资源举例来说，我们需要以多线程（或者多个队列）方式访问 NSMutableDictionary 。我们可能会照下面的代码来做：123456789101112131415161718192021- (void)setCount:(NSUInteger)count forKey:(NSString *)key&#123; key = [key copy]; dispatch_async(self.isolationQueue, ^()&#123; if (count == 0) &#123; [self.counts removeObjectForKey:key]; &#125; else &#123; self.counts[key] = @(count); &#125; &#125;);&#125;- (NSUInteger)countForKey:(NSString *)key;&#123; __block NSUInteger count; dispatch_sync(self.isolationQueue, ^()&#123; NSNumber *n = self.counts[key]; count = [n unsignedIntegerValue]; &#125;); return count;&#125; 通过以上代码，只有一个线程可以访问 NSMutableDictionary 的实例。 注意以下四点： 不要使用上面的代码，请先阅读多读单写和锁竞争 我们使用 async 方式来保存值，这很重要。我们不想也不必阻塞当前线程只是为了等待写操作完成。当读操作时，我们使用 sync 因为我们需要返回值。 从函数接口可以看出，-setCount:forKey: 需要一个 NSString 参数，用来传递给 dispatch_async。函数调用者可以自由传递一个 NSMutableString 值并且能够在函数返回后修改它。因此我们必须对传入的字符串使用 copy 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 NSString 类型），调用copy基本上是个空操作。 isolationQueue 创建时，参数 dispatch_queue_attr_t 的值必须是DISPATCH_QUEUE_SERIAL（或者0）。 barrier分发block实现并行队列多读单写我们能够改善上面的那个例子。GCD 有可以让多线程运行的并发队列。我们能够安全地使用多线程来从 NSMutableDictionary 中读取只要我们不同时修改它。我们使用 barrier 来分发一个block实现对字典的多读单写操作。这样的一个 block 的运行时机是，在它之前所有计划好的 block 完成之后，并且在所有它后面的 block 运行之前。 以如下方式创建队列：1self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT); 并且用以下代码来改变setter函数：1234567891011- (void)setCount:(NSUInteger)count forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(self.isolationQueue, ^()&#123; if (count == 0) &#123; [self.counts removeObjectForKey:key]; &#125; else &#123; self.counts[key] = @(count); &#125; &#125;);&#125; 当使用并发队列时，要确保所有的 barrier 调用都是 async 的。如果你使用 dispatch_barrier_sync ，那么你很可能会使你自己（更确切的说是，你的代码）产生死锁。写操作需要 barrier，并且可以是 async 的。 锁竞争首先，这里有一个警告：上面这个例子中我们保护的资源是一个 NSMutableDictionary，出于这样的目的，这段代码运行地相当不错。但是在真实的代码中，把隔离放到正确的复杂度层级下是很重要的。 如果你对 NSMutableDictionary 的访问操作变得非常频繁，你会碰到一个已知的叫做锁竞争的问题。锁竞争并不是只是在 GCD 和队列下才变得特殊，任何使用了锁机制的程序都会碰到同样的问题——只不过不同的锁机制会以不同的方式碰到。 时序性避免使用锁所有对 dispatch_async，dispatch_sync 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码。GCD 某些程序上可以使用时序(译注：原词为 scheduling)来避免使用锁，但在最后，问题只是稍有变化。根本问题仍然存在：如果你有大量的线程在相同时间去访问同一个锁或者队列，你就会看到性能的变化。性能会严重下降。 平衡两个开销你应该直接从复杂层次中隔离开。当你发现了性能下降，这明显表明代码中存在设计问题。这里有两个开销需要你来平衡：第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。例如：一个在隔离队列中运行 block，它可能潜在的阻塞了其他将要在这个隔离队列中运行的代码。第二个是太频繁出入临界区的开销。例如频繁调用 dispatch_async 和 dispatch_sync 。无论再怎么优化，这两个操作都不是无代价的。令人忧伤的，不存在通用的标准来指导如何正确的平衡，你需要自己评测和调整。启动 Instruments 观察你的 app 忙于什么操作。 设计层保护隔离队列在你自己的代码中，要考虑自己是否在更高的层次保护了隔离队列。举个例子：类 Foo 有一个隔离队列并且它本身保护着对 NSMutableDictionary 的访问，代替的，可以有一个用到了 Foo 类的 Bar 类有一个隔离队列保护所有对类 Foo 的使用。换句话说，你可以把类 Foo 变为非线程安全的（没有隔离队列），并在 Bar 中，使用一个隔离队列来确保任何时刻只能有一个线程使用 Foo 。 死锁问题全都使用异步分发 同步分发死锁 在 GCD 中，同步和异步地分发一个 block，一个工作单元。以同步分发的方式非常容易出现死锁。见下面的代码：123456dispatch_queue_t queueA; // assume we have thisdispatch_sync(queueA, ^()&#123; dispatch_sync(queueA, ^()&#123; foo(); &#125;);&#125;); 一旦我们进入到第二个 dispatch_sync 就会发生死锁。我们不能分发到queueA，因为有人（当前线程）正在队列中并且永远不会离开。 更隐晦的产生死锁方式：1234567891011121314151617181920dispatch_queue_t queueA; // assume we have thisdispatch_queue_t queueB; // assume we have thisdispatch_sync(queueA, ^()&#123; foo();&#125;);void foo(void)&#123; dispatch_sync(queueB, ^()&#123; bar(); &#125;);&#125;void bar(void)&#123; dispatch_sync(queueA, ^()&#123; baz(); &#125;);&#125; 单独的每次调用 dispatch_sync() 看起来都没有问题，但是一旦组合起来，就会发生死锁。 解决：异步调用不会产生死锁这是使用同步分发存在的固有问题，如果我们使用异步分发，比如：123456dispatch_queue_t queueA; // assume we have thisdispatch_async(queueA, ^()&#123; dispatch_async(queueA, ^()&#123; foo(); &#125;);&#125;); 一切运行正常。异步调用不会产生死锁。因此值得我们在任何可能的时候都使用异步分发。我们使用一个异步调用结果 block 的函数，来代替编写一个返回值（必须要用同步）的方法或者函数。这种方式，我们会有更少发生死锁的可能性。 异步调用的副作用就是它们很难调试。当我们在调试器里中止代码运行，回溯并查看已经变得没有意义了。 要牢记这些。死锁通常是最难处理的问题。 如何设计健壮的异步 API记住几种好的实践： 需要倾向于异步 API。当你创建一个 API，它会在你的控制之外以各种方式调用，如果你的代码能产生死锁，那么死锁就会发生。 主动在自己的函数或者方法中调用异步分发dispatch_async()。不要让你的函数调用者来这么做，这个调用应该在你的方法或者函数中来做。 返回值传递，异步地将方法或函数的返回值传递给回调处理程序。这个API（方法或函数）应该同时持有一个结果 block 和一个将结果传递过去的队列。不需要API调用者自己来做分发。这么做的原因很简单：几乎所有事件，函数调用都应该在一个适当的队列中，而且以这种方式编写的代码是很容易阅读的。总之，你的函数将会（必须）调用 dispatch_async() 去运行回调处理程序，所以它同时也可能在需要调用的队列上做这些工作。 如果你写一个类，让你类的使用者设置一个回调处理队列或许会是一个好的选择。你的代码可能像这样：123456789- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;&#123; dispatch_async(self.isolationQueue, ^(void)&#123; // do actual processing here dispatch_async(self.resultQueue, ^(void)&#123; handler(YES); &#125;); &#125;);&#125; 如果你以这种方式来写你的类，让类之间协同工作就会变得容易。如果类 A 使用了类 B，它会把自己的隔离队列设置为 B 的回调队列。 迭代执行如果你正在倒弄一些数字，并且手头上的问题可以拆分出同样性质的部分，那么 dispatch_apply 会很有用。 如果你的代码看起来是这样的：12345for (size_t y = 0; y &lt; height; ++y) &#123; for (size_t x = 0; x &lt; width; ++x) &#123; // Do something with x and y here &#125;&#125; 小小的改动或许就可以让它运行的更快：12345dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) &#123; for (size_t x = 0; x &lt; width; x += 2) &#123; // Do something with x and y here &#125;&#125;); 代码运行良好的程度取决于你在循环内部做的操作。 block 中运行的工作必须是非常重要的，否则这个头部信息就显得过于繁重了。除非代码受到计算带宽的约束，每个工作单元为了很好适应缓存大小而读写的内存都是临界的。这会对性能会带来显著的影响。受到临界区约束的代码可能不会很好地运行。详细讨论这些问题已经超出了这篇文章的范围。使用 dispatch_apply 可能会对性能提升有所帮助，但是性能优化本身就是个很复杂的主题。维基百科上有一篇关于 Memory-bound function 的文章。内存访问速度在 L2，L3 和主存上变化很显著。当你的数据访问模式与缓存大小不匹配时，10倍性能下降的情况并不少见。 组很多时候，你发现需要将异步的 block 组合起来去完成一个给定的任务。这些任务中甚至有些是并行的。现在，如果你想要在这些任务都执行完成后运行一些代码，”groups” 可以完成这项任务。看这里的例子：12345678910111213141516171819202122dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_group_async(group, queue, ^()&#123; // Do something that takes a while [self doSomeFoo]; dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123; self.foo = 42; &#125;);&#125;);dispatch_group_async(group, queue, ^()&#123; // Do something else that takes a while [self doSomeBar]; dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123; self.bar = 1; &#125;);&#125;);// This block will run once everything above is done:dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123; NSLog(@\"foo: %d\", self.foo); NSLog(@\"bar: %d\", self.bar);&#125;); 需要注意的重要事情是，所有的这些都是非阻塞的。我们从未让当前的线程一直等待直到别的任务做完。恰恰相反，我们只是简单的将多个 block 放入队列。由于代码不会阻塞，所以就不会产生死锁。 同时需要注意的是，在这个小并且简单的例子中，我们是怎么在不同的队列间进切换的。 对现有API使用 dispatch_group_t一旦你将 groups 作为你的工具箱中的一部分，你可能会怀疑为什么大多数的异步API不把 dispatch_group_t 作为一个可选参数。这没有什么无法接受的理由，仅仅是因为自己添加这个功能太简单了，但是你还是要小心以确保自己使用 groups 的代码是成对出现的。 举例来说，我们可以给 Core Data 的 -performBlock: API 函数添加上 groups，就像这样：123456789101112- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block&#123;if (group == NULL) &#123;[self performBlock:block];&#125; else &#123;dispatch_group_enter(group);[self performBlock:^()&#123;block();dispatch_group_leave(group);&#125;];&#125;&#125; 当 Core Data 上的一系列操作(很可能和其他的代码组合起来)完成以后，我们可以使用 dispatch_group_notify 来运行一个 block 。 很明显，我们可以给 NSURLConnection 做同样的事情：12345678910111213141516171819+ (void)withGroup:(dispatch_group_t)groupsendAsynchronousRequest:(NSURLRequest *)requestqueue:(NSOperationQueue *)queuecompletionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler&#123; if (group == NULL) &#123; [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; &#125; else &#123; dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123; handler(response, data, error); dispatch_group_leave(group); &#125;]; &#125;&#125; 为了能正常工作，你需要确保: dispatch_group_enter() 必须要在 dispatch_group_leave()之前运行。 dispatch_group_enter() 和 dispatch_group_leave() 一直是成对出现的（就算有错误产生时）。 事件源GCD 有一个较少人知道的特性：事件源 dispatch_source_t。 跟 GCD 一样，它也是很底层的东西。当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。 GCD 事件源是以极其资源高效的方式实现的。 监视进程如果一些进程正在运行而你想知道他们什么时候存在，GCD 能够做到这些。你也可以使用 GCD 来检测进程什么时候分叉，也就是产生子进程或者传送给了进程的一个信号（比如 SIGTERM）。123456789101112NSRunningApplication *mail = [NSRunningApplicationrunningApplicationsWithBundleIdentifier:@\"com.apple.mail\"];if (mail == nil) &#123;return;&#125;pid_t const pid = mail.processIdentifier;self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid,DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(self.source, ^()&#123;NSLog(@\"Mail quit.\");&#125;);dispatch_resume(self.source); 当 Mail.app 退出的时候，这个程序会打印出 Mail quit.。 注意：在所有的事件源被传递到你的事件处理器之前，必须调用 dispatch_resume()。 监视文件这种可能性是无穷的。你能直接监视一个文件的改变，并且当改变发生时事件源的事件处理将会被调用。 你也可以使用它来监视文件夹，比如创建一个 watch folder：123456789101112131415161718192021222324NSURL *directoryURL; // assume this is set to a directoryint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) &#123;char buffer[80];strerror_r(errno, buffer, sizeof(buffer));NSLog(@&quot;Unable to open \\&quot;%@\\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno);return;&#125;dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^()&#123;unsigned long const data = dispatch_source_get_data(source);if (data &amp; DISPATCH_VNODE_WRITE) &#123;NSLog(@&quot;The directory changed.&quot;);&#125;if (data &amp; DISPATCH_VNODE_DELETE) &#123;NSLog(@&quot;The directory has been deleted.&quot;);&#125;&#125;);dispatch_source_set_cancel_handler(source, ^()&#123;close(fd);&#125;);self.source = source;dispatch_resume(self.source); 你应该总是添加 DISPATCH_VNODE_DELETE 去检测文件或者文件夹是否已经被删除——然后就停止监听。 定时器大多数情况下，对于定时事件你会选择 NSTimer。定时器的GCD版本是底层的，它会给你更多控制权——但要小心使用。 需要特别重点指出的是，为了让 OS 节省电量，需要为 GCD 的定时器接口指定一个低的余地值(译注：原文leeway value)。如果你不必要的指定了一个低余地值，将会浪费更多的电量。 这里我们设定了一个5秒的定时器，并允许有十分之一秒的余地值：12345678910dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^()&#123; NSLog(@\"Time flies.\");&#125;);dispatch_time_t startdispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);self.source = source;dispatch_resume(self.source); 取消所有的事件源都允许你添加一个 cancel handler 。这对清理你为事件源创建的任何资源都是很有帮助的，比如关闭文件描述符。GCD 保证在 cancel handle 调用前，所有的事件处理都已经完成调用。 参考上面的监视文件例子中对 dispatch_source_set_cancel_handler() 的使用。 输入输出写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。GCD 有一些能够帮上忙的地方。不会涉及太多的细节，我们只简单的分析下问题是什么，GCD 是怎么处理的。 习惯上，当你从一个网络套接字中读取数据时，你要么做一个阻塞的读操作，也就是让你个线程一直等待直到数据变得可用，或者是做反复的轮询。这两种方法都是很浪费资源并且无法度量。然而，kqueue 通过当数据变得可用时传递一个事件解决了轮询的问题，GCD 也采用了同样的方法，但是更加优雅。当向套接字写数据时，同样的问题也存在，这时你要么做阻塞的写操作，要么等待套接字直到能够接收数据。 在处理 I/O 时，还有一个问题就是数据是以数据块的形式到达的。当从网络中读取数据时，依据 MTU(]最大传输单元)，数据块典型的大小是在1.5K字节左右。这使得数据块内可以是任何内容。一旦数据到达，你通常只是对跨多个数据块的内容感兴趣。而且通常你会在一个大的缓冲区里将数据组合起来然后再进行处理。假设（人为例子）你收到了这样8个数据块： 0: HTTP/1.1 200 OK\\r\\nDate: Mon, 23 May 2005 22:381: :34 GMT\\r\\nServer: Apache/1.3.3.7 (Unix) (Red-H2: at/Linux)\\r\\nLast-Modified: Wed, 08 Jan 2003 233: :11:55 GMT\\r\\nEtag: “3f80f-1b6-3e1cb03b”\\r\\nCon4: tent-Type: text/html; charset=UTF-8\\r\\nContent-5: Length: 131\\r\\nConnection: close\\r\\n\\r\\n\\r6: \\n\\r\\n An Example Page\\r\\n7: \\r\\n\\r\\n Hello World, this is a veL2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"live2d-widget-model-wanko\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false,\"tagMode\":false}); 如果你是在寻找 HTTP 的头部，将所有数据块组合成一个大的缓冲区并且从中查找 \\r\\n\\r\\n 是非常简单的。但是这样做，你会大量地复制这些数据。大量 旧的 C 语言 API 存在的另一个问题就是，缓冲区没有所有权的概念，所以函数不得不将数据再次拷贝到自己的缓冲区中——又一次的拷贝。拷贝数据操作看起来是无关紧要的，但是当你正在做大量的 I/O 操作的时候，你会在 profiling tool(Instruments) 中看到这些拷贝操作大量出现。即使你仅仅每个内存区域拷贝一次，你还是使用了两倍的存储带宽并且占用了两倍的内存缓存。 GCD 和缓冲区最直接了当的方法是使用数据缓冲区。GCD 有一个 dispatch_data_t 类型，在某种程度上和 Objective-C 的 NSData 类型很相似。但是它能做别的事情，而且更通用。 注意，dispatch_data_t 可以被 retained 和 releaseed ，并且 dispatch_data_t 拥有它持有的对象。 这看起来无关紧要，但是我们必须记住 GCD 只是纯 C 的 API，并且不能使用Objective-C。通常的做法是创建一个缓冲区，这个缓冲区要么是基于栈的，要么是 malloc 操作分配的内存区域 —— 这些都没有所有权。 dispatch_data_t 的一个相当独特的属性是它可以基于零碎的内存区域。这解决了我们刚提到的组合内存的问题。当你要将两个数据对象连接起来时：123dispatch_data_t a; // Assume this hold some valid datadispatch_data_t b; // Assume this hold some valid datadispatch_data_t c = dispatch_data_create_concat(a, b); 数据对象 c 并不会将 a 和 b 拷贝到一个单独的，更大的内存区域里去。相反，它只是简单地 retain 了 a 和 b。你可以使用 dispatch_data_apply 来遍历对象 c 持有的内存区域：1234dispatch_data_apply(c, ^bool(dispatch_data_t region, size_t offset, const void *buffer, size_t size) &#123;fprintf(stderr, \"region with offset %zu, size %zu\\n\", offset, size);return true;&#125;); 类似的，你可以使用 dispatch_data_create_subrange 来创建一个不做任何拷贝操作的子区域。 读和写在 GCD 的核心里，调度 I/O（译注：原文为 Dispatch I/O） 与所谓的通道有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。创建这样一个通道最基本的方式就是调用：12dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd,dispatch_queue_t queue, void (^cleanup_handler)(int error)); 这将返回一个持有文件描述符的创建好的通道。在你通过它创建了通道之后，你不准以任何方式修改这个文件描述符。 有两种从根本上不同类型的通道：流和随机存取。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。 如果你想要为一个文件创建一个通道，你最好使用需要一个路径参数的 dispatch_io_create_with_path ，并且让 GCD 来打开这个文件。这是有益的，因为GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量。 类似通常的 read(2)，write(2) 和 close(2) 的操作，GCD 提供了 dispatch_io_read，dispatch_io_write 和 dispatch_io_close。无论何时数据读完或者写完，读写操作调用一个回调 block 来结束。这些都是以非阻塞，异步 I/O 的形式高效实现的。 在这你得不到所有的细节，但是这里会提供一个创建TCP服务端的例子： 首先我们创建一个监听套接字，并且设置一个接受连接的事件源： _isolation = dispatch_queue_create([[self description] UTF8String], 0);_nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);struct sockaddr_in sin = {};sin.sin_len = sizeof(sin);sin.sin_family = AF_INET6;sin.sin_port = htons(port);sin.sin_addr.s_addr= INADDR_ANY;int err = bind(result.nativeSocket, (struct sockaddr *) &amp;sin, sizeof(sin));NSCAssert(0 &lt;= err, @””); _eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, _nativeSocket, 0, _isolation);dispatch_source_set_event_handler(result.eventSource, ^{acceptConnection(_nativeSocket);}); 当接受了连接，我们创建一个I/O通道： typedef union socketAddress {struct sockaddr sa;struct sockaddr_in sin;struct sockaddr_in6 sin6;} socketAddressUnion; socketAddressUnion rsa; // remote socket addresssocklen_t len = sizeof(rsa);int native = accept(nativeSocket, &amp;rsa.sa, &amp;len);if (native == -1) {// Error. Ignore.return nil;} _remoteAddress = rsa;_isolation = dispatch_queue_create([[self description] UTF8String], 0);_channel = dispatch_io_create(DISPATCH_IO_STREAM, native, _isolation, ^(int error) {NSLog(@”An error occured while listening on socket: %d”, error);}); //dispatch_io_set_high_water(_channel, 8 1024);dispatch_io_set_low_water(_channel, 1);dispatch_io_set_interval(_channel, NSEC_PER_MSEC 10, DISPATCH_IO_STRICT_INTERVAL); socketAddressUnion lsa; // remote socket addresssocklen_t len = sizeof(rsa);getsockname(native, &amp;lsa.sa, &amp;len);_localAddress = lsa; 如果我们想要设置 SO_KEEPALIVE（如果使用了HTTP的keep-alive），我们需要在调用 dispatch_io_create 前这么做。 创建好 I/O 通道后，我们可以设置读取处理程序： dispatch_io_read(_channel, 0, SIZE_MAX, _isolation, ^(bool done, dispatch_data_t data, int error){if (data != NULL) {if (_data == NULL) {_data = data;} else {_data = dispatch_data_create_concat(_data, data);}[self processData];}}); 如果所有你想做的只是读取或者写入一个文件，GCD 提供了两个方便的封装： dispatch_read 和 dispatch_write 。你需要传递给 dispatch_read 一个文件路径和一个在所有数据块读取后调用的 block。类似的，dispatch_write 需要一个文件路径和一个被写入的 dispatch_data_t 对象。 基准测试在 GCD 的一个不起眼的角落，你会发现一个适合优化代码的灵巧小工具： uint64_t dispatch_benchmark(size_t count, void (^block)(void)); 把这个声明放到你的代码中，你就能够测量给定的代码执行的平均的纳秒数。例子如下： size_t const objectCount = 1000;uint64_t n = dispatch_benchmark(10000, ^{@autoreleasepool {id obj = @42;NSMutableArray *array = [NSMutableArray array];for (size_t i = 0; i &lt; objectCount; ++i) {[array addObject:obj];}}});NSLog(@”-[NSMutableArray addObject:] : %llu ns”, n); 在我的机器上输出了： -[NSMutableArray addObject:] : 31803 ns 也就是说添加1000个对象到 NSMutableArray 总共消耗了31803纳秒，或者说平均一个对象消耗32纳秒。 正如 dispatch_benchmark 的帮助页面指出的，测量性能并非如看起来那样不重要。尤其是当比较并发代码和非并发代码时，你需要注意特定硬件上运行的特定计算带宽和内存带宽。不同的机器会很不一样。如果代码的性能与访问临界区有关，那么我们上面提到的锁竞争问题就会有所影响。 不要把它放到发布代码中，事实上，这是无意义的，它是私有API。它只是在调试和性能分析上起作用。 访问帮助界面： curl “http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt&quot;| /usr/bin/groffer –tty -T utf8 原子操作头文件 libkern/OSAtomic.h 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。 这些函数都是很底层的，并且你需要知道一些额外的事情。就算你已经这样做了，你还可能会发现一两件你不能做，或者不易做的事情。当你正在为编写高性能代码或者正在实现无锁的和无等待的算法工作时，这些函数会吸引你。 这些函数在 atomic(3) 的帮助页里全部有概述——运行 man 3 atomic 命令以得到完整的文档。你会发现里面讨论到了内存屏障。查看维基百科中关于内存屏障的文章。如果你还存在疑问，那么你很可能需要它。 计数器OSAtomicIncrement 和 OSAtomicDecrement 有一个很长的函数列表允许你以原子操作的方式去增加和减少一个整数值 —— 不必使用锁（或者队列）同时也是线程安全的。如果你需要让一个全局的计数器值增加，而这个计数器为了统计目的而由多个线程操作，使用原子操作是很有帮助的。如果你要做的仅仅是增加一个全局计数器，那么无屏障版本的 OSAtomicIncrement 是很合适的，并且当没有锁竞争时，调用它们的代价很小。 类似的，OSAtomicOr ，OSAtomicAnd，OSAtomicXor 的函数能用来进行逻辑运算，而 OSAtomicTest 可以用来设置和清除位。 10.2、比较和交换OSAtomicCompareAndSwap 能用来做无锁的惰性初始化，如下： void sharedBuffer(void){static void buffer;if (buffer == NULL) {void * newBuffer = calloc(1, 1024);if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {free(newBuffer);}}return buffer;} 如果没有 buffer，我们会创建一个，然后原子地将其写到 buffer 中如果 buffer 为NULL。在极少的情况下，其他人在当前线程同时设置了 buffer ，我们简单地将其释放掉。因为比较和交换方法是原子的，所以它是一个线程安全的方式去惰性初始化值。NULL的检测和设置 buffer 都是以原子方式完成的。 明显的，使用 dispatch_once() 我们也可以完成类似的事情。 原子队列OSAtomicEnqueue() 和 OSAtomicDequeue() 可以让你以线程安全，无锁的方式实现一个LIFO队列(常见的就是栈)。对有潜在精确要求的代码来说，这会是强大的代码。 还有 OSAtomicFifoEnqueue() 和 OSAtomicFifoDequeue() 函数是为了操作FIFO队列，但这些只有在头文件中才有文档 —— 阅读他们的时候要小心。 自旋锁最后，OSAtomic.h 头文件定义了使用自旋锁的函数：OSSpinLock。同样的，维基百科有深入的有关自旋锁的信息。使用命令 man 3 spinlock 查看帮助页的 spinlock(3) 。当没有锁竞争时使用自旋锁代价很小。 在合适的情况下，使用自旋锁对性能优化是很有帮助的。一如既往：先测量，然后优化。不要做乐观的优化。 下面是 OSSpinLock 的一个例子： @interface MyTableViewCell : UITableViewCell @property (readonly, nonatomic, copy) NSDictionary *amountAttributes; @end @implementation MyTableViewCell{NSDictionary *_amountAttributes;} (NSDictionary )amountAttributes;{if (_amountAttributes == nil) {static __weak NSDictionary cachedAttributes = nil;static OSSpinLock lock = OS_SPINLOCK_INIT;OSSpinLockLock(&amp;lock);_amountAttributes = cachedAttributes;if (_amountAttributes == nil) {NSMutableDictionary *attributes = [[self subtitleAttributes] mutableCopy];attributes[NSFontAttributeName] = [UIFont fontWithName:@”ComicSans” size:36];attributes[NSParagraphStyleAttributeName] = [NSParagraphStyle defaultParagraphStyle];_amountAttributes = [attributes copy];cachedAttributes = _amountAttributes;}OSSpinLockUnlock(&amp;lock);}return _amountAttributes;} 就上面的例子而言，或许用不着这么麻烦，但它演示了一种理念。我们使用了ARC的 __weak 来确保一旦 MyTableViewCell 所有的实例都不存在， amountAttributes 会调用 dealloc 。因此在所有的实例中，我们可以持有字典的一个单独实例。 这段代码运行良好的原因是我们不太可能访问到方法最里面的部分。这是很深奥的——除非你真正需要，不然不要在你的 App 中使用它。 话题 #2 下的更多文章 原文 Low-Level Concurrency APIs 译文 Objc的底层并发API - webfrogs","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"常见的后台实现","slug":"iOS/常见的后台实现","date":"2017-09-24T11:03:35.000Z","updated":"2017-09-24T11:03:35.000Z","comments":true,"path":"2017/09/24/iOS/常见的后台实现/","link":"","permalink":"https://huos3203.github.io/2017/09/24/iOS/常见的后台实现/","excerpt":"","text":"概览本文主要探讨一些常用后台任务的最佳实践： 如何做异步网络请求 如何异步处理大型文件，以保持较低的内存占用 操作队列 (Operation Queues) 还是 GCD ?操作队列提供了在 GCD 中不那么容易复制的有用特性。其中最重要的一个就是可以取消在任务处理队列中的任务，而且操作队列在管理操作间的依赖关系方面也容易一些。GCD 给予你更多的控制权力以及操作队列中所不能使用的底层函数。详细介绍可以参考底层并发 API 这篇文章。 后台 UI 代码首先要强调：UIKit 只能在主线程上运行。而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理，以避免其将主线程阻塞太久。 后台获取UI数据例如使用操作队列隔离以下昂贵操作：12345678__weak id weakSelf = self;[self.operationQueue addOperationWithBlock:^&#123; NSNumber* result = findLargestMersennePrime(); [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; MyClass* strongSelf = weakSelf; strongSelf.textLabel.text = [result stringValue]; &#125;];&#125;]; 如你所见，这些代码其实一点也不直接明了。我们首先声明了一个 weak 引用来参照 self，否则会形成循环引用（ block 持有了 self，私有的 operationQueue retain 了 block，而 self 又 retain 了 operationQueue ）。为了避免在运行 block 时访问到已被释放的对象，在 block 中我们又需要将其转回 strong 引用。 这在 ARC 和 block 主导的编程范式中是解决 retain cycle 的一种常见也是最标准的方法。 后台绘制UI如果你确定 drawRect: 是你的应用的性能瓶颈，那么你可以将这些绘制代码放到后台去做。但是在你这样做之前，检查下看看是不是有其他方法来解决，比如、考虑使用 core animation layers 或者预先渲染图片而不去做 Core Graphics 绘制。 如果你确实认为在后台执行绘制代码会是你的最好选择时再这么做。其实解决起来也很简单，把 drawRect: 中的代码放到一个后台操作中去做就可以了。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext ：12345UIGraphicsBeginImageContextWithOptions(size, NO, 0);// drawing code hereUIImage *i = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return i; 通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。 cell在操作队列中异步绘制如果你在 table view 或者是 collection view 的 cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。你可以将它们添加到后台操作队列，也可以在用户将 cell 滚动出边界时的 didEndDisplayingCell 委托方法中进行取消。这些技巧都在 2012 年的WWDC Session 211 – Building Concurrent User Interfaces on iOS中有详细阐述。 其他方案除了在后台自己调度绘制代码，以也可以试试看使用 CALayer 的 drawsAsynchronously 属性。然而你需要精心衡量这样做的效果，因为有时候它能使绘制加速，有时候却适得其反。 异步网络请求处理你的所有网络请求都应该采取异步的方式完成。 然而，在 GCD 下，有时候你可能会看到这样的代码1234567// 警告：不要使用这些代码。dispatch_async(backgroundQueue, ^&#123; NSData* contents = [NSData dataWithContentsOfURL:url] dispatch_async(dispatch_get_main_queue(), ^&#123; // 处理取到的日期 &#125;);&#125;); 乍看起来没什么问题，但是这段代码却有致命缺陷。你没有办法去取消这个同步的网络请求。它将阻塞主线程直到它完成。如果请求一直没结果，那就只能干等到超时（比如 dataWithContentsOfURL: 的超时时间是 30 秒）。 分析状况 当队列是串行执行时，它将一直被阻塞住。 当队列是并行执行时，GCD 需要重开一个线程来补凑你阻塞住的线程。 两种结果都不太妙，所以最好还是不要阻塞线程。 方案一要解决上面的困境，我们可以使用 NSURLConnection 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。例如：在NSOperation子类DownloadOperation中重写start方法，并实现NSURLConnectionDelegate代理方法。12345678910111213@interface DownloadOperation : NSOperation&lt;NSURLConnectionDelegate&gt;- (void)start&#123; NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isConcurrent = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ &#123; self.connection = [NSURLConnection connectionWithRequest:request delegate:self]; &#125;];&#125; 然而，在这里还有一些事情值得注意： NSURLConnection 是通过 run loop 来发送事件的。因为发送事件不会花多少时间，因此最简单的是就只使用 main run loop 来做这个。然后，我们就可以用后台线程来处理输入的数据了。 方案二另一种可能的方式是使用像 AFNetworking 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。 要处理URL 连接，我们重写自定义的 operation 子类中的 start 方法：1234567891011- (void)start&#123; NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ &#123; self.connection = [NSURLConnectionconnectionWithRequest:request delegate:self]; &#125;];&#125; 由于重写的是 start 方法，所以我们需要自己要管理操作的 isExecuting 和 isFinished 状态。要取消一个操作，我们需要取消 connection ，并且设定合适的标记，这样操作队列才知道操作已经完成。1234567- (void)cancel&#123; [super cancel]; [self.connection cancel]; self.isFinished = YES; self.isExecuting = NO;&#125; 当连接完成加载后，它向代理发送回调：1234567- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; self.data = self.buffer; self.buffer = nil; self.isExecuting = NO; self.isFinished = YES;&#125; 就这么多了。完整的代码可以参见GitHub上的示例工程。 总结来说，我们建议要么你花时间来把事情做对做好，要么就直接使用像 AFNetworking 这样的框架。其实 AFNetworking 还提供了不少好用的小工具，比如有个 UIImageView 的 category，来负责异步地从一个 URL 加载图片。在你的 table view 里使用的话，还能自动帮你处理取消加载操作，非常方便。 扩展阅读： Concurrency Programming Guide NSOperation Class Reference: Concurrent vs. Non-Concurrent Operations Blog: synchronous vs. asynchronous NSURLConnection GitHub: SDWebImageDownloaderOperation.m Blog: Progressive image download with ImageIO WWDC 2012 Session 211: Building Concurrent User Interfaces on iOS 进阶：后台文件 I/O构建一个类，负责一行一行读取文件而不是一次将整个文件读入内存，另外要在后台队列处理文件，以保持应用相应用户的操作。为了达到这个目的，我们使用能让我们异步处理文件的 NSInputStream 。根据官方文档的描述： 如果你总是需要从头到尾来读/写文件的话，streams 提供了一个简单的接口来异步完成这个操作 不管你是否使用 streams，大体上逐行读取一个文件的模式是这样的： 建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据 从 stream 中读取一块数据 对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出 将剩余的字节添加到中间缓冲层去 回到 2，直到 stream 关闭 为了将其运用到实践中，我们又建立了一个示例应用，里面有一个 Reader 类完成了这件事情，它的接口十分简单1234@interface Reader : NSObject- (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion;- (id)initWithFileAtPath:(NSString*)path;@end runloop分发NSInputStream事件注意，这个类不是 NSOperation 的子类。与 URL connections 类似，输入的 streams 通过 run loop 来传递它的事件。这里，我们仍然采用 main run loop 来分发事件，然后将数据处理过程派发至后台操作线程里去处理。 12345678910111213141516- (void)enumerateLines:(void (^)(NSString*))blockcompletion:(void (^)())completion&#123; if (self.queue == nil) &#123; self.queue = [[NSOperationQueue alloc] init]; self.queue.maxConcurrentOperationCount = 1; //串行队列 &#125; self.callback = block; self.completion = completion; self.inputStream = [NSInputStream inputStreamWithURL:self.fileURL]; self.inputStream.delegate = self; //分发NSInputStream事件 [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [self.inputStream open];&#125; 调用时的代码：123456789101112131415161718- (void)import:(id)sender&#123; NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\"Clarissa Harlowe\" withExtension:@\"txt\"]; NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]], @\"Please download the sample data\"); self.reader = [[Reader alloc] initWithFileAtURL:fileURL]; [self.reader enumerateLinesWithBlock:^(NSUInteger i, NSString *line)&#123; if ((i % 2000ull) == 0) &#123; NSLog(@\"i: %d\", i); [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; [self.button setTitle:line forState:UIControlStateNormal]; &#125;]; &#125; &#125; completionHandler:^(NSUInteger numberOfLines)&#123; NSLog(@\"lines: %d\", numberOfLines); [self.button setTitle:@\"Done\" forState:UIControlStateNormal]; &#125;];&#125; NSInputStream代理方法现在，input stream 将（在主线程）向我们发送代理消息，然后我们可以在操作队列中加入一个 block 操作来执行处理了：123456789101112131415161718192021- (void)stream:(NSStream*)stream handleEvent:(NSStreamEvent)eventCode&#123; switch (eventCode) &#123; ... case NSStreamEventHasBytesAvailable: &#123; NSMutableData *buffer = [NSMutableData dataWithLength:4 * 1024]; NSUInteger length = [self.inputStream read:[buffer mutableBytes] maxLength:[buffer length]]; if (0 &lt; length) &#123; [buffer setLength:length]; __weak id weakSelf = self; [self.queue addOperationWithBlock:^&#123; //在后台串行队列的线程池中逐行处理缓冲区 [weakSelf processDataChunk:buffer]; &#125;]; &#125; break; &#125; ... &#125;&#125; 缓冲区处理处理数据块的过程是先查看当前已缓冲的数据，并将新加入的数据附加上去。接下来它将按照换行符分解成小的部分，并逐行处理。数据处理过程中会不断的从buffer中获取已读入的数据。然后把这些新读入的数据按行分开并存储。剩余的数据被再次存储到缓冲区中：12345678910111213141516171819202122232425262728- (void)processDataChunk:(NSMutableData *)buffer&#123; if (self.remainder != nil) &#123; [self.remainder appendData:buffer]; &#125; else &#123; self.remainder = buffer; &#125; [self.remainder obj_enumerateComponentsSeparatedBy:self.delimiter usingBlock:^(NSData* component, BOOL last) &#123; if (!last) &#123; [self emitLineWithData:component]; &#125; else if (0 &lt; [component length]) &#123; self.remainder = [component mutableCopy]; &#125; else &#123; self.remainder = nil; &#125; &#125;];&#125;- (void)emitLineWithData:(NSData *)data;&#123; NSUInteger lineNumber = self.lineNumber; self.lineNumber = lineNumber + 1; if (0 &lt; data.length) &#123; NSString *line = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; self.callback(lineNumber, line); &#125;&#125; 现在你运行示例应用的话，会发现它在响应事件时非常迅速，内存的开销也保持很低（在我们测试时，不论读入的文件有多大，堆所占用的内存量始终低于 800KB）。绝大部分时候，使用逐块读入的方式来处理大文件，是非常有用的技术。 延伸阅读： File System Programming Guide: Techniques for Reading and Writing Files Without File Coordinators StackOverflow: How to read data from NSFileHandle line by line? 总结通过我们所列举的几个示例，我们展示了如何异步地在后台执行一些常见任务。在所有的解决方案中，我们尽力保持了代码的简单，这是因为在并发编程中，稍不留神就会捅出篓子来。 很多时候为了避免麻烦，你可能更愿意在主线程中完成你的工作，在你能这么做事，这确实让你的工作轻松不少，但是当你发现性能瓶颈时，你可以尝试尽可能用最简单的策略将那些繁重任务放到后台去做。 我们在上面例子中所展示的方法对于其他任务来说也是安全的选择。在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。 话题 #2 下的更多文章 原文 Common Background Practices 译文 常见的后台实践","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"iOS多线程API介绍","slug":"iOS/iOS多线程API介绍","date":"2017-09-24T09:18:49.000Z","updated":"2017-09-24T09:18:49.000Z","comments":true,"path":"2017/09/24/iOS/iOS多线程API介绍/","link":"","permalink":"https://huos3203.github.io/2017/09/24/iOS/iOS多线程API介绍/","excerpt":"","text":"并发所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。 OS X 和 iOS 提供了几种不同的 API 来支持并发编程。每一个 API 都具有不同的功能和使用限制，这使它们适合不同的任务。同时，这些 API 处在不同的抽象层级上。我们有可能用其进行非常深入底层的操作，但是这也意味着背负起将任务进行良好处理的巨大责任。 实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱。当开发者在使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文首先对 OS X 和 iOS 中不同的并发编程 API 进行一些介绍，然后再深入了解并发编程中独立于与你所使用的特定 API 的一些内在挑战。 OS X 和 iOS 中的并发编程OS X 和 iOS 提供了相同的并发编程API。 本文会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue，以及 NSRunLoop（并非并发）。 由于高层 API 是基于底层 API 构建的，所以我们首先将从底层的 API 开始介绍，然后逐步扩展到高层 API。不过在具体编程中，选择 API 的顺序刚好相反：因为大多数情况下，选择高层的 API 不仅可以完成底层 API 能完成的任务，而且能够让并发模型变得简单。 如果你对我们为何坚持推荐使用高抽象层级以及简单的并行代码有所疑问的话，那么你可以看看这篇文章的第二部分并发编程中面临的挑战，以及 Peter Steinberger 写的关于线程安全的文章。 线程线程（thread）是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。 多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。 你可以使用 Instruments 中的 CPU strategy view 来得知你的代码或者你在使用的框架代码是如何在多核 CPU 中调度执行的。 需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，以及无法控制执行多长时间后将被暂停，以便轮换执行别的任务。这种线程调度是非常强大的一种技术，但是也非常复杂，我们稍后研究。 先把线程调度的复杂情况放一边，开发者可以使用 POSIX 线程 API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。 线程实例在一百万个数字中查找最小值和最大值。 pthread 方式实现下面这个小示例利用 pthread 来在一百万个数字中查找最小值和最大值。其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#import &lt;pthread.h&gt;struct threadInfo &#123;uint32_t * inputValues;size_t count;&#125;;struct threadResult &#123;uint32_t min;uint32_t max;&#125;;void * findMinAndMax(void *arg)&#123;struct threadInfo const * const info = (struct threadInfo *) arg;uint32_t min = UINT32_MAX;uint32_t max = 0;for (size_t i = 0; i &lt; info-&gt;count; ++i) &#123;uint32_t v = info-&gt;inputValues[i];min = MIN(min, v);max = MAX(max, v);&#125;free(arg);struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));result-&gt;min = min;result-&gt;max = max;return result;&#125;int main(int argc, const char * argv[])&#123;size_t const count = 1000000;uint32_t inputValues[count];// 使用随机数字填充 inputValuesfor (size_t i = 0; i &lt; count; ++i) &#123;inputValues[i] = arc4random();&#125;// 开始4个寻找最小值和最大值的线程size_t const threadCount = 4;pthread_t tid[threadCount];for (size_t i = 0; i &lt; threadCount; ++i) &#123;struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));size_t offset = (count / threadCount) * i;info-&gt;inputValues = inputValues + offset;info-&gt;count = MIN(count - offset, count / threadCount);int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);NSCAssert(err == 0, @\"pthread_create() failed: %d\", err);&#125;// 等待线程退出struct threadResult * results[threadCount];for (size_t i = 0; i &lt; threadCount; ++i) &#123;int err = pthread_join(tid[i], (void **) &amp;(results[i]));NSCAssert(err == 0, @\"pthread_join() failed: %d\", err);&#125;// 寻找 min 和 maxuint32_t min = UINT32_MAX;uint32_t max = 0;for (size_t i = 0; i &lt; threadCount; ++i) &#123;min = MIN(min, results[i]-&gt;min);max = MAX(max, results[i]-&gt;max);free(results[i]);results[i] = NULL;&#125;NSLog(@\"min = %u\", min);NSLog(@\"max = %u\", max);return 0;&#125; NSThread方式实现NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切。例如，开发者可以利用 NSThread 的一个子类来定义一个线程，在这个子类的中封装需要在后台线程运行的代码。针对上面的那个例子，我们可以定义一个这样的 NSThread 子类： 12345678910111213141516171819202122232425262728@interface FindMinMaxThread : NSThread@property (nonatomic) NSUInteger min;@property (nonatomic) NSUInteger max;- (instancetype)initWithNumbers:(NSArray *)numbers;@end@implementation FindMinMaxThread &#123;NSArray *_numbers;&#125;- (instancetype)initWithNumbers:(NSArray *)numbers&#123;self = [super init];if (self) &#123;_numbers = numbers;&#125;return self;&#125;- (void)main&#123;NSUInteger min;NSUInteger max;// 进行相关数据的处理self.min = min;self.max = max;&#125;@end 要想启动一个新的线程，需要创建一个线程对象，然后调用它的 start 方法： 123456789101112NSMutableSet *threads = [NSMutableSet set];NSUInteger numberCount = self.numbers.count;NSUInteger threadCount = 4;for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;NSUInteger offset = (count / threadCount) * i;NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);NSRange range = NSMakeRange(offset, count);NSArray *subset = [self.numbers subarrayWithRange:range];FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];[threads addObject:thread];[thread start];&#125; 现在，我们可以通过检测到线程的 isFinished 属性来检测新生成的线程是否已经结束，并获取结果。 线程问题直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。 接下来，我们将介绍两个基于队列的并发编程 API ：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的线程池，来解决上面遇到的问题。 Grand Central Dispatch为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。在下一篇关于底层并发 API 的文章中，我们将更深入地介绍 GCD。 通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个线程池。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。 GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。 GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。 使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。更多相关内容，在本文的优先级反转部分中会有介绍。 虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的并发编程中面临的挑战，这样可以注意到一些潜在的问题。本期的另外一篇优秀文章：底层并发 API 中，包含了很多深入的解释和一些有价值的提示。 Operation Queues操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。 操作队列成员 主队列：在主线程上运行 自定义队列：在后台子线程上执行 操作任务：NSOperation 的子类，即在前两种队列中所要执行的任务代码 实现操作任务你可以通过重写 main 或者 start 方法 来定义自己的 operations 。 重写 main方法当 main 方法返回的时候，这个 operation 就结束了。无法控制操作状态属性（例如 isExecuting 和 isFinished）。123456@implementation YourOperation- (void)main&#123;// 进行处理 ...&#125;@end 重写 start方法这种方式可以拥有更多的控制权，以及在一个操作中可以执行异步任务，重写 start 方法必须手动管理操作的状态（例如 isExecuting 和 isFinished）。 重写实现： 1234567891011121314@implementation YourOperation- (void)start&#123;self.isExecuting = YES;self.isFinished = NO;// 开始处理，在结束时应该调用 finished ...&#125;- (void)finished&#123;self.isExecuting = NO;self.isFinished = YES;&#125;@end 注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。 取消功能的实现为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 isCancelled 属性： 123456- (void)main&#123;while (notDone &amp;&amp; !self.isCancelled) &#123;// 进行处理&#125;&#125; 重写 operation 的description 方法这样就可以很容易的标示出在某个队列中当前被调度的所有操作 。 操作队列管理添加操作任务当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中： 123NSOperationQueue *queue = [[NSOperationQueue alloc] init];YourOperation *operation = [[YourOperation alloc] init];[queue addOperation:operation]; 添加一次性任务另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：123[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;// 代码...&#125;]; 操作队列的任务个数除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。 操作优先级另外还有一个方便的功能就是根据队列中 operation 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。 操作依赖如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系。使用NSOperation类的实例方法addDependency:实现操作之间的依赖关系。对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。如下：123[intermediateOperation addDependency:operation1];[intermediateOperation addDependency:operation2];[finishedOperation addDependency:intermediateOperation]; 这些简单的代码可以确保 operation1 和 operation2 在 intermediateOperation 之前执行，当然，也会在 finishOperation 之前被执行。 从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。 Run Loops实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。 Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。 场景一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的，在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置计时器、使用 NSURLConnection 或者调用 performSelector:withObject:afterDelay:，其实背后都是 run loop 在处理这些异步任务。 runloop运行模式无论何时你使用 run loop 来执行一个方法的时候，都需要记住一点：run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行这种任务上是一种聪明的做法。 关于这点，在 iOS 中非常典型的一个示例就是滚动。在进行滚动时，run loop 并不是运行在默认模式中的，因此， run loop 此时并不会响应比如滚动前设置的计时器。一旦滚动停止了，run loop 会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其设为 NSRunLoopCommonModes 的模式，并添加到 run loop 中。 子线程中使用runloop主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于常见的后台实践的文章里阐述了一些关于这种模式的很好的例子。 如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。 并发编程中面临的挑战使用并发编程会带来许多陷阱。只要一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。 关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务嘎然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。 资源共享并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等。在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。 示例为了演示这类问题，我们举一个关于资源的简单示例：描述：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题：你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。 我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。 这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。 在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（乱序执行）。 互斥锁互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。 除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。 当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：底层并发技术。 解决方案：原子声明属性从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。 性能开销及锁的竞争在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出临界区段（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。 不同类型的锁锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(锁的竞争是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。 我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。 死锁互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。 看看下面的代码，它交换两个变量的值：1234567891011void swap(A, B)&#123;lock(lockA);lock(lockB);int a = A;int b = B;A = b;B = a;unlock(lockB);unlock(lockA);&#125; 大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：12swap(X, Y); // 线程 1swap(Y, X); // 线程 2 此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。 再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。 解决方案建议阅读一下底层并发编程 API 中的全部使用异步分发一节。 资源饥饿（Starvation）当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。 解决方案为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。 优先级反转本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的优先级反转。 优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。 高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。 在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。 解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。 从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。 总结我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。 但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。 我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。 话题 #2 下的更多文章 原文 Concurrent Programming: APIs and Challenges 精细校对 @onevcat","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"iOS视图渲染","slug":"iOS/UI/iOS视图渲染","date":"2017-09-23T14:51:07.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2017/09/23/iOS/UI/iOS视图渲染/","link":"","permalink":"https://huos3203.github.io/2017/09/23/iOS/UI/iOS视图渲染/","excerpt":"","text":"图形堆栈当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的液晶显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。 软件堆栈组成从简单的角度来看，软件堆栈看起来有点像这样： GPU强大的图形硬件Display的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。 GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。 GPU Driver是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES. OpenGL的扩展APIOpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。 在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。在OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。 GPU纹理合成渲染流程 合成挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。 耗时挑战：下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。 最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。 这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。 合成/纹理概念合成：在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。 纹理：屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中的纹理就是 CALayer。 纹理合成：在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。 纹理合成像素的计算公式如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。 如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：1R = S + D * ( 1 – Sa ) 结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。 显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：1R = S 结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。 如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:1230.5 0 0.5R = S + D * (1 - Sa) = 0 + 0 * (1 - 0.5) = 00 1 0.5 我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。 记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。 opaque 的属性：不透明 VS 透明当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。 CALayer 有一个叫做 opaque 的属性会告诉 GPU 纹理上的像素是透明还是不透明的。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。 所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。 像素对齐 VS 不重合在一起 像素对齐到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。 滚动/错位当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动：当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是：当纹理的起点不在一个像素的边界上。 在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。 Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。 Masks位图蒙板一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和蒙板下面包含的像素合并之前都会把 mask 应用到图层的像素上去，最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。例如：当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。 离屏渲染(Offscreen Rendering)离屏渲染：即在屏幕外对图层树的合并/渲染，此时会有一个屏幕外缓冲区缓存图层树，然后该缓冲区会被渲染到屏幕上。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。 离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 Color Hits Green and Misses Red 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。 GPU离屏渲染多图层动画如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。 两个权衡点第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。第二，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。 副作用：mask蒙板渲染至缓冲区离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。 避免使用离屏渲染因为直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。layer的几种触发离屏渲染为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。所以当你打开 Color Offscreen-Rendered Yellow 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。 离屏渲染空间限制同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。 更多的关于合成像往常一样，维基百科上有更多关于透明合成的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。 OS X如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 Quartz Debug 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 developer portal 中下载到。 Core Animation OpenGL ES正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。 Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。 Core Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。 举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 -drawInContext 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在drawInContext中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。 Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。 CPU限制 VS GPU限制当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。 为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要把尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。 既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。 要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。 Core Graphics / Quartz 2D通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。 Quartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。 让我们简单的了解一下 Quartz 2D 主要的概念。有关详细信息可以到苹果的官方文档中了解。 放心，当 Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。 主要的概念相对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的股票应用作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。 当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。 比方说，我们要画一个八角形，我们通过 UIKit 能做到这一点123456789101112131415UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(16.72, 7.22)];[path addLineToPoint:CGPointMake(3.29, 20.83)];[path addLineToPoint:CGPointMake(0.4, 18.05)];[path addLineToPoint:CGPointMake(18.8, -0.47)];[path addLineToPoint:CGPointMake(37.21, 18.05)];[path addLineToPoint:CGPointMake(34.31, 20.83)];[path addLineToPoint:CGPointMake(20.88, 7.22)];[path addLineToPoint:CGPointMake(20.88, 42.18)];[path addLineToPoint:CGPointMake(16.72, 42.18)];[path addLineToPoint:CGPointMake(16.72, 7.22)];[path closePath];path.lineWidth = 1;[[UIColor redColor] setStroke];[path stroke]; 相对应的 Core Graphics 代码：123456789101112131415CGContextBeginPath(ctx);CGContextMoveToPoint(ctx, 16.72, 7.22);CGContextAddLineToPoint(ctx, 3.29, 20.83);CGContextAddLineToPoint(ctx, 0.4, 18.05);CGContextAddLineToPoint(ctx, 18.8, -0.47);CGContextAddLineToPoint(ctx, 37.21, 18.05);CGContextAddLineToPoint(ctx, 34.31, 20.83);CGContextAddLineToPoint(ctx, 20.88, 7.22);CGContextAddLineToPoint(ctx, 20.88, 42.18);CGContextAddLineToPoint(ctx, 16.72, 42.18);CGContextAddLineToPoint(ctx, 16.72, 7.22);CGContextClosePath(ctx);CGContextSetLineWidth(ctx, 1);CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);CGContextStrokePath(ctx); 需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 -drawInContext: 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 CGBitmapContextCreate().这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。 注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 UIGraphicsGetCurrentContext() 来得到最顶层的上下文。你可以使用 UIGraphicsPushContext() 和 UIGraphicsPopContext() 在 UIKit 的堆栈中推进或取出上下文。 最为突出的是，UIKit 使用 UIGraphicsBeginImageContextWithOptions() 和 UIGraphicsEndImageContext() 方便的创建类似于 CGBitmapContextCreate() 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：12345678UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextBeginPath(ctx);CGContextMoveToPoint(ctx, 16.72, 7.22);CGContextAddLineToPoint(ctx, 3.29, 20.83);...CGContextStrokePath(ctx);UIGraphicsEndImageContext(); 或者另外一种方法:12345678910CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);CGContextScaleCTM(ctx, 0.5, 0.5);UIGraphicsPushContext(ctx);UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(16.72, 7.22)];[path addLineToPoint:CGPointMake(3.29, 20.83)];...[path stroke];UIGraphicsPopContext(ctx);CGContextRelease(ctx); 你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 Adobe Illustrator 和 Adobe Photoshop 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 NeXTSTEP 。(原来也是乔老爷的作品)。 CGLayer我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 Dave Hayden指出，这些小道消息不再可靠。 像素屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。 稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。 默认的像素布局在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:123A R G B A R G B A R G B| pixel 0 | pixel 1 | pixel 20 1 2 3 4 5 6 7 8 9 10 11 ... 这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: 240,99,24.一个完全不透明的橙色像素拥有的 ARGB 值为:255，240，99，24，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:84，80，33，8. 另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：123x R G B x R G B x R G B| pixel 0 | pixel 1 | pixel 20 1 2 3 4 5 6 7 8 9 10 11 ... 这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。 当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。 深奥的布局大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式： 另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。 还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。 整件事件中，Core Graphics 也支持一些像灰度模式和 CMYK 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。 二维数据当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。 在某些情况下，一些视频框架便会使用二维数据。 YCbCr当我们处理视频数据时，YCbCr 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。 出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。 图片格式当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。 JPEG每个人都知道 JPEG。它是相机的产物。它代表着照片如何存储在电脑上。甚至你妈妈都听说过 JPEG。 一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真相真是差十万八千里了。 将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于离散余弦变换(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种哈夫曼编码的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。 这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。 那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。 PNGPNG读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。 在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。 挑选一个格式当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。 已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。 当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是有效的PNG文件。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。 让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。 图层后备存储的渲染UIKit 和 Pixels每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。 With –drawRect:如果你的视图类实现了 -drawRect:，他们将像这样工作: 设置一个标示当你调用 -setNeedsDisplay，UIKit 将会在这个视图的图层上调用 -setNeedsDisplay。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以多次调用 -setNeedsDisplay并不会造成性能损失。 装备后备存储当渲染系统准备好，它会调用视图图层的-display方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。2.1 使用 UIKit 的绘制方法当你使用 UIKit 的绘制方法，例如: UIRectFill() 或者 -[UIBezierPath fill] 代替你的 -drawRect: 方法，他们将会使用这个上下文。使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 UIGraphicsGetCurrent() 将会返回那个对应的上下文。既然 UIKit 使用 UIGraphicsGetCurrent() 绘制方法，绘图将会进入到图层的后备存储。2.2 直接使用 Core Graphics 方法通过调用 UIGraphicsGetCurrent() 得到相同的上下文，并将这个上下文传给 Core Graphics 方法。 从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 -setNeedsDisplay ，将会依次将图层的后备存储更新到视图上。 不使用 -drawRect:当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。 在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。 实现-drawRect: 还是不实现 -drawRect:最快的绘制就是你不要做任何绘制。大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。 当你需要自定义绘图代码时，Apple 在WWDC 2012’s session 506:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。 另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 -drawRect: 方法。有时，通过 UIGraphicsBeginImageContextWithOptions() 或者 CGBitmapContextCeate() 创建位图会显得更有意义，从位图上面抓取图像，并设置为 CALayer 的内容。下面我们将给出一个例子来测试，检验。 单一颜色如果我们看这个例子：123456// Don't do this- (void)drawRect:(CGRect)rect&#123;[[UIColor redColor] setFill];UIRectFill([self bounds]);&#125; 现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。 我们跟本不需要实现 -drawRect:，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。 可变尺寸的图像类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×50 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。 Core Animation 可以通过 CALayer 的 contentsCenter 属性来改变图像，大多数情况下，你可能更倾向于使用，-[UIImage resizableImageWithCapInsets:resizingMode:]。 同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。 并发绘图上一次 objc.io 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？ 如果你必须实现 -drawRect:，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。 我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。为了同时绘制，我们需要做下面的操作: 正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread. 我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 WWDC 2012 session 211 中讨论过。(异步下载图片经常用到这个) 增加一个你可以在其中绘制的新方法： 12345678910- (UIImage *)renderInImageOfSize:(CGSize)size&#123; UIGraphicsBeginImageContextWithOptions(size, NO, 0); // 绘制代码块 UIImage *result = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return result;&#125; 这个方法通过 UIGraphicsBeginImageContextWithOptions() 方法，并根据给定的大小创建一个新的 CGContextRef 位图上下文。这个方法也会将这个上下文设置为当前UIKit的上下文。现在你可以在这里做你想在 -drawRect: 中做的事了。然后通过 UIGraphicsGetImageFromCurrentImageContext(),获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。 很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。 要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 UIGraphicsBeginImageContextWithOptions() 开始，以 UIGraphicsEndIamgeContext() 结束。 你需要像下面这样触发渲染代码：123456789UIImageView *view; // assume we have thisNSOperationQueue *renderQueue; // assume we have thisCGSize size = view.bounds.size;[renderQueue addOperationWithBlock:^()&#123; UIImage *image = [renderer renderInImageOfSize:size]; [[NSOperationQueue mainQueue] addOperationWithBlock:^()&#123; view.image = image; &#125;];&#125;]; 要注意，我们是在主队列中调用 view.image = image.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。 像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 -renderInImageOfSize:。 最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。 CALayer到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。 通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。 尽管还有很多其他种类的图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。 自定义绘制的图层如果一个 CALayer 的子类实现了 -drawInContext: 或者它的代理，类似于 -drawLayer:inContest:, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。 形状和文本图层形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 -drawInContext: 方法，然后在方法内绘制形状或文本，他们的性能也很接近。 在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。 异步绘图CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。 当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 -drawRect:/-drawInContext: 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。 这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。 对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。 话题 #3 下的更多文章 原文 Getting Pixels onto the Screen 译文 将像素绘制到屏幕上去 - answer-huang","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"视图","slug":"iOS/视图","permalink":"https://huos3203.github.io/categories/iOS/视图/"}],"tags":[]},{"title":"iResearcher简介","slug":"个人项目/iResearcher简介","date":"2017-09-10T14:09:39.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/09/10/个人项目/iResearcher简介/","link":"","permalink":"https://huos3203.github.io/2017/09/10/个人项目/iResearcher简介/","excerpt":"","text":"简介iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。 APP截图由于运营方已停止服务器访问，暂时只能截图呈现APP相关功能。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"NSURLSession的使用说明","slug":"iOS/NSURLSession的使用说明","date":"2017-09-08T18:48:43.000Z","updated":"2017-09-08T18:50:27.000Z","comments":true,"path":"2017/09/09/iOS/NSURLSession的使用说明/","link":"","permalink":"https://huos3203.github.io/2017/09/09/iOS/NSURLSession的使用说明/","excerpt":"","text":"iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。 现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。 NSURLConnection机制NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。 NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 &lt;NSURLConnectionDelegate&gt; 和 &lt;NSURLConnectionDataDelegate&gt;）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。 缓存策略在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。 鉴权查询在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的 cookie 或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 NSURLProtocol 对象所拦截，以便在必要的时候无缝地改变其加载行为。 不管怎样，NSURLConnection 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 NSURLConnection 的几个核心概念提出了挑战，让苹果有理由对它进行重构。 在 2013 的 WWDC 上，苹果推出了 NSURLConnection 的继任者：NSURLSession。 NSURLSession成员和 NSURLConnection 一样，NSURLSession 指的也不仅是同名类 NSURLSession，还包括一系列相互关联的类。NSURLSession 包括了与之前相同的组件，NSURLRequest 与 NSURLCache，但是把 NSURLConnection 替换成了 NSURLSession、NSURLSessionConfiguration 以及 NSURLSessionTask 的 3 个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask。 NSURLSessionConfiguration可配置性初始化与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。 抽象类NSURLSessionTask数据加载NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。 我们先来深入探讨 task，过后再来讨论 NSURLSessionConfiguration。 NSURLSessionTaskNSURLsessionTask 是一个抽象类，其下有 3 个实体子类封装了现代程序三个最基本的网络任务： NSURLSessionDataTask：加载数据，当加载任务完成时，它会返回相关联的数据，比如 JSON 或者 XML NSURLSessionUploadTask：上传文件，当上传任务完成时，也会有上传相关数据返回，所以继承自 NSURLSessionDataTask。 NSURLSessionDownloadTask：下载文件，当下载任务结束时，它会返回已下载文件的一个临时的文件路径。 所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个恢复数据（resume data），然后可以传递给下一次新创建的 download task，以便继续之前的下载。 工厂方法不同于直接使用 alloc-init 初始化方法，task 是由一个 NSURLSession 创建的。每个 task 的构造方法都对应有或者没有 completionHandler 这个 block 的两个版本: block回调构造方式: –dataTaskWithRequest:completionHandler:通过指定 completionHandler 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。 代理回调构造方式：–dataTaskWithRequest:对于需要 override 原有 session task 的 delegate 的默认行为的情况,使用代理回调 这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 resume 方法来让它开始运行。 数据加载工厂Data task 可以通过 NSURL 或 NSURLRequest 创建（使用前者相当于是使用一个对于该 URL 进行标准 GET 请求的 NSURLRequest，这是一种快捷方法）：1234567891011NSURL *URL = [NSURL URLWithString:@\"http://example.com\"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask *task = [session dataTaskWithRequest:requestcompletionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;// ...&#125;];[task resume]; 数据上传工厂Upload task 的创建需要使用一个 request，另外加上一个要上传的 NSData 对象或者是一个本地文件的路径对应的 NSURL：12345678910111213NSURL *URL = [NSURL URLWithString:@\"http://example.com/upload\"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSData *data = ...;NSURLSession *session = [NSURLSession sharedSession];NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:requestfromData:datacompletionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;// ...&#125;];[uploadTask resume]; 数据下载工厂Download task 也需要一个 request，不同之处在于 completionHandler 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：1234567891011121314NSURL *URL = [NSURL URLWithString:@\"http://example.com/file.zip\"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:requestcompletionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123;NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath];NSURL *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];[[NSFileManager defaultManager] copyItemAtURL:location toURL:newFileLocation error:nil];&#125;];[downloadTask resume]; 编者注 原文中这块代码以及上文的表述中存有一些问题，详见这个 issue，本文已进行更正，如果您有不同意见，欢迎在 Github 上给我们反馈。 NSURLSession 的 delegate 方法NSURLSession 的 delegate 方法是 NSURLConnection 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个映射表来进行一个完整的概览。 连接层/任务层代理NSURLSession 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。 session 的 delegate 方法处理连接层的问题：诸如服务器信任，客户端证书的评估，NTLM 和 Kerberos 协议这类问题。 task 的 delegate 处理网络请求为基础的问题：如 Basic，Digest，以及代理身份验证（Proxy authentication）等。 网络请求结束代理在 NSURLConnection 中两个delegate方法：数据加载完成：NSURLConnectionDataDelegate 中的 -connectionDidFinishLoading:网络连接失败： NSURLConnectionDelegate 中的 -connection:didFailWithError:，在 NSURLSession 中改为一个 delegate 方法： NSURLSessionTaskDelegate 的 -URLSession:task:didCompleteWithError: NSURLSession 中表示传输多少字节的参数类型现在改为 int64_t，以前在 NSURLConnection 中相应的参数的类型是 long long。 block参数回调代理模式NSURLSession 给 Foundation 框架引入了一种全新的模式：即 代理方法中以completionHandler: 这种block 作为参数的方式。 这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程； Delgate 只需要简单地调用 dispatch_async 就可以切换到后台进行相关的操作，然后在操作完成时调用 completionHandler 即可。 它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。 以 NSURLSessionTaskDelegate代理中的方法为例：1-URLSession:task:didReceiveChallenge:completionHandler: completionHandler 接受的两个参数：参数一：NSURLSessionAuthChallengeDisposition:鉴权查询的策略参数二：NSURLCredential:证书（仅当第一个参数——应对鉴权查询的策略为使用证书，即 NSURLSessionAuthChallengeUseCredential 时有效，否则该参数为 NULL）。 想要查看更多关于 session task 的信息，可以查看 WWDC Session 705: “What’s New in Foundation Networking” NSURLSessionConfigurationNSURLSessionConfiguration 对象用于对 NSURLSession 对象进行初始化。 配置开发灵活性NSURLSessionConfiguration 扩充了 NSMutableURLRequest 所提供的网络请求层的设置选项，从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 NSURLSessionConfiguration 可以找到几乎任何你想要进行配置的选项，提供给我们相当大的灵活性和控制权。 配置加载机制NSURLSession 在初始化时会把配置它的 NSURLSessionConfiguration 对象进行一次 copy，并保存到自己的 configuration 属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个 configuration 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。 三个配置类工厂方法针对NSURLSession 不同的使用场景，如下三个配置类方法： +defaultSessionConfiguration： 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享 NSURLCredentialStorage。 +ephemeralSessionConfiguration： 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。 +backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。 想要查看更多关于后台 session 的信息，可以查看 WWDC Session 204: “What’s New with Multitasking” 配置属性NSURLSessionConfiguration 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。 基本配置 HTTPAdditionalHeaders: 指定了一组默认的可以设置出站请求（outbound request）的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。 12345678910NSString *userPasswordString = [NSString stringWithFormat:@\"%@:%@\", user, password];NSData * userPasswordData = [userPasswordString dataUsingEncoding:NSUTF8StringEncoding];NSString *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:0];NSString *authString = [NSString stringWithFormat:@\"Basic %@\", base64EncodedCredential];NSString *userAgentString = @\"AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)\";configuration.HTTPAdditionalHeaders = @&#123;@\"Accept\": @\"application/json\",@\"Accept-Language\": @\"en\",@\"Authorization\": authString,@\"User-Agent\": userAgentString&#125;; networkServiceType: 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。 allowsCellularAccess 和 discretionary 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 discretionary 这个属性，而不是 allowsCellularAccess，因为前者会把 WiFi 和电源的可用性考虑在内。 timeoutIntervalForRequest 和 timeoutIntervalForResource 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 timeoutInterval 去限制发送请求的总时间，但其实它真正的含义是：分组（packet）之间的时间。实际上我们应该使用 timeoutIntervalForResource 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。 HTTPMaximumConnectionsPerHost: 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 NSURLConnection 用于管理私有的连接池。现在有了 NSURLSession，开发者可以在需要时限制连接到特定主机的数量。 HTTPShouldUsePipelining: 这个属性在 NSMutableURLRequest 下也有，它可以被用于开启 HTTP 管线化（HTTP pipelining），这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。 sessionSendsLaunchEvents: 是另一个新的属性，该属性指定该 session 是否应该从后台启动。 connectionProxyDictionary: 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。 关于连接代理的更多信息可以在 CFProxySupport Reference 找到。 Cookie 策略 HTTPCookieStorage: 存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage 的 +sharedHTTPCookieStorage 这个单例对象，这与 NSURLConnection 是相同的。 HTTPCookieAcceptPolicy: 决定了什么情况下 session 应该接受从服务器发出的 cookie。 HTTPShouldSetCookies: 指定了请求是否应该使用 session 存储的 cookie，即 HTTPCookieSorage 属性的值。 安全策略 URLCredentialStorage: 存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage 的 +sharedCredentialStorage 这个单例对象，这与 NSURLConnection 是相同的。 TLSMaximumSupportedProtocol 和 TLSMinimumSupportedProtocol 确定 session 是否支持 SSL 协议。 缓存策略 URLCache : 是 session 使用的缓存。默认情况下会使用 NSURLCache 的 +sharedURLCache 这个单例对象，这与 NSURLConnection 是相同的。 requestCachePolicy : 指定了一个请求的缓存响应应该在什么时候返回。这相当于 NSURLRequest 的 -cachePolicy 方法。 自定义协议 protocolClasses: 用来配置特定某个 session 所使用的自定义协议（该协议是 NSURLProtocol 的子类）的数组。 结论iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 NSURLConnection 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。 尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 NSURLSession 仍然是实现更高级别网络功能的一个强大的基础框架。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"支持OSX浏览PDF简单视图","slug":"macOS/支持OSX浏览PDF简单视图","date":"2017-09-08T18:48:43.000Z","updated":"2018-10-12T19:56:59.000Z","comments":true,"path":"2017/09/09/macOS/支持OSX浏览PDF简单视图/","link":"","permalink":"https://huos3203.github.io/2017/09/09/macOS/支持OSX浏览PDF简单视图/","excerpt":"","text":"运行scheme： PDFReaderForOSX 即可 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-PDFReader-737a7e\", \"huos3203\", \"PDFReader\", \"737a7e\", false); 支持iOSpageViewController: pdf翻页效果视图控制器startingViewController:DataViewController,翻页视图控制器的视图源modelController:ModelController:NSObject,数据视图数据源的model模型。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"ngrok使用","slug":"hexo/ngrok使用","date":"2017-09-06T12:23:24.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2017/09/06/hexo/ngrok使用/","link":"","permalink":"https://huos3203.github.io/2017/09/06/hexo/ngrok使用/","excerpt":"","text":"注册1.注册https://ngrok.com/signup Start by downloading ngrok. Install your authtoken 1./ngrok authtoken 2tpoyojTzL5w55Y4na5DY_3shJgaMVzjJ***** Create your first secure tunnel 1./ngrok http 80 Open the web interface at http://localhost:4040 to inspect and replay requests Read the documentation for instructions on advanced features like adding HTTP authentication, setting custom subdomains and more.开启TCP协议 开启TCP实现SSH远程访问. 详见1./ngrok tcp 22 如图： 每当执行开启命令，端口就会随机生成最新的。 配置SSH远程工具自定义SSH名：ngrokSSH域名地址：0.tcp.ngrok.io (ngrok提供的免费域名，IP地址ping就变新)SSH端口号：16335 （每次重新启动时需更新）用户名称/密码: 电脑管理员账户/密码 手机热点访问远程内网电脑连接前准备： 使用“网络实用工具”扫描0.tcp.ngrok.io域名，确保当前网络16335端口开启 备选方案，使用手机热点分享，来访问内网电脑，进行连通测试。 连接成功。总结：可以使用ngrok客户端，开启tcp协议端口，实现SSH远程控制，在不要求过高的网速和安全，可以不搭建ngrok服务器。 强大的tunnel(隧道)工具部署原理部署ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost”，这个诠释有两层含义：1、可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。2、支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。 一、ngrok tunnel与ngrok部署 网络tunnel（隧道）对多数人都是很”神秘“的概念，tunnel种类很多，没有标准定义，我了解的也不多（日常工作较少涉及），这里也就不 深入了。在《HTTP权威指南》中有关于HTTP tunnel（http上承载非web流量）和SSL tunnel的说明，但ngrok中的tunnel又与这些有所不同。 ngrok实现了一个tcp之上的端到端的tunnel，两端的程序在ngrok实现的Tunnel内透明的进行数据交互。ngrok分为client端(ngrok)和服务端(ngrokd)，实际使用中的部署如下：内网服务程序可以与ngrok client部署在同一主机，也可以部署在内网可达的其他主机上。ngrok和ngrokd会为建立与public client间的专用通道（tunnel）。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"搞定III目录笔记","slug":"阅读/搞定III目录笔记","date":"2017-08-17T15:41:11.000Z","updated":"2017-08-17T15:55:45.000Z","comments":true,"path":"2017/08/17/阅读/搞定III目录笔记/","link":"","permalink":"https://huos3203.github.io/2017/08/17/阅读/搞定III目录笔记/","excerpt":"","text":"11个模型 《搞定III》第1章 GTD现象几类读者：似懂非懂型，止步于列举清单等第二类：很难坚持第三类：学以致用型如何阅读本书：手头备小本子，“假设的肯定”自我培训：可信赖，可操作，长期追踪的步骤找到最终答案相信自己的决定的钥匙 第2章 步骤第3章 自我管理的基本内容 获得掌控第4章 捕捉 :梦想家，发散思维搜集所有信息 第5章 明确意义:执行者，处理原材料，有的放矢 1. 结果导向型思维的战术价值 2. 第6章 组织整理 第7章 深思 第8章 参与 第9章 把GTD运用到工作和生活中 六个高度:六层次法第10章 摆正视角 第11章 紧急问题：下一步行动 第12章 1万英尺：项目 第13章 2万英尺：关注和责任范围 第14章 3万英尺：长短期目标 第15章 4万英尺：愿景 第16章 5万英尺：宗旨和原则 第17章 摆正视角：重访“格雷西的花园” 实际运用第18章 实际运用第19章 尾声","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"在space-vim平台安装若干插件","slug":"shell/在space-vim平台安装若干插件","date":"2017-08-17T14:26:46.000Z","updated":"2018-09-22T21:18:50.000Z","comments":true,"path":"2017/08/17/shell/在space-vim平台安装若干插件/","link":"","permalink":"https://huos3203.github.io/2017/08/17/shell/在space-vim平台安装若干插件/","excerpt":"","text":"space-vim首次启用一个 layer，需要执行 SPC f R, 或者 :so $MYVIMRC, 重新加载 .vimrc 并执行 :PlugInstall 安装所需的相关插件 。或者退出重新打开 vim, vim-plug 将会检测并自动安装缺失的插件。基于vim-plug的插件管理平台vim-plug命令工具 Commands Command Description PlugInstall [name ...] [#threads] Install plugins PlugUpdate [name ...] [#threads] Install or update plugins PlugClean[!] Remove unused directories (bang version will clean without prompt) PlugUpgrade Upgrade vim-plug itself PlugStatus Check the status of plugins PlugDiff Examine changes from the previous update and the pending changes PlugSnapshot[!] [output path] Generate script for restoring the current snapshot of the plugins Plug options Option Description branch/tag/commit Branch/tag/commit of the repository to use rtp Subdirectory that contains Vim plugin dir Custom directory for the plugin as Use different name for the plugin do Post-update hook (string or funcref) on On-demand loading: Commands or &lt;Plug&gt;-mappings for On-demand loading: File types frozen Do not update unless explicitly specified 安装objc 自动提示插件YouCompleteMeYouCompleteMe命令工具 在spacevim添加使用space-vim封装的layer 1Layer &apos;ycmd&apos; &quot;语法自动补齐 YouCompleteMe 安装位置： ~/.vim/plugged/YouCompleteMe 。 编译 YCM在使用space-vim平台上，使用layer方式安装会执行如下编译操作： 1!./install.py --clang-completer 详见脚本：space-vim/layers/+tools/ycmd/packages.vim 参考：征服恐惧！用 Vim 写 iOS App12brew install cmake./install.py --clang-completer --system-libclang --clang-completer: 告诉脚本需要 clang 的支持--system-libclang: 告诉编译脚本使用系统的 clang，因为之前 clang 升级 4.0 的时候，并没有已经编译好的包给我下载，所以这里不用系统 clang 的话，编译脚本会下载一个 clang 3.0，这样就无法支持 iOS 10.0 以后的 sdk 了，因为 iOS 10.0 以后的 sdk 为了支持 swift 引入了一些 clang 3.0 不支持的新语法，所以这里要加上 –system-libclang。 FlagsForFile脚本获取编译参数YCMD 是通过每个项目路径下的 .ycm_extra_conf.py 脚本文件，定义了FlagsForFile 的函数来获取某一个特定文件需要的编译参数，一般情况下大部分文件的编译参数是相同的。 安装vim插件使用vim-plug安装 1Plug &apos;keith/sourcekittendaemon.vim&apos; NOTE: This plugin doesn’t provide Swift runtime files. If you’d like those checkout swift.vim AsyncRun shell command编辑器命令:AsyncRun + shell命令即可在后台执行shell命令，打开quickfix就可以实时查看执行结果了。也可以通过添加配置的方式来实现开始执行命令的时候自动打开quickfix窗口：12:copen //打开脚本运行日志窗口 :AsyncRun git status //异步执行shell脚本","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"PBBReader项目重构模型","slug":"个人项目/PBBReader项目重构模型","date":"2017-07-25T17:06:47.000Z","updated":"2018-09-22T21:18:51.000Z","comments":true,"path":"2017/07/26/个人项目/PBBReader项目重构模型/","link":"","permalink":"https://huos3203.github.io/2017/07/26/个人项目/PBBReader项目重构模型/","excerpt":"","text":"使用属性结构与法1234567891011\\`\\`\\`pumlsalt&#123; &#123;T + world ++ America ++ sss +++ aaa &#125;&#125;\\`\\`\\`puml","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"WKWebView控件和JS脚本传参及交互","slug":"iOS/UI/WKWebView控件和JS脚本传参及交互","date":"2017-07-07T09:54:41.000Z","updated":"2018-07-03T12:30:31.000Z","comments":true,"path":"2017/07/07/iOS/UI/WKWebView控件和JS脚本传参及交互/","link":"","permalink":"https://huos3203.github.io/2017/07/07/iOS/UI/WKWebView控件和JS脚本传参及交互/","excerpt":"","text":"WebKit简介 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-WKWebView-JS-d03bc0e\", \"huos3203\", \"WKWebView-JS\", \"d03bc0e\", false); 自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势:1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道）2、更多的支持 HTML5 的特性3、官方宣称的高达60fps的滚动刷新率以及内置手势4、Safari 相同的 JavaScript 引擎5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。 添加监听代理和JS接口在OC中添加监听的接口清单：以JS脚本的接口showMobile为例：1234WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];WKUserContentController *userCC = config.userContentController;//MARK:在OC中添加监听的接口清单：JS脚本的接口名[userCC addScriptMessageHandler:self name:@\"showMobile\"]; 设置WKUserContentController的代理 设置代理类遵守WKScriptMessageHandler协议 1@interface ViewController () &lt;WKScriptMessageHandler&gt; 注册对JS接口监听，注入代理类 1[userCC addScriptMessageHandler:self name:@\"showMobile\"]; 实现WKUserContentController代理的回调方法,响应JS接口事件 123- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;NSLog(@\"%@\",message.body);&#125; JS脚本接口js接口声明格式：1window.webkit.messageHandlers.接口名.postMessage('参数') 接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。 参数：object类型，多个参数时需要封装为集合类型来实现多参传递。 当OC拦截到该接口时，可以在WKScriptMessageHandler回调方法中的WKScriptMessage参数实例中获取该参数值: message.body。 三个例子： JS无参调用OC当无参调用OC时，参数必须为null 1window.webkit.messageHandlers.showMobile.postMessage(null) JS传参调用OC传递单个参数时，直接写入即可，例如：xiao黄 1window.webkit.messageHandlers.showName.postMessage('xiao黄') 传递多个参数时，需要封装为集合类型实现多参传递。例如:当传递一个电话，一条信息，需要封装为[&#39;13300001111&#39;,&#39;Go Climbing This Weekend !!!&#39;]1window.webkit.messageHandlers.showSendMsg.postMessage(['13300001111', 'Go Climbing This Weekend !!!']) iOS原生API调用JS脚本在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。例如调用JS函数alertMobile()：1234[self.wkWebView evaluateJavaScript:@\"alertMobile()\" completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;//TODONSLog(@\"%@ %@\",response,error);&#125;]; 在OC中为JS定义属性/函数 当注入的类型字符串类型时，必须用&#39;&#39;括起来。 OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。 通过NSString形式，编写JS脚本，通过以下两种方式注入网页 方式一：在初始化WKWebView时，通过配置WKWebViewConfiguration&gt;userContentController注入JS脚本 。123456//MARK:向网页中注入JS脚本例如，参数/函数等WKUserScript *script = [[WKUserScript alloc] initWithSource:@\"var number=0;\"injectionTime:WKUserScriptInjectionTimeAtDocumentStartforMainFrameOnly:YES];WKUserContentController *userCC = config.userContentController;[userCC addUserScript:script]; 方式二：使用WKWebView实例方法evaluateJavaScript动态注入JS脚本 1[self.wkWebView evaluateJavaScript:@\"var number=0;\" completionHandler:nil]; iOS原生API调用JS函数使用WKWebView实例方法evaluateJavaScript动态调用JS函数1[self.wkWebView evaluateJavaScript:@\"alertSendMsg('18870707070','下午好！')\" completionHandler:nil];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"控件","slug":"iOS/控件","permalink":"https://huos3203.github.io/categories/iOS/控件/"}],"tags":[]},{"title":"vim编辑器键盘映射命令map","slug":"shell/vim编辑器键盘映射命令map","date":"2017-07-04T15:06:52.000Z","updated":"2018-09-22T21:18:50.000Z","comments":true,"path":"2017/07/04/shell/vim编辑器键盘映射命令map/","link":"","permalink":"https://huos3203.github.io/2017/07/04/shell/vim编辑器键盘映射命令map/","excerpt":"","text":"使用:map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：1:map &lt;F5&gt; i&#123;e&lt;Esc&gt;a&#125;&lt;Esc&gt; 执行过程：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。 不同模式下的键盘映射使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射： Command 命令 Normal 常规模式 Visual可视化模式 Operator Pending运算符模式 Insert Only插入模式 Command Line 命令行模式 :map y y y :nmap y :vmap y :omap y :map! y y :imap y :cmap y 查看键盘映射1:map 取消键盘映射1:unmap &lt;F10&gt; #参数 注意：必须为:unmap命令指定一个参数。如果未指定任何参数，那么系统将会报错，而不会取消所有的键盘映射。针对不同模式下的键盘映射，需要使用与其相对应的unmap命令。例如：使用:iunmap命令，取消插入模式下的键盘映射；而取消常规模式下的键盘映射，则需要使用:nunmap命令。如果想要取消所有映射，可以使用:mapclear命令。请注意，这个命令将会移除所有用户定义和系统默认的键盘映射。 参考文章VIM键盘映射 (Map)Vim按键映射","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"vim编辑器的基本用法","slug":"shell/vim编辑器的基本用法","date":"2017-07-04T10:09:29.000Z","updated":"2018-09-22T21:18:50.000Z","comments":true,"path":"2017/07/04/shell/vim编辑器的基本用法/","link":"","permalink":"https://huos3203.github.io/2017/07/04/shell/vim编辑器的基本用法/","excerpt":"","text":"参考 基本操作基本概念动作：是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。1:h navigation 操作符：对某个区域文本执行的操作。比如，d、~、gU 和 &gt; 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。1:h operator 文本对象：1:h text-objects 缓冲区列表缓冲区的几种状态：已激活，已载入，已列出，已命名12:ls #列出所有可以列出的缓冲区:ls! #命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区 创建一个无名临时缓冲区1:enew 激活一个缓冲区1:e file2 命名一个缓冲区1:w /path/file #存储位置 参数列表1:h argument-list 操作命令范围概念关键字符：,|;|数字|\\$|% 跳转历史和变更历史1234:jumps:changes:h changelist:h jumplist 常用命令space-Vim使用文档空格 f t 打开/关闭树型栏SPC f R 刷新文件结构目录, f c unite命令集合快速查找命令集SPC b h 返回vim主页SPC f r 最近打开过的文件清单 markdown插件命令,1..3 快速标题格式###生成章节,ct 在当前位置插入所有章节的清单,cs 新建窗口显示博客章节目录清单,支持编辑时跳转到指定的章节位置,cp 预览博客发布的效果 git插件命令SPC g s git statusSPC g d git diffAsyncRun git add file git add fileSPC g c git commitSPC g p git push uniteVim插件：Unite新手指导(译)Unite可以在一个项目中快速浏览文件。但是它不仅限于文件，其他任何可以列出的东西都可以很好的被显示和搜索。这个开放式的特性很可能是人们找到它的原因 用法Unite命令采用的格式为:Unite source，其中”source”是buffer，file和file_rec其中之一。 buffer: 浏览当前打开的buffer列表file: 浏览当前目录的文件列表file_rec: 递归的列出当前目录的文件当一个命令被使用，一个新的水平分割窗口会被打开。比如，命令:Unite file将会显示当前目录的文件列表。在这个窗口中，标准的Vim命令模式下的命令可以使用。可以使用“j”和“k”浏览该列表，可以使用“/”来查询。如果你在一个文件上按下enter键，Unite将会打开它。如果光标是在一个目录上，Unite将会进入该目录，并且更新该文件列表。使用NERO Tree命令查看帮助命令1? 将选中的目录变为根目录：1C # change tree root to the selected dir 模式插入搜索模式如果你在Unite窗口进入插入模式，光标将会移到该窗口的最上方，并显示“&gt;”提示符。输入字符会搜索该列表–这里和FuzzyFinder相似。和常规vim一样，按键可以退出插入模式回到命令模式。 命令模式在命令模式下，当光标在一个文件上，按下a，Unite会显示一个可以操作该文件命令的列表。这个命令列表被称为actions，这个列表可以像Unite其他部分一样被搜索和调用。 操作actions可以组合通配符。如果输入:Unite file, 然后按下*将会标记所有文件，再输入a将会列出所有actions，最后选择above，Unite将会打开所有被标记的文件。 单行操作光标移动hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。 单词移动：1.一个单词由字母，数字和下划线组成，那么就用小写的e和w。即：程序变量移动。2.单词是由blank字符分隔符，那么就用大写的E和W。 即：程序语句移动。 123w → 到下一个单词的开头。e → 到下一个单词的结尾。b → 到前一个单词的开头。 本行移动： 12340 → 数字零，到行头^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）$ → 到本行行尾g_ → 到本行最后一个不是blank字符的位置。 行间移动： 123NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）gg → 到第一行。（陈皓注：相当于1G，或 :1）G 到最后一行 多行范围范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。 很多命令都可以加一个数字，用于指明操作范围 范围可以是一个行号，用于指定某一行 范围也可以是一对通过 , 或 ; 分割的行号 大部分命令，默认只作用于当前行 只有 :write 和 :global 是默认作用于所有行的 范围的使用是十分直观的。以下为一些例子（其中，:d 为 :delete 的缩写）： 命令 操作的行 :d 当前行 :.d 当前行 :1d 第一行 :$d 最后一行 :1,$d 所有行 :%d 所有行（这是 1,$ 的语法糖） :.,5d 当前行至第 5 行 :,5d 同样是当前行至第 5 行 :,+3d 当前行及接下来的 3 行 :1,+3d 第一行至当前行再加 3 行 :,-3d 当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围） :3,&#39;xdelete 第三行至标注 为 x 的那一行 :/^foo/,$delete 当前行以下，以字符 “foo” 开头的那一行至结尾 :/^foo/+1,$delete 当前行以下，以字符 “foo” 开头的那一行的下一行至结尾 需要注意的是，; 也可以用于表示范围。区别在于，a,b 的 b 是以当前行作为参考的。而 a;b 的 b 是以 a 行作为参考的。举个例子，现在你的光标在第 5 行。这时 :1,+1d 会删除第 1 行至第 6 行，而 :1;+1d 会删除第 1 行和第 2 行。 可视化区域选择并编辑文本1.区域选择其命令格式： &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt; 在visual 模式下，这些命令很强大。 action可以是任何的命令，如 d (删除), y (拷贝),v (可以视模式选择)。object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。 示例：假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。123456vi&quot; → 会选择 foo.va&quot; → 会选择 &quot;foo&quot;.vi) → 会选择 &quot;foo&quot;.va) → 会选择(&quot;foo&quot;).v2i) → 会选择 map (+) (&quot;foo&quot;)v2a) → 会选择 (map (+) (&quot;foo&quot;)) 2.可视化选择： v,V, 前面，我们看到了 的示例 （在Windows下应该是），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：123J → 把所有的行连接起来（变成一行）&lt; 或 &gt; → 左右缩进= → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了） 3.在所有被选择的行后加上点东西：123选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……)$ 到行最后A, 输入字符串，按 ESC。 文本编辑插入光标位置1234i → Insert 模式，按 ESC 回到 Normal 模式.a → 在光标后插入o → 在当前行后插入一个新行O → 在当前行前插入一个新行 操作文本： 1.删除：字符，单词，行 x → 删当前光标所在的一个字符。 cw → 替换从光标所在位置后到一个单词结尾的字符【准确的说是删除从光标位置到一个单词结尾的字符并进入插入模式】 dd → 删除当前行，并把删除的行存到剪贴板里 通过行号确定你要删除的行； set nu → 显示行号； :32,65d → 32-65行就被删除了 2.拷贝：单词，行，段 ye → 当前位置拷贝到本单词的最后一个字符。 yy → 拷贝当前行相当于 ddP（dd删除当前行，再粘贴） 0y$ → 拷贝当前行，即：光标移动组合操作格式：&lt;start position&gt;&lt;command&gt;&lt;end position&gt; y2/foo → 拷贝2个 “foo” 之间的字符串。 还有很多时候并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等 注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等 3.粘帖：1p/P → p是表示在当前位置之后，P表示在当前位置之前","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"SourceKittenSwift语法自动补齐工具","slug":"shell/SourceKittenSwift语法自动补齐工具","date":"2017-06-29T10:08:50.000Z","updated":"2018-09-22T21:18:49.000Z","comments":true,"path":"2017/06/29/shell/SourceKittenSwift语法自动补齐工具/","link":"","permalink":"https://huos3203.github.io/2017/06/29/shell/SourceKittenSwift语法自动补齐工具/","excerpt":"","text":"vim插件工具：Vundle 主题色：|组合键 | Description|空格 + T + n| 随机切换颜色主题。SPC T s |使用unite buffer方式切换一个主题 插件Unite预定义操作命令Unite或unite.vim插件可以搜索和显示信息，例如：任意源文件、缓冲区的，最近使用的文件或记录。可以直接运行在Unite窗口中显示的几个预设操作。 neocomplete一个自动补全的插件，使用TAB或ENTER键来选择。同时，它又额外附带了补全代码段的特性（模版补全），要想使用这种特性，必须安装另外的插件neosnippet或者ultisnips。 NERD Commenter快速注释/解开注释 Goyo and Limelight干净模式和背景虚化。两者配合使用，效果非常好。vim 也可以很文艺 Bookmarks插件旨在解决 Vim 自带书签无法高亮、无法持久化、难于记忆的问题，而且解决的非常漂亮. 下面列出其主要特性: 单行书签切换 ⚑单行的注释(说明)书签 ☰在 quickfix 窗口中访问所有书签书签自动保存，下次开启自动加载针对工作目录的独立书签(可选)高度可定制可以和 Unite 插件的 quickfix 结合不依赖 Vim 自身的 marks Gitagit插件 其他插件Key Mode Action +gu Normal Open undo tree +i Normal Toggle indentation lines +j Normal Start smalls +r Normal Quickrun +? Normal Dictionary +W Normal Wiki +K Normal Thesaurus","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"在slack上实现实时绘UML图","slug":"导图/在slack上实现实时绘UML图","date":"2017-06-28T15:57:00.000Z","updated":"2018-09-22T21:18:59.000Z","comments":true,"path":"2017/06/28/导图/在slack上实现实时绘UML图/","link":"","permalink":"https://huos3203.github.io/2017/06/28/导图/在slack上实现实时绘UML图/","excerpt":"","text":"umlbot源码库","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"PBBReader阅读器解析","slug":"iOS/PBBReader阅读器解析","date":"2017-06-26T17:02:18.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"2017/06/27/iOS/PBBReader阅读器解析/","link":"","permalink":"https://huos3203.github.io/2017/06/27/iOS/PBBReader阅读器解析/","excerpt":"","text":"支持OS X浏览PDF简单视图运行scheme： PDFReaderForOSX 即可 支持iOSpageViewController: pdf翻页效果视图控制器startingViewController:DataViewController,翻页视图控制器的视图源modelController:ModelController:NSObject,数据视图数据源的model模型。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[]},{"title":"Perfect开发天气接口API","slug":"macOS/Perfect开发天气接口API","date":"2017-06-26T17:01:24.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"2017/06/27/macOS/Perfect开发天气接口API/","link":"","permalink":"https://huos3203.github.io/2017/06/27/macOS/Perfect开发天气接口API/","excerpt":"","text":"Perfect介绍Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。 请求过滤器过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。 HTTP请求/响应路由HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。 句柄:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。 路由:主要依据请求的方法HTTP request method和请求内容包括的路径信息来决定的。 1234routes.add(method: .post, uris: [\"HostMonitor/client/log/addLog\"])&#123; (request,response) in //处理请求,并响应请求 &#125; URI路由变量URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。每个变量组件是通过一个程序块{ }声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号}之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。变量值:在匹配该模式下URL能够通过HTTPRequest.urlVariables字典查询变量值。该字典是[String:String]类型。 请求对象HTTPRequest当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。 HTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。 以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"终端","slug":"macOS/终端","permalink":"https://huos3203.github.io/categories/macOS/终端/"}],"tags":[]},{"title":"搞定2提升工作与生活效率的52项原则","slug":"阅读/搞定2提升工作与生活效率的52项原则","date":"2017-06-26T10:41:37.000Z","updated":"2017-08-17T15:55:45.000Z","comments":true,"path":"2017/06/26/阅读/搞定2提升工作与生活效率的52项原则/","link":"","permalink":"https://huos3203.github.io/2017/06/26/阅读/搞定2提升工作与生活效率的52项原则/","excerpt":"","text":"《搞定II》前言 轻松实现轻松做事第一部分 理清头绪，发挥创造力第1章 理清思路，确立新方向 第2章 知道哪些事情自己尚未做，你才会为之心安 第3章 理清承担的任务，可以更好地选择新任务 第4章 要实现未来的目标，首先明确当前的位置 第5章 以有限的可能，去利用无限的机遇 第6章 一心二用带来压力与失败 第7章 有意识地权衡轻重缓急 第8章 完成未竟之事，释放自身能量 第9章 如果你一直想着某件事，很可能是还没有搞定 第10章 只要有空间，创造力就会展现 第11章 渠深流畅 第12章 担忧无益 第13章 你不是你的工作 第二部分 高效关注第14章 想看得更清楚，请从更高处着眼 第15章 只有身体力行，你才会知道如何去做 第16章 工作足够努力是不可能的 第17章 精力随心思而动 第18章 目标越明确，实现目标的途径越多 第19章 精益求精 第20章 关注重心的变化等于结果的变化 第21章 视角是地球上最贵重的商品 第22章 多加思考 第23章 思考有度 第24章 效率是改善工作的唯一机会 第25章 关注一件事才能“全神贯注” 第26章 未来目标的价值，在于它当前培育的变化 第三部分 建立有效的制约机制第27章 稳定带来创造力 第28章 形式与功能必须符合效率最高的原则 第29章 优化系统，放飞思想 第30章 反应能力提升生存能力 第31章 系统的强弱取决于最薄弱的环节 第32章 系统的效率与你的感知度成反比 第33章 功能取决于形式 第34章 目标明确才能赢得胜利 第35章 多人负责等于无人负责 第36章 确定原则，而不是监管制度 第37章 利用大脑来思考工作，而不是单纯关注工作 第38章 思考的价值超乎想象 第39章 资源越是有限，规划越有必要 第四部分 放松自我，开始工作第40章 对自己做的事情承担起责任 第41章 过度控制等于失去控制 第42章 进展越好，状态越好 第43章 相信自己的行动选择，需要多层面的自我管理 第44章 你的力量取决于你的放松能力 第45章 预料之内的意外算不上意外 第46章 目光越长远，进展越顺畅 第47章 放慢速度以提升速度 第48章 你没有时间做任何项目 第49章 坚持做好小事，就能产生重大影响 第50章 亲力亲为才能了解事物 第51章 动中求变更容易 第52章 最伟大的成功源自最惨重的失败 第五部分 注意基本要素工作流程的5个阶段 处理与组织整理流程图 自然式计划模式 每周回顾指南 后记致谢","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"CoreML机器学习初级教程","slug":"iOS/CoreML机器学习初级教程","date":"2017-06-24T22:10:44.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"2017/06/25/iOS/CoreML机器学习初级教程/","link":"","permalink":"https://huos3203.github.io/2017/06/25/iOS/CoreML机器学习初级教程/","excerpt":"","text":"资源Core ML开发文档ML模型资源页面在Working with Models中包含有几个常用的模型模板，例如用于在图片中检测物体——树、动物、人等等。Integrating a Core ML Model into Your App 官方Core ML文档示例 AppMarsHabitatPricePredictor 模型的输入只是数字，因此代码直接使用生成的 MarsHabitatPricer 方法和属性，而不是将模型包装在 Vision 模型中。每次都改一下参数，很容易看出模型只是一个线性回归：137 solarPanels + 653.50 greenHouses + 5854 * acres 配置 ：将 Core ML 模型集成到你的 App本教程使用 Places205-GoogLeNet 模型，可以从苹果的ML页面下载。往下滑找到 Working with Models，下载第一个。还在这个页面，注意一下其它三个模型，它们都用于在图片中检测物体——树、动物、人等等。 注意：如果你有一个训练过的模型，并且是使用受支持的机器学习工具训练的，例如 Caffe、Keras 或 scikit-learn，Converting Trained Models to Core ML 介绍了如何将其转换为 Core ML 格式。 添加模型下载 GoogLeNetPlaces.mlmodel 后，把它从 Finder 拖到项目导航器的 Resources 组里： 生成模型类选择该文件，然后等一会儿。Xcode 生成了模型类后会显示一个箭头： 查看模型类点击箭头，查看生成的类：三个类：GoogLeNetPlaces: 主类，包含一个 model 属性和两个 prediction 方法GoogLeNetPlacesInput: 输入类,包含一个 CVPixelBuffer 类型的 sceneImage 属性，Vision 框架会负责把我们熟悉的图片格式转换成正确的输入类型。GoogLeNetPlacesOutput：输出属性,Vision 框架会将 GoogLeNetPlacesOutput 属性转换为自己的 results 类型. 实现Vision工作流程标准的 Vision 工作流程是创建模型，创建一或多个请求，然后创建并运行请求处理程序。并管理对 prediction方法的调用，所以在所有生成的代码中，我们只会使用 model 属性。 创建模型：在 Vision Model 中包装 Core ML ModelCoreML模型 是用于 Vision 请求的 Core ML 模型的容器打开 ViewController.swift，并在 import UIKit 下面 import 两个框架： 12import CoreMLimport Vision 创建VNCoreMLRequest图像分析请求VNCoreMLRequest 是一个图像分析请求，它使用 Core ML 模型来完成工作。它的 completion handler 接收 request 和 error 对象。Core ML 模型GoogLeNetPlaces 是一个分类器，因为它仅预测一个特征：图像的场景分类。这时request.results 是 VNClassificationObservation 对象数组。 12345678910111213// 创建一个带有 completion handler 的 Vision 请求let request = VNCoreMLRequest(model: model) &#123; [weak self] request, error in guard let results = request.results as? [VNClassificationObservation], let topResult = results.first else &#123; fatalError(&quot;unexpected result type from VNCoreMLRequest&quot;)&#125;// 在主线程上更新 UIlet article = (self?.vowels.contains(topResult.identifier.first!))! ? &quot;an&quot; : &quot;a&quot; DispatchQueue.main.async &#123; [weak self] in self?.answerLabel.text = &quot;\\(Int(topResult.confidence * 100))% it&apos;s \\(article) \\(topResult.identifier)&quot; &#125;&#125; VNClassificationObservation 有两个属性：identifier - 一个 String，以及 confidence - 介于0和1之间的数字，这个数字是是分类正确的概率。使用对象检测模型时，你可能只会看到那些 confidence 大于某个阈值的对象，例如 30％ 的阈值。然后取第一个结果，它会具有最高的 confidence 值，然后根据 identifier 的首字母把不定冠词设置为“a”或“an”。最后，dispatch 回到主线程来更新 label。你很快会明白分类工作为什么不在主线程，因为它会很慢。 创建并运行VNImageRequestHandler请求处理程序VNImageRequestHandler 是标准的 Vision 框架请求处理程序；不特定于 Core ML 模型。给它 image 作为 detectScene(image:) 的参数。然后调用它的 perform 方法来运行处理程序，传入请求数组。在这个例子里，我们只有一个请求。把下面几行添加到 detectScene(image:) 的末尾：123456789// 在主线程上运行 Core ML GoogLeNetPlaces 分类器let handler = VNImageRequestHandler(ciImage: image)DispatchQueue.global(qos: .userInteractive).async &#123; do &#123; try handler.perform([request]) &#125; catch &#123; print(error) &#125;&#125; 使用模型来自动识别场景在两个地方调用 detectScene(image:)把下面几行添加到 viewDidLoad() 的末端和 imagePickerController(_:didFinishPickingMediaWithInfo:) 的末端：12345guard let ciImage = CIImage(image: image) else &#123; fatalError(&quot;couldn&apos;t convert UIImage to CIImage&quot;)&#125;detectScene(image: ciImage) 现在构建并运行。 场景一:机器识别出了50%的概率是摩天大厦 场景二机器人识别出了75%的概率是水族池 什么是深度学习自20世纪50年代以来，AI 研究人员开发了许多机器学习方法。苹果的 Core ML 框架支持神经网络、树组合、支持向量机、广义线性模型、特征工程和流水线模型。但是，神经网络最近已经取得了很多极为神奇的成功，开始于 2012 年谷歌使用 YouTube 视频训练 AI 来识别猫和人。仅仅五年后，谷歌正在赞助一场确定 5000 种植物和动物的比赛。像 Siri 和 Alexa 这样的 App 也存在它们自己的神经网络。神经网络尝试用节点层来模拟人脑流程，并将节点层用不同的方式连接在一起。每增加一层都需要增加大量计算能力：Inception v3，一个对象识别模型，有48层以及大约2000万个参数。但计算基本上都是矩阵乘法，GPU 来处理会非常有效。GPU 成本的下降使我们能够创建多层深度神经网络，此为深度学习。神经网络，circa 2016神经网络需要大量的训练数据，这些训练数据理想化地代表了全部可能性。用户生成的数据爆炸性地产生也促成了机器学习的复兴。训练模型意味着给神经网络提供训练数据，并让它计算公式，此公式组合输入参数以产生输出。训练是离线的，通常在具有多个 GPU 的机器上。要使用这个模型，就给它新的输入，它就会计算输出：这叫做推论。推论仍然需要大量计算，以从新的输入计算输出。因为有了 Metal 这样的框架，现在可以在手持设备上进行这些计算。在本教程的结尾你会发现，深度学习远非完美。真的很难建立具有代表性的训练数据，很容易就会过度训练模型，以至于它会过度重视一些古怪的特征。苹果提供了什么？苹果在 iOS 5 里引入了 NSLinguisticTagger 来分析自然语言。iOS 8 出了 Metal，提供了对设备 GPU 的底层访问。去年，苹果在 Accelerate 框架添加了 Basic Neural Network Subroutines (BNNS)，使开发者可以构建用于推理（不是训练）的神经网络。今年，苹果给了我们 Core ML 和 Vision！Core ML 让我们更容易在 App 中使用训练过的模型。Vision 让我们轻松访问苹果的模型，用于面部检测、面部特征点、文字、矩形、条形码和物体。你还可以在 Vision 模型中包装任意的图像分析 Core ML 模型，我们在这篇教程中就干这个。由于这两个框架是基于 Metal 构建的，它们能在设备上高效运行，所以不需要把用户的数据发送到服务器。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"iOS11ARKit初探","slug":"iOS/iOS11ARKit初探","date":"2017-06-24T19:46:59.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"2017/06/25/iOS/iOS11ARKit初探/","link":"","permalink":"https://huos3203.github.io/2017/06/25/iOS/iOS11ARKit初探/","excerpt":"","text":"iOS11新技术ARKit教程增强现实(AR)描述用户体验，将2D或3D元素从设备的摄像头中添加到实时视图中，从而使这些元素出现在真实世界中。ARKit结合了设备运动跟踪，摄像镜头捕捉，先进的场景处理，以及显示方便来简化建立AR体验的任务。ARKit开发文档 理解 Augmented Reality理解AR概念、特性和最佳实践来构建很好的AR体验，ARSession：一个共享对象，可以管理增强现实体验所需的设备摄像头和运动处理。 AR相关配置ARSessionConfiguration:只记录设备方向的轨迹的基本配置ARWorldTrackingSessionConfiguration:一种跟踪设备定位和位置的配置，它可以检测设备摄像头看到的真实表面。 AR标准视图一个基本的AR体验DEMO配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容 Providing 3D Virtual Content with SceneKit ARSCNView:一种显示AR体验的视图，它通过3D SceneKit内容增强了相机视图。 Providing 2D Virtual Content with SpriteKit ARSKView:一种显示AR体验的视图，增加了2D SpriteKit内容的摄像头视图。 借助 ARKit 和 Core ML，基于 iOS 11 进行开发。iOS 11 为开发者带来了各种可能性。借助 ARKit，开发者可将生动逼真的增强现实带到 app 之中。而有了 Core ML，开发者可利用机器学习来创建各种更智能的 app。进一步了解基于 iOS 11 的开发","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[]},{"title":"plantuml语法概览","slug":"导图/plantuml语法概览","date":"2017-06-24T18:08:49.000Z","updated":"2018-09-04T19:39:50.000Z","comments":true,"path":"2017/06/25/导图/plantuml语法概览/","link":"","permalink":"https://huos3203.github.io/2017/06/25/导图/plantuml语法概览/","excerpt":"","text":"","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"序列图sequence语法插件","slug":"导图/序列图sequencediagram语法","date":"2017-06-24T16:00:03.000Z","updated":"2018-05-29T13:58:23.000Z","comments":true,"path":"2017/06/25/导图/序列图sequencediagram语法/","link":"","permalink":"https://huos3203.github.io/2017/06/25/导图/序列图sequencediagram语法/","excerpt":"","text":"MarkDown插件 loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-bubkoo-hexo-filter-sequence-4ab9c15\", \"bubkoo\", \"hexo-filter-sequence\", \"4ab9c15\", false); 这个插件在markdown暂时无法渲染出图像，不建议使用。 官方序列图预览工具 概述序列图(sequence diagram)，又称时序图。 通过描述对象之间发送消息的时间顺序 显示多个对象之间的动态协作元素===== 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 角色Actor系统角色。http://blog.csdn.net/ethmery/article/details/50670284 标题MarkDown语法：1Title:[标题] 对象Object位于序列图顶部，代表参与交互行为的对象。常见的命名方式： 类名+对象名 类名，无对象名（匿名对象） 对象名，无类名对象(object)是对客观事物的抽象，类(class)是对对象的抽象。 一个对象可以通过发送消息来创建另一个对象 一个对象可以被删除/自我删除，此时以”×”表示MarkDown语法： 声明一个或多个对象12participant [对象名1]participant [对象名2] 123456participant Aparticipant BNote left of A: 这是对A的注释Note right of B: 这是对B的注释Note over A: 这是A上的注释Note over A,B: 这是A和B共有的注释 为对象添加注释123Note left/right to [对象名]: [注释]Note over [对象名]: [注释]Note over [多个对象，之间以,隔开]: [注释] 生命线Lifeline 序列图中的对象在一段时间内的存在 以从对象底部中心延伸出的竖直虚线表示 对象之间的消息传递发生于生命线之间 激活期Activation 序列图中的对象执行一项操作的时期 或执行其自身的代码 或等待另一个对象的返回信息 以生命线上相应时间段内窄矩形表示 消息Message 用于对对象间通信内容进行建模的类 以垂直于生命线的单方向箭头表示 消息包含内容： 消息名称 消息参数 可能带有条件表达式，以确定是否发送/发送分支MarkDown语法： 语法格式：1[发送对象][箭头符号][接收对象]: [消息] 效果实现：1234A-&gt;B: -&gt;B--&gt;C: --&gt;B-&gt;&gt;A: -&gt;&gt;C--&gt;&gt;A: --&gt;&gt; 定义箭头语法： -&gt; 实线黑色三角箭头 –-&gt; 虚线黑色三角箭头 -&gt;&gt; 实线开放箭头 –-&gt;&gt; 虚线开放箭头 消息显示顺序与代码中消息编写顺序一致","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"flowchart流程图语法","slug":"导图/flowchart流程图语法","date":"2017-06-24T15:32:41.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"2017/06/24/导图/flowchart流程图语法/","link":"","permalink":"https://huos3203.github.io/2017/06/24/导图/flowchart流程图语法/","excerpt":"","text":"基本格式http://blog.csdn.net/KimBing/article/details/52934959?locationNum=2&amp;fps=1 对象 六种对象：开始对象，结束对象，操作对象，条件对象，输入对象，子任务对象 1对象变量=&gt;[start|end|operation|condition|inputoutput|subroutine]:[描述信息] 流程控制语法流程控制三要素：位置、方向，条件 12条件对象(YES/NO/消息)-&gt; 其他对象操作对象(left/right/top)-&gt; 其他对象 样例```//结构模块st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？ //流程控制模块st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op```效果：12345678910//结构模块st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？//流程模块st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"Hexo功能插件","slug":"hexo/Hexo功能插件","date":"2017-06-24T11:59:03.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2017/06/24/hexo/Hexo功能插件/","link":"","permalink":"https://huos3203.github.io/2017/06/24/hexo/Hexo功能插件/","excerpt":"","text":"安装插件//保证格式正确：”插件名”: “^版本号”, 方式一通过package.json 新增插件库//保证格式正确：”插件名”: “^版本号”, 1234&quot;hexo-filter-plantuml&quot;: &quot;^1.0.1&quot;,&quot;hexo-filter-sequence&quot;: &quot;^1.0.3&quot;,&quot;hexo-tag-plantuml&quot;: &quot;^1.0.0&quot;,&quot;hexo-pdf&quot;: &quot;^1.1.1&quot; 如何插件版本号：可以在插件的github库文件package.json中得到。 执行安装：1sudo npm install 方式二: 安装单个插件即下文的作图插件说明中使用的安装方式 举例：作图插件 flowchart流程图 sequence队列图 plantuml类图plantumlhexo-filter-plantuml安装：1npm install --save hexo-filter-plantuml hexo使用语法：```puml @startuml class A @enduml``` 效果图： hexo-filter-sequencesequence 安装：1npm install --save hexo-filter-sequence 配置_config.yml:123456789sequence:# webfont: # optional, the source url of webfontloader.js# snap: # optional, the source url of snap.svg.js# underscore: # optional, the source url of underscore.js# sequence: # optional, the source url of sequence-diagram.js# css: # optional, the url for css, such as hand drawn themeoptions:theme:css_class: hexo使用语法：```sequence Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob–&gt;Alice: I am good thanks!``` 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 效果图： hexo-filter-flowchart安装：1npm install --save hexo-filter-flowchart hexo使用语法：```flowst=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something…|request st-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e``` 效果图：123456789101112131415st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e 插件hexo-pdf安装：1npm install --save hexo-pdf hexo使用语法： 普通 PDF 1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; 相对路径 1&#123;% pdf ./bash_freshman.pdf %&#125; 支持Google盘/Slideshare 1&#123;% pdf https://drive.google.com/file/d/0B6qSwdwPxPRdTEliX0dhQ2JfUEU/preview %&#125; Slideshare1&#123;% pdf http://www.slideshare.net/slideshow/embed_code/key/8Jl0hUt2OKUOOE %&#125; 预览： “hexo-tag-plantuml”","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[]},{"title":"shell命令处理字符串","slug":"shell/shell命令处理字符串","date":"2017-06-23T10:32:45.000Z","updated":"2018-09-22T21:18:49.000Z","comments":true,"path":"2017/06/23/shell/shell命令处理字符串/","link":"","permalink":"https://huos3203.github.io/2017/06/23/shell/shell命令处理字符串/","excerpt":"","text":"截取字符串 %+字符+正则表达式 删除字符及右边内容，从源字符串右边开始匹配% 单井号表示一旦匹配成功立即删除%% 双井号表示一直等相匹配到最后一个字符时再删除 #+正则表达式+字符 删除字符及左边内容，从源字符串左边开始匹配# 单井号表示一旦匹配成功立即删除## 双井号表示一直等相匹配到最后一个字符时再删除 实例从line指定的路径中截取两个信息，类别和文件名称1line=\"shell/shell命令处理字符串.md\" 截取文件类别：shell删除最右边的“/shell命令处理字符串.md” 1categories=\"$&#123;line%%/*&#125;\" # %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符 截取文件名称：shell命令处理字符串先删除最左边的“shell/”,再删除最右边的“.md” 12titlemd=\"$&#123;line##*/&#125;\" # ##*/: 删除\"/\"左边所有字段即\"shell/\"title=\"$&#123;titlemd%%\\.*&#125;\" # 删除.md文件后缀","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[]},{"title":"个人项目概览及环境搭建","slug":"个人项目/个人项目概览及环境搭建","date":"2017-06-22T11:25:08.000Z","updated":"2018-09-22T21:18:51.000Z","comments":true,"path":"2017/06/22/个人项目/个人项目概览及环境搭建/","link":"","permalink":"https://huos3203.github.io/2017/06/22/个人项目/个人项目概览及环境搭建/","excerpt":"","text":"环境搭建说明 迁出项目mupdf已合并到PBBReader_Mac项目中，迁出库即可 1https://192.168.81.13/svn/PBBReader_Mac 运行PBB Reader项目 发布pkg包运行target :MakeInstaller，它依赖PBB Reader项目,当运行时，如下过程： 编译生成运行PBB Reader.app包 通过Packages打包工具生成pkg安装包，生成pkg目录在Distribution/ImportSVN/${timeDir}/。例如：Distribution/ImportSVN/20170118/PbbReader for OS 1.0.4.0037α.pkg 上传至SVN服务器 方式一：可以在第二步中拿到pkg文件，手动上传。 方式二：通过脚本来上传。12345#先判断svn目录是否存在,直接checkout目录导ImportSVN中cd $ImportSVN...echo \"导入SVN成功：$SVNURL/$&#123;timeDir&#125;/$&#123;ProductName&#125;.pkg\"fi 通过SVN脚本上传时，可以直接在Distribution/releaseNote.md文件中输入提交信息。 脚本清单发布脚本目录：Distribution/Packages/Script PreInstall.sh:发布脚本,Xcode运行MakeInstaller执行的脚本。 updateVersion.sh:更新版本号脚本，读取PBBReader-Info.plist文件两个字段信息：12CFBundleShortVersionString:版本号CFBundleVersion:build版本号 将两个版本号组合成发布内测版本号后，更新Welcome.html文件中的版本信息块中。具体呈现在双击pkg安装包安装过程中，显示的app版本信息的内容。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[]},{"title":"mupdf使用说明","slug":"编译/mupdf的使用说明","date":"2017-06-19T18:25:32.000Z","updated":"2017-06-19T18:25:32.000Z","comments":true,"path":"2017/06/20/编译/mupdf的使用说明/","link":"","permalink":"https://huos3203.github.io/2017/06/20/编译/mupdf的使用说明/","excerpt":"","text":"需求描述目前手机端使用mupdf，通过在底层添加加密方法实现定制pbb阅读器功能。资源获取如下：Download packages of the latest release for your system:Source code for all platforms.Windows viewer and tools.Android viewer on Google Play.Android viewer APK installer files.iPad and iPhone version on the App Store.The latest development source is available directly from the git repository:git clone –recursive git://git.ghostscript.com/mupdf.git 总结：没有适配osx版本，放弃。 使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。猜想：这样以来，使用苹果提供相关API，将无法定制底层操作，即无法实现密文浏览功能，故先从明文阅读器开发开始。 mupdf源码库集成加密最新整合集成加密到源码库，并发布到git服务器上，便于协作维护:https://server.local/git/mupdf.git协作过程：在服务器端添加账号：test test123123456$ git clone https://server.local/git/mupdf.git mupdf$ cd mupdf/thirdparty/$ git submodule init$ git submodule update$ open mupdf/platform/ios/MuPDF.xcodeproj$ build &amp; run 封装MuPDFFramework便于集成至PBBReader中：初始化mupdf页面接口：1234MuPDFViewController *bindingPhone = [[MuPDFViewController alloc] initWithNibName:nil bundle:nil];bindingPhone.filename=filename;bindingPhone.openfilepath=select_files;[self.view.window.contentViewController presentViewControllerAsSheet:bindingPhone];","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"PDF","slug":"macOS/PDF","permalink":"https://huos3203.github.io/categories/macOS/PDF/"}],"tags":[]},{"title":"米粉卡的区别参考办理","slug":"其他/米粉卡的区别参考办理","date":"2017-06-17T21:44:31.000Z","updated":"2018-10-05T21:42:35.000Z","comments":true,"path":"2017/06/18/其他/米粉卡的区别参考办理/","link":"","permalink":"https://huos3203.github.io/2017/06/18/其他/米粉卡的区别参考办理/","excerpt":"","text":"米粉卡：联通/电信办卡需要实名制，可以根据情况办理：米粉卡分为三种： 日租无限流量卡，1元/天 3G流量套餐 ，3元/天无限流量卡 如果平时在外不常使用流量，偶尔需求量大的话，天租比较合适。 10元/G 流量卡，两种套装：29元/月 2G流量。59元/月 4G流量 如果对移动办公比较感冒，对流量需求量大，可以考虑10元/G，每月20元 0月租卡，任我行 降预存，最节省套餐，不过也以为这没有流量福利","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"使用Numbers做导图","slug":"导图/使用Numbers做导图","date":"2017-06-16T17:43:31.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/06/17/导图/使用Numbers做导图/","link":"","permalink":"https://huos3203.github.io/2017/06/17/导图/使用Numbers做导图/","excerpt":"","text":"Pages文档、Numbers电子表格 和 Keynote演示文稿无不集思广益， 是创建精彩作品的理想工具。利用实时协作功能，你的团队成员可通过 Mac、iPad 或 iPhone 协作，共同编辑文档、电子表格或演示文稿，而 PC 用户也可通过 iCloud 版 iWork 一起参与。另外，你可以通过 Touch ID 瞬间解锁带有密码保护的文档。 与其他人协作有了 iCloud 版 Pages、Numbers 和 Keynote，你和团队可通过 Mac 或 PC 上的网页浏览器，访问并编辑你的各种文件。只需登录 iCloud.com，打开网页上的 app，就可以开始工作。无论你的团队成员是近在咫尺，还是远在天边，合作起来都是如此高效。登录iCloud版APP 图表使用法功能一：实用模版任君选择Numbers丰富的模板样式供用户选择，包括核对清单、贷款比较、预算、支出报告、员工日程表等，这些模版可广泛应用于企业员工日常的工作中，而且颜色、字体和图表质感均非常搭调，不仅实用还很美观。 基础空白，核对清单，核对清单总计，制图基础知识 个人财务简单预算，个人预算，个人储蓄，净值，退休储蓄，贷款比较，抵押贷款计算器 个人日历，日程表，跑步记录，家居装饰，球队组织，宝宝计划，旅游计划，聚会计划，膳食计划，食谱 商业员工日程表，发票，投资回报，盈亏平衡分析 教育出勤，成绩簿，概率实验，相关性项目，教育储蓄 功能二：演示效果佳 表格/形状/图片/视频便捷插入（iPad中不存在画笔） 功能三：空白模版很方便 格式随意修改功能四：熟练使用250多个函数成为神算手 菜单—插入—公式（Formula）— 基本公式算法 功能五：三维、交互式图表效果更出色功能六：可指定数据类型的单元格的技巧功能七：数据随时存 iCloud用处大","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"Xcode9新特性","slug":"xcode/Xcode9新特性","date":"2017-06-15T16:54:38.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/06/16/xcode/Xcode9新特性/","link":"","permalink":"https://huos3203.github.io/2017/06/16/xcode/Xcode9新特性/","excerpt":"","text":"无线调试升级设备系统体验iOS11系统需要几步操作： 下载配置文件：iOS_11_beta_Configuration_Profile，在手机端使用safari浏览器打开链接，自动安装到描述文件中。 设置中的“软件更新”会自动检测到iOS11 Developer beta版本，表明可以下载更新了。 配置设备信息 链接你的设备选择Window -&gt; Device and Simulators，完成之后左侧Connected区域你的设备右侧会显示小地图的图标，表示你已经连接上，此时断开数据线，就可以开始无线调试了。如下图所示： 如果iphone和mac不在同一局域网，你可以按照下图进行设置： xcode 的新特性 集成github 在偏好设置中，新增github账号 在导航栏中，新增git版本库导航器快速查看本地版本的Branches／Tags和commit时间轴，以及Remotes远程版本库信息。支持版本库基本操作：新建／合并／切换分支，打tag标签。还支持新建远程仓库，删除远程分支。通过双击commit的时间轴的一个条目来查看某次提交中文件的更改详情 xcode欢迎页面，clone已有库的界面，可以直接查看readme.md markdown的支持在Markdown文件中，您键入时，标题，粗体和斜体文本，链接和其他格式将立即在编辑器中呈现。Jump Bar甚至可以了解Markdown结构，因此您可以快速浏览README.md和文档文件。 色彩管理在Xcode中的xcassets中添加自定义的颜色，指定颜色名字:MyColor，这样就可以在代码和IB中方便的引用了。 右键选择添加New Color Set 点击Any，在右侧区域中轻松设置你的颜色 使用 代码中引用：UIColor(named:) 新方法引用你的颜色 1view.backgroundColor = UIColor(named:\"MyColor\") IB中引用你的颜色","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"特性","slug":"xcode/特性","permalink":"https://huos3203.github.io/categories/xcode/特性/"}],"tags":[]},{"title":"Xcode8中SB适配横竖屏按钮VaryforTraits","slug":"xcode/Xcode8中SB适配横竖屏按钮VaryforTraits","date":"2017-06-13T17:33:59.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/06/14/xcode/Xcode8中SB适配横竖屏按钮VaryforTraits/","link":"","permalink":"https://huos3203.github.io/2017/06/14/xcode/Xcode8中SB适配横竖屏按钮VaryforTraits/","excerpt":"","text":"升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代:Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。 添加竖屏约束xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器： 以前版本： Vary for Traits对不同设备和方向上添加约束 点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型假如：选width，会发现约束会同时应用到iPhone的横竖屏：选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了接下来为竖屏状态的界面添加约束， 点击Done Varying按钮完成对约束的添加 iPad适配时无法区分横竖屏对比iPhone横竖屏：竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"SB","slug":"xcode/SB","permalink":"https://huos3203.github.io/categories/xcode/SB/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"}]},{"title":"搞定1无压工作的艺术","slug":"阅读/搞定1无压工作的艺术","date":"2017-06-13T10:34:26.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/06/13/阅读/搞定1无压工作的艺术/","link":"","permalink":"https://huos3203.github.io/2017/06/13/阅读/搞定1无压工作的艺术/","excerpt":"","text":"前言第一部分 通向从容之道第1章 新情况，新做法 如何回归“心如止水”的境界在知识工作的环境下（信息大爆炸，事物繁杂的特点），传统时间管理法逐渐无法达到心如止水的境界， 第2章 掌控生活：横向管理工作流程的5个步骤横向管理的5个步骤 收集：把一切会引起大脑注意的事务，不分轻重缓急（潜在的重要信息／任务／想法／行动／安排）一律从大脑中清空，作为原始材料放置工作篮中。 理清：它是什么？检查工作篮的材料，理清它们的意义，扔掉垃圾事件 整理：理清流程图和整理流程图一样，2分钟原则 回顾：思考回顾体现了GTD的最核心 执行： 策划行动的三个方法： 四标准法：情境，时间，精力，重要性 每日工作三分类法：事先计划的事，突发事件，安排自己的事 检视工作的六层次法： 当前行动，当前项目，关注及责任范围，目标，愿景，目的和原则流程图如下：衍生的清单：项目清单下一步行动将要／也许清单孵化清单 第3章 控制项目：纵向管理项目计划的5个阶段第二部分 远离压力，提高效率第4章 准备工作：确定时间、空间和工具第5章 收集阶段：归拢材料第6章 处理阶段：清空工作篮第7章 组织整理：建立好清单第8章 检查回顾：保障系统的有效运行第9章 执行阶段：选择最合适的行动第10章 学会控制项目第三部分 三个关键原则第11章 原则一：养成收集的习惯第12章 原则二：确定“下一步行动”第13章 原则三：学会关注结果结语","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"WacomSlate笔记本使用","slug":"智能设备/WacomSlate笔记本使用","date":"2017-06-03T23:32:45.000Z","updated":"2018-09-22T21:19:00.000Z","comments":true,"path":"2017/06/04/智能设备/WacomSlate笔记本使用/","link":"","permalink":"https://huos3203.github.io/2017/06/04/智能设备/WacomSlate笔记本使用/","excerpt":"","text":"使用场景梳理任务列表，整理阅读笔记和思维导图，来配合iPad完成每日工作任务 使用效率按时出图，分解任务，规划职业 带来的回报### Starter.playgroundbookiPad学习开发swift第一步：创建书本的结构（参考模版）Starter.playgroundbook第二步：了解模版的结构第三步：增删改模版，增加个人的书本内容官方建议流程：Make targeted changes to the book’s content and structure in Xcode.Transfer the updated book into Swift Playgrounds using iCloud or AirDrop.只能使用iCloud和AirDrop来同步swift书籍同步到iPad上。Open the updated book and test the changes.Note any additional changes that are needed, and return to step 1. 最终使用方法：是在iPad上的一款应用，支持swift快速开发，只需要在appStore中下载Swift Playgrounds程序。在这个这个程序中有精选栏，和我的Playgorund 精选：就是内置了一些有趣的swift学习编程，从基础进阶再探索，简单易学的教学 我的Playground：有新建，分享，编辑三个按钮，和自己的程序书架。有两种方式开始编程： 新建一个空白的playgroundbook 通过iCloud 云同步已有的playgroundbook，这也是和mac端共享代码的途径（airdrop暂时没有测通，Mac端开启airdrop却看不到ipad设备），也可以通过第三方来同步，比如sync源码分享： 点击分享按钮，再点击要分享的playgroundbook文件，然后通过airdrop方式同 Mac共享文件。不过暂时没测通。如果使用微信，qq分享似乎发送到Mac端显示的是目录，无法通过打开方式来使用swift playground 程序效果分享： 在playgroundbook编辑页面，点击”。。。”弹出下拉列表页，提供fenxiang四种方式 拍照 创建PDF 录制影片 实时直播（需要第三方直播软件，暂时没测试） 激活iPad拥有自己的工作空间 激活iPad，安装自己喜欢的几款APP 测试电耗，连续使用8个小时，89%到30%，耗损50%，按工作场景应该能续航16小时左右 尝试键盘连接，使用外设键盘编辑文本还是比较舒服的，便捷，坐等移动键盘到手 摸索iPad使用场景 第一屏为咨询APP主页，在这里将发现更多新的东西，和未知的兴趣点，并同步至Pocker中，即搜集箱，充满期待 第二屏为下一步行动列表页，将第一屏搜集到的原材料，参考四象限法则，整理筛选排优先级，加工成可执行的下一步行动，过滤不能行动的事件 第三屏将行动导图梳理规范化，提高趣味性，增强行动动力，自我鼓励督促完成任务，培养自觉性和对承诺的责任心，逐步养成生活习惯","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"麦步第一天体验","slug":"智能设备/麦步第一天体验","date":"2017-06-02T14:39:46.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/06/02/智能设备/麦步第一天体验/","link":"","permalink":"https://huos3203.github.io/2017/06/02/智能设备/麦步第一天体验/","excerpt":"","text":"开源开发文档gitHub源码库 效率可用功能滴答清单，同步神速，可以使用麦步来标记完成任务 表盘：纯黑背景比较适合，内置白底表盘无法卸载工具：计步准确，睡眠监测还行，久坐提醒不错 思考功能怎样充分使用麦步，融入到现有的时间管理习惯中 开发一款麦步trello清单APP需求：麦步app获取到当天的trello清单，支持查看和完成操作预研：麦步无须APP账号绑定等，仅凭蓝牙是如何获取到滴答清单的？原理：结果：开发一款trello清单是否可行1.2 文档分析：在第二步：编译及打包环境 gcc-arm-none-eabi-4_7-2014q2-20140408-win32.exe 编译环境 IDE工具Visual MWatch.exe执行编译操作。可见暂时仅支持win系统开发。 借助IFTTT工具是否能将trello清单同步至麦步中2.1 中间APP 选择系统提醒APP/(日历APP支持时间设置)原理： 通过IFTTT工具将trello清单同步到提醒APP中，然后滴答清单读取提醒清单同步到麦步上。缺点：trello开始与截止日期等属性无法同步至提醒app，由于麦步仅同步滴答清单的当天任务列表，中间必须认为设置起始时间等。 日历属于一块圣地，不要轻易设置日程安排。他应该是第三象限不急重要的事情。当指定时间地点时，优先级立即为最高 trello创建人物是否能讲日期同步到系统提醒APP中，不可行的话，就需要单独对任务指定开始和截止时间。 提醒麦步获取信息的通道：蓝牙平台区别：Apple手机全局提醒，安卓可以过滤app 针对性个例：滴答清单麦步是如何针对性滴答清单，获取APP内部信息的。 其中的原理，涉及到，如果开发一款trello清单是否可行。 耗电：使用计步表盘，及时更新数据，相较普通时钟表盘，电耗是否一致，差距在哪？ trello日历订阅源滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历) 获取从trello看板中生成订阅源普通用户的看板限制的Power-Ups的一个数两步设置： 第一步：启动日历看板的菜单项—Power-Ups—Calendar–点击启动—出现设置图标按钮，如图： 第二步：开启日历订阅功能（默认关闭）点击设置按钮，并启动订阅功能，自动生成订阅路径 添加日历订阅源iPhone日历订阅需要通过通过Mac实现 使用 iCloud 日历订阅滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历) 可以通过监听事件来同步trello看板中的所有信息","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"swift开发macOS系统的终端命令行应用","slug":"macOS/swift开发macOS系统的终端命令行应用","date":"2017-05-29T13:00:08.000Z","updated":"2017-05-29T13:00:08.000Z","comments":true,"path":"2017/05/29/macOS/swift开发macOS系统的终端命令行应用/","link":"","permalink":"https://huos3203.github.io/2017/05/29/macOS/swift开发macOS系统的终端命令行应用/","excerpt":"","text":"教程命令行程序MacOS的教程 使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。选用SWIFT的理由：Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。 main.swift主体许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。 终端调用程序命令行可分两种模式 静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。 交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。 在同一个目录下执行 1./Panagram 相对路径执行 1Debug/Panagram","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"终端","slug":"macOS/终端","permalink":"https://huos3203.github.io/categories/macOS/终端/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"}]},{"title":"如何阅读一本书目录","slug":"阅读/如何阅读一本书目录","date":"2017-05-28T12:04:28.000Z","updated":"2017-05-29T13:00:08.000Z","comments":true,"path":"2017/05/28/阅读/如何阅读一本书目录/","link":"","permalink":"https://huos3203.github.io/2017/05/28/阅读/如何阅读一本书目录/","excerpt":"","text":"脑图 第一篇 阅读的层次第一章 阅读的活力与艺术 第二章 阅读的层次 第三章 阅读的第一个层次：基础阅读 第四章 阅读的第二个层次：检视阅读 第五章 如何做一个自我要求的读者 第二篇 阅读的第三个层次：分析阅读 第六章 一本书的分类 第七章 透视一本书 第八章 与作者找出共通的词义 第九章 判断作者的主旨 第十章 公正地评断一本书 第十一章 赞同或反对作者 第十二章 辅助阅读 第三篇 阅读不同读物的方法第十三章 如何阅读实用型的书 第十四章 如何阅读想像文学 第十五章 阅读故事、戏剧与诗的一些建议 第十六章 如何阅读历史书 第十七章 如何阅读科学与数学 第十八章 如何阅读哲学书 第十九章 如何阅读社会科学 第四篇 阅读的最终目标第二十章 阅读的第四个层次：主题阅读 第二十一章 阅读与心智的成长 附录一 建议阅读书目 附录二 四种层次阅读的练习与测验 索引","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[]},{"title":"搞定书籍目录","slug":"阅读/搞定书籍目录","date":"2017-05-28T12:04:28.000Z","updated":"2017-09-09T18:56:18.000Z","comments":true,"path":"2017/05/28/阅读/搞定书籍目录/","link":"","permalink":"https://huos3203.github.io/2017/05/28/阅读/搞定书籍目录/","excerpt":"","text":"《搞定I》前言第一部分 通向从容之道？第1章 新情况，新做法？ 收集存档清空大脑，万物皆于此， 2分钟法则整理可立刻执行的有效清单，不做材料清单 第2章 掌控生活：横向管理工作流程的5个阶段 第3章 控制项目：纵向管理项目计划的5个阶段 第二部分 远离压力，提高效率第4章 准备工作：确定时间、空间和工具 第5章 收集阶段：归拢材料 第6章 处理阶段：清空工作篮 第7章 组织整理：建立好清单 第8章 检查回顾：保障系统的有效运行 第9章 执行阶段：选择最合适的行动 第10章 学会控制项目 第三部分 三个关键原则第11章 原则一：养成收集的习惯 第12章 原则二：确定“下一步行动” 第13章 原则三：学会关注结果 结语","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"痛定思痛的项目管理弊病","slug":"个人项目/痛定思痛的项目管理弊病","date":"2017-05-27T15:06:17.000Z","updated":"2018-09-22T21:18:52.000Z","comments":true,"path":"2017/05/27/个人项目/痛定思痛的项目管理弊病/","link":"","permalink":"https://huos3203.github.io/2017/05/27/个人项目/痛定思痛的项目管理弊病/","excerpt":"","text":"问题 现状：两个项目源码存在八成为同样的代码，管理在两个SVN库中。背景：从一个SVN项目分裂成两个独立项目（PBB_2/Reader_v2）对应延伸出来SVN库，随后在两个库中开发不同的功能版本（PBB_7/Reader_v9）。需求：现在准备将两项目中新增的功能重新合并起来，即将PBB_v7合并到Reader_v9中。分析：需要把PBB_v3–PBB_v7的5个提交，合并到Reader_v9中 对PBB迭代的十几个版本中新增的功能涉及面太广，手动合并出错率高，协作难度大，纯劳力搬砖着实要命。以下总结几条建议 方案一：打补丁法合并源码 注：仅适用于同一个库使用 实现步骤： git-svn命令把svn库转为git库 将5个提交重演到Reader_v9版中 重演方案： 打补丁法：通过压缩提交法把PBB_v7若干提交整合成一个提交，再创建一个补丁，重演到Reader_v9上 交互变基压缩法，压缩成一个提交 reset压缩提交法，将提交压缩 git reset –soft 1bf27c6a33d87c2e36fa75431224124f91d8b482 案例：在大型项目中，贡献者常以使用补丁文件贡献代码结论：打补丁法的前提打补丁的宿主库必须和将要应用补丁的库为同一库源。故使用版本库来合并两个独立不想关的svn库，无法通过打补丁法实现合并。 方案二：项目模块化合并 在PBB Reader中通过项目依赖整合IJK／mupdf／maker 操作 取消Maker原有IJK，mupdf的依赖 在PBB Reader中配置Maker依赖 ：隐私空间涉及到的阅读功能在Reader中实现 新需求开发 好处 源码隔离，功能共享，对现有功能的源码无要做任何修改 项目之间相互独立，便于后续拆分或整合 更多精力专注代码优化 否决方案二，采用手动合并Reader本属于一个播放器，是从PBB应用的lite版，主要业务都是在PBB中实现的，当前需求是让PBB集成到Reader中，如何使用PBB Framework集成，需要暴漏大量的接口，业务层的高耦合性已经违背了封装原则。故作罢。 突破了合并时遇到的棘手问题，加密崩溃，最终排查出socker传输结构体导致的异常，maker和Reader之间的差异导致合并过程更加困难，最终采用对讲maker中对加密实现文件的封装，在集成到Reader中，即隔离冲突，暴露功能，程序架构集成过程中更便捷合理化。 相关知识： 引用日志：git reflog引用日志只存在本地仓库中，只记录第一次clone到之后，在本地仓库中的操作日志，服务器端不会同步这些引用记录，所以在本地无法查看别人的引用日志。 祖先引用几种表达式含义 第一种：^/^^^(多个)HEAD^:指向祖先提交hash值^（^^^） :指向该引用的上一个提交，几个符号就是指向上几个提交^数字:只适用于合并（merge）提交，有多个父提交。如：hash值^2表示第二父提交。第一父提交是指合并时所在的分支，第二父提交是指合并进来的分支。 第二种：~数字HEAD~: 指向祖先提交HEAD~数字:指向指向上几个提交hash值^数字:指向该引用的上几个提交","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://huos3203.github.io/categories/个人项目/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"命令","slug":"命令","permalink":"https://huos3203.github.io/tags/命令/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"升职必备的技能修炼二 以道御术","slug":"阅读/修炼升职必备的技能二","date":"2017-05-25T18:09:00.000Z","updated":"2017-05-25T18:15:01.000Z","comments":true,"path":"2017/05/26/阅读/修炼升职必备的技能二/","link":"","permalink":"https://huos3203.github.io/2017/05/26/阅读/修炼升职必备的技能二/","excerpt":"","text":"“老付”谈论的是目标，所有的方法都是为目标服务的，目标统率人的行为。 怎样规划自己的人生？ 怎样树立自己的目标？ 怎样把目标转化成实际的行动？ 怎样提高自己实现目标的能力？","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"修炼升职必备的技能","slug":"阅读/修炼升职必备的技能","date":"2017-05-25T16:40:42.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/05/26/阅读/修炼升职必备的技能/","link":"","permalink":"https://huos3203.github.io/2017/05/26/阅读/修炼升职必备的技能/","excerpt":"","text":"焦虑是由于缺乏控制力，以及组织管理、准备和行动不足所造成的。 四象限走出第三象限，将工作重心放进第二象限 第二象限法则 猴子法则：屏蔽干扰的伎俩 项目与行动的区别项目需要分解为可执行的行动 以动词开头的行动 添加行动的预期效果 下一步行动法，驱动项目的进行。 时间投资衣柜整理法收集，处理，组织，回顾，行动2分钟法则无论在什么情况下，我们在工作时都将经历这五个阶段： 收集篮：收集一切引起我们注意的事情。收集的关键是将‘一切引起我们注意的东西’放在‘收集篮’里，在清空大脑的同时达到‘心如止水’的境界。 工具军规 收集工具越少越好 保证5秒钟内拿出工具 定期清空工具： 今日事今日毕 ，定期清空，比如每周五清空所有事件迎接周末 处理收集篮：加工处理后，确定它们的实质以及解决方法。2分钟突击原则：指定任务可行性标签不可行： 1. 垃圾事件 2. 将来某时／也许事件 3. 参考资料（处理方法就是分类归档）可执行： 1. 2分钟事件（专治拖延症） 2. 项目事件 3. 委托事件 4. 预约事件 5.待办事件 原则： 从最上面一项开始处理 一次只处理一件事情 永远不要再放回收集篮（被迫中断的事情除外），争取一次做好 组织：组织整理，得出结论‘3+1’组合的清单系统材料，收集篮清单（做到每日清理）将某时／也许清单待办事清单项目清单（多任务集合，多个下一步行动）一般会放在待办清单中 回顾：解决盲目的问题，我们还需要做到对任务进行回顾。 让灵感应运而生周回顾的时候恰恰是这样一种状态，对所有的一切都了如指掌，对所有的一切都做了充足的准备。 站在3万米的高度去看待问题通过对自己一周工作的重新审视，向自己发问：到底哪些事有利于我更好地接近目标？今后遇到类似的事情应该如何取舍？当我们站在一个新的高度去看待现在的人和事，你会有前所未有的发现。 孵化和修剪你的任务及目标 把它们列为我们行动的选择方案。 行动：选择最佳方案利用一个月的时间去思考自己的未来发展，然后制定一个‘自上而下’的职业规划；当这个规划确定之后，我会‘自下而上’地搞定自己的工作，并且在工作的过程中随时修订自己的规划，这就是我的工作方式。 ‘自上而下’的目标系统大卫·艾伦的六个高度去进行检视和规划： 原则 （五万米）你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。如果你以前没有思考过这些，建议你现在就开始思考。我可以和你分享一下我的原则：工作是谋求更好生活的途径，追求无压、流畅、高效的工作。 愿景（四万米）这里面包含3—5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。在这个层面你需要问自己 ◎我的目标是什么？ ◎哪些人已经达到了我的这个目标？ ◎他们是如何达到目标的？ ◎达到这个目标之后我的工作和生活会是怎样的？ 目标（三万米）目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。比如说我现在的目标就是： ◎每周通过参加商务聚会来扩展自己的人脉，主动给朋友们打电话来巩固自己的人脉； ◎参加管理学的培训课程或者是参加MBA学习来提高自己的综合能力； ◎每天坚持阅读40分钟，以扩充自己的知识面，并且更深层次地研究自己所在的专属领域。 责任范围（两万米）工作上的角色：如销售、管理、产品开发等；生活中的角色：如家庭、个人财务、精神层面等。要把每一个角色扮演好，就需要执行一些任务，以拉近现实和期望的距离。比如在这个层面我会拿出我负责的项目和产品，看看在开发、销售、管理上是否还有提升的可能性，因为毕竟要把自己责任范围内的事情做得漂亮，才有可能升职或者有其他进一步的发展。 任务（一万米）所有需要一步以上完成的事情都是一个任务，虽然我们已经有了一个‘自上而下’的目标系统，但是我们仍然要将注意力放在眼前的任务上，比如‘新产品的营销策略’等。 下一步行动（跑道）这是最细枝末节的事件，我们要将它们全部放进我们的清单，然后逐一完成。谁更关注细节，谁就能获得更大的成功。刚开始我们都在同一个跑道里面绕圈，但是最终只有职业规划清晰的人才会驾车进入快车道，直奔目标而去。”","categories":[{"name":"阅读","slug":"阅读","permalink":"https://huos3203.github.io/categories/阅读/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"经历","slug":"经历","permalink":"https://huos3203.github.io/tags/经历/"}]},{"title":"calibre一站式电子书解决方案","slug":"智能设备/calibre一站式电子书解决方案","date":"2017-05-25T14:26:15.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/05/25/智能设备/calibre一站式电子书解决方案/","link":"","permalink":"https://huos3203.github.io/2017/05/25/智能设备/calibre一站式电子书解决方案/","excerpt":"","text":"Calibre，是一个免费的开源的“一站式”的电子书解决方案，它可以全面满足你的电子书需求。Calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。当然它也内置了一个 ePub 格式电子书编辑工具以满足修改电子书的需要。 感兴趣的几个功能点： 爬虫功能，即可以支持一键抓取新闻，根据指定的feed订阅源，来制作书籍。 这样便可每天爬取最新消息，发到kindle上看新闻 支持kindle书籍，相比kindle应用，它能自由复制书本内容，便于笔记整理。","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"远程操作mysql数据库","slug":"其他/远程操作mysql数据库","date":"2017-05-24T17:07:47.000Z","updated":"2018-10-05T21:42:35.000Z","comments":true,"path":"2017/05/25/其他/远程操作mysql数据库/","link":"","permalink":"https://huos3203.github.io/2017/05/25/其他/远程操作mysql数据库/","excerpt":"","text":"腾讯云服务器 申请账户，体验5天，搭建一个jira服务，还有微信小程序服务 需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统） 想使用daocloud加速器，就要更新docker版本docker run –detach –publish 8080:8080 cptactionhank/atlassian-jira:latesthttp://[dockerhost]:8080 and finish the configuration 远程服务器的基本操作 登录：ssh -l username 服务ip／域名 ssh ubuntu@123...*6 5**RtH sudo docker pull cptactionhank/atlassian-jira 服务器端拷贝文件目录 scp -i localDir serveruser@serverip:serverDir docker下安装mysql数据库镜像12sudo docker pull mysql sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest -name : 容器名MYSQL_ROOT_PASSWORD : 数据库密码-d : 镜像名:tag 版本 终端：单行登录mysql1sudo docker exec -it jiradb mysql -ujira -pjira 进入mysql终端,访问数据库123456sudo docker exec -it jiradb bash#登录数据库 默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码mysql -uroot -p #登录本地数据库 可以 省略-h参数 -h 127.0.0.1回车输入密码：jiradb #就是$MYSQL_ROOT_PASSWORD的值即登录 用户权限控制 查看sql服务器的状态： 1status; 创建用户名 1create user jira identified by &apos;jira&apos;; 赋予权限 1234grant all privileges on *.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos; with grant option;grant all privileges on *.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos; with grant option;flush privileges;quit; 数据库操作 创建数据库 1create database jiradb character set &apos;UTF8&apos;; 查看当前数据库名： 1select database(); 切换指定数据库 1use jiradb; 查看数据库表 1show tables; 创建表 jira和数据库关联结果无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联：从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功123Connect to MySQL from an application in another Docker containersudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest` 最终采用在ubuntu系统中安装mysql：1$sudo apt-get -y install mysql-server ##问题：Could not reach any registry endpoint安装Linux加速器：curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://142900b5.m.daocloud.io该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。ubuntu 系统安装daocloud检测工具：curl -sSL https://get.daocloud.io/daomonit/install.sh | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c 更新服务器上的docker官网教程 Update your apt sourcesTo set APT to use packages from the Docker repository: Log into your machine as a user with sudo or root privileges. Open a terminal window. Update package information, ensure that APT works with the https method, and that CA certificates are installed. 12$ sudo apt-get update$ sudo apt-get install apt-transport-https ca-certificates Docker资源库|Ubuntu version| Repository||—|—-||Precise 12.04 (LTS)|deb https://apt.dockerproject.org/repo ubuntu-precise main||Trusty 14.04 (LTS) |deb https://apt.dockerproject.org/repo ubuntu-trusty main||Wily 15.10 |deb https://apt.dockerproject.org/repo ubuntu-wily main||Xenial 16.04 (LTS) |deb https://apt.dockerproject.org/repo ubuntu-xenial main| Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from https://master.dockerproject.org. To install docker on a multi-architecture system, add an [arch=…] clause to the entry. Refer to Debian Multiarch wiki for details. 导入库 = deb https://apt.dockerproject.org/repo ubuntu-precise main1$ echo \"&lt;REPO&gt;\" | sudo tee /etc/apt/sources.list.d/docker.list `6.Update the APT package index.1$ sudo apt-get update 7.Verify that APT is pulling from the right repository.When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL https://apt.dockerproject.org/repo/. The version currently installed is marked with ***.The output below is truncated. $ apt-cache policy docker-engine docker-engine:Installed: 1.12.2-0~trustyCandidate: 1.12.2-0~trustyVersion table:*** 1.12.2-0~trusty 0500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages100 /var/lib/dpkg/status1.12.1-0~trusty 0500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages1.12.0-0~trusty 0500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages From now on when you run apt-get upgrade, APT pulls from the new repository. To upgrade your kernel and install the additional packages, do the following: Open a terminal on your Ubuntu host.Update your package manager.$ sudo apt-get updateInstall both the required and optional packages.$ sudo apt-get install linux-image-generic-lts-trustyRepeat this step for other packages you need to install.Reboot your host to use the updated kernel.$ sudo rebootAfter your system reboots, go ahead and install Docker. Install the latest versionMake sure you have satisfied all the prerequisites, then follow these steps. Note: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully.Log into your Ubuntu installation as a user with sudo privileges.Update your APT package index.$ sudo apt-get updateInstall Docker.$ sudo apt-get install docker-engineStart the docker daemon.$ sudo service docker startVerify that docker is installed correctly by running the hello-world image.$ sudo docker run hello-worldThis command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"iOS和OSX集成gitAPI","slug":"开源库/iOS和OSX集成gitAPI","date":"2017-05-17T17:33:46.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/05/18/开源库/iOS和OSX集成gitAPI/","link":"","permalink":"https://huos3203.github.io/2017/05/18/开源库/iOS和OSX集成gitAPI/","excerpt":"","text":"在项目中使用git submodule工具集成子项目ObjectiveGit 在新项目中使用git submodule集成gitAPI参考官方提供的两个demo OS X: CommitViewer iOS: ObjectiveGit iOS Example 123git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit如果之前配置过，直接更新：git submodule update --init --recursive cd External/ObjectiveGit，然后执行./script/bootstrap安装相关依赖. 拖动 ObjectiveGitFramework.xcodeproj 文件 到iOS/OSX项目导航窗口 . 在build Phases中配置APP的依赖，根据平台添加ObjectiveGit-Mac or ObjectiveGit-iOS. APP通过连接器链接 ObjectiveGit.framework. 在build setting中“Header Search Paths” (HEADER_SEARCH_PATHS)设置libgit2头文件在项目的路径，例如：External/ObjectiveGit/External/libgit2/include. Add a new “Copy Files” build phase, set the destination to “Frameworks” and add ObjectiveGit.framework to the list. This will package the framework with your application as an embedded private framework. It’s hard to tell the difference between the platforms, but the Mac framework is in build/Debug whereas the iOS framework is in build/Debug-iphoneos Don’t forget to #import &lt;ObjectiveGit/ObjectiveGit.h&gt; or @import ObjectiveGit; as you would with any other framework. 知识点 类变量关联.xib控件text值 字体样式菜单来改变字体样式 在OSX中设置控件的Bindings代替IBOutlet 先关联再使用属性依赖特性来同步数据 类变量关联.xib控件text值相关参考 选中NSTextField的bindings检查器面板 在value单元内设置bind to 的值，通过下拉框选中 Delegate Model key Path:输入类变量的名称。 切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联： 依赖属性Foundation 框架提供的表示属性依赖的机制如下：参考属性的依赖1234+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key或+ (NSSet *)keyPathsForValuesAffecting&lt;键名&gt; 将属性关联起来，这样就可以将类变量的值同步至UI控件中了：123456789101112+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keySet = [NSSet setWithObjects:@\"commit\", nil]; if ([key isEqualToString:@\"messageTitle\"] || [key isEqualToString:@\"messageDetails\"] || [key isEqualToString:@\"author\"] || [key isEqualToString:@\"date\"]) &#123; return keySet; &#125; return [super keyPathsForValuesAffectingValueForKey:key];&#125; 实现字体样式菜单来改变字体样式 在xib中拖一个Object并设置为NSFontManager.h类的实现。 选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"SubModule与SubTree的差异","slug":"git/SubModule与SubTree的差异","date":"2017-05-17T11:23:22.000Z","updated":"2018-10-11T20:58:56.000Z","comments":true,"path":"2017/05/17/git/SubModule与SubTree的差异/","link":"","permalink":"https://huos3203.github.io/2017/05/17/git/SubModule与SubTree的差异/","excerpt":"","text":"核心区别git submodule类似于引用，而git subtree类似于拷贝，比如你在一篇博客中想用到你另一篇博客的内容，git submodule是使用那篇博客的链接，而git subtree则是将内容完全copy过来。 submodule命令 添加submodule12git submodule add -b branchA http://github.com/../repoA.git pathAgit submodule add http://github.com/../repoB.git pathB 执行以上命令后会生成.gitmodule的文件，文件存储子模块信息:1234567[submodule \"repoA\"] path = pathA url = http://github.com/../repoA.git branch = branchA[submodule \"ModuleB\"] path = ModuleB url = http://github.com/../repoB.git 提交.gitmodule文件12git commit -m &apos;add submodule&apos;git push clone新库初始化submoduleclone之后各模块内容为空目录，需要执行： 1git submodule init 拉取所有子模块需要在.gitmodules文件中指定branch:分支名 123git submodule foreach git pull或git submodule foreach git pull origin master 更新所有模块更新后每个子模块并非在指定分支上，而是关联最近一次commitID。使用git submodule foreach为每一个子模块执行切换命令: 1git submodule foreach git checkout master 切换到所有master分支上（ModuleB为ResourceEvaluate，暂时需要单独执行） 删除子模块123456git rm --cached moduleArm -rf moduleAvi .gitmodules //删除moduleA相关的内容git add .git commit -m &quot;remove moduleA&quot;git push origin master subtree命令 subtree添加子模块通过subtree添加子模块,–squash可省略，其功能是只有最新的提交记录被引入，去掉后则是引入所有历史提交记录 1234#增加远程仓库并设置引用名`ModuleA`，此步可省略，主要是为了简化后面的操作git remote add ModuleA http://github.com/../ModuleA.git master#`subtree`添加子模块git subtree add --prefix=ModuleA --squash ModuleA master subtree更新 1git subtree pull -P ModuleA ModuleA master subtree提交 1git subtree push --prefix=ModuleA ModuleA master / submodule subtree 结果 远程仓库空间占用 submodule只是引用，基本不占用额外空间 子模块copy，会占用较大的额外空间 submodule占用空间较小，略优 本地空间占用 可根据需要下载 会下载整个项目 所有模块基本都要下载，二者差异不大 仓库克隆 克降后所有子模块为空，需要注册及更新，同时更新后还需切换分支 克隆之后即可使用 submodule步骤略多，subtree占优 更新本地仓库 更新后所有子模块后指向最后一次提交，更新后需要重新切回分支，所有子模块只需一条更新语句即可 所有子模块需要单独更新 各有优劣，相对subtree更好用一些 提交本地修改 只需关心子模块即可，子模块的所有操作与普通git项目相同 提交执行命令相对复杂一些 submodule操作更简单，submodule占优","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"}],"tags":[]},{"title":"开发思想模式总结","slug":"导图/开发思想模式总结","date":"2017-05-15T16:14:07.000Z","updated":"2018-09-22T21:18:59.000Z","comments":true,"path":"2017/05/16/导图/开发思想模式总结/","link":"","permalink":"https://huos3203.github.io/2017/05/16/导图/开发思想模式总结/","excerpt":"","text":"OOP面向对象编程：1. 封装，2，继承，3. 多态五大原则：SRP单一职责原则：一个类的功能要单一，表现突出的VIPER模式OCP开放封闭原则:模块扩展性为开放的，模块更改性则为封闭的。LSP替换原则，DIP依赖原则，ISP接口分离原则：模块间的功能通过抽象接口隔离 封装：将抽象事物的特征，行为，转化为代码中的类：属性和方法即为封装，体现2.对属性和方法的访问权限的控制 私有，公有不同级别的保护。继承：广义上也是一种对代码的复用。继承有两种方式：实现继承和接口继承。 多态：一个类实例的同一个方法，在不同情形有不同的表现形式。类似多个构造器和便利构造器，实现的功能都是初始化类实例的作用 子类场景优点：代码封装，重用组件 自定义系统控件时： 如：对UITableViewCell等视图，自定义布局。 针对多平台，多版本来编写代码实现：创建一个基类，创建iPhone子类／iPad子类来继承重写特性方法。 子类化模型对象，继承isEqual:,hash,copyWithZone:和description等方法，参考开源框架Mantle 子类的场景替代方案深层次的集成的替代方案： 子类使用相同的接口，协议替代， 当对象正常运行需要大量配置时，使用代理来完成配置 对现有的类增加简单功能时，使用类别来扩展 重写一堆相同方法子类时，使用配置对象代替 当重用某些功能时，使用组合多个对象来代替，而不是扩展它们 简明架构：VIPER模式：单一职责，将APP逻辑结构划分为不同的责任层：View视图，Interactor交互器，Presenter展示器，Entity实体，Routing路由 接口隔离原则：隔离依赖项， 单一职责原则：利于测试各层间边界处的交互。 轻量化VC，提高可读性，维护性。 基于用例的应用设计 待办事项清单示例用例别称为验收标准，或行为集，它们用来描述应用的用途。独立于用户界面，主要针对在应用程序中的负责业务逻辑层的测试操作。举例：清单可以根据时间，类型以及名字排序，这就是一个用例。特征：足够小，良好的定义。作用：将复杂的应用分解成较小的用例。 单一职责原则：便于测试测试用例：模拟网络数据-&gt;拦截HTTP请求-&gt;模拟一个响应对象给请求方目的：模拟数据，激活iResearcher 多线程下载 VIPER架构 LLDB命令和断点的合用变量，对象：p ，po，e 表达式，流程控制：thread断点管理：breakpointLLDB和PythonAppleScript Instruments自定义工具–DTrace语法 -&gt;自动化脚本终端成员DTrace使用IB工具来编写DTrace脚本，并可以方便的导出DTrace脚本，可用于脚本自动化时收集APP运行状态的数据，探针 （断言，动作，提供者，全部变量 ，begin，end）DTrace脚本是在内核中运行中的，需要IB工具做缓冲区，来封装内核数据达到ib工具识别 废除功能：run Browser浏览器功能UI automation功能 view属性的自动布局","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[]},{"title":"Xcode8插件制作替代Alcatraz","slug":"xcode/Xcode8插件制作替代Alcatraz","date":"2017-05-15T14:09:30.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/05/15/xcode/Xcode8插件制作替代Alcatraz/","link":"","permalink":"https://huos3203.github.io/2017/05/15/xcode/Xcode8插件制作替代Alcatraz/","excerpt":"","text":"背景 Xcode7插件工具Alcatraz开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。以往Xcode插件开发在没有官方支持的情况下，提供了Xcode-Plugin-Template和各种dump好的头文件，我们仍然需要在没有文档的情况下做各种猜测和hook。关于插件的开发，可以看看这篇文章。 Xcode8编辑源码的插件Xcode source editor extensionsXcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发Xcode source editor extensions来扩展以下三个功能: Add commands to the source editor // 给Xcode的代码编辑器扩展一些命令（在Editor菜单下增加额外的菜单） Edit text //通过这些命令对源代码进行编辑 Change selections //对选中文本的编辑功能 源码编辑器插件添加命令菜单通过Info.plist中添加菜单打开Info.plist，展开NSExtension至XCSourceEditorCommandDefinitions，命令菜单的定义如下：12345678910111213141516&lt;key&gt;NSExtensionAttributes&lt;/key&gt;&lt;dict&gt; &lt;key&gt;XCSourceEditorCommandDefinitions&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;XCSourceEditorCommandClassName&lt;/key&gt; &lt;string&gt;$(PRODUCT_MODULE_NAME).SourceEditorCommand&lt;/string&gt; &lt;key&gt;XCSourceEditorCommandIdentifier&lt;/key&gt; &lt;string&gt;com.xt.APPlugins.AutoComment.SourceEditorCommand&lt;/string&gt; &lt;key&gt;XCSourceEditorCommandName&lt;/key&gt; &lt;string&gt;Source Editor Command&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;XCSourceEditorExtensionPrincipalClass&lt;/key&gt; &lt;string&gt;$(PRODUCT_MODULE_NAME).SourceEditorExtension&lt;/string&gt;&lt;/dict&gt; 其中： XCSourceEditorCommandClassName指向命令的处理类，该类实现XCSourceEditorCommand。 XCSourceEditorCommandIdentifier是命令的唯一标识，通常我们会对一组命令设置同一个XCSourceEditorCommand，在invocation中获取此标识做区分处理。 XCSourceEditorCommandName是命令在菜单栏展示的菜单名称。通过代码定制命令菜单此外，菜单项是动态加载的，可以实现SourceEditorExtension.swift的commandDefinitions:实现SourceEditorExtension用来管理extension的生命周期相关,SourceEditorCommand则用来处理具体的命令。这会覆盖掉Info.plist中的定义。12345678910//1. 启动extension被调用，自定义相关操作func extensionDidFinishLaunching()&#123;&#125;var commandDefinitions: [[XCSourceEditorCommandDefinitionKey: AnyObject]] &#123; // If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter. ////commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令 return [[.classNameKey: \"SourceEditorCommand\", .identifierKey: \"CustomIdentifier\", .nameKey: \"CustomeName\"]]&#125; 命令插件功能实现打开SourceEditorCommand.swift，实现perform(with:completionHandler:)。123456789101112131415161718192021222324252627282930313233class SourceEditorCommand: NSObject, XCSourceEditorCommand&#123; //当通过Xcode菜单键调用插件时调用，实现插件功能的主体 func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void &#123; // 正则匹配含有 闭包 的文本 var updatedLineIndexes = [Int]() for lineIndex in 0 ..&lt; invocation.buffer.lines.count &#123; let line = invocation.buffer.lines[lineIndex] as! NSString do &#123; let results = try findClosureSyntax(line: line) //简化所有闭包语法格式：移除闭包里面括号 _ = results.map &#123; result in let cleanLine = line.remove(characters: [\"(\", \")\"], in: result.range) updatedLineIndexes.append(lineIndex) invocation.buffer.lines[lineIndex] = cleanLine &#125; &#125; catch &#123; completionHandler(error as NSError) &#125; &#125; completionHandler(nil) &#125; //使用正则表达式去遍历每一行代码是否含有闭包 func findClosureSyntax(line:NSString) throws -&gt;[NSTextCheckingResult] &#123; let regex = try NSRegularExpression(pattern: \"\\\\&#123;.*\\\\(.+\\\\).+in\", options: .caseInsensitive) let range = NSRange(0 ..&lt; line.length) return regex.matches(in: line as String, options: .reportProgress, range: range) &#125;&#125; XCSourceEditorCommandInvocation的buffer提供了当前选中的文件源代码中的信息，包括文件的lines, selections, indentationWidth等等，具体作用可以查看WWDC视频或者苹果的文档查看，在此就不一一介绍了。 测试 选择scheme后编译运行自定义的extensions插件 选择测试安装插件的Xcode 点击run按钮会单独启动一个全新的Xcode在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。 然后执行Editor &gt; Clean Closure &gt; Source Editor Command，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！ 命令快捷键设置快捷键去自动调用Clean Syntax命令 打开Xcode的Preferences，选择Key Bindings ; 搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。 WWDC2016之初识Xcode Source Editor Extensionxcode常用的插件清单使用 Xcode Source Editor Extension开发Xcode 8 插件详解一步步实现Xcode 8 插件","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"}]},{"title":"从UIKit到AppKit","slug":"macOS/从UIKit到AppKit","date":"2017-03-03T17:55:16.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/03/04/macOS/从UIKit到AppKit/","link":"","permalink":"https://huos3203.github.io/2017/03/04/macOS/从UIKit到AppKit/","excerpt":"","text":"不同点NSWindowController在Mac上应用都支持多窗口（NSWindowController），AppKit 中都有 NSWindowController担当着类似在iOS中的view controller处理的任务。 window在iOS占据整个屏幕，几乎不怎么不用。 NSViewControllerAppKit 中的 NSViewController默认不支持交互，缺少生命周期相关方法和UIKit中熟悉的特性。但在OS X 10.10 Yosemite之后，NSViewController改进很多，默认支持交互中的响应链。 NSWindow 和 UIWindow在UIKit中UIWindow是一个 view 的子类.在AppKit中NSWindow用 contentView 属性持有一个指向其顶层 view 的引用。 响应者链（responder chain）如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下view controller 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 window 和 window controller。在这种情况下，如果你想在 view controller 处理事件，你需要手动把它添加到响应者链中。 Target-Action消息传递方式Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。 传递机制的局限基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息： 在iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。 在 Mac 平台上 action 方法的第一个参数永远是发送者，否则将不视为无效方法。在AppKit唯一有效的action 方法声明方式：1- (void)performAction:(id)sender; 控件关联Action事件的区别iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。 在 iOS 中，每个控件可以通过addTarget:action:forControlEvents:和多个 target-action 关联。 在AppKit中通常一个控件仅对应一个 target-action对。 View视图系统因为历史遗留问题，Mac 的视图系统和 iOS的视图系统有很大区别。 绘图处理器差异iOS由 Core Animation layer 驱动，使用GPU处理。AppKit视图系统相关的任务主要靠 CPU 处理，因为在AppKit设计之初，GPU还没有诞生。Mac开发参考资料：Introduction to View Programming Guide for CocoaWWDC session：Layer-Backed Views: AppKit + Core AnimationOptimizing Drawing and Scrolling Layer-Backed View: iOS反哺AppKit层支持视图 iOS反哺AppKit默认情况下，AppKit 的 view 不是由 Core Animation layer 驱动的；AppKit 整合 layer-backing 是 iOS 反哺的结果。 layer backing启用／禁用:wantsLayerAppKit 区分 layer-backed view 和 layer-hosting view，可以在每个视图树的根节点启用或者禁用 layer backing。启用 layer backing 方法一：把窗口的 contentView 的 wantsLayer 属性设置为 YES 方法二：在 Interface Builder 的 View Effects Inspector 面板完成这会导致 window 的视图树中所有的 view 都启用 layer backing，这样就没必要反复设置每个 view 的 wantsLayer 属性了。 修改layer属性在AppKit上开启layer backing之后，layer的拥有者是AppKit，这就意味着不能直接编辑 layer的属性。在 iOS 上可以直接编辑：1self.layer.backgroundColor = [UIColor redColor].CGColor;在 AppKit编辑layer属性需要以下步骤： 重写 NSView 的 wantsUpdateLayer 方法并返回 YES,这能让你可以改变 layer 的属性。这样以来，在view 更新周期中，将不会再调用 view 的 drawRect: 方法。取而代之，调用updateLayer方法来更新Layer。举个例子，用这方法去实现一个非常简单的有纯色背景的 view（没错，NSView 没有backgroundColor 属性）：这个例子的前提是这个 view 的父 view 已经为其视图树启用了 layer backing。另一种可行的实现则只需要重写 drawRect: 方法并在其中绘制背景颜色。123456789101112131415161718192021@interface ColoredView: NSView@property (nonatomic) NSColor *backgroundColor;@end@implementation ColoredView- (BOOL)wantsUpdateLayer&#123; return YES;&#125;- (void)updateLayer&#123; self.layer.backgroundColor = self.backgroundColor.CGColor;&#125;- (void)setBackgroundColor:(NSColor *)backgroundColor&#123; _backgroundColor = backgroundColor; [self setNeedsDisplay:YES];&#125;@end 合并 Layer当APP启动过多的layer-backed view 会带来巨大的内存消耗（每一个 layer 有其自己的 backing store，还有可能和其他 view的 backing store 重叠）而且会带来潜在的合成这些 layer 的消耗。 canDrawSubviewsIntoLayer合并Layer从 OS X 10.9 开始，如果不单独对一个 view 中的子 view 做动画，可以通过设置 canDrawSubviewsIntoLayer 属性来让 AppKit 合并一个视图树中所有 layer 的内容到一个共有的 layer。 隐式layer-backed合并Layer所有隐式 layer-backed 的子 view（比如，没有显式地对这些子 view 设置 wantsLayer = YES）现在将会被绘制到同一个 layer 中。不过wantsLayer 设置为 YES 的子 view 仍然持有它们自己的 backing layer， 而且不管 wantsUpdateLayer 返回什么，它们的 drawRect: 方法仍然会被调用。 Layer 重绘策略layer-backed view 默认的自动重绘策略layer-backed view 会默认设置重绘策略为 NSViewLayerContentsRedrawDuringViewResize。在行为上，这个非 layer-backed view 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。 设置layer-backed view手动重绘策略 设置手动重绘策略：把 layerContentsRedrawPolicy 属性设置为 NSViewLayerContentsRedrawOnSetNeedsDisplay 实现手动重绘操作：调用 -setNeedsDisplay:方法来触发重绘操作这样便由你来决定 layer 的内容何时需要重绘。帧的改变将不再自动触发重绘。 设置view的属性来重绘Layer view中layerContentsPlacement属性：等价layer中的 contentGravity 属性。这个属性允许你指定在调整大小的时候当前的 layer 内容该怎么映射到 layer 上。 Layer-Hosting View:使用 Core Animation layerlayer-hosting view 是视图树中的叶子节点，使用这种模式可以对layer 及其子 layer 做任何操作，代价是你再也不能给该 view 添加任何子 view。 创建 为 view 的 layer 属性分配一个 layer 对象， 设置wantsLayer 为 YES这些步骤的顺序是非常关键：123456789- (instancetype)initWithFrame:(NSRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.layer = [[CALayer alloc] init]; self.wantsLayer = YES; &#125;&#125; 在你设置了自定义的 layer 之后，再设置 wantsLayer 是非常重要的。 其他与 View 相关的陷阱坐标系统原点设置左下／左上角通过重写isFlipped 并返回 YES 来恢复到你熟悉的左上角。 View背景颜色属性drawsBackground由于 AppKit 中的 view 没有背景颜色属性可以让你直接设置为 [NSColor clearColor] 来让其变得透明，许多 NSView 的子类比如 NSTextView 和 NSScrollView 开放了一个 drawsBackground 属性，如果你想让这一类 view 透明，你必须设置该属性为 NO。 设置光标追踪区域为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 NSView 中指定的 updateTrackingAreas 方法中来做这件事情。一个通用的写法看起来是这样子的：123456789- (void)updateTrackingAreas&#123; [self removeTrackingArea:self.trackingArea]; self.trackingArea = [[NSTrackingArea alloc] initWithRect:CGRectZero options:NSTrackingMouseEnteredAndExited|NSTrackingInVisibleRect|NSTrackingActiveInActiveApp owner:self userInfo:nil]; [self addTrackingArea:self.trackingArea];&#125; NSCell困惑AppKit 的控件之前是由 NSCell 的子类驱动的，可以被所有同类型的控件重用。AppKit 最初区分 view 和 cell 是为了节省资源 - view 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 view 重用的 cell 对象。不要混淆这些 cell 和 UIKit 里 table view 的 cell 及 collection view 的 cell。 自定义一个按钮控件Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。举个例子，如果你想创建一个自定义的按钮， 首先要继承 NSButton 和 NSButtonCell 然后在这个 cell 子类里面进行你自定义的绘制， 然后通过重写 +[NSControl cellClass]方法告诉自定义按钮使用你的 cell 子类 获取 Core Graphics 上下文最后，如果你想知道在你自己的 drawRect: 方法里怎么获取当前的 Core Graphics 上下文，答案是 NSGraphicsContext 的 graphicsPort 属性。详细内容请查看 Cocoa Drawing Guide。 动画如果你的 view 不是由 layer 驱动的，那你的动画自然是完全由 CPU 处理，这意味着动画的每一步都必须相应地绘制到 window-backing store 上。 对 layer-backed view做动画正如上面说的，在 AppKit 中,这些 layer 由 AppKit 管理，你不应该修改 layer-backed view 中的 layer。 几何属性与iOS 相反，view 的几何属性并不仅仅是对应的 layer 的几何属性的映射，但 AppKit 却会把 view 内部的几何属性同步到 layer。 的animator proxy动画1view.animator.alphaValue = .5; 在幕后，这句代码会启用 layer 的隐式动画，设置其透明度，然后再次禁用 layer 的隐式动画。 NSAnimationContext动画 结束回调1234567891011[NSAnimationContext runAnimationGroup:^(NSAnimationContext *context)&#123; //持续时间 context.duration = 1; //缓动类型 context.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; view.animator.alphaValue = .5;&#125; completionHandler:^&#123; // ...&#125;]; 无结束回调12[NSAnimationContext currentContext].duration = 1;view.animator.alphaValue = .5; 启用隐式动画12[NSAnimationContext currentContext].allowsImplicitAnimations = YES;view.alphaValue = .5; CAAnimations控制动画使用 CAAnimation 实例更全面地控制动画。和 iOS 相反，你不能直接把它们加到 layer 上（因为 layer 不应该由你来修改），不过你可以使用 NSAnimatablePropertyContainer 协议中定义的 API，NSView 和 NSWindow 已经实现了该协议。1234CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];animation.values = @[@1, @.9, @.8, @.7, @.6];view.animations = @&#123;@\"alphaValue\": animation&#125;;view.animator.alphaValue = .5; 帧动画对于帧动画来说，把 view 的 layerContentsRedrawPolicy 设置为 NSViewLayerContentsRedrawOnSetNeedsDisplay 是非常重要的，不然的话 view 的内容在每一帧都会被重绘。 很遗憾，NSView 没有开放 Core Animation layer 所有可以进行动画的属性，transform 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。 上面提到的所有东西都适用于 layer-backed view。对于 layer-hosting view 来说，你可以直接对 view 的 layer 或者子 layer 使用 CAAnimations，因为你拥有它们的控制权。 文字系统有了 TextKit，iOS 7 终于有了和 Mac 上早就有了的 Cocoa Text System 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 iOS；相反，Apple 对其做了些显著的改变。举个例子，AppKit 开放 NSTypesetter 和 NSGlyphGenerator，你可以通过继承这两者来自定义它们的一些特性。iOS 并不开放这些类，但是你可以通过 NSLayoutManagerDelegate 协议达到定制的目的。总体来说，两个平台的文字系统还是非常相似的，所有你在 iOS 上能做的在 Mac 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。 沙盒符合沙盒机制的 Mac 应用才能通过 Mac App Store 销售。然而，我们已经习惯了沙盒机制还没出现之前的 Mac 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。管理Mac应用对沙盒支持： 独有特性有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：进程间通讯，使 Mac 应用脚本化,在沙盒中脚本化其他应用 , 为你的应用构建插件。当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"视图","slug":"macOS/视图","permalink":"https://huos3203.github.io/categories/macOS/视图/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"},{"name":"混编","slug":"混编","permalink":"https://huos3203.github.io/tags/混编/"}]},{"title":"RxSwift基本概念","slug":"开源库/RxSwift基本概念","date":"2017-03-03T13:01:41.000Z","updated":"2018-10-05T21:42:36.000Z","comments":true,"path":"2017/03/03/开源库/RxSwift基本概念/","link":"","permalink":"https://huos3203.github.io/2017/03/03/开源库/RxSwift基本概念/","excerpt":"","text":"FRP函数式反应型编程Functional Reactive Programming ， 缩写为 FRP 函数编程函数是第一等公民所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。将数组通过指定的函数映射成另一个数组，例如将increment函数作为参数传入数组的map函数:12let increment = &#123; return $0 + 1 &#125;[1,2,3].map(increment) // [2,3,4] 函数式的函数map 映射函数map 可以把一个数组按照一定的规则转换成另一个数组，定义如下：123func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; U[]//效果[ x1, x2, ... , xn].map(f) -&gt; [f(x1), f(x2), ... , f(xn)]map接受一个把 T 类型的转换成 U 类型的transform函数，最终返回的是 U 类型的集合。 filter 筛选函数filter通过在闭包中对每个元素进行逻辑运算，来排除为false的元素12345func filter(includeElement: (T) -&gt; Bool) -&gt; [T]//实现var oldArray = [10,20,45,32]var filteredArray = oldArray.filter(&#123; return $0 &gt; 30 &#125;)println(filteredArray) // [45, 32] reduce 迭代函数reduce函数把U类型集合中的所有元素，以initial为初始值，按照combine规则，逐个迭代并返回一个U类型的对象。定义如下：1func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; Ureduce 有两个参数，initial是初始值，combine定义规则闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，闭包返回的新值作为下一轮循环中的initial值。写几个小例子试一下：1234567var oldArray = [10,20,45,32]var sum = 0sum = oldArray.reduce(0,&#123;$0 + $1&#125;) // 0+10+20+45+32 = 107sum = oldArray.reduce(1,&#123;$0 + $1&#125;) // 1+10+20+45+32 = 108sum = oldArray.reduce(5,&#123;$0 * $1&#125;) // 5*10*20*45*32 = 1440000sum = oldArray.reduce(0,+) // 0+10+20+45+32 = 107println(sum) 函数式和指令式的比较响应式编程 - Reactive在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景： 用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。 用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。 那么什么是反应型编程呢？ Reactive programming is programming with asynchronous data streams. 反应型编程是异步数据流的编程。 对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流： –a—b-c—d—X—|–&gt; a, b, c, d 是具体的值，代表了某个事件 X 表示发生了一个错误 | 是这个流已经结束了的标记 ———-&gt; 是时间轴比如我们要统计用户点击鼠标的次数，那么可以这样：clickStream: —c—-c–c—-c——c–&gt; vvvvv map(c becomes 1) vvvv —1—-1–1—-1——1–&gt; vvvvvvvvv scan(+) vvvvvvvvvcounterStream: —1—-2–3—-4——5–&gt;反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。 swift 函数式编程Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。Swift 本身并不是一门函数式语言，不过有一些函数式的方法和特性 map reduce 等函数式函数 函数是一等公民 模式匹配我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。 RxSwift 响应式编程Rx.playground Observable观察者模式Rx 的基础：Observable ， Observable&lt;Element&gt; 是观察者模式中可观察的对象，相当于一个事件序列 (GeneratorType)。支持订阅的事件序列，在下文简称为订阅源或可观察者。订阅源的事件队列中包括三种事件类型： .Next(value): 表示新的事件数据。 .Completed: 表示事件序列的完结。 .Error: 同样表示完结，但是代表异常导致的完结。 新建订阅源几种快捷方法 empty是一个空的序列，它只发送 .Completed 消息。Observable+Creation.swift123456789public static func empty() -&gt; Observable&lt;E&gt;example(\"empty\") &#123; let emptySequence: Observable&lt;Int&gt; = empty() let subscription = emptySequence.subscribe &#123; event in print(event) &#125;&#125;--- empty example ---Completed never 是没有任何元素、也不会发送任何事件的空序列。Observable+Creation.swift1234/**- returns: An observable sequence whose observers will never get called.*/public static func never() -&gt; Observable&lt;E&gt; just 是只包含一个元素的序列，它会先发送 .Next(value) ，然后发送 .CompletedObservable+Creation.swift123456/**Returns an observable sequence that contains a single element.*/public static func just(_ element: E) -&gt; Observable&lt;E&gt; &#123;return Just(element: element)&#125; sequenceOf 可以把一系列元素转换成订阅源1let sequenceOfElements/* : Observable&lt;Int&gt; */ = sequenceOf(0, 1, 2, 3) asObservable方法 将遵守ObservableType协议的对象转为可观察者序列ObservableType.swift123456public protocol ObservableType : ObservableConvertibleType&#123; //Default implementation of converting `ObservableType` to `Observable`. public func asObservable() -&gt; Observable&lt;E&gt;&#125;let sequenceFromArray = [1, 2, 3, 4, 5].asObservable() failWith创建一个没有元素的序列，只会发送失败 (.Error) 事件。12345let error = NSError(domain: \"Test\", code: -1, userInfo: nil)let erroredSequence: Observable&lt;Int&gt; = failWith(error)let subscription = erroredSequence.subscribe &#123; event in print(event)&#125;--- failWith example ---Error(Error Domain=Test Code=-1 \"The operation couldn’t be completed. (Test error -1.)\") create自定义订阅源create 可以通过闭包创建序列，通过 .on(e: Event) 添加可观察者事件。1234567891011121314151617example(\"create\")&#123; let myJust = &#123; (singleElement: Int) -&gt; Observable&lt;Int&gt; in return create &#123; observer in observer.on(.Next(singleElement)) observer.on(.Completed) return NopDisposable.instance &#125; &#125; let subscription = myJust(5).subscribe &#123; event in print(event) &#125;&#125;--- create example ---Next(5)Completed deferred订阅源的懒加载deferred表示当有有新增订阅者第一次订阅了该订阅源时，订阅源才会被创建，且每个订阅者订阅的对象都是内容相同而完全独立的序列。123456789101112131415example(\"TestDeferred\") &#123; var value: String? = nil var subscription: Observable&lt;String?&gt; = deferred &#123; return just(value) &#125; // got value value = \"Hello!\" subscription.subscribe &#123; event in print(event) &#125;&#125;--- TestDeferred example ---Next(Optional(\"Hello!\"))Completed 几种特殊类型的订阅源Subject 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 Observable 对象，同时又可以对它的订阅者们发送事件。 PublishSubject 向所有订阅者发送事件队列当PublishSubject类型订阅源事件队列中.on()新增事件时，会触发所有订阅者，一起响应该事件。12345678910111213141516example(\"PublishSubject\") &#123; let subject = PublishSubject&lt;String&gt;() writeSequenceToConsole(\"1\", sequence: subject) subject.on(.Next(\"a\")) subject.on(.Next(\"b\")) writeSequenceToConsole(\"2\", sequence: subject) subject.on(.Next(\"c\")) subject.on(.Next(\"d\"))&#125;--- PublishSubject example ---Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: Next(d)Subscription: 2, event: Next(d) 基于PublishSubject的几种补发式订阅源以下几种类型的订阅源，相较第一种仅多了补发历史事件，姑且称为补发式订阅源。 ReplaySubject先向最新订阅者补发所有已发生的事件当ReplaySubject类型的订阅源，新增订阅者时，该类型的订阅源会把之前已发送过的所有事件队列重新补发给这个最新订阅者。这样就迫使订阅者会对从历史的事件队列逐一响应。bufferSize 是缓冲区的大小，决定了补发队列的最大值。如果 bufferSize 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。123456789101112131415161718example(\"ReplaySubject\") &#123; let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) writeSequenceToConsole(\"1\", sequence: subject) subject.on(.Next(\"a\")) subject.on(.Next(\"b\")) writeSequenceToConsole(\"2\", sequence: subject) subject.on(.Next(\"c\")) subject.on(.Next(\"d\"))&#125;--- ReplaySubject example ---Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b) // 补了一个 bSubscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: Next(d)Subscription: 2, event: Next(d) BehaviorSubject 先向最新订阅者补发最近一次历史事件BehaviorSubject类型的订阅源会向最新订阅者发送最近一次的历史事件队列，如果没有则发送一个默认值。1234567891011121314151617181920example(\"BehaviorSubject\") &#123; let subject = BehaviorSubject(value: \"z\") writeSequenceToConsole(\"1\", sequence: subject) subject.on(.Next(\"a\")) subject.on(.Next(\"b\")) writeSequenceToConsole(\"2\", sequence: subject) subject.on(.Next(\"c\")) subject.on(.Completed)&#125;--- BehaviorSubject example ---Subscription: 1, event: Next(z)Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: CompletedSubscription: 2, event: Completed VariableVariable 是基于 BehaviorSubject 的一层封装，它的优势是：不会被显式终结。即：不会收到 .Completed 和 .Error 这类的终结事件，它会主动在析构的时候发送 .Complete123456789101112131415161718example(\"Variable\")&#123; let variable = Variable(\"z\") writeSequenceToConsole(\"1\", sequence: variable) variable.value = \"a\" variable.value = \"b\" writeSequenceToConsole(\"2\", sequence: variable) variable.value = \"c\"&#125;--- Variable example ---Subscription: 1, event: Next(z)Subscription: 1, event: Next(a)Subscription: 1, event: Next(b)Subscription: 2, event: Next(b)Subscription: 1, event: Next(c)Subscription: 2, event: Next(c)Subscription: 1, event: CompletedSubscription: 2, event: Completed 支持订阅的嵌套函数map{规则} 遍历映射通过闭包中定义的规则将队列中的数据映射到新的队列中，支持订阅遍历事件。123func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; U[]//效果[ x1, x2, ... , xn].map(f) -&gt; [f(x1), f(x2), ... , f(xn)]map接受一个把 T 类型的转换成 U 类型的transform函数，最终返回的是 U 类型的集合。12345678910example(\"map\") &#123; let originalSequence = sequenceOf(1,2,3) originalSequence.map&#123; $0 * 2 &#125;.subscribe&#123; print($0) &#125;&#125;--- map example ---Next(2)Next(4)Next(6)Completed flatMap 嵌套式遍历映射嵌套式遍历描述：在遍历当前队列的过程中，每次执行闭包时都会遍历另一个嵌套队列中的所有事件。可以想象嵌套for 循环来理解。1234567891011121314151617example(\"flatMap\") &#123; let sequenceInt = sequenceOf(1, 2, 3) let sequenceString = sequenceOf(\"A\", \"B\", \"--\") sequenceInt.flatMap&#123; int in sequenceString &#125;.subscribe&#123; print($0) &#125;&#125;--- flatMap example ---Next(A)Next(B)Next(--)Next(A)Next(B)Next(--)Next(A)Next(B)Next(--)Completed scan(initial:U,combine:(U, T) -&gt; U)迭代映射scan 有点像 reduce ，把U类型集合中的所有元素，以initial为初始值，按照combine规则，逐个迭代并返回一个U类型的对象。12345678910111213141516example(\"scan\")&#123; let sequenceToSum = sequenceOf(0, 1, 2, 3, 4, 5) sequenceToSum.scan(0) &#123; acum, elem in acum + elem &#125; .subscribe &#123; print($0) &#125;&#125;--- scan example ---Next(0)Next(1)Next(3)Next(6)Next(10)Next(15)Completed Filtering 支持订阅的过滤器filter{布尔语句} 条件过滤法123456789101112example(\"filter\")&#123;let subscription = sequenceOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).filter &#123; $0 % 2 == 0 &#125;.subscribe &#123; print($0) &#125;&#125;--- filter example ---Next(0)Next(2)Next(4)Next(6)Next(8)Completed distinctUntilChanged() 去重过滤法（相邻且不重复）123456789101112example(\"distinctUntilChanged\") &#123; let subscription = sequenceOf(1, 2, 3, 1, 1, 4) .distinctUntilChanged().subscribe&#123; print($0) &#125;&#125;--- distinctUntilChanged example ---Next(1)Next(2)Next(3)Next(1)Next(4)Completed take(int) 掐尖过滤法take只获取队列中前 n 个事件，在满足数量之后会自动 .Completed12345678910example(\"take\") &#123;let subscription = sequenceOf(1, 2, 3, 4, 5, 6).take(3).subscribe &#123; print($0) &#125;&#125;--- take example ---Next(1)Next(2)Next(3)Completed Combining 订阅源聚合器订阅源聚合器将多个可观察者（订阅源）合并成一个可观察者（聚合订阅源），这样更便于订阅者同时监听多个订阅源。 startWith 向可观察者队列中添加排头兵（新增的可观察者）1234567let subscription = sequenceOf(4, 5, 6).startWith(3).subscribe &#123; print($0)&#125;--- startWith example ---Next(3)Next(4)Next(5)Next(6)Completed combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件便于订阅者监听聚合订阅源中每个订阅源的最后一次事件数据1234567891011121314example(\"combineLatest 1\") &#123; let intOb1 = PublishSubject&lt;String&gt;() let intOb2 = PublishSubject&lt;Int&gt;() combineLatest(intOb1, intOb2) &#123;\"\\($0) \\($1)\"&#125;.subscribe &#123; print($0) &#125; intOb1.on(.Next(\"A\")) intOb2.on(.Next(1)) intOb1.on(.Next(\"B\")) intOb2.on(.Next(2))&#125;--- combineLatest 1 example ---Next(A 1)Next(B 1)Next(B 2) zip(intOb1, intOb2) 拉链式合并仅在凑齐聚合源中所有订阅源的事件时，才会聚合一次，触发订阅者的响应。可以将多达8个订阅源1234567891011121314example(\"zip 1\") &#123; let intOb1 = PublishSubject&lt;String&gt;() let intOb2 = PublishSubject&lt;Int&gt;() zip(intOb1, intOb2) &#123; \"\\($0) \\($1)\" &#125;.subscribe &#123; print($0)&#125; intOb1.on(.Next(\"A\")) intOb2.on(.Next(1)) intOb1.on(.Next(\"B\")) intOb1.on(.Next(\"C\")) intOb2.on(.Next(2))&#125;--- zip 1 example ---Next(A 1)Next(B 2) merge() 按可观察者的新的事件次序合并队列订阅者会按次序来响应聚合订阅源的每一件事件1234567891011121314151617example(\"merge 1\") &#123; let subject1 = PublishSubject&lt;Int&gt;() let subject2 = PublishSubject&lt;Int&gt;() sequenceOf(subject1, subject2).merge().subscribeNext &#123; int in print(int)&#125; subject1.on(.Next(1)) subject1.on(.Next(2)) subject2.on(.Next(3)) subject1.on(.Next(4)) subject2.on(.Next(5))&#125;--- merge 1 example ---12345 switchLatest订阅源切换器：用于嵌套式订阅源通过切换（var3.value）嵌套的订阅源，来切换订阅者当前监听的订阅源，以响应当前订阅源中的可观察者的事件。12345678910111213141516171819202122232425262728example(\"switchLatest\") &#123; let var1 = Variable(0) let var2 = Variable(200) // var3 is like an Observable&lt;Observable&lt;Int&gt;&gt; let var3 = Variable(var1) let d = var3.switchLatest().subscribe&#123; print($0) &#125; var1.value = 1 var1.value = 2 var1.value = 3 var1.value = 4 var3.value = var2 var2.value = 201 var1.value = 5 var3.value = var1 var2.value = 202 var1.value = 6&#125;--- switchLatest example ---Next(0)Next(1)Next(2)Next(3)Next(4)Next(200)Next(201)Next(5)Next(6) 订阅器 订阅器：subscribe 用来订阅可观察者的事件队列（即订阅源），并指定响应的相关操作 Next订阅器：subscribeNext 只订阅 .Next 事件 Completed订阅器：subscribeCompleted 只订阅.Completed 完成事件 Error订阅器：subscribeError 订阅 .Error 失败事件 订阅器观察者：doOn 在订阅器执行之前，获得执行代码的机会。可对比理解：swift中的属性观察者 控制take掐尖过滤器过滤器通过指定的事件和状态语句来判断是否停止take takeUntil 得到指定事件之后触发 .Completed 事件1234567891011121314151617example(\"takeUntil\") &#123; let originalSequence = PublishSubject&lt;Int&gt;() let whenThisSendsNextWorldStops = PublishSubject&lt;Int&gt;() originalSequence.takeUntil(whenThisSendsNextWorldStops) .subscribe &#123; print($0) &#125; originalSequence.on(.Next(1)) originalSequence.on(.Next(2)) whenThisSendsNextWorldStops.on(.Next(1)) originalSequence.on(.Next(3))&#125;--- takeUntil example ---Next(1)Next(2)Completed takeWhile 判断语句takeWhile 则是可以通过状态语句判断是否继续 take 。1234567891011example(\"takeWhile\") &#123; let sequence = PublishSubject&lt;Int&gt;() sequence.takeWhile &#123; int in int &lt; 2 &#125;.subscribe &#123; print($0) &#125; sequence.on(.Next(1)) sequence.on(.Next(2)) sequence.on(.Next(3))&#125;--- takeWhile example ---Next(1)Completed","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"互动性的教学工具XCPlayground","slug":"swift/互动性的教学工具XCPlayground","date":"2017-03-01T17:27:16.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/03/02/swift/互动性的教学工具XCPlayground/","link":"","permalink":"https://huos3203.github.io/2017/03/02/swift/互动性的教学工具XCPlayground/","excerpt":"","text":"Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。 演习框架API，了解框架结构SceneKitMac.playground是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。 测试驱动开发我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。 Sources打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。 注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。 导入Frameworks如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。 手动配置cocoa touch Framework来桥接playground在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接注：.swift的文件中的方法必须是public修饰。参考文档：Playground help -&gt; Importing Custom Frameworks into a Playground 导入个人项目文件，需要借助cocoa touch Framework桥接playground 需要workspace来管理Framework项目和playground文件，典型例子：pod项目都是用workspace来管理多个项目。 把个人项目的swift文件关联到Cocoa touch Framework项目的target中： 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift 在build选项中选中Framework的scheme进行编译 ,要保证framework的target配置：build setting -&gt; build active architecture Only -&gt;debug选项设置为YES 打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致. xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项. 在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项. 导入cocopads管理的依赖库xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库解决办法：http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#123456789101112131415161718192021#在写入磁盘之前，修改一些工程的配置:post_install do |installer| installer.pods_project.targets.each do |target| if target.name != 'CocoaAsyncSocket' #playground相关配置，会导致'GCDAsyncSocket.h' file not found target.build_configurations.each do |config| config.build_settings['CONFIGURATION_BUILD_DIR'] = '$PODS_CONFIGURATION_BUILD_DIR' #Use Legacy Swift Language Version” (SWIFT_VERSION): # https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685 puts \"SWIFT_VERSIION:\" config.build_settings['SWIFT_VERSION'] = \"3.0.1\" puts config.build_settings['SWIFT_VERSION'] end else #输出操作 puts \"以下不能在playground中使用的库名：\" puts target.name end endend Playground沙盒ResourcesPlaygrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。 本地 bundle访问本地资源Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：1234567let jsonPath = NSBundle.mainBundle().bundlePath.stringByAppendingPathComponent(\"weather.json\")if letjsonData = NSData(contentsOfFile: jsonPath),json = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: nil) as? [String: AnyObject] &#123; // ...&#125; 共享 访问Documents共享目录“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。 如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件: 1234let sharedImagePath = XCPSharedDataDirectoryPath.stringByAppendingPathComponent(\"image.png\")if let image = UIImage(contentsOfFile: sharedImagePath) &#123; // ...&#125; PlaygroundSupportliveView视图代理实现在playground中实现UI显示及交互操作liveView定义：1public var liveView: XCPlaygroundLiveViewable?遵循了XCPlaygroundLiveViewable协议即可在playground中可视化显示： 在iOS 和 tvOS中UIView and UIViewController遵循该协议 在OS X中NSView and NSViewController遵循该协议 用户自定类型，须遵守XCPlaygroundLiveViewable协议总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。用法：1PlaygroundPage.current.liveView = UIView()／NSViewController() 捕获值（XCPCaptureValue在XCPlayground中过时）冒泡排序可视化预览XCPlayground Module123/// This function has been deprecated.@available(*, deprecated)public func XCPCaptureValue&lt;T&gt;(identifier: String, value: T) 简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。 使用：导入框架import XCPlayground 扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写 一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？ 通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值： 123456789import XCPlaygroundfor forecast in forecasts &#123; if let tempString = forecast[\"temp\"]?[\"english\"] as? String, temperature = tempString.toInt() &#123; XCPCaptureValue(\"Temperature\", temperature) &#125;&#125; 另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中： 异步执行（Asynchronous Execution）不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。PlaygroundSupport 模块包含一个能够延长该过程的函数：1public var needsIndefiniteExecution: Bool 开启异步：默认值为false,当使用liveView代理时，会自动设置为true。当为true时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为false时，当代码执行完直接终止。 手动终止：还可以使用PlaygroundPage.finishExecution()手动终止正在运行的Playground。 1234567891011121314import PlaygroundSupportPlaygroundPage.current.needsIndefiniteExecution = truelet url = NSURL(string: \"http://httpbin.org/image/png\")!let task = NSURLSession.sharedSession().dataTaskWithURL(url) &#123; data, _, _ in let image = UIImage(data: data) // ... //手动终止 PlaygroundPage.current.currentPage.finishExecution()&#125;task.resume() 支持Markdown格式的文档官方文档除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。 不同于Swift代码中的注释文档语法, Swift Playgrounds 使用 Markdown 来显示多格式的文档。例如：//:：可以指定单行文本说明/*: Markdown格式内容... */：可以用Markdown格式来显示丰富的文档内容 xcode切换备注以Markdown格式显示： 选择Editor → Show Rendered Markup 菜单 在 File Inspector (⌘⌥1) 选中 Render Documentation 复选框。 在xcode8中打开之前版本时，菜单上的Show Rendered Markup会显示为Upgrade playgound...升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。 12345678910111213141516171819//: This line will have **bold** and *italic* text./*:## Headers of All Sizes### Lists of Links- [NSHipster](http://nshipster.com)- [ASCIIwwdc](http://asciiwwdc.com)- [SwiftDoc](http://swiftdoc.org)### Images, Too![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)![Local Image](bomb.gif) *Images in the Resources directory can be referenced locally**/ Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"playground","slug":"swift/playground","permalink":"https://huos3203.github.io/categories/swift/playground/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"}]},{"title":"使用Cocoapods创建私有podspec","slug":"macOS/使用Cocoapods创建私有podspec","date":"2017-02-28T15:46:16.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/28/macOS/使用Cocoapods创建私有podspec/","link":"","permalink":"https://huos3203.github.io/2017/02/28/macOS/使用Cocoapods创建私有podspec/","excerpt":"","text":"创建一个版本库来托管pod索引:pod repo add命令第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：github、CODING、开源中国、Bitbucket以及CSDN等，代码托管平台。当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。第二步：pod化版本库，使其专门用户管理个人的*podspec索引文件repo add命令1234# pod repo add [Private Repo Name] [GitHub HTTPS clone URL]$ pod repo add PodRepo https://github.com/huos3203/PodRepo.git#输出：&gt; Cloning spec repo `PodRepo` from `https://github.com/huos3203/PodRepo.git`此时在本地会生成~/.cocoapods/repos/PodRepo目录，这个目录就可以用来存储你所有的开源包。每当一个或多个*.podspec文件测试无误时，就可以使用pod repo push命令向私有索引库中提交该文件。lib create命令1$ pod repo push PodRepo LogSwift.podspec #PodRepo是本地Repo名字 后面是podspec名字完成之后这个组件库就添加到私有索引库中，自动生成的pod 库标准结构： 同时push命令会将新增的索引目录推送至自己的远程仓库中，即索引托管库PodRepo.git中。 下面详述podspec文件的配置，检测，使用的过程。 使用模板命令创建Pod工程项目 lib create初始化Pod模板项目：lib create命令1pod lib create LogSwift有以下五步命令行交互：交互12345678910What is your email?&gt; What language do you want to use?? [ Swift / ObjC ]&gt;SwiftWould you like to include a demo application with your library? [ Yes / No ]&gt;YesWhich testing frameworks will you use? [ Quick / None ]&gt;QuickWould you like to do view based testing? [ Yes / No ]&gt;会自动执行pod install命令创建项目并生成依赖。 添加库文件和资源例如：把一个网络模块的共有组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/PodTestLibrary中了，然后编辑demo工程，测试组件。测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。 配置podspec文件及验证命令lib lint打tag号作为podspec版本号因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag打标签12$ git tag -m \"first release\" 0.1.0$ git push --tags #推送tag到远端仓库 编辑podspec文件podspec文件是一个Ruby格式：podspec文件1234567891011121314151617181920212223242526272829Pod::Spec.new do |s|s.name = \"PodTestLibrary\" #名称s.version = \"0.1.0\" #版本号s.summary = \"Just Testing.\" #简短介绍，下面是详细介绍s.description = &lt;&lt;-DESCTesting Private Podspec.* Markdown format.* Don't worry about the indent, we strip it!DESCs.homepage = \"https://coding.net/u/boyers/p/podTestLibrary\" #主页,这里要填写可以访问到的地址，不然验证不通过# s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\" #截图s.license = 'MIT' #开源协议s.author = &#123; \"boyers\" =&gt; \"boyers@foxmail.com\" &#125; #作者信息s.source = &#123; :git =&gt; \"https://coding.net/boyers/podTestLibrary.git\", :tag =&gt; \"0.1.0\" &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS# s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址s.platform = :ios, '7.0' #支持的平台及版本s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARCs.source_files = 'Pod/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置s.resource_bundles = &#123;'PodTestLibrary' =&gt; ['Pod/Assets/*.png']&#125; #资源文件地址s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址s.frameworks = 'UIKit' #所需的framework，多个用逗号隔开s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 验证podspec文件可用性12345$ pod lib lint输出：-&gt; PodTestLibrary (0.1.0)PodTestLibrary passed validation. 说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。 将源码托管到远程仓库通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH地址，然后cd到LogSwift目录添加到远程仓库1234$ git add .$ git commit -s -m \"Initial Commit of Library\"$ git remote add origin https://coding.net/git/LogSwift.git #添加远端仓库$ git push origin master #提交到远端仓库 手动配置Pod私库项目支持：spec create1$ pod spec create LogSwift git@coding.net:boyers/LogSwift.git 执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令pod lib lint验证一下。 :path =&gt; 在新项目配置检测podspec文件在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 指定本地依赖的两种方式:Podfile123platform :ios, '7.0'pod 'LogSwift', :path =&gt; '~/code/Cocoapods/podTest/LogSwift' # 指定路径pod 'LogSwift', :podspec =&gt; '~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec' # 指定podspec文件 指定源码的远程仓库作为依赖前提时索引文件中指定的tag版本的源码必须推送到远程仓库Podfile12platform :ios, '7.0'pod 'MusicLrc', :git =&gt; 'https://github.com/huos3203/MusicLrcTest.git' 然后执行pod install命令安装依赖，打开项目工程，可以看到库文件和资源都被加载到Pods子项目中了，不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/LogSwift中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。 万事具备，向私有索引库中提交podspec文件：repo push每当一个或多个*.podspec文件测试无误时，就可以使用pod repo push命令向私有索引库中提交该文件。lib create命令1$ pod repo push PodRepo LogSwift.podspec #PodRepo是本地Repo名字 后面是podspec名字完成之后这个组件库就添加到私有索引库中，自动生成的pod 库标准结构： 同时push命令会将新增的索引目录推送至自己的远程仓库中，即索引托管库PodRepo.git中。 trunk push 添加到Cocoapods的官方索引库注册trunk，邮箱验证在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:sudo gem install cocoapods开始注册trunk：1pod trunk register boyer@163.com 'boyers1250' --verbose-verbose参数是为了便于输出注册过程中的调试信息。执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。使用下面的命令可以向trunk服务器查询自己的注册信息：1pod trunk me 通过trunk推送podspec文件现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点： 确保你的源码已经push到Github上。 确保你所push的代码已经打上”version tag”版本号标签：只有确保了以上两点，CocoaPods才能更准确地找到你的repo。现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：1pod trunk push WZLBadge.podspec 执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。 使用远程的私有Pod库我们的这个组件库就已经制作添加完成了，现在可以pod search命令查到这个库，当使用时配置Podfile依赖文件即可。 pod search 查找库查找库12345678$ pod search PodTestLibrary-&gt; PodTestLibrary (0.1.0)Just Testing.pod 'PodTestLibrary', '~&gt; 0.1.0'- Homepage: https://coding.net/u/boyers/p/podTestLibrary- Source: https://coding.net/boyers/podTestLibrary.git- Versions: 0.1.0 [WTSpecs repo] 在Podfile文件中配置库依赖配置库依赖1pod 'PodTestLibrary', '~&gt; 0.1.0' 更新维护podspec文件配置，升级库版本subspec特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括工具类，底层Model及UIKit扩展等。 添加模块库文件和资源具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录 打tag号作为podspec版本号因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag打标签12$ git tag -m \"first release\" 0.1.0$ git push --tags #推送tag到远端仓库 更新podspec配置文件当创建了subspec，之前项目整体的依赖dependency: 源文件:source_files 头文件:public_header_files 资源文件:resource都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系，比如UIKitAddition就依赖于CommonTools。更新podspec配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Pod::Spec.new do |s|s.name = \"PodTestLibrary\"s.version = \"1.0.0\"s.summary = \"Just Testing.\"s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESCs.homepage = \"https://coding.net/u/boyers/p/podTestLibrary\"# s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"s.license = 'MIT's.author = &#123; \"boyers\" =&gt; \"boyers@foxmail.com\" &#125;s.source = &#123; :git =&gt; \"https://coding.net/boyers/podTestLibrary.git\", :tag =&gt; \"1.0.0\" &#125;# s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'s.platform = :ios, '7.0's.requires_arc = true#s.source_files = 'Pod/Classes/**/*'#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;#s.public_header_files = 'Pod/Classes/**/*.h's.subspec 'NetWorkEngine' do |networkEngine| networkEngine.source_files = 'Pod/Classes/NetworkEngine/**/*' networkEngine.public_header_files = 'Pod/Classes/NetworkEngine/**/*.h' networkEngine.dependency 'AFNetworking', '~&gt; 2.3'ends.subspec 'DataModel' do |dataModel| dataModel.source_files = 'Pod/Classes/DataModel/**/*' dataModel.public_header_files = 'Pod/Classes/DataModel/**/*.h'ends.subspec 'CommonTools' do |commonTools| commonTools.source_files = 'Pod/Classes/CommonTools/**/*' commonTools.public_header_files = 'Pod/Classes/CommonTools/**/*.h' commonTools.dependency 'OpenUDID', '~&gt; 1.0.0'ends.subspec 'UIKitAddition' do |ui| ui.source_files = 'Pod/Classes/UIKitAddition/**/*' ui.public_header_files = 'Pod/Classes/UIKitAddition/**/*.h' ui.resource = \"Pod/Assets/MLSUIKitResource.bundle\" ui.dependency 'PodTestLibrary/CommonTools'ends.frameworks = 'UIKit' #s.dependency 'AFNetworking', '~&gt; 2.3' #s.dependency 'OpenUDID', '~&gt; 1.0.0'end 编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-&gt;1.0.0。 但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"UIStackView教程了解StackView","slug":"iOS/UI/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2017/02/25/iOS/UI/UIStackView教程了解StackView/","link":"","permalink":"https://huos3203.github.io/2017/02/25/iOS/UI/UIStackView教程了解StackView/","excerpt":"","text":"原地址 UIStackView简单介绍一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏Stack View中的视图，你只需要设置该View的Hidden属性为true，剩下的工作Stack View会自己完成。。坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。对于水平的Stack View，这个属性则稍有不同：.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。对于水平的Stack View，这个属性则稍有不同：Fill:Leading:Center:Trailing: 布局方式对比 添加一个新的Stack View点击故事板画布左下角Auto Layout工具栏中的Stack按钮：另一种解散的方法是选中Stack View，然后点击Editor\\Emebed in\\stack view菜单。 解散一个废弃的Stack View首先，选定想解散的Stack View。按下Option键，点击Stack 按钮。这将弹出一个上下文菜单，然后点击Unembed：另一种解散的方法是选中Stack View，然后点击Editor\\Unemebed菜单。 使用场景描述当APP运行中增加或删除一个view时，需要重新调整邻近view的位置布局。预见困境： 在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束 使用第三方库来实现 根据任务复杂程度完全用代码实现也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。 UIStackView提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。 实现需求存在着这几方面的问题: 问题一：自适应横竖屏在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用UIStackView来帮助实现自动适应横竖屏的效果。 问题二：控件间留白不紧凑点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。 Storyboard引入界面打开Main.storyboard，找到Spot Info View Controller这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到Stack View属性的改变导致其内部视图的变化。如果想在运行App时看见这些颜色，在SpotInfoViewController的viewDidLoad()方法中将下列语句注释：swift12345// 清空标签和按钮的背景色for view in backgroundColoredViews &#123; view.backgroundColor = UIColor.clearColor()&#125; Size类便于使用storyboard在本案例中，故事板中Scene大小不是默认600x600，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。 创建水平UIStackView按钮模块 选中按钮用Command+左键同时选中Spot Info View Controller底下一排的所有按钮： Stack按钮添加一个新的Stack View点击故事板画布左下角Auto Layout工具栏中新增的Stack按钮： 这些按钮被嵌到一个新的Stack View中： 给新的Stack View添加布局约束要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。3.1 在Outline视图中选取Stack View 3.2 Shift+右键调出View树在Stack View 的任意地方按下Shift+右键或者Control+Shift+左键（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。 自动布局工具栏中的Pin按钮,添加一个约束 首先勾选Constrain to margins。然后在Stack View四周添加下列约束：swift1Top: 20, Leading: 0, Trailing: 0, Bottom: 0仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints： 按钮等间距分布添加约束后，导致第一个按钮被拉伸： 使用等宽约束的Spacer View实现解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。 Distribution属性：沿轴向水平分布distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。打开Stack View属性面板。将Distribution属性由Fill修改为Equal Spacing：编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！ Rating版块选中RATING标签，以及旁边的显示为几个星形图标的标签：然后点击Stack按钮将它们嵌到一个Stack View中：然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：swift1Top: 20, Leading: 0, Bottom: 20打开属性面板，将间距设置为8：你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：编译运行，进行测试 创建垂直的Stack ViewXcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。 WHY VISIT模块选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：点击Stack 按钮将二者嵌到一个Stack View： 添加约束默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：最后点击Add 4 Constraints按钮。显示结果如下图所示： alignment属性：轴向的垂直方向Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：将Alignment设置为Fill，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%. 如果我们只想让底下的标签将宽度扩展到100%怎么办？ 这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。 我们将用另外一个Stack View来说明这个问题。 垂直／水平Stack View嵌套使用Weather版块在Weather版块相对复杂一些，因为它多了一个Hide按钮。要隐藏Stack View中的视图，你只需要设置该View的Hidden属性为true，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。 垂直stackView注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom： 水平StackView中出现按钮拉伸标签的问题注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！ 垂直stack View1:嵌套WEATHER标签和标签选中WEATHER标签和标签：点击 Stack 按钮：点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：swift1Top: 20, Leading: 0, Trailing: 0, Bottom: 20将Stack View的Alignment设为Fill：我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。 当然，底下的标签宽度还是需要100%占满的。 我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。 垂直stack View2: 仅嵌套WEATHER标签从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：然后点击Stack 按钮：确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading： 按钮和WEATHER标签两个约束从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。 顶级 Stack View在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：然后点击 Stack 按钮：点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：编译运行：噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。 右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints： 重新调整视图位置现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。 从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端： 现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。 点击 Hide 按钮，选中它： 然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：现在 Hide 按钮将回到正确的位置： 基于配置的 Size 类最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10. 选择顶层 Stack View，点击 Spacing 前面的+按钮： 选择 Any Width &gt; Compact Height： 在新出现的 wAny hC 一栏中，将 Spacing 设为 10：编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。 动画现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。 Stack View完全支持 UIView 动画。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。 让我们来看看代码怎么实现。打开 SpotInfoViewController.Swift，找到updateWeatherInfoViews(hideWeatherInfo:animated:)方法。 将方法的最后一行：swift1weatherInfoLabel.hidden = shouldHideWeatherInfo替换为：swift12345678910if animated &#123; UIView.animateWithDuration(0.3) &#123; self.weatherInfoLabel.hidden = shouldHideWeatherInfo &#125;&#125; else &#123; weatherInfoLabel.hidden = shouldHideWeatherInfo&#125; 编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？ 除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。开始项目源码完整项目源码 总结","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"控件","slug":"iOS/控件","permalink":"https://huos3203.github.io/categories/iOS/控件/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"}]},{"title":"更改设备屏幕上显示的应用程序图标下方的名称","slug":"iOS/UI/更改设备屏幕上显示的应用程序图标下方的名称","date":"2017-02-24T14:23:59.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2017/02/24/iOS/UI/更改设备屏幕上显示的应用程序图标下方的名称/","link":"","permalink":"https://huos3203.github.io/2017/02/24/iOS/UI/更改设备屏幕上显示的应用程序图标下方的名称/","excerpt":"","text":"修改APP启动图标上的名称，需配置Info.plist文件，增加CFBundleDisplayName属性键值对。进入到如下界面： 在Info.plist文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。 agvtool自动增加版本号命令行工具版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。 注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。 注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。 设置 Current Project Version 为选定的值Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。 设置 Versioning System 为 Apple Generic默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。 注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。 设置版本和编译号agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。 版本号命令退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。 查看版本号： 1agvtool what-marketing-version 更新版本号 1agvtool new-marketing-version &lt;指定的版本号&gt; 编译号命令 将编译号设置为指定版本 1agvtool new-version -all &lt;指定的版本号&gt; 更新编译号 1agvtool next-version -all 查看当前编译号 1agvtool what-version","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"配置","slug":"iOS/配置","permalink":"https://huos3203.github.io/categories/iOS/配置/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"经历","slug":"经历","permalink":"https://huos3203.github.io/tags/经历/"},{"name":"配置","slug":"配置","permalink":"https://huos3203.github.io/tags/配置/"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/02/21/测试/高期望实现异步单元测试/","link":"","permalink":"https://huos3203.github.io/2017/02/21/测试/高期望实现异步单元测试/","excerpt":"","text":"异步单元测试在Xcode 6之前的版本里面并没有内置XCTest，只能是在主线程的RunLoop里面使用一个while循环,然后一直等待响应或者直到timeout. 在Xcode 6里，苹果以XCTestExpection类的方式向XCTest框架里添加了测试期望(test expection)。XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。 常规实现方式在主线程里，使用while循环每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出： 12345678910111213141516171819202122func testAsyncTheOldWay()&#123; let timeoutDate = Date.init(timeIntervalSinceNow: 5.0) var responseHasArrived = false Alamofire.request(\"https://www.baidu.com\").responseData&#123;response in print(\"获取到的数据长度：\\(String(data: response.data!, encoding:String.Encoding.utf8)!)\") responseHasArrived = true XCTAssert((response.data?.count)! &gt; 0) &#125; while (responseHasArrived == false &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; 0)) &#123; CFRunLoopRunInMode(CFRunLoopMode.defaultMode, 0.01, false) &#125; if (responseHasArrived == false) &#123; XCTFail(\"Test timed out\") &#125;&#125; XCTest相关API在Xcode 6里，苹果以XCTestExpection类的方式向XCTest框架里添加了测试期望(test expection)。 XCTestExpection:高期望(High Expectations)的实现和使用设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。 expectation(description:):为XCTest测试单元设置期望为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻fulfill实现该期望对象12//expectation(description: String) -&gt; XCTestExpectationlet expection = expectation(description: \"失败时显示原因\") fulfill():调用它表示测试达到期望值一般在单元测试通过时调用，告知测试已达期望，这一方法替代了responseHasArrived作为Flag的方式12//- (void)fulfill;expection.fulfill() waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行1234// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)waitForExpectations(timeout: 5) &#123; error in print(\"错误信息:\\(error?.localizedDescription)\")&#125;如果完成处理的代码在指定时限里执行并调用了fulfill()方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行 expectation(forNotification:object:handler:):通知期望该方法监听一个通知,如果在规定时间内正确收到通知则测试通过12345678910111213141516//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation//设置一个测试通知期望expectation(forNotification: \"BLDownloadImageNotification\", object: nil) &#123;(notification) -&gt; Bool in let userInfo = notification.userInfo as! [String:String] let name = userInfo[\"name\"] print(\"name:\\(name)\") return true&#125;来定义一个通知并发送通知，来测试：let notif = Notification.Name(rawValue: \"BLDownloadImageNotification\")NotificationCenter.default.post(name: notif, object: self, userInfo: [\"name\":\"iTBoyer\",\"sex\":\"man\"])//设置延迟多少秒后，如果没有满足测试条件就报错waitForExpectations(timeout: 3, handler: nil) 使用expectation(description:)实现帮助理解 expectation(forNotification:object:handler:) 方法和 expectation(description:) 的区别1234567891011121314151617func testAsynForNotificationWithExpectation() &#123; let expectation = self.expectation(description: \"BLDownloadImageNotification\") let notif = NSNotification.Name(rawValue: \"BLDownloadImageNotification\") let sub = NotificationCenter.default.addObserver(forName: notif, object: nil, queue: nil) &#123; (notification) -&gt; Void in expectation.fulfill() &#125; //发送一个通知 NotificationCenter.default.post(name: notif, object: nil) //waitForExpectations waitForExpectations(timeout: 1, handler: nil) //移除通知 NotificationCenter.default.removeObserver(sub)&#125; expectation(for:evaluatedWith:handler:):谓词计算测试法利用谓词计算，判断button的backgroundImageForState方法，是否正确的获得了backgroundImage，如果20秒内正确获得则通过测试，否则失败1234567891011121314151617//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectationfunc testThatBackgroundImageChanges()&#123; let viewController = OnclickLikeViewController() //viewController.loadView() //不执行viewDidload方法 let _ = viewController.view let button = viewController.button let img = button.backgroundImage(for: .normal) XCTAssertNil(img,\"此时img不为nil,中止执行\") //当img不是nil时，执行断言 let predicate = NSPredicate.init &#123; (anyobject, bindings) -&gt; Bool in // let button = anyobject as! UIButton return button.backgroundImage(for: UIControlState()) != nil &#125; expectation(for: predicate, evaluatedWith: button, handler: nil) waitForExpectations(timeout: 20, handler: nil)&#125; 使用expectation(description:)实现帮助理解 expectation(for:evaluatedWith:handler:) 方法和 expectation(description:) 的区别1234567891011121314151617181920212223func testThatBackgroundImageChanges()&#123; //设置期望 let expectation = self.expectation(description: \"backgroundImageForState\") let viewController = OnclickLikeViewController() //viewController.loadView() //不执行viewDidload方法 let _ = viewController.view let button = viewController.button let img = button.backgroundImage(for: .normal) XCTAssertNil(img,\"此时img不为nil,中止执行\") //当img不是nil时，执行断言 let predicate = NSPredicate.init &#123; (anyobject, bindings) -&gt; Bool in // let button = anyobject as! UIButton return button.backgroundImage(for: UIControlState()) != nil //实现测试期望 expectation.fulfill() &#125; //等待期望实现 waitForExpectations(timeout: 20, handler: nil)&#125; 传递expectation在目的方法中再fulfill()实现期望例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的fulfill()方法，实现单元测试的期望1234567891011121314151617181920212223242526272829*/func testAsynForNotificationWithExpectation2() &#123; let expectation = self.expectation(description: \"BLDownloadImageNotification\") let notif = Notification.Name(rawValue: \"BLDownloadImageNotification\") NotificationCenter.default.addObserver(self, selector: #selector(AsyncTheOldWayTest.downLoadImage(_:)), name: notif, object: nil) //将期望封装在字典中传递 let userInf = [\"name\":\"iTBoyer\",\"sex\":\"man\",\"expectation\":expectation] NotificationCenter.default.post(name: notif, object: self, userInfo: userInf) //等待期望实现 waitForExpectations(timeout: 1, handler: nil) NotificationCenter.default.removeObserver(self) &#125; // func downLoadImage(_ notification:Notification) &#123; // let userInfo = notification.userInfo as! [String:AnyObject] let name = userInfo[\"name\"] let sex = userInfo[\"sex\"] print(\"name:\\(name), sex = \\(sex)\") let expectation = userInfo[\"expectation\"] as! XCTestExpectation expectation.fulfill() &#125;&#125;","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"测试","slug":"xcode/测试","permalink":"https://huos3203.github.io/categories/xcode/测试/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"},{"name":"单元测试","slug":"单元测试","permalink":"https://huos3203.github.io/tags/单元测试/"}]},{"title":"UI自动测试学习","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/02/21/测试/UI自动测试学习/","link":"","permalink":"https://huos3203.github.io/2017/02/21/测试/UI自动测试学习/","excerpt":"","text":"UI Testing 和 AccessibilityUI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。 Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。 UI Testing APIXCUIApplication()获取APP实例XCUIApplication()继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法launch():启动程序terminate():终止程序 获取XCUIElementQuery对象的四种方式第一种简写形式：buttons-&gt;XCUIElementQuery12let buttons:XCUIElementQuery = XCUIApplication().buttonslet textFields:XCUIElementQuery = XCUIApplication().textFields 三种通过XCUIElementType的枚举值通过XCUIElementType的枚举值来获取XCUIElementQuery对象，其中第二种是简写方式。XCUIElementType枚举声明如下：123456789101112@available(iOS 9.0, *)public enum XCUIElementType : UInt &#123; ...... case button case radioButton case textField case comboBox case menuButton case toolbarButton ......&#125; 第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery取某种类型的元素以及它的子类集合，能获取到系统级控件如UIButton，和用户自定义的UI控件12let buttons:XCUIElementQuery = XCUIApplication().descendantsMatchingType(.Button)let textFields:XCUIElementQuery = XCUIApplication().descendantsMatchingType(.textField) 第三种仅获取当前层级子元素：childrenMatchingType取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如UIButton，不获取用户自定义的UI控件12let buttons:XCUIElementQuery = XCUIApplication().childrenMatchingType(.Button)let textFields:XCUIElementQuery = XCUIApplication().childrenMatchingType(.textField) 第四种所有包含的元素：containingType12let buttons:XCUIElementQuery = XCUIApplication().containingType(.Button)let textFields:XCUIElementQuery = XCUIApplication().containingType(.textField) XCUIElement表示系统的各种UI控件XCUIElementUI控件在测试框架中的代理，继承NSObject，实现XCUIElementAttributes协议, XCUIElementTypeQueryProvider协议，可以表示系统的各种UI控件。 XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性 XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合 访问UI控件 exist:判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试. element()／下标方法：XCUIElementQuery实例的方法获取UI控件，不能直接通过XCUIElement 来访问 app 中的元素，只能通过 Accessibility 中的像是 identifier 或者 frame 这样的属性来获取 UI 的信息。12let userNameTextField:XCUIElement = app.textFields.element(boundBy: 0)let userNameTextField:XCUIElement = app.textFields[\"username\"] 对于 XCUIElementQuery，Query的执行是有延迟的，它和最后我们得到的 XCUIElement 并不是一一对应的。和 NSURL 与请求到的内容的关系类似，随着时间的变化，同一个 URL 有可能请求到不同的内容。在拿到Query实例后，只有在通过下标或访问方法访问时，才会真正寻找对应的 UI 控件。这就是说，随着我们的 UI 的变化，同样的 query 也可能获取到不用的UI控件。为了获取UI元素准确：我们可以通过在 Interface Builder 或者代码中，对UI控件的 identifier属性进行设置，这样就可以使用下标的方式进行访问了。 设置UI控件触发事件和属性值使用typeText(text:String),tap(),doubleTap()等方法。以获取userNameTextField控件为例：123let userNameTextField:XCUIElement = app.textFields.element(boundBy: 0)userNameTextField.tap()userNameTextField.typeText(\"文本内容\") XCUIElementAttributes协议UI元素中包含的各个属性，identifier，frame,title,label等… 使用: 可使用这些属性来获取UI元素对象。title获取123let username = \"hsg\"userNameTextField.typeText(username)app.textFields[username].tap() identifier获取123let identifier = \"hsg\"userNameTextField.typeText(username)app.textFields[username].tap()","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"测试","slug":"xcode/测试","permalink":"https://huos3203.github.io/categories/xcode/测试/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"},{"name":"单元测试","slug":"单元测试","permalink":"https://huos3203.github.io/tags/单元测试/"}]},{"title":"自定义展示型控制器","slug":"iOS/自定义展示型控制器","date":"2017-02-17T12:26:11.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/17/iOS/自定义展示型控制器/","link":"","permalink":"https://huos3203.github.io/2017/02/17/iOS/自定义展示型控制器/","excerpt":"","text":"loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-huos3203-PresentationsDemo-2cce4c908\", \"huos3203\", \"PresentationsDemo\", \"2cce4c908\", false); 触发转场的方式官方支持的自定义转场 在 UINavigationController 中 push 和 pop; 在 UITabBarController 中切换 Tab; Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于modalPresentationStyle属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式;UICollectionViewController 的布局转场：仅限于 UICollectionViewController 与 UINavigationController 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。相关触发转场的动作UINavigationControllerUINavigationController 中所有修改其viewControllers栈中 VC 的方法都可以自定义转场动画：swift12345678//我们使用的最广泛的 push 和 pop 方法func pushViewController(_ viewController: UIViewController, animated animated: Bool)func popViewControllerAnimated(_ animated: Bool) -&gt; UIViewController?//不怎么常用的 pop 方法func popToRootViewControllerAnimated(_ animated: Bool) -&gt; [UIViewController]?func popToRootViewControllerAnimated(_ animated: Bool) -&gt; [UIViewController]?//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。func setViewControllers(_ viewControllers: [UIViewController], animated animated: Bool) UITabBarControllerswift12345//注意传递的参数必须是其下的子 VCunowned(unsafe) var selectedViewController: UIViewController?var selectedIndex: Int//和上面类似的整体更新func setViewControllers(_ viewControllers: [UIViewController]?, animated animated: Bool) Modal 转场：swift1234// Presentation 转场func presentViewController(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: (() -&gt; Void)?)// Dismissal 转场func dismissViewControllerAnimated(_ flag: Bool, completion completion: (() -&gt; Void)?) Segue在 storyboard 里设置 segue有两种方式：Button to VC，这种在点击 Button 的时候触发转场；VC to VC，这种需要在代码中调用performSegueWithIdentifier:sender:。prepareForSegue:sender:方法是在转场发生前修改转场参数的最后机会。这点对于 Modal 转场比较重要，因为在 storyboard里 Modal 转场的 Segue 类型不支持选择 Custom 模式，使用 segue 方式触发时必须在prepareForSegue:sender:里修改模式。 iOS 8 的变化iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：swift12func showViewController(_ vc: UIViewController, sender sender: AnyObject?)func showDetailViewController(_ vc: UIViewController, sender sender: AnyObject?)这两个方法咋看上去是给 UISplitViewController 用的，在 storyboard 里 segue 的候选模式里，直接给出了Show(e.g. Push)和Show Detail(e.g. Replace)这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。这两个方法在 UISplitViewController 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：| |ViewController|NavigationController|TabBarController||:——-|:——-|:——–|:——–||showViewController:sender: |Presentation| Push | Presentation(by self) ||showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|UINavigationController 重写了showViewController:sender:而执行 push 操作，上面的by self意思是用容器 VC 本身而非其下子 VC 去执行 presentation。这两个方法的行为可以通过重写来改变。当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：||VC in NavigationController|VC in TabBarController||:——-|:——-|:——–||showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) ||showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) | 转场五大工具iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画： 转场代理(Transition Delegate)：有如下三种容器转场代理，对应上面三种类型的转场：123&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。这里除了是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。 动画控制器(Animation Controller)：最重要的部分，负责添加视图以及执行动画；遵守协议；由我们实现。 交互控制器(Interaction Controller)：通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守协议；系统已经打包好现成的类供我们使用。 转场环境(Transition Context):提供转场中需要的数据；遵守协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。 转场协调器(Transition Coordinator)：可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。 总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。 特殊的 Modal 转场容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与 containerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。 iOS 8引入的UIPresentationControllerUIPresentationController类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 presentation 转场结束后打印视图控制器的结构，会发现 presentedVC 是由一个UIPresentationController对象来显示的，查看视图结构也能看到 presentedView 是 UIView 私有子类的UITtansitionView的子视图，这就是前面 containerView 的真面目.当UIViewController的modalPresentationStyle属性为.Custom时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供UIPresentationController的子类对 Modal 转场进行进一步的定制。实际上该类也可以在.FullScreen模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在.Custom模式下使用该类。UIPresentationController类赋予 Modal 转场以下特性： 定制 presentedView 的外观，尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画； 可以选择是否移除 presentingView 可以在不需要动画控制器的情况下单独工作 iOS 8 中的自适应适应性布局UIPresentationController类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的animateTransition:的关系：swift1234func presentationTransitionWillBegin()func presentationTransitionDidEnd(_ completed: Bool)func dismissalTransitionWillBegin()func dismissalTransitionDidEnd(_ completed: Bool) 除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：swift1234567//指定初始化方法。init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController)var presentingViewController: UIViewController &#123; get &#125;var presentedViewController: UIViewController &#123; get &#125;var containerView: UIView? &#123; get &#125;//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。func presentedView() -&gt; UIView? 没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，UIPresentationController类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过viewForKey:方便获取转场的视图，而该方法在 Modal 转场中获取的是presentedView()返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。 定制presentedView外观：重载size方法和frameOfPresentedViewInContainerView属性重载存储属性：get方法返回登场页面的位置和大小1234567891011121314151617override var frameOfPresentedViewInContainerView: CGRect&#123; var presentViewFrame = CGRect.zero let containerBounds = containerView?.bounds //登场控制器内容页面的大小 presentViewFrame.size = size(forChildContentContainer: presentedViewController, withParentContainerSize: (containerBounds?.size)!) presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width return presentViewFrame&#125;//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款override func size(forChildContentContainer container: UIContentContainer, withParentContainerSize parentSize: CGSize) -&gt; CGSize &#123; return CGSize.init(width:CGFloat(floorf(Float(parentSize.width/3.0))), height: parentSize.height)&#125; 过渡动画，转场协调器(Transition Coordinator)参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的transitionCoordinator()方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。 转场开始 在containerView中插入过渡视图chromeView 为转场中chromeView过渡视图添加转场动画 presentedViewController.transitionCoordinator转场协调器，添加转场的登场和退场动画presentationTransitionWillBegin123456789101112131415161718192021override func presentationTransitionWillBegin() &#123; chromeView.frame = (self.containerView?.bounds)! chromeView.alpha = 0.0 //在`containerView`中插入视图`chromeView` containerView?.insertSubview(chromeView, at:0) //coordinator转场协调器负责转场动画的呈现和dismissal let coordinator = presentedViewController.transitionCoordinator if (coordinator != nil) &#123; //添加登场动画 coordinator!.animate(alongsideTransition: &#123; (context:UIViewControllerTransitionCoordinatorContext!) -&gt; Void in //animate the alpha to 1.0. self.chromeView.alpha = 1.0 &#125;, completion:nil) &#125; else &#123; chromeView.alpha = 1.0 &#125;&#125; 转场结束在presentedViewController.transitionCoordinator转场协调器中添加转场的退场动画dismissalTransitionWillBegin12345678910111213141516override func dismissalTransitionWillBegin()&#123; let coordinator = presentedViewController.transitionCoordinator if (coordinator != nil) &#123; //添加退场动画 coordinator!.animate(alongsideTransition: &#123; (context:UIViewControllerTransitionCoordinatorContext!) -&gt; Void in self.chromeView.alpha = 0.0 &#125;, completion:nil) &#125; else &#123; chromeView.alpha = 0.0 &#125;&#125; 适配屏幕旋转在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观12345override func containerViewWillLayoutSubviews()&#123; chromeView.frame = (containerView?.bounds)! presentedView?.frame = frameOfPresentedViewInContainerView&#125; Modal的两种PresentationStyle 设置整个转场动画是否将覆盖全屏幕 .OverFullScreen: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡 .FullScreen : 全覆盖全屏 即：占据全屏来显示登场视图12345678910//设置整个转场动画是否将覆盖全屏幕override var shouldPresentInFullscreen: Bool&#123; return true&#125;override var adaptivePresentationStyle: UIModalPresentationStyle&#123; return UIModalPresentationStyle.fullScreen&#125; 交互式转场实现交互化在非交互转场的基础上将之交互化需要两个条件：由转场代理提供交互控制器，这是一个遵守协议的对象，不过系统已经打包好了现成的类UIPercentDrivenInteractiveTransition供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。 使用一个变量来标记交互状态配合转场交互如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。在两个容器控制器NavigationController和TabBarController转场为例： 在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳； 在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。 转场动画控制器：向转场中添加视图，执行转场动画转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。UIViewControllerAnimatedTransitioning代理协议方法，提供了转场所需要的重要数据： containerView()：运行转场动画的容器视图 转场视图控制器 方法一：viewController(forKey:)：UITransitionContextViewControllerKey枚举值：from，to 方法二：viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0):iOS 8新增 API 用于方便获取参与转场的视图.两个键值：UITransitionContextFromViewKey,UITransitionContextToViewKey. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class ExampleAnimatedTransitioning: NSObject,UIViewControllerAnimatedTransitioning&#123; //used to determine if the presentation animation is presenting (as opposed to dismissing). var isPresentation : Bool = false //returns the duration in seconds of the transition animation. func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; //返回动画时间 return 0.5 &#125; //get the respective views of these view controllers. //Next we get the container view and if the presentation animation is presenting, we add the to view to the container view. func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; //get the from and to view controllers from the UIViewControllerContextTransitioning object. let fromVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from) let toVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) //determine the start and end positions of the view. let fromView = fromVC?.view let toView = toVC?.view let containerView = transitionContext.containerView if isPresentation &#123; containerView.addSubview(toView!) &#125; //decide on which view controller to animate based on whether the transition is a presentation or dismissal let animatingVC = isPresentation ? toVC : fromVC let animatingView = animatingVC?.view let finalFrameForVC = transitionContext.finalFrame(for: animatingVC!) var initialFrameForVC = finalFrameForVC //This will animate the view from right to left during a presentation and vice versa during dismissal. initialFrameForVC.origin.x += initialFrameForVC.size.width let initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC let finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC animatingView?.frame = initialFrame //根据协议中的方法获取动画的时间。 let duration = transitionDuration(using: transitionContext) UIView.animate(withDuration: duration, delay:0, usingSpringWithDamping:300.0, initialSpringVelocity:5.0, options:UIViewAnimationOptions.allowUserInteraction, animations:&#123; //we move the view to the final position. animatingView?.frame = finalFrame &#125;, completion:&#123; (value: Bool) in if !self.isPresentation &#123; //If the transition is a dismissal, we remove the view. fromView?.removeFromSuperview() &#125; //we complete the transition by calling transitionContext.completeTransition() transitionContext.completeTransition(true) &#125;) &#125; // UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in // let isCancelled = transitionContext.transitionWasCancelled() // transitionContext.completeTransition(!isCancelled) // &#125;) //如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。 func animationEnded(_ transitionCompleted: Bool) &#123; // &#125;&#125; 转场代理协议(Transition Delegate)自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。 实现转场代理协议方法，整合动画控制器和自定义展示控制器 返回管理用户信息视图控制器如何展示的控制器。前面实现的ExamplePresentationViewController类可同时处理 presentation转场 和 dismissal 转场。 动画控制器为 presentation 和 dismissal 转场分别提供了动画控制器。 UIPresentationController只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。 12345678910111213141516171819202122232425262728293031323334class ExampleTransitioningDelegate: NSObject,UIViewControllerTransitioningDelegate&#123; //returns a presentation controller that manages the presentation of a view controller. func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController? &#123; //presentation动画控制器 let presentationController = ExamplePresentationViewController(presentedViewController:presented, presenting:presenting) return presentationController &#125; //为presentation转场提供登场转场动画控制器 func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; //登场转场动画控制器 let animator = ExampleAnimatedTransitioning() animator.isPresentation = true return animator &#125; //为dismissal 转场提供退场转场动画控制器 func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; //退场转场动画控制器 let animator = ExampleAnimatedTransitioning() animator.isPresentation = false return animator &#125;&#125; 使用自定义的转场的代理自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。UIViewControllerTransitioningDelegate转场代理： 强引用代理变量:强引用的变量来维护该代理 Modal转场代理的特性：由presentedVC自身来遵循转场代理presentedVC.modalPresentationStyle，和前两个容器控制器转场代理不同。 两种支持自定义转场模式：.Custom或.FullScreen,默认值为.FullScreenfromVC.class123456789//强引用的变量来维护该代理let exampleTransitionDelegate = ExampleTransitioningDelegate()//create an instance of ExampleViewController which will provide the content to display.let presentedVC = ExampleViewController()presentedVC.modalPresentationStyle = .custompresentedVC.transitioningDelegate = exampleTransitionDelegate//present this view controller.present(toVC, animated: true, completion: nil) 两种常规的转场方式UIView方式:transitionFromView不需要获取 containerView 以及手动添加 toView 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。1234UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ inlet isCancelled = transitionContext.transitionWasCancelled()transitionContext.completeTransition(!isCancelled)&#125;) UIViewController方式：在子 VC 间转换的方法该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行animations闭包里的动画。1transitionFromViewController:toViewController:duration:options:animations:completion:该方法仅限于在自定义容器控制器里使用，如果直接使用 UINavigationController 和 UITabBarController 调用该方法执行子VC间转换会抛出异常。 不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。 原文","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"转场","slug":"iOS/转场","permalink":"https://huos3203.github.io/categories/iOS/转场/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://huos3203.github.io/tags/动画/"},{"name":"转场","slug":"转场","permalink":"https://huos3203.github.io/tags/转场/"}]},{"title":"整理iOS中几种常用的展示型视图控制器","slug":"iOS/iOS中几种常用的展示控制器使用","date":"2017-02-16T17:53:18.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/17/iOS/iOS中几种常用的展示控制器使用/","link":"","permalink":"https://huos3203.github.io/2017/02/17/iOS/iOS中几种常用的展示控制器使用/","excerpt":"","text":"开始项目完整项目 UIAlertController在iOS8中，提供UIAlertController控制器代替UIAlertView和UIActionSheet两个控件。给用户展示提示信息的新的一种方式。 优势 能够自适应的（在iPad上，an action sheet style alert will present itself in a popover）， 显示方式：可以轻松切换Action sheets和alert view两种显示样式alert view被以modal态显示presenting视图控制器上，Action sheets被固定在以屏幕底部。 按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。 子控件支持：Alert view支持按钮和输入框两种，Action sheets仅支持按钮一种控件。 不同于以往的两类UIAlertController继承自UIViewController。这意味着可以使用视图控制器提供展示信息的功能。 创建使用UIAlertController用title，message参数来实例化alertController实例，然后在实例中添加两个闭包的按钮showAlertWasTapped12345678910111213141516@IBAction func showAlertWasTapped(sender: UIButton) &#123; let alertController = UIAlertController(title: \"Appcoda\", message: \"Message in alert dialog\", preferredStyle: UIAlertControllerStyle.Alert) let deleteAction = UIAlertAction(title: \"Delete\", style: UIAlertActionStyle.Destructive, handler: &#123;(alert :UIAlertAction!) in println(\"Delete button tapped\") &#125;) alertController.addAction(deleteAction) let okAction = UIAlertAction(title: \"OK\", style: UIAlertActionStyle.Default, handler: &#123;(alert :UIAlertAction!) in println(\"OK button tapped\") &#125;) alertController.addAction(okAction) presentViewController(alertController, animated: true, completion: nil)&#125;运行效果： UIAlertControllerStyle枚举：Alert切换ActionSheet在UIAlertController之前，切换alert和action sheet需要重写大量的代码，但现在只需要改变一个枚举值UIAlertControllerStyle.Alert为UIAlertControllerStyle.ActionSheet.UIAlertControllerStyle.ActionSheet1let alertController = UIAlertController(title: \"Appcoda\", message: \"Message in alert dialog\", preferredStyle: UIAlertControllerStyle.ActionSheet)在iPhone上，屏幕底部显示一个action sheet。问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。 popoverPresentationController锚点：sourceView/sourceRectpopover controller在alertController视图内展示，需要一个popover箭头指向alertController视图的某一位置。通过设置sourceView来确定popover箭头位置，这个popover以及popover箭头指向的矩形区域都在这个sourceView上。在调用presentViewController()之前添加代码：12alertController.popoverPresentationController?.sourceView = viewalertController.popoverPresentationController?.sourceRect = sender.frame UIPopoverPresentationControllerAlert主要用于显示用户的提示信息，当展示的信息很多时，就需要借助popover presentation controller。 在compact和regular两种屏幕中显示模态视图在storyboard文件，设置视图的storyboard ID:PopoverViewController，设置模态视图展示样式，展示在compact-width和regular-width的两种设备屏幕上。实现如下：actionWasTapped123456789@IBAction func actionWasTapped(sender: UIBarButtonItem) &#123; let storyboard : UIStoryboard = UIStoryboard(name: \"Main\", bundle: nil) let vc = storyboard.instantiateViewControllerWithIdentifier(\"PopoverViewController\") as! UIViewController vc.modalPresentationStyle = UIModalPresentationStyle.Popover let popover: UIPopoverPresentationController = vc.popoverPresentationController! popover.barButtonItem = sender //`popover箭头`锚的位置 presentViewController(vc, animated: true, completion:nil)&#125; 设置锚点四种方式 barButtonItem先获取该视图控制器的popoverPresentationController控制器，通过popover控制器的barButtonItem属性来设置锚点控件。当弹出时popover箭头就指向这个barButtonItem控件。 通过指定sourceView和sourceRect两个属性，就像前面例子中一样来指定锚点位置。 通过其他属性来实现，例如：permittedArrowDirections，也能够指定锚点。 如果在在展示过程中，无法确定箭头的方向时，就是用默认值：UIPopoverArrowDirection.Any.在iPad显示： 在iPhone上以模态显示： 在iPhone设备上dissmiss模态视图要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循UIPopoverPresentationController协议，实现两个代理方法 实现UIPopoverPresentationController协议 PopoverViewController类定义修改如下:1class PopoverViewController: UIViewController, UIPopoverPresentationControllerDelegate &#123; 在actionWasTapped()函数中调用presentViewController()之前添加：1popover.delegate = self 方法一：返回自适应设备的视图展示样式当APP在compact-width设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。这里OS系统被告知在compact-width设备上，使用全屏的样式展示视图。adaptivePresentationStyleForPresentationController()1234func adaptivePresentationStyleForPresentationController(controller: UIPresentationController) -&gt; UIModalPresentationStyle &#123; return UIModalPresentationStyle.FullScreen&#125; 方法二：返回自定义的视图控制器当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的Popover presentation展示方式，但是我们指定在compact-width设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。presentationController(_:viewControllerForAdaptivePresentationStyle)1234567func presentationController(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle) -&gt; UIViewController? &#123; let navigationController = UINavigationController(rootViewController: controller.presentedViewController) let btnDone = UIBarButtonItem(title: \"Done\", style: .Done, target: self, action: \"dismiss\") navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone return navigationController&#125; Done按钮的dismiss事件在导航控制器中国封装这个视图，在导航条上添加一个Done按钮，点击Donedismiss这个视图dismiss1234func dismiss() &#123; self.dismissViewControllerAnimated(true, completion: nil)&#125; 在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。如果想让iPhone像iPad一样显示一个Popover，只adaptivePresentationStyleForPresentationController返回：1return UIModalPresentationStyle.None","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"转场","slug":"iOS/转场","permalink":"https://huos3203.github.io/categories/iOS/转场/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://huos3203.github.io/tags/动画/"},{"name":"转场","slug":"转场","permalink":"https://huos3203.github.io/tags/转场/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"2017/02/16/macOS/JavaScript自动化组件OC桥接/","link":"","permalink":"https://huos3203.github.io/2017/02/16/macOS/JavaScript自动化组件OC桥接/","excerpt":"","text":"文档JavaScript自动化有一个内置的Objective-C Bridge，使您能够访问文件系统，创建Cocoa应用程序。Objective-C Bridge的主要接入点是全局属性objc和$。 FrameworksFoundation framework中的语法默认支持JavaScript自动化。也可以通过使用ObjC.import()方法导入其他Frameworks 和 libraries。例如，使用Cocoa框架中的NSBeep()函数，需要导入Cocoa框架12ObjC.import('Cocoa')$.NSBeep()除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过头文件的名称来暴漏出来（不带.h）例如：arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：1ObjC.import('/Library/Frameworks/Awesome.framework') 数据类型原始的JavaScript数据类型映射到C数据类型。例如，一个JavaScript字符串映射为char *，而JavaScript整数映射到int。使用objc API返回一个char *时，会得到一个JS 字符串 原始的JavaScript数据类型将被自动转换为ObjC对象类型，并能作为一个预期的对象类型的参数传递给ObjC方法。例如，一个JS字符串将被转换为一个NSString对象如果是什么方法签名说应该是输入。 注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。 实例化的类和调用方法所有类都定义为$对象的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。如果ObjC方法不带参数，然后调用JavaScript属性名访问属性值。这个例子中实例化一个空的字符串。1str = $.NSMutableString.alloc.init如果ObjC方法不带参数，根据JSExport规范来命名，通过JavaScript的方法调用（function-typed property）；对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);这个例子说明JavaScript字符串转为NSString然后写入到一个文件12str = $.NSString.alloc.initWithUTF8String('foo')str.writeToFileAtomically('/tmp/foo', true) 如果你调用一个方法，如-intValue，返回C数据类型而不是一个对象，然后你会回到原始的JavaScript数据类型。此示例返回原始的JavaScript的整数，99。1$.NSNumber.numberWithInt(99).intValue 访问 ObjC PropertiesObjC属性也可以通过JavaScript属性来访问，很像调用无参数方法。当一个桥接对象属性的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的getter或setter选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为方法选择器来调用。使用自定义getter名定义一个属性，你可以使用属性名 或 getter名，并得到相同的结果。12task = $.NSTask.alloc.inittask.running == task.isRunning另外，不同的参数方法，桥接对象属性映射到ObjC属性也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：launchPath。12task.launchPath = '/bin/sleep'task.setLaunchPath('/bin/sleep')","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"JS","slug":"macOS/JS","permalink":"https://huos3203.github.io/categories/macOS/JS/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"搭建","slug":"搭建","permalink":"https://huos3203.github.io/tags/搭建/"},{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"},{"name":"混编","slug":"混编","permalink":"https://huos3203.github.io/tags/混编/"}]},{"title":"macOS支持JavaScript自动化组件基础","slug":"macOS/macOS支持JavaScript自动化组件基础","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"2017/02/16/macOS/macOS支持JavaScript自动化组件基础/","link":"","permalink":"https://huos3203.github.io/2017/02/16/macOS/macOS支持JavaScript自动化组件基础/","excerpt":"","text":"苹果 OS X Yosemite系统把 JavaScript作为AppleScript的另一选择。Automation 是 OS X 10.10版本中的新特性，苹果在官网发布JavaScript for Automation Release Notes有篇文章介绍了用JavaScript写自动化Automation脚本。JavaScript凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。再加上JavaScript先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入OS X平台代替私有的AppleScript，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。资源JavaScript OS X App ExamplesJavaScript for Automation Cookbook OSA框架:Open Scripting ArchitectureOSA组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：Script Editor编辑器，全系统的Script菜单，Run JavaScript Automator命令的操作，applets小程序，命令行osascript工具，NSUserScriptTask API中，还可以运用在其他的OSA组件中例如：AppleScript。这也就包括了Mail规则、Folder操作、Address Book插件、日历闹钟和消息触发器。 脚本字典脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在Script Editor脚本字典浏览器已经更新到显示术语AppleScript，JavaScript和Objective-C（Scripting Bridge framework）格式。 打开脚本字典启动Script Editor (/Applications/Utilities/) –&gt;File &gt; Open Dictionary or Window &gt; Library。 object specifier在JavaScript自动化主机环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的JavaScript属性时，会返回一个新的object specifier，也就是这个对象的specifier 属性。 object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。 访问APP六种方式:By name1Application('Mail') By bundle ID1Application('com.apple.mail') By path1Application('/Applications/Mail.app') By process ID1Application(763) On a remote machine1Application('eppc://127.0.0.1/Mail') currentApplication1Application.currentApplication() 语法示例Access properties1Mail.name Access elements1Mail.outgoingMessages[0] Call commands1Mail.open(...) Create new objects1Mail.OutgoingMessage(...) 属性的get/set方法点运算符访问脚本对象，是JavaScript语法特性之一。如上所述，返回的对象是一个object specifier是一个对象的引用，而不是属性实际值。当访问属性时，会作为一个get函数，返回实际值：1subject = Mail.inbox.messages[0].subject()当赋值属性时，会作为一个set函数，把参数赋值该属性：1Mail.outgoingMessages[0].subject = 'Hello world'获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）1subjects = Mail.inbox.messages.subject() 元素数组通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问索引12window = Mail.windows.at(0)window = Mail.windows[0]name12window = Mail.windows.byName('New Message')window = Mail.windows['New Message']ID1window = Mail.windows.byId(412) Note: 使用ID来访问不是方括号[]而是(). 调用命令命令被称为函数。 直接参数的函数，该参数作为命令的第一个参数传递。 如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。 如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。 如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。 直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。无参数命令1message.open() 无参数名的命令1Mail.open(message) 带参数名的命令1234response = message.reply(&#123;replayAll: true,openingWindow: false&#125;) Command with direct parameter and named parameters123Safari.doJavaScript('alert(\"Hello world\")', &#123;in: Safari.windows[0].tabs[0]&#125;) Creating Objects通过调用类构造函数初始化属性和数据来创建新对象。在创建对象时,需要执行的其中步骤： make()方法：调用对象上的make()方法来实例化对象。 push()方法：调用对象数组上的push方法来实例化对象。在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。 Create a new object.1message = Mail.OutgoingMessage().make() Create a new object with properties.12345message = Mail.OutgoingMessage(&#123;subject: 'Hello world',visible: true&#125;)Mail.outgoingMessages.push(message) Create a new object with data.12para = TextEdit.Paragraph(&#123;&#125;, 'Some text')TextEdit.documents[0].paragraphs.push(para) 使用对象一旦你在应用程序中创建一个新的对象（通过调用make或push），可以像任何现有的应用程序对象一样进行交互。12message = Mail.OutgoingMessage().make()message.subject = 'Hello world' Scripting Additions使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。使用这些，必须明确设置includeStandardAdditions的flag为 true。1234567app = Application.currentApplication()app.includeStandardAdditions = trueapp.say('Hello world')app.displayDialog('Please enter your email address', &#123;withTitle: 'Email',defaultAnswer: 'your_email@site.com'&#125;) Applets在Script Editor编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为Applet。程序支持以下事件处理：当Applet运行时，run处理事件被调用：1function run() &#123;...&#125; 用于拖放操作的openDocuments处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：1function openDocuments(docs) &#123;...&#125;传递的参数是一个文件路径字符串数组。更多样例 UI Automation通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器Script Editor中浏览System Events的脚本字典，特别是进程套件Processes Suite，以查看支持此类型自动化的应用程序接口元素的列表。下面的示例使用UI脚本创建Notes中的新注释。12345678Notes = Application('Notes')Notes.activate()delay(1)SystemEvents = Application('System Events')Notes = SystemEvents.processes['Notes']Notes.windows[0].splitterGroups[0].groups[1].groups[0].buttons[0].click()","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"JS","slug":"macOS/JS","permalink":"https://huos3203.github.io/categories/macOS/JS/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"混编","slug":"混编","permalink":"https://huos3203.github.io/tags/混编/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://huos3203.github.io/tags/JavaScript/"}]},{"title":"通过沙盒中JS脚本访问其他APP","slug":"macOS/通过沙盒中JS脚本访问其他APP","date":"2017-02-14T18:25:29.000Z","updated":"2018-10-15T17:22:37.000Z","comments":true,"path":"2017/02/15/macOS/通过沙盒中JS脚本访问其他APP/","link":"","permalink":"https://huos3203.github.io/2017/02/15/macOS/通过沙盒中JS脚本访问其他APP/","excerpt":"","text":"如何使用脚本字典里的命令和对象来与其他的应用进行通讯?这个教程将向您展示现在使用 AppleScript 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 AppleScript。 在自己的APP中编写编写AppleScript代码AppleScript 脚本指南与其他应用进行通讯的脚本一般来说都很短，也容易理解。AppleScript 可以被想做一种传送的机制，而不是一种处理环境。典型脚本:123456789101112131415161718192021222324252627282930on chockify(inputString) set resultString to \"\" repeat with inputStringCharacter in inputString set asciiValue to (ASCII number inputStringCharacter) if (asciiValue &gt; 96 and asciiValue &lt; 123) then set resultString to resultString &amp; (ASCII character (asciiValue - 32)) else if ((asciiValue &gt; 64 and asciiValue &lt; 91) or (asciiValue = 32)) then set resultString to resultString &amp; inputStringCharacter else if (asciiValue &gt; 47 and asciiValue &lt; 58) then set numberStrings to &#123;\"ZERO\", \"ONE\", \"TWO\", \"THREE\", \"FOR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"&#125; set itemIndex to asciiValue - 47 set numberString to item itemIndex of numberStrings set resultString to resultString &amp; numberString &amp; \" \" else if (asciiValue = 33) then set resultString to resultString &amp; \" DUH\" else if (asciiValue = 63) then set resultString to resultString &amp; \" IF YOU KNOW WHAT I MEAN\" end if end if end if end if end if end repeat resultStringend chockify 创建事件描述符 (event descriptor) 导入Carbon.h它有关于所有的 AppleEvent 的定义。1#import &lt;Carbon/Carbon.h&gt; // for AppleScript definitions OC中创建chockify事件描述符这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 NSString 作为参数，创建chockify事件描述符：123456789101112131415161718192021- (NSAppleEventDescriptor *)chockifyEventDescriptorWithString:(NSString *)inputString&#123; // parameter NSAppleEventDescriptor *parameter = [NSAppleEventDescriptor descriptorWithString:inputString]; NSAppleEventDescriptor *parameters = [NSAppleEventDescriptor listDescriptor]; [parameters insertDescriptor:parameter atIndex:1]; // you have to love a language with indices that start at 1 instead of 0 // target ProcessSerialNumber psn = &#123;0, kCurrentProcess&#125;; NSAppleEventDescriptor *target = [NSAppleEventDescriptor descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:sizeof(ProcessSerialNumber)]; // function NSAppleEventDescriptor *function = [NSAppleEventDescriptor descriptorWithString:@\"chockify\"]; // event NSAppleEventDescriptor *event = [NSAppleEventDescriptor appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID]; [event setParamDescriptor:function forKeyword:keyASSubroutineName]; [event setParamDescriptor:parameters forKeyword:keyDirectObject]; return event;&#125; OC中加载 AppleScript通过应用包(Application bundle)的一个 URL 可以创建 NSAppleScript的实例。而反过来，脚本也要和上面创建的 chockify 事件描述符一起使用。123456789101112131415161718NSURL *URL = [[NSBundle mainBundle] URLForResource:@\"Automation\" withExtension:@\"scpt\"];if (URL) &#123; NSAppleScript *appleScript = [[NSAppleScript alloc] initWithContentsOfURL:URL error:NULL]; NSAppleEventDescriptor *event = [self chockifyEventDescriptorWithString:[self.chockifyInputTextField stringValue]]; NSDictionary *error = nil; NSAppleEventDescriptor *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error]; if (! resultEventDescriptor) &#123; NSLog(@\"%s AppleScript run error = %@\", __PRETTY_FUNCTION__, error); &#125; else &#123; NSString *string = [self stringForResultEventDescriptor:resultEventDescriptor]; [self updateChockifyTextFieldWithString:string]; &#125;&#125;如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 Foundation 类很相似，但是返回的错误并不是一个 NSError 的实例。 调用事件描述符123456789101112131415- (NSString *)stringForResultEventDescriptor:(NSAppleEventDescriptor *)resultEventDescriptor&#123; NSString *result = nil; if (resultEventDescriptor) &#123; if ([resultEventDescriptor descriptorType] != kAENullEvent) &#123; if ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) &#123; result = [resultEventDescriptor stringValue]; &#125; &#125; &#125; return result;&#125; InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法 调用沙盒中脚本代码与访问其他应用了解APP沙盒限制如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行JavaScript。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。 对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。NSUserScriptTask使这一切变得可能。由此：Apple 引入了一个新的抽象类 NSUserScriptTask,有三个具体的子类实现: NSUserUnixTask: 执行 Unix shell 命令 NSUserAutomatorTask: Automator 工作流 NSUserAppleScriptTask:执行AppleScript脚本,脚本是异步执行的,所以脚本不能对用户界面做更新操作。 开始安装运行脚本怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？两种策略: 帮助用户来存放运行脚本的位置 获取行脚本目录可读写 帮用户存放运行脚本的位置只能把把这些脚本放到用户的脚本文件夹(User &gt; Library &gt; Application Scripts/bundle identifier/)中，以只读的方式来运行你的脚本。脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者Library 文件夹在 OS X 里默认还是隐藏的。这样对用户都很不友好。让代码来帮助用户打开这个隐藏文件夹：123NSError *error;NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:&amp;error];[[NSWorkspace sharedWorkspace] openURL:directoryURL];通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。 设置运行脚本目录的读写权限 在 Xcode 里，你需要更新 Capabilities，让其包括 User Selected File to Read/Write。在 App Sandbox &gt; File Access里找到相关选项。 用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：12345678910111213141516171819202122232425262728293031323334353637383940414243444546NSError *error;NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:&amp;error];NSOpenPanel *openPanel = [NSOpenPanel openPanel];[openPanel setDirectoryURL:directoryURL];[openPanel setCanChooseDirectories:YES];[openPanel setCanChooseFiles:NO];[openPanel setPrompt:@\"Select Script Folder\"];[openPanel setMessage:@\"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder\"];[openPanel beginWithCompletionHandler:^(NSInteger result) &#123;if (result == NSFileHandlingPanelOKButton) &#123; NSURL *selectedURL = [openPanel URL]; if ([selectedURL isEqual:directoryURL]) &#123; NSURL *destinationURL = [selectedURL URLByAppendingPathComponent:@\"Automation.scpt\"]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *sourceURL = [[NSBundle mainBundle] URLForResource:@\"Automation\" withExtension:@\"scpt\"]; NSError *error; BOOL success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error]; if (success) &#123; NSAlert *alert = [NSAlert alertWithMessageText:@\"Script Installed\" defaultButton:@\"OK\" alternateButton:nil otherButton:nil informativeTextWithFormat:@\"The Automation script was installed succcessfully.\"]; [alert runModal]; &#125; else &#123; NSLog(@\"%s error = %@\", __PRETTY_FUNCTION__, error); if ([error code] == NSFileWriteFileExistsError) &#123; // this is where you could update the script, by removing the old one and copying in a new one &#125; else &#123; // the item couldn't be copied, try again [self performSelector:@selector(installAutomationScript:) withObject:self afterDelay:0.0]; &#125; &#125; &#125; else &#123; // try again because the user changed the folder path [self performSelector:@selector(installAutomationScript:) withObject:self afterDelay:0.0]; &#125;&#125;&#125;]; 这么一来，应用包中的 Automation.scpt 文件现在暴露在常规的文件系统中了。 执行脚本任务使用 NSUserAppleScriptTask 来替代 NSAppleScript，来运行上面创建的事件描述符。你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， NSUserAppleScriptTask 不应该被执行多次。所以写一个工厂函数来在需要的时候创建任务：工厂函数123456789101112131415161718192021- (NSUserAppleScriptTask *)automationScriptTask&#123; NSUserAppleScriptTask *result = nil; NSError *error; NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:&amp;error]; if (directoryURL) &#123; NSURL *scriptURL = [directoryURL URLByAppendingPathComponent:@\"Automation.scpt\"]; result = [[NSUserAppleScriptTask alloc] initWithURL:scriptURL error:&amp;error]; if (! result) &#123; NSLog(@\"%s no AppleScript task error = %@\", __PRETTY_FUNCTION__, error); &#125; &#125; else &#123; // NOTE: if you're not running in a sandbox, the directory URL will always be nil NSLog(@\"%s no Application Scripts folder error = %@\", __PRETTY_FUNCTION__, error); &#125; return result;&#125; 如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 directoryURL 时你需要特别小心。NSApplicationScriptsDirectory只在沙盒中有效。 在创建脚本任务后，你需要使用 AppleEvent 并提供一个结束处理来执行它：AppleEvent123456789101112131415161718NSUserAppleScriptTask *automationScriptTask = [self automationScriptTask];if (automationScriptTask) &#123; NSAppleEventDescriptor *event = [self safariURLEventDescriptor]; [automationScriptTask executeWithAppleEvent:event completionHandler:^(NSAppleEventDescriptor *resultEventDescriptor, NSError *error) &#123; if (! resultEventDescriptor) &#123; NSLog(@\"%s AppleScript task error = %@\", __PRETTY_FUNCTION__, error); &#125; else &#123; NSURL *URL = [self URLForResultEventDescriptor:resultEventDescriptor]; // NOTE: The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get // on that thread by using libdispatch or performing a selector. [self performSelectorOnMainThread:@selector(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:NO]; &#125; &#125;];&#125;对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 event 传递一个 nil，脚本就会像用户在 Finder 中双击那样的行为进行执行。NSUserAppleScriptTask脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。 同步操作NSAppleScript 和 NSUserAppleScriptTask 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 NSAppleScript 的同步特性了。要获得传统方式的行为，一种简单的方法是使用一个信号量(semaphore) 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 libdispatch 创建一个信号量：1self.appleScriptTaskSemaphore = dispatch_semaphore_create(1);接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：1234567891011121314151617// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!dispatch_semaphore_wait(self.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);// run the script taskNSAppleEventDescriptor *event = [self openNetworkPreferencesEventDescriptor];[automationScriptTask executeWithAppleEvent:event completionHandler:^(NSAppleEventDescriptor *resultEventDescriptor, NSError *error) &#123; if (! resultEventDescriptor) &#123; NSLog(@\"%s AppleScript task error = %@\", __PRETTY_FUNCTION__, error); &#125; else &#123; [self performSelectorOnMainThread:@selector(showNetworkAlert) withObject:nil waitUntilDone:NO]; &#125; // the task has completed, so let any pending tasks proceed dispatch_semaphore_signal(self.appleScriptTaskSemaphore);&#125;];再强调一下，除非确实有所需要，否则最好别这么做。","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"macOS之PDFKit基础","slug":"macOS/macOS之PDFKit基础","date":"2017-02-14T14:29:18.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/14/macOS/macOS之PDFKit基础/","link":"","permalink":"https://huos3203.github.io/2017/02/14/macOS/macOS之PDFKit基础/","excerpt":"","text":"一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。作为文件版本，可以支持元数据标记如作者，创建日期，等等。一个文件可以加密，需要密码才能查看它。两级加密存在： 用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。 所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。许多加密的PDF文件有一个“dummy”的用户密码为空字符串。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。 PDF页面一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含超链接和注释。页面可以支持裁剪，还有其他使用功能：例如隐藏多余的部分（如注册标记）。 view VS page空间坐标页面上的大多数对象都是在page空间中指定的，而不是在view空间中。也就是说，坐标系统是在点（每英寸72点），坐标原点在page左侧底部，而不是view。page空间不关心缩放，显示模式等等。一个有bounds的item，比如说32points，保留这些界限，无论显示大小。图view和page坐标系比较 PDFView class包含几个转换方法，将坐标系统从view space的page space，反之亦然。 PDF Kit ClassesPDF Kit套件提供了几个不同功能的类。PDFView和PDFSelection除外，这些类大致对应着各个对象在PDF格式的规范需求。 PDFView ClassPDFView类，就好比Web工具包的WebView类，源于Application Kit中的NSView类。在项目开发中，你可以使用Interface Builder轻松拖动一个PDFView对象放在一个window中。从/Developer/Extras/Palettes/PDFKit.palette得到调色板。PDFView可能是PDF Kit中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到PDFView。PDFView能通过调用其他PDF实用类来实现其大部分功能。如果要添加特殊功能，则需要用户自定义实用类的子类来扩展其特殊功能。Utility classes as used by PDFView PDF Kit Utility ClassesPDF套件工具类提供一种混合的Foundation-like和Application Kit-like的行为。他们有类似的NSString类和NSString Additions方法。这些类都系橙自NSObject PDF DocumentPDFDocument是PDF kit工具类中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在PDFDocument方法中的实例化。是PDFPage和PDFOutline；或相关支持操作：PDFSelection和PDFDestination。你PDFDocument对象初始化，需要一个PDF数据或一个指向PDF文件的URL。实例化之后就可以访问页数，添加或删除页面，对所选内容为NSString对象进行查找或分析。 PDFPagePDFPage代表一个PDF文档的页面。你的应用程序获取一个PDFPage对象必须通过从PDFDocument对象来实例化。PDFPage对象是用户所看到的屏幕，和一个view可以同时显示多个page。你可以使用PDFPage把PDF文档内容渲染到屏幕上，添加注释，计数字符串，定义选择，获取一个page中的文本内容作为NSString对象或NSAttributedString对象。 PDFOutline除了显示实际的文件内容，PDF Kit也能呈现PDFOutline信息，前提是PDF文档中存在目录结构。在目录结构中，一个PDFOutline对象代表一个父目录或子目录。目录是由一个层次的PDFOutline对象组层。顶层是根目录对象，它仅作为其他目录对象的容器。用户的根目录是不可见的。 PDFSelection一个PDFSelection对象包含一个跨PDF文档中文本。你不要直接创建PDFSelection。PDFSelection对象是作为返回值来实例化的。例如：通过调用PDFPage或PDFDocument对象中的selection方法，并从成功搜索的返回值来实例化PDFSelection对象。在同时显示多个PDFPage的PDFView中，PDFSelection可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。 PDFAnnotation一个PDFAnnotation对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。PDFAnnotation是如图所示的具体类的抽象类。各种具体类代表PDF Kit支持的注释类型。 PDFBorderPDFBorder对象封装的拉伸PDFAnnotation对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。 过期:从/Developer/Extras/Palettes/PDFKit.palette得到调色板。Here’s what Apple says about it:“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Addbutton, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.” 老文档PDFKit_Prog_TasksSo:there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.There’s no PDFKit.palette file anywhere on my HD (says Spotlight).I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"PDF","slug":"macOS/PDF","permalink":"https://huos3203.github.io/categories/macOS/PDF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"},{"name":"PDF","slug":"PDF","permalink":"https://huos3203.github.io/tags/PDF/"},{"name":"阅读器","slug":"阅读器","permalink":"https://huos3203.github.io/tags/阅读器/"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"2017/02/14/macOS/Fabric对macOS系统的支持调研/","link":"","permalink":"https://huos3203.github.io/2017/02/14/macOS/Fabric对macOS系统的支持调研/","excerpt":"","text":"FabricFabric 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究crashlytics在app中的运用。注册新的账户登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵浏览官方文档 crashlytics支持macOS对macOS的支持中出现的问题问题：NSApplicationCrashOnExceptions is not set. This will result in poor top-level uncaught exception reporting官方解释：Uncaught ExceptionsIntercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics. 1[[NSUserDefaults standardUserDefaults] registerDefaults:@&#123; @”NSApplicationCrashOnExceptions”: @YES &#125;]; This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default. 官方文档macOS Support拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。以上情况，可以通过设置：NSApplicationCrashOnExceptions 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set Cause a Test Crash教程崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。 run在模拟器上安装运行APP 点击Stop断开Xcode和模拟器，确保在非调试状态 在模拟器上启动APP，并执行崩溃操作 在Xcode上点击run在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。macOS系统中的日志目录：运行日志目录：/private/var/log/system.log奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. https://fabric.io/settings/apps/some_app_id/mappings 官方文档Cause a Test Crash教程","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"调试","slug":"macOS/调试","permalink":"https://huos3203.github.io/categories/macOS/调试/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"搭建","slug":"搭建","permalink":"https://huos3203.github.io/tags/搭建/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"},{"name":"SDK","slug":"SDK","permalink":"https://huos3203.github.io/tags/SDK/"},{"name":"发布","slug":"发布","permalink":"https://huos3203.github.io/tags/发布/"},{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/tags/macOS/"}]},{"title":"思维导图之开发实践篇","slug":"导图/思维导图之开发实践篇","date":"2017-02-13T17:11:26.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/14/导图/思维导图之开发实践篇/","link":"","permalink":"https://huos3203.github.io/2017/02/14/导图/思维导图之开发实践篇/","excerpt":"","text":"阅读书籍 5种图表解决工作中的12大难题 你的第一本思维导图操作书 5分钟手绘彩色圆珠笔涂鸦集 如果阅读一本书 使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。 目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。从产品、设计等方面谈谈我是如何运用思维导图的。 需求分析——完善最初的想法一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。 需求速记法先用纸笔速记的方式，把临时能想到的点记录下来在纸上列得差不多了，再新建一个 XMind 文档，把之前列的一些点一一转到电脑上，然后整理分类。 功能结构图案例 码市逻辑图通过思维导图能够一目了然的看到码市的功能 网站功能逻辑图通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。产品设计——通过画原型来完善功能结构梳理功能结构和画原型是产品设计中相互迭代的过程，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。悬赏功能结构图为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。下面这个图是码市功能结构中的发布悬赏功能部分：有了功能结构图，就可以一一对照来做原型了。原型图正如前面所说：梳理功能结构和画原型是产品设计中相互迭代的过程，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。然后得到下面的原型： 写文章时用到的思维导图原文把想到的先列出来，慢慢整理调整，梳理出写作思路。演变过程： 其他微信推出应用号的处境：","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"思维导图","slug":"思维导图","permalink":"https://huos3203.github.io/tags/思维导图/"}]},{"title":"使用JavaScript把JSON数据定义对象","slug":"swift/使用JavaScript把JSON数据定义对象","date":"2017-02-12T14:41:35.000Z","updated":"2018-10-15T17:22:37.000Z","comments":true,"path":"2017/02/12/swift/使用JavaScript把JSON数据定义对象/","link":"","permalink":"https://huos3203.github.io/2017/02/12/swift/使用JavaScript把JSON数据定义对象/","excerpt":"","text":"将JSON数据序列化为代码实例 定义一个继承自 JSExport 子协议 PersonJSExports 定义一个遵守PersonJSExports协议的Person数据模 使用 JavaScript 把JSON转为类并实例化对象都有一个完整的 JVM 在那儿了，谁还需要 NSJSONSerialization？ JSExport语言互通协议JavaScript可以脱离prototype继承完全用JSON来定义对象，但是Objective-C编程不能脱离类和继承。所以JavaScriptCore就提供了JSExport作为两种语言的互通协议。JSExport中没有预定义任何方法，但是所有继承JSExport的协议中定义的方法即协议方法，都可以在JSContext中被调用。 JSExportAs 宏: 指定方法在JS中调用的名称对于多参数的方法，JavaScriptCore的转换方式将Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);123@protocol MultiArgs &lt;JSExport&gt;- (void)doFoo:(id)foo withBar:(id)bar;@end如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏：JSExport.h1JSExportAs(PropertyName, Selector) JSExportAs的官方宏定义 xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html123#define JSExportAs(PropertyName, Selector) \\@optional Selector __JS_EXPORT_AS__##PropertyName:(id)argument; @required Selector#endif 如 setX:Y:Z方法，我们可以给他重命名，让 JS 中通过 set3D(x,y,z) 来调用使用方法12345JSExportAs(set3D,- (void)setX:(id)x Y:(id)y Z:(id)z);//调用set3D(x,y,z) 定义PersonJSExports协议和create协议方法（类方法）Person 类实现了PersonJSExports 协议，该协议规定哪些属性可以在 JavaScript中可用。在JavaScript语境中，不能像：var person = new Person()来初始化实例，可以在定义PersonJSExports协议方法时，添加一个协议方法来弥补这一点。见下例create...类方法：1234567891011121314151617181920212223242526272829303132333435363738// Custom protocol must be declared with `@objc`@objc protocol PersonJSExports : JSExport &#123; //属性 var firstName: String &#123; get set &#125; var lastName: String &#123; get set &#125; var birthYear: NSNumber? &#123; get set &#125; //方法 func getFullName() -&gt; String /// 在JavaScript中调用这个类方法 class func createWithFirstName(firstName: String, lastName: String) -&gt; Person&#125;### 定义Person模型定义一个遵守`PersonJSExports`协议的`Person`数据模// Custom class must inherit from `NSObject`@objc class Person : NSObject, PersonJSExports &#123; // JS协议属性必须声明为`dynamic` dynamic var firstName: String dynamic var lastName: String dynamic var birthYear: NSNumber? init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125; //JS协议类方法 class func createWithFirstName(firstName: String, lastName: String) -&gt; Person &#123; return Person(firstName: firstName, lastName: lastName) &#125; //JS协议方法 func getFullName() -&gt; String &#123; return \"\\(firstName) \\(lastName)\" &#125;&#125; JSContext 配置之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 JavaScript 环境。我们也将借此导入Mustache JS library，我们将应用模板到我们的 Person 对象。12345678// export Person class，JS中以该`Person标示符`作为类名使用context.setObject(Person.self, forKeyedSubscript: \"Person\")// load Mustache.jsif let mustacheJSString = String(contentsOfFile:..., encoding:NSUTF8StringEncoding, error:nil) &#123; context.evaluateScript(mustacheJSString)&#125; JavaScript 数据和进程下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。数据：Persons.json12345[ &#123; \"first\": \"Grace\", \"last\": \"Hopper\", \"year\": 1906 &#125;, &#123; \"first\": \"Ada\", \"last\": \"Lovelace\", \"year\": 1815 &#125;, &#123; \"first\": \"Margaret\", \"last\": \"Hamilton\", \"year\": 1936 &#125;]创建新的 Person 实例：loadPeople.js123456789101112131415var loadPeopleFromJSON = function(jsonString) &#123; var data = JSON.parse(jsonString); var people = []; for (i = 0; i &lt; data.length; i++) &#123; //在swift中的js协议方法：`createWithFirstName:lastName:` var person = Person.createWithFirstNameLastName(data[i].first, data[i].last); person.birthYear = data[i].year; //`push:`添加到数组中 people.push(person); &#125; //返回该对象 return people;&#125;JSContext加载装换loadPeople.js脚本加载js脚本之后，loadPeopleFromJSON即可作为下标被context调用该方法:加载loadPeople.js123456// load loadPeople.jsif let loadPeople = String(contentsOfFile:..., encoding:NSUTF8StringEncoding, error:nil) &#123; //加载js脚本之后，`loadPeopleFromJSON`即可作为下标被context调用该方法 context.evaluateScript(loadPeople)&#125; 注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。 使用Mustache 模板 渲染Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。mustache模板引擎Mustache 的 Swift 语言实现版本mustache的特点就是很语法很简单，主要语法如下: 1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ &name }}，这个和分隔符无关 2. {{#person}}…{{/person}} 区块，4种方式 person 是真假值，决定是否输出 person 是list of array，会循环展开 for x in person:section.render(&apos;xxx) person 是匿名函数/object, 区块包裹的html 会作为参数传递进去 person 是dict，直接打印 dict[key] 3. {{^person}}…{{/person}，反向区块 4. {{！name }} 注释 5. {{> box }} 载入子模块 加载 JSON 数据，调用 JSContext 将数据解析成 Person 对象的数组，并用 Mustache 模板呈现每个Person：123456789101112131415161718192021222324// 从文件`Persons.json`中加载json数据if let peopleJSON = NSString(contentsOfFile:..., encoding: NSUTF8StringEncoding, error: nil) &#123; // 获取js中定义的`loadPeopleFromJSON`的方法 let load = context.objectForKeyedSubscript(\"loadPeopleFromJSON\") // 通过调用load方法将`JSON 数据`解析成`Person 对象`的数组 if let people = load.callWithArguments([peopleJSON]).toArray() as? [Person] &#123; // get rendering function and create template let mustacheRender = context.objectForKeyedSubscript(\"Mustache\").objectForKeyedSubscript(\"render\") let template = \", born \" // loop through people and render Person object as string for person in people &#123; println(mustacheRender.callWithArguments([template, person])) &#125; &#125;&#125;// Output:// Grace Hopper, born 1906// Ada Lovelace, born 1815// Margaret Hamilton, born 1936JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"}],"tags":[]},{"title":"Java​Script​Core实现swift混编","slug":"swift/Java​Script​Core实现swift混编","date":"2017-02-12T13:34:06.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/12/swift/Java​Script​Core实现swift混编/","link":"","permalink":"https://huos3203.github.io/2017/02/12/swift/Java​Script​Core实现swift混编/","excerpt":"","text":"OS X Mavericks 和 iOS 7 引入了 JavaScriptCore 库，它把 WebKit 的 JavaScript 引擎用 Objective-C 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，JavaScript 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。 如何从 JavaScript 环境中提取值以及如何调用其中定义的函数? 那么反向呢？怎样从 JavaScript 访问我们在 Objective-C或 Swift 定义的对象和方法？ swift通过JSContext调用JavaScript如何从JavaScript 环境中提取值以及如何调用其中定义的函数? 全局实例JSContext：运行JavaScript代码的环境全局实例JSContext作用就像在浏览器内运行的一个JavaScript脚本，JSContext 类似于 window。通过JSContext实例运行JavaScript代码创建变量，做计算，定义方法：12345let context = JSContext() //创建全局环境context.evaluateScript(\"var num = 5 + 5\") //计算context.evaluateScript(\"var names = ['Grace', 'Ada', 'Margaret']\") //定义变量context.evaluateScript(\"var triple = function(value) &#123; return value * 3 &#125;\") //定义方法let tripleNum: JSValue = context.evaluateScript(\"triple(num)\") 动态类型JSValue:包裹JSContext环境下每一个可能的JS值JavaScript 是动态语言，所以动态类型JSValue包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 null 和 undefined。获取tripleNum值：1println(\"Tripled: \\(tripleNum.toInt32())\")JSValue 包括一系列方法用于访问其可能的值以保证有正确的 Foundation 基本类型包括： 下标取值：访问JSContext环境下的任何值JSContext 和 JSValue 实例可以使用下标的方式访问之前创建的 context 的任何值。 JSContext：需要一个字符串下标 JSValue：允许使用字符串或整数标来得到里面的对象和数组 JSContext下标取值 swift语法未映射成[]的原始方法objectAtKeyedSubscript()和objectAtIndexedSubscript()1let names = context.objectForKeyedSubscript(\"names\") //JSContext字符串下标原始方法 JSValue整数下标原始方法未映射成[]的原始方法objectAtKeyedSubscript()和objectAtIndexedSubscript()123let initialName = names.objectAtIndexedSubscript(0) //JSValue整数下标原始方法println(\"The first name: \\(initialName.toString())\") //JSValue method// The first name: Grace 在这里，Objective-C 代码可以利用下标表示法，如下例：context[@”names”]，names[0]，[initialName toString]，Swift 目前只公开原始方法:objectAtKeyedSubscript() 和 objectAtIndexedSubscript()来让下标成为可能。 callWithArguments调用JS方法：只需传入Foundation基本类型参数上述JavaScript代码中，JSValue包装了一个triple函数，在Objective-C / Swift 代码中可以使用 Foundation基本类型作为参数来直接调用该函数。再次，JavaScriptCore 很轻松的处理了这个桥接：1234 let tripleFunction = context.objectForKeyedSubscript(\"triple\") //下标取值let result = tripleFunction.callWithArguments([5]) //传入基本类型参数直接调用println(\"Five tripled: \\(result.toInt32())\") exceptionHandler错误处理exceptionHandler 是一个接收JSContext 引用和异常本身的回调处理的闭包。通过设置上下文的 exceptionHandler 属性，可以观察和记录语法，类型以及运行时错误:123456context.exceptionHandler = &#123; context, exception inprintln(\"JS Error: \\(exception)\")&#125;context.evaluateScript(\"function multiply(value1, value2) &#123; return value1 * value2 \")// JS Error: SyntaxError: Unexpected end of script123456context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;NSLog(@\"JS Error: %@\", exception);&#125;;[context evaluateScript:@\"function multiply(value1, value2) &#123; return value1 * value2 \"];// JS Error: SyntaxError: Unexpected end of script JavaScript 通过JSContext调用 swift／OC怎样从 JavaScript 访问我们在 Objective-C或 Swift 定义的对象和方法？让 JSContext 访问我们的本地客户端代码的方式主要有两种： block块键值对：把OC中的block块赋值给JSContext的一个标示键，该标识键的JSValue可以通过callWithArguments调用. JSExport 协议。 block块 键值对:该block键的JSValue通过callWithArguments调用当一个 Objective-C block 被赋给 JSContext 里的一个标识符，JavaScriptCore 会自动的把 block 封装在 JavaScript 函数里，并以该标示符作为函数名来调用该block的实现。这使得在 JavaScript 中可以简单的使用 Foundation 和 Cocoa类，所有的桥接都为你做好了。CFStringTransform处理语言的强大威力 在 JSContext 中使用 Swift 闭包需要注意两点: 与 @objc_block 属性一起声明 使用Swift中的unsafeBitCast()函数，把对象转换为AnyObject 12345678910let simplifyString: @objc_block String -&gt; String = &#123; input in var mutableString = NSMutableString(string: input) as CFMutableStringRef CFStringTransform(mutableString, nil, kCFStringTransformToLatin, Boolean(0)) CFStringTransform(mutableString, nil, kCFStringTransformStripCombiningMarks, Boolean(0)) return mutableString&#125;context.setObject(unsafeBitCast(simplifyString, AnyObject.self), forKeyedSubscript: \"simplifyString\")//通过simplifyString标示符来调用block的实现println(context.evaluateScript(\"simplifyString('안녕하새요!')\"))// annyeonghasaeyo! 12345678910//给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数context[@\"simplifyString\"] = ^(NSString *input) &#123;NSMutableString *mutableString = [input mutableCopy];CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, NO);CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformStripCombiningMarks, NO);return mutableString;&#125;;//通过simplifyString标示符来调用block的实现NSLog(@\"%@\", [context evaluateScript:@\"simplifyString('안녕하새요!')\"]); 内存管理由于 block 可以保有变量引用，而且 JSContext 也强引用它所有的变量，为了避免强引用循环需要特别小心。避免保有JSContext 或一个 block 里的任何 JSValue。相反，使用 [JSContext currentContext] 得到当前上下文，并把你需要的任何值用参数传递。 JSExport 协议在继承JSExport 协议的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给JavaScript代码来调用。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"JS混编","slug":"swift/JS混编","permalink":"https://huos3203.github.io/categories/swift/JS混编/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/tags/macOS/"},{"name":"混编","slug":"混编","permalink":"https://huos3203.github.io/tags/混编/"},{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/tags/iOS/"},{"name":"Java​Script​Core","slug":"Java​Script​Core","permalink":"https://huos3203.github.io/tags/Java​Script​Core/"},{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/tags/swift/"}]},{"title":"用Git将代码恢复到一个历史的版本","slug":"git/用Git将代码恢复到一个历史的版本","date":"2017-02-10T18:19:48.000Z","updated":"2018-09-05T15:52:33.000Z","comments":true,"path":"2017/02/11/git/用Git将代码恢复到一个历史的版本/","link":"","permalink":"https://huos3203.github.io/2017/02/11/git/用Git将代码恢复到一个历史的版本/","excerpt":"","text":"经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：目的：在当前分支上，将代码恢复到一个历史的提交版本上。 暴力的方式如果仓库是自己在用（不影响别人），那么可以使用git reset --hard &lt;target_commit_id&gt; 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。 第一步：查看本地的索引的提交日志：12345$ git reflog a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to mastera1d09fd HEAD@&#123;1&#125;: checkout: moving from master to alla1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to mastera1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD 第二步：根据上面的sh2值，回滚：1git reset —hard a1d09fd 这样就可以找回代码. 温柔的方式1234#回滚git reset —hard a1d09fd#将当前代码切换回最新的提交git reset --soft origin/source 此时工作区变成了历史的提交内容，这个时候用 git add 和 git commit 即可. 后悔药 舍弃上一次工作区的更改git checkout . 舍弃暂存区的更改git reset --hard 恢复上一次提交的内容到工作区git reset -- .git reset filename 先提交后再恢复到上一次提交的状态git revert idgit revert HEAD 修改提交的日志分两步git commit -am &quot;日志信息&quot;git commit -amend","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"恢复","slug":"git/恢复","permalink":"https://huos3203.github.io/categories/git/恢复/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/tags/git/"},{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"bilibiliForMac版之mpv依赖编译","slug":"编译/bilibili之Mac版ffmpeg依赖编译","date":"2017-02-10T10:45:03.000Z","updated":"2017-05-26T18:13:12.000Z","comments":true,"path":"2017/02/10/编译/bilibili之Mac版ffmpeg依赖编译/","link":"","permalink":"https://huos3203.github.io/2017/02/10/编译/bilibili之Mac版ffmpeg依赖编译/","excerpt":"","text":"Bilibili Mac Client一款基于mpv和ffmpeg底层库实现的播放器. 项目依赖库编译在项目中所需的相关依赖库 下载资源 下载mpv-build 1git clone https://github.com/mpv-player/mpv-build.git 执行下载ffmpeg, libass 和mpv资源，同时完成编译的命令： 12cd mpv-build/ ./rebuild -j4 使用参数 “–enable-shared ” 可以开启 ffmpeg 的动态版本: 12cd ffmpeg/./configure --enable-shared 安装ffmpeg 123在ffmpeg目录下执行：make make install 开始编译mpv动态依赖库： 开启libmpv动态库的支持：123cd ../mpv/./waf configure --enable-libmpv-shared --disable-libass./waf build 变更去除static参数：./waf configure –enable-static-build –enable-libmpv-shared –disable-libass 集成到项目中指定libmpv.dylib相对路径直接编译出来的库会是绝对路径，需要先通过install_name_tool 修改 相对路径：12cd build/install_name_tool -id \"@executable_path/lib/libmpv.dylib\" libmpv.dylib 聚合ffmpeg相关依赖包执行 mpvtools/dylib-unhell ，目标是 libmpv.dylib1TOOLS/dylib-unhell.py libmpv.dylib这样会多出一个 lib文件夹，里面会出现变为相对路径的文件，复制导入到项目即可。 相对路径脚本学习使用otool -L 和install_name_tool完成了一系列操作：12install_name_tool -changeinstall_name_tool -id 扩展一：123456789101112131415161718192021#!bin/shmkdir \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib\"cp -f /your/path/to/xcode_project_name/dylib/*.dylib \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib/\"echo \"--------$(pwd)----------------\"cur_dir=\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\"cd $&#123;cur_dir&#125;echo \"--进入$(pwd)--\"for dirlist in $(ls $&#123;cur_dir&#125;) #查看它们的 rpath otool -L $&#123;dirlist&#125; #制作相对路径 #方法一 install_name_tool -change /usr/local/lib/$&#123;dirlist&#125; @executable_path/lib/$&#123;dirlist&#125; \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME\" #方法二 install_name_tool -id \"@executable_path/lib/$&#123;dirlist&#125;\" $&#123;dirlist&#125;dodone 扩展二1234567891011echo \"--------$(pwd)----------------\"cur_dir=\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\"cd $&#123;cur_dir&#125;echo \"--进入$(pwd)--\"lib=\"libmediainfo.0.dylib\"#-f 参数判断 $file 是否存在if [ -f \"$lib\" ]; then otool -L $&#123;lib&#125; install_name_tool -id \"@executable_path/lib/$&#123;lib&#125;\" $&#123;lib&#125; otool -L $&#123;lib&#125;fi","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"},{"name":"视频","slug":"macOS/视频","permalink":"https://huos3203.github.io/categories/macOS/视频/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://huos3203.github.io/tags/编译/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://huos3203.github.io/tags/ffmpeg/"},{"name":"mpv","slug":"mpv","permalink":"https://huos3203.github.io/tags/mpv/"},{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/tags/shell/"}]},{"title":"开发Mac上的App插件","slug":"macOS/开发Mac上的App插件","date":"2017-02-07T12:38:58.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2017/02/07/macOS/开发Mac上的App插件/","link":"","permalink":"https://huos3203.github.io/2017/02/07/macOS/开发Mac上的App插件/","excerpt":"","text":"在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过NSBundle和 plug-ins插件,可以很方便的向原有APP中添加新功能点。 目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能 包 (Bundles) 和接口 (Interfaces)如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： Screen Savers 到 Image Units等。在Framework &amp; Library中的 Bundle 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。bundle 模版项目与APP项目比较： 一个 Contents 目录，里面包含了 Info.plist 和 Resource 目录。 如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 MacOS 目录。 Bundle 工程里缺少的一个东西是 main() 函数。它是被宿主App 调用执行的。 为 TextEdit 加入 Plugin 支持两种插件的方式: 第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。 第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。本文章的项目文件仍然会放在 GitHub 供大家参考。 在 TextEdit 中扫描 Bundle请打开 “01 TextEdit” 目录下面的 TextEdit.xcodeproj 工程，同时浏览它里面包含的代码。TextEdit 里面有三个简单的组成部分：扫描 bundle，加载 bundle，调用 bundle 的 UIloadPlugins 方法：打开 Controller.m，你可以看见 -(void)loadPlugins 方法 (它在 applicationDidFinishLaunching: 中被调用)。 扩展插件菜单：在界面菜单右侧加入了一个新的 NSMenuItem，为调用插件提供一个入口（通常你会在 MainMenu.xib 做这件事情并且链接 outlets，但是我们这次偷下懒）。 扫描插件目录：获得插件目录（在 ~/Library/Application Support/Text Edit/Plug-Ins/ ）下，并且扫描这个目录。123456789101112131415161718192021NSString *pluginsFolder = [self pluginsFolder];NSFileManager *fm = [NSFileManager defaultManager];NSError *outErr;for (NSString *item in [fm contentsOfDirectoryAtPath:pluginsFolder error:&amp;outErr]) &#123; if (![item hasSuffix:@\".bundle\"]) &#123; continue; &#125; NSString *bundlePath = [pluginsFolder stringByAppendingPathComponent:item]; NSBundle *b = [NSBundle bundleWithPath:bundlePath]; if (!b) &#123; NSLog(@\"Could not make a bundle from %@\", bundlePath); continue; &#125; //获取实现插件代理协议方法的类 id &lt;TextEditPlugin&gt; plugin = [[b principalClass] new]; NSMenuItem *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:@selector(pluginMenuItemCalledAction:) keyEquivalent:@\"\"]; [item setRepresentedObject:plugin];&#125; 注：扫描插件目录，确保得到的是一个 .bundle 文件，然后用 NSBundle 载入你找到的 bundle 并且实例化里面的类。 插件代理你会注意到一个 TextEditPlugin 的 protocol 的引用。在 TextEditMisc.h 能找它的定义:声明代理协议1234@protocol TextEditPlugin &lt;NSObject&gt;- (NSString*)menuItemTitle;- (void)actionCalledWithTextView:(NSTextView*)textView inDocument:(id)document;@end这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。 NSPrincipalClass键:值–实现插件代理协议方法的类名称在 bundle 里面调用的 principalClass 方法是什么呢？当你创建一个 Bundle 的时候，你可以在里面创建一个或者多个类，同时你需要让 TextEdit 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 Info.plist 文件加入一个 NSPrincipalClass 的键，同时设置它的值为实现插件方法的类的名字。你可以用 [NSBundle principalClass] 方便地从 NSPrincipalClass 的值里面寻找并创建这个类。 添加扩展插件菜单的响应事件在 Plug-Ins 菜单加入一个新的按钮，设置 action 为 pluginMenuItemCalledAction:，并且设置它表示你已经实例化的对象。 如果在 menu item 里面没有设置一个target，即目标是nil，那么它会寻找响应链，来寻找第一个实现 pluginMenuItemCalledAction: 方法的对象。如果它找不到，那么这个菜单选项将会不能用。举一个例子，实现 pluginMenuItemCalledAction 的最好的地方是在 Document 的 window controller 类中。打开 DocumentWindowController.m，然后定位到pluginMenuItemCalledAction12345- (void)pluginMenuItemCalledAction:(id)sender &#123; id &lt;TextEditPlugin&gt;plugin = [sender representedObject]; [plugin actionCalledWithTextView:[self firstTextView] inDocument:[self document]];&#125; 代码本身很清晰，搜集插件实例，调用 actionCalledWithTextView:inDocument: 方法（被定义在 protocol 里面的），运行你插件里面的代码。 制作插件 新建模版项目打开 “01 MarkYellow” 工程看一下。这是一个 Xcode (通过OS X ▸ Framework &amp; Library ▸ Bundle template 建立) 的标准工程，里面只添加了一个类：TEMarkYellow。 设置NSPrincipalClass键值如果你打开MarkYellow-Info.plist，你可以看到 NSPrincipalClass 的值设置成了上面提到的 TEMarkYellow。 实现协议代理接着，打开 TEMarkYellow.m，你将会看见定义在协议里面的方法。 第一个方法（menuItemTitle）返回插件的名字，最为入口名显示在 menu 里面。 第二个方法 (actionCalledWithTextView:inDocument:)，把所有选中的文字变成黄色的背景。改变字体颜色123456789101112131415- (void)actionCalledWithTextView:(NSTextView*)textView inDocument:(id)document &#123; if ([textView selectedRange].length) &#123; NSMutableAttributedString *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy]; [ats addAttribute:NSBackgroundColorAttributeName value:[NSColor yellowColor] range:NSMakeRange(0, [ats length])]; // 先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。 By asking the text view if you can change the text first, it will automatically do the right thing to enable undoing of attribute changes if ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]]) &#123; [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats]; [textView didChangeText]; &#125; &#125;&#125; 集成插件运行 TextEdit （它会创建Plug-Ins目录），然后构建 MarkYellow 工程。把 MarkYellow.bundle 丢到你的 ~/Library/Application Support/Text Edit/Plug-Ins/ 目录下面，重启你的 TextEdit 应用。一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 Plug-Ins ▸ Mark Selected Text Yellow，选择的文字的背景颜色就变成黄色的了。 XCode8版本问题Xcode8 不再支持Application Plug-in插件XCode8.2.1继续使用xcode插件这个是因为苹果解决xcode ghost，把插件屏蔽了。解决方法sudo /usr/libexec/xpccachectl然后必须重启电脑后生效.","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[]},{"title":"Crash文件分析方法","slug":"调试/Crash文件分析方法","date":"2017-02-07T12:38:58.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"2017/02/07/调试/Crash文件分析方法/","link":"","permalink":"https://huos3203.github.io/2017/02/07/调试/Crash文件分析方法/","excerpt":"","text":"第一步：在任意目录创建调试crash的目录 第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM 第三步：将symbolicatecrash工具copy到crash目录1find /Applications/Xcode.app -name symbolicatecrash -type f 2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起拷贝到crash目录：1cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash 第四步：执行symbolicatecrash1.打开终端用命令切换到桌面的crash目录下：1cd /Users/你的电脑名称/Desktop/crash 2.执行命令1./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash 这时候终端有可能会出现：Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60. 3.输入命令：1export DEVELOPER_DIR=\"/Applications/XCode.app/Contents/Developer\" 4.再执行 2.的命令行 5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。1Unsupported crash log version: 12 at ./symbolicatecrash line 614. 第五步：1dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"调试","slug":"xcode/调试","permalink":"https://huos3203.github.io/categories/xcode/调试/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"}]},{"title":"Hexo标签插件","slug":"hexo/Hexo标签插件","date":"2017-01-23T15:17:33.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2017/01/23/hexo/Hexo标签插件/","link":"","permalink":"https://huos3203.github.io/2017/01/23/hexo/Hexo标签插件/","excerpt":"标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 引用块 在文章中插入引言，可包含作者、来源和标题。 别号： quote 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 样例 无参普通blockquote 123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.","text":"标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 引用块 在文章中插入引言，可包含作者、来源和标题。 别号： quote 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 样例 无参普通blockquote 123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 引用书上的句子 123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. boyer huo Wide Awake 引用 Twitter 123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用网络上的文章 123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125; Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块 在文章中插入代码。 别名:code 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 样例 普通的代码块 123&#123;% codeblock %&#125;alert('Hello World!');&#123;% endcodeblock %&#125; 1alert(&apos;Hello World!&apos;); 指定语言 123&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125; 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明 123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125; Array.map12Array.maparray.map(callback[, thisArg]) 附加说明和网址 1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; _.compactUnderscore.js123_.compactUnderscore.js_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块 (MD语法) 样例 行内代码块 1行内 `code 块 ` 缩进代码块 1234// Some commentsline 1 of codeline 2 of codeline 3 of code 多行代码块 12345``` [language] [title] [url] [link text] 代码块 `` ` 表格 样例 默认左对齐 123|参数|描述|默认值||-------|-------|----------||文本内容 |文本内容| 文本内容 | 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 向右对齐 123|参数|描述|默认值||-------:|-------:|-------:|| 文本内容 | 文本内容 | 文本内容| 三种布局 路径:(储存到路径文件夹) post source/_posts page source draft source/_drafts 向左对齐 123|参数|描述|默认值||:------|:------|:------|| 文本内容 | 文本内容 | 文本内容| 日期变量 描述:（可以通过日期来管理文章） :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 居中对齐 123|参数|描述|默认值||:------:|:------:|:------:|| 文本内容 | 文本内容 | 文本内容| 变量 描述 layout 布局当:false不加任何布局样式 title 标题 date 文件建立日期 Pull Quote 在文章中插入 Pull quote。123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; jsFiddle 官网在文章中嵌入 jsFiddle 在线的shell编辑器,可以供我们在线测试html、js、和css代码。1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; Gist 在文章中嵌入 Gist1&#123;% gist gist_id [filename] %&#125; filename: 可选，当不指定文件名时，嵌入显示gist_id下所有文件。 一个gist可能存在多个文件：1https://gist.github.com/dergachev/4627207#file-gif-screencast-osx-md 4627207：表示gist_id ，#file-后边内容：表示Gist中某个文件名 如下:指定文章中嵌入ecba275d5e4404678354中的NSAttributeString相关方法.m内容。1&#123;% gist ecba275d5e4404678354 NSAttributeString相关方法.m %&#125; iframe 在文章中插入 iframe。1&#123;% iframe url [width] [height] %&#125; 插入图片 样例 Hexo语法 在文章中插入指定大小的图片。1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; MD语法 原图+toolTip 1![boyer logo](http://boyers.coding.me/img/logo.png &quot;这是我的logo图片&quot;) 注脚语法 可以在稍後的文件中再定义图片地址12![boyer logo][logo][logo]: http://boyers.coding.me/img/logo.png &quot;这是我的logo图片&quot; ![boyer logo][logo][logo]: http://boyers.coding.me/img/logo.png “这是我的logo图片” 指定图片大小1![boyer logo](http://boyers.coding.me/img/logo.png [200] [200] &quot;这是我的logo图片&quot;) 超链接 样例 Hexo语法 在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。1&#123;% link text url [external] [title] %&#125; MD语法 智能识别超链接 1http://boyers.coding.me http://boyers.coding.me 文本式 1[boyer Blog](http://boyers.coding.me) boyer Blog toolTip式 1[boyer Blog](http://boyers.coding.me \"这是我的博客首页\") boyer Blog Include Code 插入 source 文件夹内的代码文件(.m/json/xml等)。1&#123;% include_code [title] [lang:language] path/to/file %&#125; Youtube 在文章中插入 Youtube 视频。1&#123;% youtube video_id %&#125; Vimeo 在文章中插入 Vimeo 视频。1&#123;% vimeo video_id %&#125; 引用文章 根据服务器根目录分为两种方式：12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 以Docker使用博客为例 相对路径 1&#123;% post_path Docker使用 %&#125; 相对于服务器根目录的位置： 绝对路径 1&#123;% post_link Docker使用 Docker使用 %&#125; 本博中其他文章的超链接： 引用资源 引用文章的资源。Assets指的是那些不在source目录下的资源，比如图片、CSS文件或者Javascript文件。Hexo提供一种更方便的方法来管理这些资源（Assets）。想使其生效，首先修改 post_asset_folder 字段的设置，将其值改为 true 。当生效后，在你创建文章的时候，Hexo会创建一个同名目录，你可以将该文章关联的资源全部放到该目录下。这样就可以更加方便的使用它们了。使用方法就是上面介绍过的标签插件。123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; Raw 一些内容不想被主题渲染，可以使用该插件呈现原始状态。如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。123&#123;% raw %&#125;content&#123;% endraw %&#125;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"Kindle之ResilioSync索引","slug":"智能设备/Kindle之ResilioSync索引","date":"2017-01-23T12:49:49.000Z","updated":"2019-01-16T21:01:15.000Z","comments":true,"path":"2017/01/23/智能设备/Kindle之ResilioSync索引/","link":"","permalink":"https://huos3203.github.io/2017/01/23/智能设备/Kindle之ResilioSync索引/","excerpt":"","text":"Kindle伴侣精品书库Kindle伴原文Resilio Sync同步密钥1BOC3NIGPF2DOKETOF2FAHXJXE2HF24QWC 精品书库精品库 每周一书每周一书 国外书籍国外精选 Resilio Sync原地址详解 实现原理Resilio Sync 这款软件的优点上面已经说了一些，就是不依赖中心服务器，所有的文件都分布在用密钥连接在一起的电脑上。这里重点说一下小伙伴们关心的缺点。 缺点一：免费版只能强制同步所有文件，比如书库的大小有 5G，只能将这 5G 的电子书全部同步到你的电脑上，这需要你有一块足够大的硬盘。除非你升级到收费版（每年 100 元）实现选择性同步。 缺点二：因为没有中心服务器，所以下载的速度依赖于每个电脑的上传速度，和中心服务器的分享方式相反，人越多同步的速度就越快，反之，人越少同步的速度就越慢。 在IgnoreList文件中忽略不想同步的文件BitTorrent Sync还支持文件过滤，如果你有一些文件不想被同步，你可以通过配置IgnoreList实现。IgnoreList是一个UTF-8编码的txt文件，里面你可以定义单个文件，路径，以及规则，他支持简单的“？”和“*”匹配。12cd 同步目录/.sync／cat IgnoreList &gt;# IgnoreList is a UTF-8 encoded .txt file that helps you specify single files, paths and rules &gt;# for ignoring during the synchronization job. It supports &quot;?&quot; and &quot;*&quot; wildcard symbols. # # # OS generated files # .DS_Store .Spotlight-V100 .Trashes ehthumbs.db desktop.ini Thumbs.db # Temporary files # ~* *~ .~lock.* *.part *.crdownload @eaDir @SynoResource .@__thumb 高级设置相关说明123456789101112131415161718192021disk_low_priority：true 设置在磁盘上操作文件的优先级，如果设置为false，在同步文件时读写文件将会采用最高速度和优先级，不过这样会影响其他应用的性能。folder_rescan_interval：600 设置扫描目录的时间间隔，单位为秒lan_encrypt_data：true 如果设置为ture，则在本地网络传输时会采用加密传输。lan_use_tcp：false 如果设置为ture，在本地网络同步会采用tcp传输，而不是采用udp传输。注意：在LAN中禁止加密并采用tcp传输，会增加传输速度。rate_limit_local_peers：false 申请在本地网络的peers直接限速传输，默认没有在LAN里面限速send_buf_size：5 在发送文件时可以使用的发送缓存，可以设置1~100Mrecv_buf_size：5 在接收文件时可以使用的接收缓存，可以设置1~100Msync_max_time_diff：600 同步的设备之间的时间差别sync_trash_ttl：30 设置多少天之后自动删除.SyncArchive目录中的文件max_file_size_diff_for_patching：1000max_file_size_for_versioning：1000 版本控制的一个参数，不了解... 常见问题汇总添加同步链接后为什么找不到节点？如果是刚添加同步密钥或链接，请稍等片刻。如果很长时间仍然找不到节点无法同步，请尝试：把已经添加的同步目录删除，在 Sync 界面上谭家的同步断开，然后重新添加同步密钥或同步链接。 提示“与 x 个用户的时间差”怎么办？如果系统的时间严重不准会导致 BT Sync 无法正常工作。如果 Sync 软件提示的事您的电脑有时间差，请确保开启自动时间同步，如果时间同步没问题，请先退出 Sync 软件重新开启。如果提醒其他人有时间差，请忽略。 为什么同步的电子书比目录标示的大？书库在维护的过程中会删除一些质量较差和重复的电子书，如果被删除的电子书已经同步到你的电脑上，就会被 Sync 自动备份下来。备份位置在同步目录下的隐藏文件夹 .sync/Archive 中，在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“打开存档文件”即可打开。 默认情况下，此目录中的文件 30 天后会自动删除。书库中删除的文件没有保留的必要，为了避免备份文件占用空间，可以禁用此功能。先把 Archive 文件夹删除，然后在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“首选项”，取消“在文件夹存档中存储已删除的文件”前面的勾选即可。 开启 Sync 后电脑变得很卡怎么办？因为 Sync 传输数据时需要读写硬盘，这可能会导致电脑其它的数据读取变慢，解决方法就是设置限速，让同步细水长流。打开 Sync 的软件的“首选项”，在“高级”选项卡中找到“限制接收速率”和“限制发送速率”，输入一个合适的值即可。另外，如果正在做其他工作，建议暂停或暂时退出 Sync 软件。 另外，在“高级”界面里，点击底部的“打开高级用户偏好设置”，把“disk_low_priority”这项设置为 true 也可以缓解卡顿的现象。其中“rate_limit_local_peers”是设置在磁盘上操作文件的优先级，默认为 false，在同步文件时读写文件将会采用最高速度和优先级，所以会影响其他应用的性能。 重新添加能继续用之前的同步目录吗？有时因为某种原因，导致添加到 Resilio Sync 的同步丢失，需要重新添加密钥，这种情况下，是可以继续使用之前的同步目录的，只需要在重新添加密钥选择同步目录的时候，选择原来的目录即可。","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/tags/资源/"},{"name":"kindle","slug":"kindle","permalink":"https://huos3203.github.io/tags/kindle/"},{"name":"书籍","slug":"书籍","permalink":"https://huos3203.github.io/tags/书籍/"},{"name":"ResilioSync","slug":"ResilioSync","permalink":"https://huos3203.github.io/tags/ResilioSync/"}]},{"title":"Kindle114 资源集[转]","slug":"智能设备/Kindle资源","date":"2017-01-23T12:49:49.000Z","updated":"2017-01-23T17:34:23.000Z","comments":true,"path":"2017/01/23/智能设备/Kindle资源/","link":"","permalink":"https://huos3203.github.io/2017/01/23/智能设备/Kindle资源/","excerpt":"","text":"鸣谢 hi-pda dtgc Kindle115 综合类 青风乘翼 最近出版的译著 更新中 周旋久 按字母排列的书籍 提取码：djhp F、H、J、R字母 提取码 39bd S、T、Y字母 提取码 42b1 烫伤关东煮 约1t以上 20160302更新 18810815415 精排版书籍 （可能是豆瓣读书编辑） liantingv70657 炜博happy 更新中 guyuemuziye6@gmail.com 旅游原版书 （微博号逼影共享，解压密码bygx） 枫729882492 电子书资源外链发布站 赤霓 nnuuij11111 风扒皮1503 zphstar skmjtptwr 327995970ou xunys ohhe 没我找不到的电子书 （此人吹牛居多，书籍不全） 搜珍玉鏡 菜是菜菜 13805758171 yun360419811 虚昧斋 分享新书 可私信求书 唯我君行 中医、VB haoyou43 mobi epub 格式书籍 350+ 更新中 liguobing55 txt合集 青辰VOW 部分全站打包等 苏菇莨百度盘书（BTSync） 约56G 至20160222关闭前 感谢：maldiniymx B3EWLQK7C6O6RK3CU5CG3PZUYDUJLMYCP B25G263OSC7ZAXPLCZESSL3DFJOHK6UQ3 wizardforcel 杂项书籍 豆瓣图书top250 当当epub7000本 卡夫卡全集和哈佛管理 知乎话题、专栏、收藏 知日系列 知乎盐系列 图说天下系列 kindle人资源打包 精品区11G+自购区31G+自制区10G+66G programthink 文学历史类、社科类 零度小然 稀有现代书历史籍 youngharrylg 中华人民共和国前三十年历史 南阳高卧 近现代大家 doppel88 各国文学 坊書流元 语言学 高贵的容克领主 历史 dfdean 文学 名家文集 rainthounder 文史高清pdg版图书 翟子昂 中国古文字学 longhuarenn 历史 Lyra1900 iilikes 古籍类 Ac_heron 古典文学 dadssfree 大批量文史书籍 (约1.3t) qq312145694 古文史资料 （大约1t以上） 洋风汉魂 日本文史资料原版 （大约1t以上） 久舞而凄 精选精美古籍 （大约500G以上,更新中） 逍遥449824194 古籍 事无所成只因懒 古籍 钱建文 古籍 风家纪录片3 子乌书简全站打包 20130507 密码：qjq8 小说 wizardforcel 小说 莫迪亚诺作品集 王小波全集 阿加莎·克里斯蒂作品集 周浩晖作品集 医学类、心理学类 于柏清二 中医 bdywuxinghua 中医丛书 yyzsm99 心理学 异硫氰酸烯丙酯 医学 一蹀盐 呼吸医学 cnchenlian 康复医学 Zita 解剖学 图谱 LV终结者 制药技术 （物化资料夹里） 136603yin 性科学为特色 偏综合 心理学交际学电子书合集13本 hhhzihao 心理学 佛学类 CBETA_TW 中華電子佛典協會分享佛教书籍 dufojing 佛教书籍 senmy08 佛教书籍 数理学科类 小兆一凡 数学 我就叫混沌 华章数学译丛 百度云 华章数学译丛 微盘 图灵数学·统计学丛书 百度云 图灵数学·统计学丛书 微盘 生物学类（动物、植物、野外生存等） ChentaoTony1 昆虫学 jkdpgh 野外生存 动物志 麦子 生物学 动物学 xiayang405 精神病学、细胞生物学 li__cheng__ 中国植物志、各地区植物志 山刺玫 植物学 绿色营上海小组 植物学 计算机技术类 lxghost IT （xiaoshuwu.net） wintelsui IT 明月无风 耍大刀xyz PS书籍 hcbbt IT salttiger IT wizardforcel IT 非IT工业技术类 南航飞动研学群 航空航天 星河舰队司令 武器 wxjoldgoat 武器 cfhcjg 军事资料 以逸待劳hk 航天资料 语言学习类 学派英语团队 英语学习 英语学习资料 经管 商业类电子书 艺术类 （摄影、音乐、绘画等） 吸血鬼123牛仔 音乐 xslp2004 摄影 yu鈥唋ei 中国绘画 新浪微博@于双子鱼 分享私密文件 杂志类 qingge16 杂志 （含部分最新书） yanxishe 杂志 liuafenliu 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊） 更新中 foodservice 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊） 似乎是台湾地区人 更新到201410 原版书类 好想一次过 原版外文书 12879本Kindle英文原版电子书 经典、畅销英文原著100本 相关链接 计算机书籍控 脚本之家电子书 小书屋 稀酷客 读远 SaltTiger it-ebooks.cn it-ebooks.info it-ebooks.org it-ebooks.com ebooks-it.net wowebook.org bookdl.com bookzz.org allitebooks.com","categories":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/tags/资源/"},{"name":"kindle","slug":"kindle","permalink":"https://huos3203.github.io/tags/kindle/"},{"name":"书籍","slug":"书籍","permalink":"https://huos3203.github.io/tags/书籍/"}]},{"title":"AR 开发资料汇[转]","slug":"swift/AR开发资料汇","date":"2017-01-22T18:55:21.000Z","updated":"2018-09-22T21:18:47.000Z","comments":true,"path":"2017/01/23/swift/AR开发资料汇/","link":"","permalink":"https://huos3203.github.io/2017/01/23/swift/AR开发资料汇/","excerpt":"","text":"总结了AR开发的平台汇总，AR视频经典教程，AR主流资讯网站，Vuforia，EasyAR一些实例教程以及AR精选应用。 AR 平台Vuforia–不用多说，最流行的AR应用开发引擎。EasyAR－－EasyAR是国内最专业的AR引擎,是国内首款投入应用的AR SDK。EasyAR是好用且免费的增强现实(Augmented Reality)开发者引擎。HiAR–HiAR 增强现实开发平台 HiAR 是亮风台信息科技打造的新一代移动增强现实(AR)开发平台,提供一整套世界领先的增强现实(AR)技术服务。太虚AR－－成都米有网络科技有限公司自主研发集成于Unity3d实现增强现实的SDK开发包,虚拟现实SDK太虚官方网站。Wikitude–Wikitude是一家专门从事智能手机增强现实的应用，分别出品了两款应用Wikitude drive与Wikitude World Browser。Inter RealSense–RealSense 3D是一套感知计算解决方案,包括世界上最小的3D摄像头,模块比两个硬币摞起来还薄,除了硬件外,英特尔还将提供驱动及软件等全套开发工具ICreator–依托于iCreator 3D, VR引擎,模型师可以快速创建交互式3D, VR内容,并支持微信平台传播,也为模型师提供可视化3D模型交易功能。天眼－－天眼AR包括天眼云平台和天眼AR浏览器,用户需在天眼云平台完成“AR内容”制作,然后在天眼AR浏览器查看效果。Google Tango–小编重点推荐。运动追踪(Motion Tracking)，深度感知(Depth Perception)和区域学习(Area Learning)。 AR 视频教程Hololens 开发教程增强现实技术分享AR房地产AR - 双卡互动AR涂涂乐Hololens 开发Vuforia 公开课Intel realSense制作面部捕捉小游戏HiAR 视频播放HiAR 水晶球HiAR 瞬间拥有Apple WatchVuforia 入门－基础－进阶 AR 网站AR酱–发现闪闪发光的AR从业者|增强现实|混合现实|虚拟现实增强现实－－增强现实中国ARinChina 是中国最大的专注于AR增强现实技术行业的门户网站。AR 学院－－增强现实|虚拟现实技术交流社区、综合门户AR 村－－提供最新最快的AR增强现实信息,最权威的AR增强现实解读与产品发布.柚子AR－－柚子AR打造专业的增强现实技术领域门户网站,提供AR资讯、AR技术、AR视频、AR游戏、AR设备等相关知识教程,柚子AR,打造增强现实行业交流聚集地。ChinaAR－－中国AR网,是国内第一家打造增强现实技术交流的一个自媒体平台!意在打造中国AR爱好者对AR技术的交流与学习的一个平台AR 中国－－AR中国是专注于增强现实技术的新闻门户网站AR 技术网Realseer 增强现实视频合辑增强现实技术1-31篇技术视频教程合集 Vuforai 教程精选Vuforia 公开课－－包括Vuforia 环境搭建，多图识别，单页翻页效果，模型自动旋转…VUforia 视频合辑Vuforia 官方教程Vuforia 论坛Vuforia 论坛Vufoira 涂涂乐文章教程－－讲解详细Vuforia 实现物体阴影特效Vuforia 多图识别Vuforia 脱卡Vuforia SDK—- AR开发vuforia实现拍照截屏功能 EasyAR教程精选Leap Motion+EasyAR AR手势开发教程AR从入门到精通开发系列教程(1)—搭建开发环境AR从入门到精通开发系列教程(2)–创建模型并互动EasyAR 公开课EasyAR 文档EasyAR官方Sample之涂涂乐EasyAR 论坛带你开发类似Pokemon Go的AR游戏(1)带你开发类似Pokemon Go的AR游戏(2) HiAR 教程HiAR 官方文档－－看完之后就掌握的大概了，官方文档很详细了。HiAR 论坛HiAR 论坛HiAR SDK 教学视频 其他平台教程太虚AR教程太虚AR学习Metaio 学习Wikitude 公开课太虚AR公开课 Google tango教程Tango SDK 下载（提取码：sh18）跟着Shrek Team学tangoProject Tango 知识原理Google Tango 项目 AR 技术文章两家AR专利大厂在AR硬件方面的探索增强现实技术及其应用全球首份VR/AR医疗健康产业应用创新报告 AR 精选论文基于ARM和OpenCV的增强现实平台研究基于Android的增强现实技术研究与实现增强现实应用技术研究基于ARTOOLKIT的增强现实技术在恐龙博物馆中的应用研究基于增强现实技术的虚拟留言墙系统的设计与实现基于智能移动终端的移动增强现实应用研究与实现 基于unity3d的移动增强现实技术与应用研究分析增强现实中标记设计与识别方法研究户外增强现实gis的应用研究手持式增强现实神经导航关键技术研究及其系统建立基于ARToolKit平台的增强现实人机交互系统的若干问题研究基于ARToolkit的汉字识别系统的设计与实现基于ARToolKit的增强现实技术在恐龙博物馆中的应用研究 AR应用精选视+AR－－搭载独立开发的EasyAR引擎，全新视+2.0强势来袭！包罗丰富ar内容的增强现实浏览器，等你来体验！AR–这是一款增强现实AR的应用，主要分为三部分：LOL人物展示（带有经典音效），太空大战，手势交互（可以旋转与缩放）。突破现在AR格局，给玩家带来更多的乐趣。你只需一张个人身份证的反面，便会通过AR得到一个精彩的世界！小熊尼奥产品增强现实优秀应用－－大部分是国外的。十一用12个案例SoLoMo，AR+LBS让你脑洞大开的AR技术应用13款最叫绝的增强现实应用9款超赞的AR教育APP参考原文","categories":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/categories/资源/"}],"tags":[{"name":"AR","slug":"AR","permalink":"https://huos3203.github.io/tags/AR/"},{"name":"LBS+AR","slug":"LBS-AR","permalink":"https://huos3203.github.io/tags/LBS-AR/"},{"name":"QQ红包","slug":"QQ红包","permalink":"https://huos3203.github.io/tags/QQ红包/"}]},{"title":"Awsome Apple Develop Guide[转]","slug":"swift/AwsomeAppleDevelopGuide","date":"2017-01-22T18:55:21.000Z","updated":"2017-01-23T17:34:23.000Z","comments":true,"path":"2017/01/23/swift/AwsomeAppleDevelopGuide/","link":"","permalink":"https://huos3203.github.io/2017/01/23/swift/AwsomeAppleDevelopGuide/","excerpt":"","text":"此文档是Apple平台开发所使用语言的主流学习资源 iOS开发者博客 使用 iOSBlogCN添加或者订阅 从社区学习知识 iOS技术周报 objc中国 cocoachina Swift社区 从iOS面试题总结iOS有用的面试题 建议－学习iOS之前快速预览一下MAC开发环境配置 什么是Swift，如何评价 Swift 语言？ 了解一下Objective-C是什么 iOS开发60分钟入门 Start Developing iOS Apps Today 从零开始学iOS开发的15条建议 自学iOS开发的一些经验 学习路线 语言学习这里包括了Swift，Objective-C，C，C++ 中文版 Apple 官方 Swift 教程《The Swift Programming Language》1.2 中文版 Apple 官方 Swift 教程《The Swift Programming Language》2.0 The Official raywenderlich.com Swift Style Guide The Official raywenderlich.com Swift Style Guide 中文版 Using Swift with Cocoa and Objective-C中文手册 C 语言常见问题集 Google Objective-C Style Guide 中文版 Google C++ Style Guide 中文版 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译 免费视频资源玩儿转Swift 征战Objective-C 斯坦福大学公开课：iOS 7应用开发 斯坦福大学公开课：Swift开发iOS 8应用－中文字幕 斯坦福大学公开课：Swift开发iOS 8应用 WWDC 2015 Video 英文字幕 (共104个) WWDC2015下载链接 精粹一些 iOS / Web 开发相关的翻译或原创博客文章 iOS-Core-Animation-Advanced-Techniques objc.io中文翻译版本 这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排 A curated list of awesome iOS UI/UX libraries iOS8-Day-by-Day blog series iOS9 Day-by-Day blog series matteocrippa/awesome-swift Wolg/awesome-swift awesome-ios Swift | Objective-C | C/C++ | 设计 资源集合Alamofire网络库基础教程 C 语言中的指针和内存泄漏 C/C++编程的现代习惯 Swift指针的使用 Swift tips Study iOS心得 A curated list of delightful iOS resources. 优秀外文翻译资源集合 详解Swift中的iOS设计模式 在iOS8 下用Swift 创建自定义的键盘 Swift和自动引用计数(ARC)整理之强，弱和无主引用 自己动手写一个 iOS 网络请求库（一）—— NSURLSession 初探 ReactiveCocoa 3.0 初窥 Swift 2 有哪些新特性 如何使用Instruments诊断App（Swift版）：起步 理解 ARC 下的循环引用 Swift 2.0初探 2013 CocoaChina微信精选之技术汇 理解 Objective-C 的 ARC iOS开发的一些奇巧淫技 我推荐的一些iOS开发书单 叶孤城___ iOS性能优化 iOS 调试核对清单 iOS APP 测试点摘要 GCD使用经验与技巧浅谈 iOS 开发实践之 Auto Layout I Found You! 正则表达式! iOS 开发中的消息传递机制 iOS扫一扫功能开发 给游戏开发者们的 7 个制作建议 iOS另类的内存管理 iOS runloop 正确使用Block避免Cycle Retain和Crash 为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权 iOS事件分发机制（一） hit-Testing iOS事件分发机制（二）：The Responder Chain iOS富文本组件的实现—DTCoreText源码解析 渲染篇 iOS富文本组件的实现—DTCoreText源码解析 数据篇 GCD概述、语法以及好的示例 通过减少动态派送提升性能 NSString属性什么时候用copy，什么时候用strong? NSRecursiveLock递归锁的使用 在iOS上以root身份运行守护进程 iOS开发中两个常见问题的处理 iOS 8增强的自动布局功能 Theos介绍 iOS中几种定时器 - 控制了时间，就控制了一切 iOS view的frame和bounds之区别（位置和大小） iOS应用程序的生命周期 2015 Objective-C 三大新特性 | 干货 “自释放”在iOS开发中的应用 关注被忽略的 Objective-C、Swift 和 Cocoa 特性 Swift开发游戏步骤 关于iOS编码规范 Objective-C开发编码规范（一） Objective-C开发编码规范（二） Swift扩展的三个微妙细节 Objective-C类成员变量深度剖析 Swift基础(一) iOS7人机界面指南 iphone6 屏幕设计揭秘 mobile设计 iOS常用框架 iOS面试基础知识36题 GitHub 上排名前 50 的 Objective-C 项目简介 一些知名App用到的第三方库汇总 Github优秀开源项目大全-iOS [iOS单元测试系列]单元测试框架选型 购物商城的Demo 斯坦福大学公开课：iOS 7 应用开发 Demo iOS-Swift-Demos iOS 无障碍开发指导 TestingWithXcode中文文档 苹果Xcode帮助文档阅读指南 iOS项目的持续集成与管理 （译）WebViewJavascriptBridge－Obj-C和JavaScript互通消息的桥梁 截获导航控制器系统返回按钮的点击pop及右滑pop事件 UITableView常用属性和方法 Swift新特性 – 访问控制（Access Control） ViewController Programming Guide 笔记（一） HTTP Live Streaming直播(iOS直播)技术分析与实现 Mantle 初步使用 使用CAReplicatorLayer创建动画 iOS动画——ViewAnimations iOS动画——Layer Animations 收集整理了下iOS平台下比较主流炫酷的几款动画框架 Masonry介绍与使用实践(快速上手Autolayout) iOS学习之Autolayout 如何实现一个不规则排列的图片布局算法 | 干货 响应式视图 微软前员工：开发Apple Watch应用的27个技巧 Apple Watch开发初探 Apple Watch开发专题 深入理解Objective-C：方法缓存 优化UITableViewCell高度计算的那些事 一个完整的Core Data应用 iOS安全系列之一：HTTPS block基础篇 block终极篇 关于iOS多线程，你看我就够了 Objective-C Run time轻松学习之三——IMP指针的作用 轻松学习之二——iOS利用Runtime自定义控制器POP手势动画 Cocoa Runtime系统知识整理 理解 Objective-C Runtime Objective-C isa 指针 与 runtime 机制 Objective-C Runtime Objective-C Runtime Objective-C特性：Runtime 项目结构经验iOS 项目的目录结构能看出你的开发经验 iOS项目架构探索 iOS应用架构谈系列 学习UIiOS组件之UIScrollView详解 UIScrollView 实践经验 参考原文","categories":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/categories/资源/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/tags/iOS/"},{"name":"汇总","slug":"汇总","permalink":"https://huos3203.github.io/tags/汇总/"},{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/tags/资源/"}]},{"title":"iOS面试题大集合[转]","slug":"swift/iOS面试题大集合","date":"2017-01-22T18:55:21.000Z","updated":"2017-01-22T18:55:21.000Z","comments":true,"path":"2017/01/23/swift/iOS面试题大集合/","link":"","permalink":"https://huos3203.github.io/2017/01/23/swift/iOS面试题大集合/","excerpt":"","text":"iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。 Now！！请使用ARC 什么是iOS开发iOS是iPhone iPad等手持设备的操作系统，所谓的iOS开发就是开发运行在iOS系统上的应用或者游戏，比如支付宝，微信，微博等，当然这也包括了iPad版的应用，iOS开发可以归纳到移动开发领域。 有时候面试官是那种’脑残粉’，了解一下Apple的发展历史，可能比较聊的开。 苹果Mac计算机31年发展历程回顾 苹果公司 苹果公司在知乎上的话题 乔布斯个人传记 拼写正确的重要性有些面试官可能更注重细节，所以，拼写的单词一定要对，比如iOS，Xcode，iPhone，Objective-C，JSON等，良好的拼写习惯，会让面试官觉得你细心靠谱。 Swift和Objective-C的比较仁者见仁智者见智，从个人的使用角度上来看，Swift在某些情况上比Objective-C更加的严谨了，入门非常简单，但是想开发应用，还是需要学习cocoa框架，这玩意路子还是Objective-C的，所以有基础可能更好的理解Swift在iOS/Mac OS X 中的开发和应用。 知乎原文 了解Watch OSWatch OS是苹果公司推出的应用在手表上的一个操作系统，Watch OS 1.0需要跟iPhone相结合才能工作。 Apple Watch Watch OS 2.0 开发概述 iOS面试property 后面可以有哪些修饰符 读写修饰符 readwrite | readonly readwrite Xcode会帮助我们创建setter，getter方法，readonly Xcode只会帮助我们创建getter方法，不会创建setter方法。 setter相关的修饰符 assign | retain | copy 2.1 setter相关的修饰符表明了setter方法该如何实现，assign用于基本数据类型NSInteger，CGFloat，C数据类型int，float，id类型等，这个符号不会涉及内存管理，但是如果是对象类使用了它，可能会导致内存泄漏或者EXC_BAD_ACCESS错误。 2.2 retain用于对象类的内存管理，如果基本数据类型使用它，Xcode会直接报错。当对象类使用此修饰符时，setter方法的实现是先release一次，然后再对新的对象做一次retain操作。 2.3 copy主要用于NSString，用于内容复制。 原子性修饰符 atomic | nonatomic atomic 表示线程安全 nonatomic 表示非线程安全，使用此修饰符会提高性能 getter，setter修饰符 这两个修饰符用于设置生成的getter，setter的方法名 strong，weak修饰符（ARC）在ARC中内存管理都只需要使用这两个修饰符，而且strong是默认全局的，只要你写了Objective-C的对象，不自己添加weak的话，默认就是strong。 5.1 strong表示这个对象的拥有者 一个对象可以有多个拥有者，strong就是用来表示对这个对象的拥有。比如在往NSMutableArray中添加Objective-C对象，当你从数组中删除时，这个对象并不会释放。需要你手动设置为nil，或者在控制器的生命周期内，由系统来释放。 5.2 weak指针变量仍然可以指向一个对象，但不是这个对象的拥有者 weak修饰的指针变量也可以指向对象，但不是这个对象的实际拥有者，也就是说weak修饰的指针变量如果想要释放，需要strong修饰的指针变量设置为nil，weak修饰的指针变量也会是一个nil，它指向的对象已经没有了，还需要设置weak修饰的指针变量为nil。 nonnull nullable null_resettable Xcode 6.3推出的nullability annotations，主要是为了更好的Swift与Objective-C混编，在Swift中有可选型的概念!,?，但是Objective-C中木有这玩意，于是Xcode 6.3中才有了这个，从字面可以看出: nonnull 表示对象不应该为空，如果是这个修饰符对应的就是Swift中已经解包的对象或者! nullable表示可以为nil或者NULL,对应是Swift中的可选? null_resettable则是表达属性的空属性，该属性setter访问器允许将其设置为nil（设置该属性为默认值），但是它的getter访问器不会提供一个nil值（因为它提供了默认值），有一个这样的属性如UIView’s tintColor，如果没有tint颜色指定时它会提供一个默认的tint颜色值，对应的Swift使用是var tintColor:UIColor! 实战 使用 weak 关键字，相比 assign 有什么不同 一般情况下使用weak是避免循环引用，因为它不是对象的拥有者。而assign则是用于基本数据类型，或者C类型，而且assign是直接赋值，可能会导致一个问题。比如我想a和b共用一块内存，a是用assign修饰的，a = b，现在a使用的目的已经完成，我想释放这个内存，但是a并不知道b到底用没用完，如果此时a释放内存，而b还在使用，那么会导致应用程序crash，使用weak就能避免这样的问题。 怎么用 copy 关键字 copy拷贝的是内容,retain是拷贝的指针* 以`string`为例,如果`string`的属性为`copy`的话,那么传入参数为`NSString`的话,即为不可变`string`,`retain`,`copy`效果一样. * 如果传入参数是`mutable`的话,那么`copy`拷贝内容,源随意变化不影响该属性的值.`retain`拷贝指针,源变化则属性值着变化,因为属性和源指向如何使用呢,通常在需要拷贝内容,但是副本和源不要互相影响的情况下使用.`*` 同一内存地址. * 例如`array/dictionary`中,可能会需要一个副本来做一些操作(筛选,排序等),但是并不希望影响原始值,则可以使用`copy` @property (copy) NSMutableArray *array; 这样写有什么问题吗 因为用了copy, 内部会深拷贝一次, 指针实际指向的是NSArray, 所以如果调用removeObject和addObject方法的话, 会unRecognized selector 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 当一个对象发生改变时不影响另外一个对象，这里就需要使用copy关键字了，实现NSCopying协议，重写- (id)copyWithZone:(NSZone *)zone方法。1234567- (void)setName:(NSString *)name&#123; if(_name != name) &#123; _name = [name copy]; &#125;&#125; @protocol 和 category 中如何使用 @property @protocol可以通过关键字:@synthesize或者在继承的类里面重新定义一次该属性(extension里面定义是不行的) category通过关联:objc_setAssociatedObject/objc_getAssociatedObject @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property本质是定义一个objc_property结构体如何生成目前不清楚 weak属性需要在dealloc中置nil么 不需要，因为weak会自动设置nil @synthesize和@dynamic分别有什么作用 关于@synthesize（现在已经不需要在写这个属性了，它是用来生成getter和setter方法） @dynamic 就是要告诉编译器getter和setter方法会在程序运行或者用到动态绑定的方式，以便让编译器通过编译，这个主要要在NSManagerObject上。 ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些 在默认情况下，所有的实例变量和局部变量都是strong类型的。 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题因为不想改变了其中的值后把原来的值也跟着改变了，用了strong后会出现这样的状况。 什么是ARC请阅读，然后随便谈谈你的理解即可。ARC是为了解决下面几个问题 当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。（避免提前释放） 释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（MRC下即谁创建，谁释放，避免重复释放） 模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。 多线程操作时，不确定哪个线程最后使用完毕手把手教你ARC——iOS/Mac开发ARC入门和使用理解 Objective-C 的 ARC 请解释以下keywords的区别： assign vs weak, block vs weakassign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。 assign其实也可以用来修饰对象，那么我们为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。 block是用来修饰一个变量，这个变量就可以在block中被修改，使用block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain） weak：使用weak修饰的变量不会在block代码块中被retain同时，在ARC下，要避免block出现循环引用 weak typedof(self)weakSelf = self __block在arc和非arc下含义一样吗是不一样的，ARC会retain，非ARC不会。 描述一个你遇到过的retain cycle例子在viewController中避免循环引用123[ downloadData:^(id responseData)&#123; _data = responseData;&#125;]; 解决办法1234__weak ViewController *weakSelf = self;[ downloadData:^(id responseData)&#123; weakSelf.data = responseData;&#125;]; +(void)load; +(void)initialize;有什么用处在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。共同点：两个方法都只会被调用一次。 UIView和CALayer有什么关系 UIView是iOS界面元素的基础，所有的界面元素都继承于它。它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer的类来管理的，UIView本身更像是一个CALayer的管理器。 UIView都存在一个layer属性，可以访问到CALayer的实例。 UIView的CALayer类也存在一个view树结构，可以像UIView一样进行添加 UIView的layer树在系统内部，由系统来维护，它存在着三棵树，分别是逻辑树，动画树，显示树 如何高性能的给UIImageView加个圆角 使用贝塞尔曲线来切割图片 使用Quartz2D直接绘制图片 使用drawRect有什么影响drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。 SDWebImage里面给UIImageView加载图片的逻辑是什么样的详情看最新版SDWebImage的使用 麻烦你设计个简单的图片内存缓存器图片的内存缓存，可以考虑将图片数据保存到一个数据模型中，所以在程序运行时这个模型都存在内存中，一定要具备移除策略，即释放数据模型。 讲讲你用Instrument优化动画性能的经历怎么使用instrument loadView是干嘛用的当你访问一个ViewController的view属性时，如果此时view的值是nil，那么，ViewController就会自动调用loadView这个方法。这个方法就会加载或者创建一个view对象，赋值给view属性。loadView默认做的事情是：如果此ViewController存在一个对应的nib文件，那么就加载这个nib。否则，就创建一个UIView对象。如果你用Interface Builder来创建界面，那么不应该重载这个方法。如果你想自己创建view对象，那么可以重载这个方法。此时你需要自己给view属性赋值。你自定义的方法不应该调用super。如果你需要对view做一些其他的定制操作，在viewDidLoad里面去做。iOS 的loadView 及使用loadView中初始化View注意的问题 用过CoreData或者SQLite吗？读写是分线程的吗？遇到过死锁没？咋解决的参考CoreData与SQLite的线程安全 GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的 主队列 dispatch_main_queue(); 串行 ，更新UI 全局队列 dispatch_global_queue(); 并行，四个优先级：background，low，default，high 自定义队列 dispatch_queue_t queue; 可以自定义是并行：DISPATCH_QUEUE_CONCURRENT或者串行DISPATCH_QUEUE_SERIAL 为什么其他语言里叫函数调用， Objective-C里则是给对象发消息（或者谈下对runtime的理解）网上关于runtime的资料非常多，其实这方面在平时的开发中使用非常非常之少，底层的黑魔法。Objective-C特性：RuntimeObjective-C Runtime 什么是method swizzling在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。详细的案例 runtime 如何实现 weak 属性 123456OBJC_ASSOCIATION_ASSIGNOBJC_ASSOCIATION_RETAIN_NONATOMICOBJC_ASSOCIATION_COPY_NONATOMICOBJC_ASSOCIATION_RETAINOBJC_ASSOCIATION_COPYobjc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN); 可以自定义weak来实现内存管理，Apple已经为我们准备了常量。参考Associated ObjectsObjective-C Runtime 运行时之二：成员变量与属性 objc中向一个nil对象发送消息将会发生什么objc的特性是允许对一个 nil 对象发送消息不会 Crash，因为会被忽略掉。 什么时候会报unrecognized selector的异常调用一个不存在的方法 objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系1234567[obj foo];//编译时会变成objc_msgSend(obj,@selector(foo));[obj foo:parameter];//编译时会变成objc_msgSend(obj,@selector(foo:),parameter); 一个objc对象如何进行内存布局可参考Objective-C内存布局 一个objc对象的isa的指针指向什么？有什么作用？isa是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。 下面的代码输出什么123456789101112@implementation Son : Father- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); &#125; return self;&#125;@end 输出Son runtime如何通过selector找到对应的IMP地址id (*IMP)(id, SEL, …)这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。 Hybrid 混合开发","categories":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/categories/资源/"}],"tags":[{"name":"汇总","slug":"汇总","permalink":"https://huos3203.github.io/tags/汇总/"},{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/tags/资源/"},{"name":"面试","slug":"面试","permalink":"https://huos3203.github.io/tags/面试/"}]},{"title":"腾讯云之小直播开发","slug":"其他/腾讯云之小直播开发","date":"2017-01-22T18:55:21.000Z","updated":"2018-10-05T21:42:35.000Z","comments":true,"path":"2017/01/23/其他/腾讯云之小直播开发/","link":"","permalink":"https://huos3203.github.io/2017/01/23/其他/腾讯云之小直播开发/","excerpt":"","text":"视频服务 直播LVB 开发指南 移动直播MLVB 开发指南移动直播是一套移动终端直播解决方案的集合，它以免费源码的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。 快速集成方案 如果您想要在自己的 APP 里集成直播推流和播放功能，下面三步就能达成目标： 开通直播服务文档 集成 RTMP SDKRTMP SDK - iOS 平台播放 对接直播流管理 云端API - 如何获取推流URL？ 云端API - 如何构建房间列表？ 云端API - 如何管理直播流？小直播是有腾讯云研发团队提供的一套开源源码集，致力于以 DEMO 的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"迁移SVN库到git库保留branchs和tags","slug":"git/迁移SVN库到git库保留branchs和tags","date":"2017-01-18T12:21:46.000Z","updated":"2019-01-16T21:01:13.000Z","comments":true,"path":"2017/01/18/git/迁移SVN库到git库保留branchs和tags/","link":"","permalink":"https://huos3203.github.io/2017/01/18/git/迁移SVN库到git库保留branchs和tags/","excerpt":"","text":"SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository. 首先导入一个本地存储库在本地创建一个存储库的目录新建目录Create a local staging directory123cd ~mkdir stagingcd staging 注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。 初始化git svn使用SVN标准库结构初始化标准初始化1git svn init SVNRepo_ROOT_URL --stdlayout --prefix=svn/ SVNRepo_ROOT_URL: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：trunk，branches， tags。--prefix: 强烈建议使用svn/作为分支和标签的前缀：设置为 --prefix=svn/. 这样有助于防止Git用户混淆原声的Git分支和标签。 使用SVN自定义库结构初始化使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录：非标准化1git svn init SVN_URL -T Trunk -b Branches -t Tags --prefix=svn/ 查看配置信息 review命令1review the config 会有以下信息输出：123svn-remote.svn.url=svn://svn.example.comsvn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunksvn-remote.svn.tags=some/path/tags/*:refs/remotes/svn/tags/* 高级用户可以在执行之前，修改相关配置。 git config命令123456789101112131415161718192021git config --local --list 输出：core.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=truesvn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Macsvn-remote.svn.fetch=trunk:refs/remotes/origin/trunksvn-remote.svn.branches=branches/*:refs/remotes/origin/*svn-remote.svn.tags=tags/*:refs/remotes/origin/tags/*remote.PBBReader.url=https://git.oschina.net/iTBoyer/PBBReader.gitremote.PBBReader.fetch=+refs/heads/*:refs/remotes/PBBReader/*branch.master.remote=PBBReaderbranch.master.merge=refs/heads/masterremote.server.url=https://server.local/git/PBBReader.gitremote.server.fetch=+refs/heads/*:refs/remotes/server/*branch.v34.remote=PBBReaderbranch.v34.merge=refs/heads/v28 从远程SVN服务器拉取代码到新建的本地存储库拉取1git svn fetch 查看本地库状态statusstatus1git status 输出：内容12# On branch masternothing to commit (working directory clean) 查看分支信息branch1git branch -a 输出:123* masterremotes/svn/tags/0.1.0remotes/svn/trunk 注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。 SVN分支和标签转为本地git仓库中的标签和分支SVN分支迁移把远程svn分支转换为本地git仓库中的分支：分支转分支123for branch in `git branch -r | grep \"branches/\" | sed 's/ branches\\///'`; dogit branch $branch refs/remotes/$branchdone SVN标签迁移 把远程svn标签转换为本地git仓库中的标签 :tags转换tags123for tag in `git branch -r | grep \"tags/\" | sed 's/ tags\\///'`; dogit tag -a -m\"Converting SVN tags\" $tag refs/remotes/$tagdone SVN标签转为本地git分支 把远程svn标签转换为本地git仓库中的分支:标签转分支123for tag in `git branch -r | grep \"tags/\" | sed 's/ tags\\///'`; dogit branch $tag refs/remotes/$tagdone 在本地测试git命令push和clone操作在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。 创建一个临时的git库，用于测试push和clone测试在git中的说法，bare库是一个不存在工作空间备份的库。bare创建1234cd ~mkdir testcd testgit init --bare这样，在~/test就生成了一个baregit库。 push 测试1234cd ~/staginggit remote add test `~/test`git push --all testgit push --tags test 把~/test的放在反引号中，反引号在命令行中会~自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。尽管它的名字，--all选项不推送tags，所以需要对标签单独push操作。 clone 测试1234cd ~mkdir aclonecd aclonegit clone ~/test There should now be a clone with a working copy in ~/aclone/test.在~/aclone/test目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。 Push到正式git库中如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。以Unfuddle为例,路径如下：`git@example.unfuddle.com:example/blah.git1234cd ~/staginggit remote add unfuddle REAL_HOST_URLgit push --all unfuddlegit push --tags unfuddle 在上面的例子中，制定了远程名：unfuddle而不是默认的origin`。当然，你可以使用任何你喜欢的名字。 清理操作删除临时git库12cd ~/staginggit remote rm test staging库忽略test远程仓库. 清除clone生成的库123cd ~rm -rf aclonerm -rf test Either keep or delete the staging repo 如果需要Git和SVN之间频繁交互，建议保留staging库这会节省你非常耗时的初始化：1git svn fetch 如果你确信svn是报废的，你可以删除：12cd ~rm -rf staging 题外小贴士在局域网内访问server搭建服务器提供的git服务：小贴士SSL证书问题12$ git clone https://.../git/mupdf.git错误：fatal: unable to access 'https://..../git/mupdf.git/': SSL certificate problem: Invalid certificate chain解决：1git config --global http.sslVerify false","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"svn","slug":"git/svn","permalink":"https://huos3203.github.io/categories/git/svn/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/tags/git/"},{"name":"svn","slug":"svn","permalink":"https://huos3203.github.io/tags/svn/"},{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"},{"name":"git-svn","slug":"git-svn","permalink":"https://huos3203.github.io/tags/git-svn/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"swift错误处理","slug":"swift/错误处理","date":"2017-01-11T17:04:21.000Z","updated":"2017-01-12T11:57:41.000Z","comments":true,"path":"2017/01/12/swift/错误处理/","link":"","permalink":"https://huos3203.github.io/2017/01/12/swift/错误处理/","excerpt":"Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。 Representing and Throwing ErrorsIn Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.在swift中，错误类型是遵循Error 协议。 Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如：一个在操作一台游戏机时的会出现的错误枚举类：12345enum VendingMachineError: Error &#123;case invalidSelectioncase insufficientFunds(coinsNeeded: Int)case outOfStock&#125; Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：1throw VendingMachineError.insufficientFunds(coinsNeeded: 5) Handling ErrorsWhen an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。 There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.在swift中有四种处理错误机制: 1. 向调用方法中传递这个错误 2. 使用do-catch语句处理 3. 把错误设置为可选型 4.断言不会出现异常的情况下，使用try!禁止异常抛出 When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字try 要注意 try?或try!之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。 Propagating Errors Using Throwing FunctionsTo indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-&gt;).函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：throws即可，这种方法被称为throws函数，throws关键字位置在参数之后，返回值(-&gt;)之前 A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.抛出函数会把错误抛给调用它的函数周期中去。","text":"Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。 Representing and Throwing ErrorsIn Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.在swift中，错误类型是遵循Error 协议。 Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如：一个在操作一台游戏机时的会出现的错误枚举类：12345enum VendingMachineError: Error &#123;case invalidSelectioncase insufficientFunds(coinsNeeded: Int)case outOfStock&#125; Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：1throw VendingMachineError.insufficientFunds(coinsNeeded: 5) Handling ErrorsWhen an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。 There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.在swift中有四种处理错误机制: 1. 向调用方法中传递这个错误 2. 使用do-catch语句处理 3. 把错误设置为可选型 4.断言不会出现异常的情况下，使用try!禁止异常抛出 When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字try 要注意 try?或try!之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。 Propagating Errors Using Throwing FunctionsTo indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-&gt;).函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：throws即可，这种方法被称为throws函数，throws关键字位置在参数之后，返回值(-&gt;)之前 A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.抛出函数会把错误抛给调用它的函数周期中去。 Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function.只有抛出函数能传递错误，如果不是抛出函数，它自己必须处理掉任何抛进来的错误。 In the example below, the VendingMachine class has a vend(itemNamed:) method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:在下面的例子中，对某个请求内容不可用时，自动售货机会通过vend(itemNamed:)方法抛出一个对应的VendingMachineError错误，缺货或超过目前的存款金额成本：123456789101112131415161718192021222324252627282930struct Item &#123; var price: Int var count: Int&#125;class VendingMachine&#123; var inventory = [ \"Candy Bar\": Item(price: 12, count: 7), \"Chips\": Item(price: 10, count: 4), \"Pretzels\": Item(price: 7, count: 11) ] var coinsDeposited = 0 func vend(itemNamed name: String) throws &#123; guard let item = inventory[name] else &#123; throw VendingMachineError.invalidSelection &#125; guard item.count &gt; 0 else &#123; throw VendingMachineError.outOfStock &#125; guard item.price &lt;= coinsDeposited else &#123; throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited) &#125; coinsDeposited -= item.price var newItem = item newItem.count -= 1 inventory[name] = newItem print(\"Dispensing \\(name)\") &#125;&#125; The implementation of the vend(itemNamed:) method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.vend(itemNamed:)方法的实现中使用 guard语句来判断，当在购买操作不符合相应条件会直接抛出相应的错误，来打断该方法的其他操作。因为throw语句会立即转移程序控制权，保证了机器仅出售满足所有条件的物品。 Because the vend(itemNamed:) method propagates any errors it throws, any code that calls this method must either handle the errors—using a do-catch statement, try?, or try!—or continue to propagate them. For example, the buyFavoriteSnack(person:vendingMachine:) in the example below is also a throwing function, and any errors that the vend(itemNamed:) method throws will propagate up to the point where the buyFavoriteSnack(person:vendingMachine:)function is called.因为vend(itemNamed:)的方法抛出所有错误，所以调用该方法的函数必须处理错误（ do-catch, try?, or try!处理，或使用try向上抛出）。 例如，buyFavoriteSnack(person:vendingMachine:)也是一个抛出函数，从vend(itemNamed:)方法接受到的所有错误，都会被会buyFavoriteSnack(person:vendingMachine:)继续抛给调用它的函数中。12345678910let favoriteSnacks = [ \"Alice\": \"Chips\", \"Bob\": \"Licorice\", \"Eve\": \"Pretzels\",]func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123; let snackName = favoriteSnacks[person] ?? \"Candy Bar\" try vendingMachine.vend(itemNamed: snackName)&#125; In this example, the buyFavoriteSnack(person: vendingMachine:) function looks up a given person’s favorite snack and tries to buy it for them by calling the vend(itemNamed:) method. Because the vend(itemNamed:) method can throw an error, it’s called with the trykeyword in front of it.buyFavoriteSnack(person: vendingMachine:) 函数查找买家中意的snake，并vend(itemNamed:)调用尝试购买。使用在方法前使用try关键字来抛出异常，并向上传递。 Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the PurchasedSnackstructure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.抛出构造器也能向抛出函数一样传递错误，例如：PurchasedSnackstructure的构造器中调用了抛出函数：vend(itemNamed:)，抛出构造器可以通过向上传递来处理这些错误。12345678struct PurchasedSnack &#123; let name: String init(name: String, vendingMachine: VendingMachine) throws &#123; try vendingMachine.vend(itemNamed: name) self.name = name &#125;&#125; Handling Errors Using Do-CatchYou use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the do clause, it is matched against the catchclauses to determine which one of them can handle the error.使用do-catch语句通过运行代码块来处理错误。在do分句中如果抛出了一个错误，那么就可以在catch分句中进行处理的匹配到错误Here is the general form of a do-catchstatement:12345678do &#123; try expression statements&#125; catch pattern 1 &#123; statements&#125; catch pattern 2 where condition &#123; statements&#125; You write a pattern after catch to indicate what errors that clause can handle. If a catch clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named error. For more information about pattern matching, see Patterns.在关键字catch后边跟随匹配模式，这个catch分句就会处理匹配到的错误，如果关键字catch分句没有任何匹配模式，那么这个分句将会匹配到所有错误，并把这些错误信息赋值给系统常量error。 The catchclauses don’t have to handle every possible error that the code in its do clause can throw. If none of the catch clauses handle the error, the error propagates to the surrounding scope. However, the error must be handled by some surrounding scope—either by an enclosing do-catch clause that handles the error or by being inside a throwing function. For example, the following code handles all three cases of the VendingMachineErrorenumeration, but all other errors have to be handled by its surrounding scope:catch分句不必对do分句中的代码可能抛出每一个的错误，如果某个错误没有被catch分句匹配到处理，这个错误将会传递到调用它的函数周期中，这个错误必须在这个函数周期中处理，或通过do-catch语句来处理，或通过内部的抛出函数处理。 例如，下面的代码处理VendingMachineError枚举类中的三个错误cases，但其他的错误都是由其周边范围处理：123456789101112var vendingMachine = VendingMachine()vendingMachine.coinsDeposited = 8do &#123; try buyFavoriteSnack(person: \"Alice\", vendingMachine: vendingMachine)&#125; catch VendingMachineError.invalidSelection &#123; print(\"Invalid Selection.\")&#125; catch VendingMachineError.outOfStock &#123; print(\"Out of Stock.\")&#125; catch VendingMachineError.insufficientFunds(let coinsNeeded) &#123; print(\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\")&#125;// Prints \"Insufficient funds. Please insert an additional 2 coins.\" In the above example, the buyFavoriteSnack(person:vendingMachine:) function is called in a try expression, because it can throw an error. If an error is thrown, execution immediately transfers to the catch clauses, which decide whether to allow propagation to continue. If no error is thrown, the remaining statements in the do statement are executed.在上述代码中因为buyFavoriteSnack(person:vendingMachine:)函数会抛出错误异常，所以要在try表达式中调用。如果抛出异常就会立马执行是否继续传递的catch分句，如果没有抛出异常，会保持do分句中的代码正常进行。 Converting Errors to Optional ValuesYou use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the try? expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior:使用try?表达式处理错误，是通过把错误转换为可选值(?)类型处理。在try?表达式中出现抛出错误时，这个表达式的值=nil。12345678910func someThrowingFunction() throws -&gt; Int &#123; // ...&#125;let x = try? someThrowingFunction()let y: Int?do &#123; y = try someThrowingFunction()&#125; catch &#123; y = nil&#125; If someThrowingFunction() throws an error, the value of x and y is nil. Otherwise, the value of x and y is the value that the function returned. Note that x and y are an optional of whatever type someThrowingFunction() returns. Here the function returns an integer, so xand y are optional integers.如果函数someThrowingFunction()抛出异常，x,y = nil，否则:x,y就时函数return的值。 注意：x,y是一个可选的someThrowingFunction()返回类型。在这里函数返回integer，那么x,y是可选的integer类型。 Using try? lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.当用这种方式来处理所有错误时，使用try?表达式能写更简洁的错误处理代码，例如：下面的代码使用几种方法来获取数据，如果这些方法失败就会返回nil。12345func fetchData() -&gt; Data? &#123;if let data = try? fetchDataFromDisk() &#123; return data &#125;if let data = try? fetchDataFromServer() &#123; return data &#125;return nil&#125; Disabling Error PropagationSometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write try! before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.有时你认为不会出现异常的抛出函数或方法，但事实上，却在运行时抛出异常了。在其他情况下，可以使用try!表达式来禁止错误传递，并且十分肯定断言在运行时不会有异常抛出。如果有异常抛出，就会得到一个运行时错误。 For example, the following code uses a loadImage(atPath:) function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.例如：使用loadImage(atPath:)函数要么通过这个路径加载image，要么image加载失败抛出一个错误。在这种情况下，因为image在app资源目录resources中，所以在运行时肯定不会有异常抛出。因此可以使用try!禁止错误传递。1let photo = try! loadImage(atPath: \"./Resources/John Appleseed.jpg\") Specifying Cleanup ActionsYou use a defer statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break. For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.在代码执行离开当前代码块之前，使用一个“defer语句”来执行一组语句。defer语句让做一些必要的清理操作，在执行如何离开当前代码块：因为抛出异常或者因为return，break语句导致。例如：使用defer语句执行关闭文件和内存的释放操作，来确保清理操作完成。 A defer statement defers execution until the current scope is exited. This statement consists of the defer keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error. Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on.defer语句推迟在直到当前作用域推出时，再执行。defer语句由defer关键字和一些清理操作语句组成。defer语句不包含transfer control out of the statements例如（return，break，throw）等。 defer延迟操作是按照指定的顺序执行的，就是先执行最后一个defer语句中的代码之后，再执行第倒数第二个defer语句的代码，以此类推，倒叙清理退场。12345678910111213func processFile(filename: String) throws &#123; if exists(filename) &#123; let file = open(filename) defer &#123; close(file) &#125; while let line = try file.readline() &#123; // Work with the file. &#125; // close(file) is called here, at the end of the scope. &#125;&#125; The above example uses a defer statement to ensure that the open(_:) function has a corresponding call to close(_:).使用defer语句，确保了在open的同时与之相关的还有close。 You can use a defer statement even when no error handling code is involved.即使在没有涉及错误处理代码的时候，也可以使用“延迟”语句。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"语法","slug":"swift/语法","permalink":"https://huos3203.github.io/categories/swift/语法/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://huos3203.github.io/tags/安全/"}]},{"title":"在OC和swift中区分多个targets","slug":"iOS/在OC和swift中区分多个targets","date":"2017-01-11T13:49:33.000Z","updated":"2017-08-17T14:54:01.000Z","comments":true,"path":"2017/01/11/iOS/在OC和swift中区分多个targets/","link":"","permalink":"https://huos3203.github.io/2017/01/11/iOS/在OC和swift中区分多个targets/","excerpt":"","text":"build setting预编译位置 Preprocessor Macros Other Swift Flags 为生产和开发target配置预处理宏/编译器标识。之后我们就可以使用该标识在我们的代码来检测应用程序正在运行的版本。 Objective-C项目中Preprocessor Macros配置 添加位置：选择项目中对应的target名-&gt;在Build Settings下Apple LLVM 7.0 - Preprocessing-&gt;Preprocessor Macros。添加变量：在Rebug和Release区域添加一个变量DEVELOPMENT 对应target1: 设DEVELOPMENT=1表示开发版 对应target2: 设DEVELOPMENT=0表示生产版 使用 根据已配置的宏DEV_VERSION，我们可以在代码中利用它动态地编译项目。下面是一个简单的例子：Objective-C中使用＃if检查DEVELOPMENT的环境，并相应的设置URLs/ API密钥。 1234567#if DEVELOPMENT #define SERVER_URL @\"http://dev.server.com/api/\" #define API_TOKEN @\"DI2023409jf90ew\"#else #define SERVER_URL @\"http://prod.server.com/api/\" #define API_TOKEN @\"71a629j0f090232\"#endif Swift中Other Swift Flags对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。 配置 选中开发target，添加一个标识表示开发版本选中target -&gt; Build Setting-&gt;Swift Compiler - Custom Flags-&gt;将值设为-DDEVELOPMENT表示这个target作为开发版本。 使用 Swift中你仍然可以使用#if判定build的参数动态编译。然而，除了使用#define定义基本常量，在swift中我们也可以用let定义一个全局常量。 1234567#if DEVELOPMENTlet SERVER_URL = \"http://dev.server.com/api/\"let API_TOKEN = \"DI2023409jf90ew\"#elselet SERVER_URL = \"http://prod.server.com/api/\"let API_TOKEN = \"71a629j0f090232\"#endif 参照","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"配置","slug":"iOS/配置","permalink":"https://huos3203.github.io/categories/iOS/配置/"}],"tags":[{"name":"targets","slug":"targets","permalink":"https://huos3203.github.io/tags/targets/"}]},{"title":"Swift 语言指南[转]","slug":"swift/SwiftGuide","date":"2017-01-03T17:05:20.000Z","updated":"2017-01-23T18:33:57.000Z","comments":true,"path":"2017/01/04/swift/SwiftGuide/","link":"","permalink":"https://huos3203.github.io/2017/01/04/swift/SwiftGuide/","excerpt":"","text":"Swift 语言指南 @SwiftLanguage 更新于 2016-6-6，更新内容详见 Issue 55。往期更新回顾详见《收录周报》 这份指南汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排。对于精选项目及文章，可直接访问《Swift 项目精选》和《Swift 文章精选》。还有开发者们自己维护的《开发者、项目、最佳实践》。当然也不能错过那些活跃、优秀的《开发者个人资料页》。 入门指引苹果为 Swift（中文介绍）开发者提供的官方文档入口，包括 概述，博客（中文镜像）及 开发资源。其中以下几份文档（Swift 2.1）为入门级必备（iBooks 版）： Swift Programming Language（中文版｜PDF 版 By SwiftGG翻译组） Start Developing iOS Apps Using Swift with Cocoa and Objective-C（中文版 By @CocoaChina） 苹果同时也维护着相应 Beta 版（Swift 2.2）文档：Swift Programming Language，Start Developing iOS Apps，Using Swift with Cocoa and Objective-C。 学习实践的角度，标准库示例代码 Swift Standard Library.playground 是很棒的学习伴侣。 教程方面，苹果力荐了斯坦福课程 Stanford University: Developing iOS 8 Apps with Swift（中文字幕版 By @网易公开课） 除以上所涉及入门级文档，iOS Developer Library 还为开发者提供了更庞大、系统化的开发文档支持。 以下列举了几份已有第三方中文翻译文档： API Design Guidelines（中文版 By @SwiftGG翻译组） App Extension Programming Guide（中译镜像） iOS Human Interface Guidelines（中文版｜PDF 版 By @腾讯ISUX） HomeKit Developer Guide（中文版 By @CocoaChina） 值得称道的还有：苹果为 Apple TV Tech Talks 和 WWDC 2015 的视频添加简体中文字幕，从而方便中国开发者观看来自官方的权威技术分享。 有关于 Swift 开源及跨平台开发，可以关注 swift.org 教程文章开源项目推荐网站 苹果官方 Swift：Swift 概述、博客以及开发资源。 swift.org：开源后独立出来的 Swift 开源社区。 GitHub:apple：苹果在 GitHub 上的开源项目。 GitHub:apple/swift：swift 语言在 GitHub 上的开源项目。 ksm/SwiftInFlux：作者（Karol Mazur）将 Apple Developer Forums 上有关 Swift 特性、缺陷及变更讨论分类汇总并更新到 GitHub，具有很好的可读性。从中可以一窥 Swift 缺陷及未来潜在地变化。最关键地是有 Chris Lattner 及核心团队答疑解惑。 raywenderlich.com(中文版)：由Ray Wenderlich创建，专注于开发高质量编程指南（近期优质Swift文章及视频教程不断），著名的iOS/OS X博客及开发教程网站，非常适合新手学习。近期第一时间出了三本 Swift 新书。 Natasha The Robot： 时髦码农不容错过的 Swift 开发实战教程类网站。为了简化学习复杂性，每一篇文章涵盖技术点单一又独立，配以开发步骤、运行结果以及代码等标准方式教授。难能可贵的是，它往往出品“追剧式”（最新开发特性或API跟进式）教程，实在是开发者必藏精品网站。 NShipster (中译版：@刘镇夫，April Peng，@李乐佳，@程序员付恒 等翻译)：著名开源作者 Matt Thompson 创建的开发技术博客网站，他开发了 AFNetworking 网络库，也是非常多产的开源作者。更多了解参考：《COCOA 潮人 MATTT THOMPSON》 By @程序员付恒 jamesonquave.com：移动开发者，优秀个人博客（近期文章同样关注于Swift 语言，写得很优质）。同时他将于8/30发布一本新书《Developing iOS 8 Apps in Swift》 (Learn To Make Real World iOS 8 Apps)及视频教程。 objc.io(中译版 By @onevcat 及其朋友们)：”关于 Objective-C 最佳实践和先进技术的期刊。 由 Chris Eidhof, Daniel Eggert 和 Florian Kugler 成立于柏林。我们成立 objc.io 的目的是针对深入的、跟所有 iOS 和 OS X 开发者相关的技术话题创造一个正式的平台。“ iOSCreator：这类开发指引式教程对于初学者来讲，是直接明了的有效学习资源。推荐者@荧星诉语 iOS Dev Weekly：收录一周以来 iOS 开发资讯链接，并于周五发布。由 Dave Verwer 创办，他是一位 iPhone 和 iPad 开发者以及培训师。 Appcoda.com：质量很高的一个 iOS 开发教程站，其中iOS Programming Course这个专题很适合刚接触 iOS 开发的新手学习。 中文 iOS/Mac 开发博客列表：By @唐巧_body devtalking.com：高产的中译博客。翻译了官方博客 Swift Blog - Apple Developer,《App Extension Programming Guide》。参与翻译了《Swift Programming Language》等。 SwiftGG：一个走心的 Swift 翻译组，由《The Swift Programming Language》中文版翻译团队原班人马组成， 翻译的文章来源于国外的优秀 Swift 网站和博客，且全部获得作者和网站授权。 Swift Weekly Brief：“这个博客现在每周会将Swift开源中的重要讨论和提交整理成Open source Swift weekly brief，这对一线开发者尽早了解这门语言的动态情报很有帮助。By @崔康总编 ”。来源：Jesse Squires Swift Developer Weekly:这个网站每周推送最新的技术文章和书本推荐到你的email，由Phil Wright创办。 iosdevtips.co：iOS Development Tips 资源合集 以下是其它开发者社区或 Swift 爱好者整理的有关 Swift 语言学习的资源列表。 SwiftEducation：“这是建立在 GitHub 上的一个 Swift 学习资料汇集，包括了有关幻灯和多个练手的应用程序源码。By @极客头条”。的确有不少基础实用的好教程。这对于基础学起的同学有福了。 Awesome-Swift-Education：整理地如此美妙的学习资源，实在让人太欢喜了。 iOS Cookies：分类合理、排序靠谱的 Swift 开源类库集合。 matteocrippa/awesome-swift：这个版本的 Swift 资源集合内容丰富，分类也不错。作者：Matteo Crippa 适合iOS开发者的 15 大网站推荐：的确很全、很主流的国外 iOS 开发者网站。 掘金 Swift 版块 码农周刊 －《Swift 特刊》 CocoaChina －《Swift 新手入门汇集帖》 CSDN_CODE －《Swift 编程语言资料大合集》 InfoQ －《学习苹果 Swift 语言的一些在线资源（英文）》 刘兰涛 －《Swift 学习资源》 By @懒桃儿吃桃儿 learnswift.tips：国外主流 Swift 学习资源集合。 Awesome iOS：一个 iOS 的各类优秀的开源项目集合。真不错！可惜Swift开源项目资源不足。 iOS Developer Tips：还是有关 iOS 的开发资源及文章合集。 Wolg/awesome-swift：一位俄罗斯朋友分类整理的 Swift 资源列表（有持续更新）。 Aufree/trip-to-iOS：显然作者很用心的做了非常深入的整理。它对于开发者拓展学习范围及开发知识面非常有益。 Robin Eggenkamp - Awesome Swift：“一个收集了很多 Swift 开发资源的网站”。 iOS 开发技术前线：“一个定期翻译、发布国内外iOS优质的技术、开源库、软件架构设计、测试等文章的开源项目”。主要翻译来源 Ray Wenderlich，App Coda，Medium。来源：@开发技术前线 11个超棒的 iOS 开发学习网站：还算比较主流的归纳。不过，缺了raywenderlich.com 和 ioscreator.com 这两个重量级教程网站实在是不应该啊。 开发工具1. 编程工具 Xcode 下载：苹果应用集成开发环境。支持 C/C++, Objective C, Swift 等。不用购买开发者计划，直接下载。 Textmate：Mac OS X 上一个可高度自定义的编辑器，尤其在我想做出一个快速改变但又不想等待 Xcode 加载的时候。该工具目前已经开源 Mou ($)：OS X 上一款 Markdown 的编辑器。非常适用于编写自述文件、变更日志以及其他方面的内容。作者：罗晨 Sublime Text ($)：Mac OS X 上另一款非常受欢迎的轻量级，可高度自定义的编辑器。 RunSwift:正在犹豫是否入手苹果电脑开始一段 Swift 编程旅程的同学们，或仅仅为了试验一段简单 Swift 代码又懒得打开 Xcode，可以试试这款 Web 版 Swift 编译环境 RunSwift。 InfinitApps - Bezel：“嫌 Xcode 6 目前提供的 Watch 模拟器不够直观？Bezel 是一个用于视觉预览 WatchKit 所开发程序效果的小工具，前提是你安装了 xScope 软件（Mac端）或 xScopeMirror（iPhone端）。 By @WatchKit开发” Markdown -&gt; Playground：该开源项目可将内含有 Swift 代码的 Markdown 自动转换为 Xcode Playgrounds 文件。喜欢用 Markdown 编辑的同学很激动吧。P.S. 这款工具写于 NodeJS，原因作者有交待。 iOS/Mac Autolayout Constraints：这个工具不错，很直观，布局时可以省不少工夫。推荐者：@荧星诉语 在线生成 AppStore 审核用截图：便捷的生产力工具。免费，易操作，可自定义。 IBM Swift Sandbox：IBM的在线Swift网站，需要翻墙。 SwiftStub：另外一个Swift在线练习网站。 2. 代码管理 GitHub：声望日盛的资源分享之地。 GitHub for Mac：一个设计的非常美观的 git 客户端，不能取代你从命令行获得的所有功能，但使用起来非常简单。 GitCafe：GitCafe is a source code hosting service based on version control system Git。国内的代码托管服务，基于 Git，值得一提的是最近也推出了和 GitHub Pages 类似的服务 Gitcafe Pages。因为是在国内，所以相比较 GitHub 有速度优势，在网络环境差的情况下也许可以作为 GitHub 的备用。 Bitbucket：国外的代码托管服务，不同于 GitHub 的是，Bitbucket 可以免费建立 private 项目。 Git：分布式版本控制系统和源码管理系统，其优点是：快和简单易用。对于新手来说，可在此查看免费电子书籍。 SourceTree：A free Git &amp; Mercurial client for Windows or Mac.免费的Git和Mercurial客户端，当然也可以配合Bitbucket使用。 3. Xcode 插件 CocoaPods：第三方库的管理利器，允许你简单地把第三方库整合进自己的应用中。对我个人来说，我基本上每个项目都使用 CocoaPods。 CocoaPods Xcode Plugin：一款 Xcode 插件，允许你直接从 Xcode 管理 CocoaPod 依赖。 onevcat/VVDocumenter-Xcode：快捷注释 Xcode 插件。By @onevcat ColorSense：一款显示颜色数值的插件，还可以直接通过系统的ColorPicker来自动生成对应颜色代码 Xcode 优秀插件整理:持续保持整理更新的 Xcode 插件整理 By @ddapps CodeEagle/SwiftCodeSnippets：自动下载指定 Xcode Snippet 源的 Xcode Plugin。项目缺省提供 Snippet 代码源 burczyk/XcodeSwiftSnippets 。 realm/SwiftLint：Realm 采用 Swift 编写的基于 GitHub’s Swift Style Guide 规则的检查工具。除了命令行运行方式，也提供集成 Xcode 的方法。对于新团队，这样的工具可以自动约束大家遵循编程规范。 XCode 升级后插件失效的原理与修复办法：由一条命令引发的分析文章。@_TongJZ feinstruktur/CoPilot：通过此插件，Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。演示视频 Carthage：新兴起的去中心化的依赖管理器，目标是用最简单的方式来管理Cocoa第三方框架。优势很明显，但是也有不足，看后面的发展吧。 4. 管理工具 swiftenv：Swift 版本管理器。类似 rvm（Ruby）, nvm（Node.js）。 HomeBrew：OS X 上非常出色的包管理工具。 Transmit ($)：一个Mac OS X 上 FTP 客户端，有着非常漂亮的用户界面和有用的功能。 5. 调试工具 mattt/fuckingclangwarnings.com：警告与语义对照表。以后再也不用为 Xcode 各种警告纠结啦！By @foogry 6. 设计工具 sketch：更适合开发应用的矢量设计工具。通过插件还支持与代码协同工作。推荐书籍：Learn Sketch 3 PaintCode:PaintCode是Apple Designer入门APP开发最合适的辅助工具之一，她可以把你绘制的矢量UI自动转化为适用于iOS/OS X的Objective-C代码。 7. 发布工具 Frabic fastlane Xcode Server 7. 开源项目 RESideMenu侧滑布局类库,支持左右滑动，滑动距离; IQKeyboardManager易于集成，支持设备的方向，可通过类的方法来启用和禁用键盘管理器； ACPDownload实现类似AppStore下载状态样式； TCBlobDownload支持后台线程执行大文件下载任务，暂停和重新恢复下载； MobShareSDK实现微信朋友，朋友圈分享; BlocksKit没有创建新的宏，函数，方法和类，仅对Cocoa基础类的一个扩展，是取代了通常的delegate用法; SDWebImage图片缓存的框架; MJRefresh下拉刷新上拉加载更多MJRefresh类库; ToastAndroid风格的Toast控件,用户提示便捷得体； IQLabelView对文本控件覆盖，缩放和旋转； AFNetworking RestKit处理web服务api,解析JSON映射响应对象； Masonry一个轻量级的布局框架,拥有自己的描述语法，采用更优雅的链式语法封装自动布局； *Perfect 服务器 媒体报道开放平台Apple Watch 指南","categories":[{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/categories/资源/"}],"tags":[{"name":"汇总","slug":"汇总","permalink":"https://huos3203.github.io/tags/汇总/"},{"name":"资源","slug":"资源","permalink":"https://huos3203.github.io/tags/资源/"},{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/tags/swift/"}]},{"title":"Docker使用","slug":"其他/Docker使用","date":"2016-12-21T21:25:29.000Z","updated":"2019-01-16T21:01:14.000Z","comments":true,"path":"2016/12/22/其他/Docker使用/","link":"","permalink":"https://huos3203.github.io/2016/12/22/其他/Docker使用/","excerpt":"安装Docker for Mac在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。1234567echo '下载dmg...'curl -o Docker.dmg https://dn-dao-github-mirror.qbox.me/docker/install/mac/Docker.dmg#安装Docker.dmgMOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \\| awk '&#123;$1=$2=\"\"; print $0&#125;'` | xargs -0 echo) \\&amp;&amp; cd $&#123;MOUNTDIR&#125; &amp;&amp; cp -R Docker.app /Applications/ \\&amp;&amp; open /Applications/Docker.app 配置 Docker 加速器镜像源国内加速器右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:1http://f1361db2.m.daocloud.io 点击 Apply &amp; Restart 按钮使设置生效。 安装主机监控程序加速器 登录到 DaoCloud 控制台，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。 安装DockerToolbox，是一个完整的开发组件，通过安装和配置DaoCloud加速器 v2，提升下载 Docker Hub 镜像的速度。1234//下载pkgcurl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v18.09.0/DockerToolbox-18.09.0.pkg//安装pkgsudo installer -pkg DockerToolbox.pkg -target /","text":"安装Docker for Mac在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。1234567echo '下载dmg...'curl -o Docker.dmg https://dn-dao-github-mirror.qbox.me/docker/install/mac/Docker.dmg#安装Docker.dmgMOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \\| awk '&#123;$1=$2=\"\"; print $0&#125;'` | xargs -0 echo) \\&amp;&amp; cd $&#123;MOUNTDIR&#125; &amp;&amp; cp -R Docker.app /Applications/ \\&amp;&amp; open /Applications/Docker.app 配置 Docker 加速器镜像源国内加速器右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:1http://f1361db2.m.daocloud.io 点击 Apply &amp; Restart 按钮使设置生效。 安装主机监控程序加速器 登录到 DaoCloud 控制台，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。 安装DockerToolbox，是一个完整的开发组件，通过安装和配置DaoCloud加速器 v2，提升下载 Docker Hub 镜像的速度。1234//下载pkgcurl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v18.09.0/DockerToolbox-18.09.0.pkg//安装pkgsudo installer -pkg DockerToolbox.pkg -target / 安装Toolbox好了，下一步： $ docker-machine start default启动 Docker.当执行后提示：Host does not exist: &quot;default&quot;docker-machine createstackoverflow1docker-machine create -d virtualbox default 在 Docker 主机 DaoCloud 加速器的组件包： 1curl -sSL https://get.daocloud.io/daomonit/install.sh | sh -s d0312f829e9807ee0bf157****** 启动组件包,会在「安装主机监控程序」的 DaoCloud 控制台页面下方显示一台已经接入的主机。 执行Dao Pull命令,高速下载Docker Hub镜像文件这台 Docker 主机已经被接入 DaoCloud 平台，用户可以在 DaoCloud 控制台的「我的集群」页面发现这台主机，可以执行管理和部署应用的操作。 从Docker Hub 仓库中获取一个镜像 Docker 使用类似 git 的方式管理镜像。通过基本的镜像可以定制创建出来不同种应用的 Docker 镜像。Docker Hub 是 Docker 官方提供的镜像中心。在这里可以很方便地找到各类应用、环境的镜像。由于 Docker 使用联合文件系统，所以镜像就像是夹心饼干一样一层层构成，相同底层的镜像可以共享。所以 Docker 还是相当节约磁盘空间的。要使用一 个镜像，需要先从远程的镜像注册中心拉取，这点非常类似 git。1docker pull ubuntu Docker 命令创建管理容器 获取镜像的两种方式 1. docker pull命令12docker search perfectlysoft/ubuntudocker pull perfectlysoft/ubuntu 2. docker import命令1docker import myubuntu.tar.gz 通过镜像创建容器 创建一个容器有两种方式：12docker create 镜像名docker run 镜像名 //立即启动容器 等价于：create + start 命令组合 进入容器终端控制台如下：123root@ec72dc76502e:/# lsapp boot etc lib media opt root sbin sys usrbin dev home lib64 mnt proc run srv tmp var docker run images命令 样例1执行run images，并将 Ubuntu 的 Shell 作为入口，进入Docker容器环境操作 1docker run -it ubuntu:latest sh -c '/bin/bash' 样例2执行docker start -i 容器命令进入容器环境 1docker start -i 容器ID/容器名 从KitematicGUI进入容器环境1bash -c \"clear &amp;&amp; docker exec -it perfectswift sh\" 参数-i 表示这是一个交互容器，会把当前标准输入重定向到容器的标准输入中，而不是终止程序运行-t 指为这个容器分配一个终端 这时候我们成功创建了一个 Ubuntu 的容器，并将当前终端连接为这个 Ubuntu 的 bash shell。这时候就可以愉快地使用 Ubuntu 的相关命令了。 ps 查看容器状态 在容器运行期间，我们可以通过 docker ps 命令看到所有当前正在运行的容器。添加-a参数可以看到所有创建的容器：1docker ps -a 容器ID标识 每个容器都有一个唯一的 ID 标识，通过 ID 可以对这个容器进行管理和操作。在创建容器时，我们可以通过 –name 参数指定一个容器名称，如果没有指定系统将会分配一个，就像这里的「trusting_morse」。 启动/退出/移除容器 启动：start1docker start -i trusting_morse 注意：每次执行 docker run 命令都会创建新的容器，建议一次创建后，使用 docker start/stop 来启动和停用容器。 退出：按 Ctrl+D 退出 移除：rmID/name1docker rm [CONTAINER ID/NAMES] 重命名：rename1docker rename 容器ID newName 创建管理镜像 Docker 强大的威力在于可以把自己开发的应用随同各种依赖环境一起打包、分发、运行。要创建一个新的 Docker 镜像，通常基于一个已有的 Docker 镜像来创建。Docker 提供了两种方式来创建镜像： 把容器创建为一个新的镜像 使用 Dockerfile 创建镜像。 将容器创建为镜像 为了创建一个新的镜像，我们先创建一个新的容器作为基底： 1docker run -it ubuntu:latest sh -c '/bin/bash' 定制这个容器，例如我们可以配置 PHP 环境、将我们的项目代码部署在里面等： 12apt-get install php# some other opreations ... 当执行完操作之后，我们按 Ctrl+D 退出容器. 获取定制后的容器ID 12345docker ps -a[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScb2b06c83a50 ubuntu:latest &quot;sh -c /bin/bash&quot; 7 minutes ago Exited (0) 7 seconds ago trusting_morse 执行docker commit 把这个容器变为一个镜像： 1docker commit cb2b06c83a50 ubuntu:myubuntu 这时候 docker 容器会被创建为一个新的 Ubuntu 镜像，版本名称为 myubuntu。以后我们可以随时使用这个镜像来创建容器了，新的容器将自动包含上面对容器的操作。 打包/发布镜像 1docker save -o myubuntu.tar.gz ubuntu:myubuntu 导入打包镜像 1docker import myubuntu.tar.gz Dockerfile 通过Dockerfile创建镜像1docker build yourDir/Dockerfile 确保Dockerfile文件在一个目录中，否则会提示错误 Docker Hub 提供了类似 GitHub 的镜像存管服务。一个镜像发布到 Docker Hub 不仅可以供更多人使用，而且便于镜像的版本管理。在一个企业内部可以通过自建 Docker Registry 的方式来统一管理和发布镜像。将 Docker Registry 集成到版本管理和上线发布的工作流之中，还有许多工作要做，在我整理出最佳实践后会第一时间分享。使用命令行的方式创建 Docker 镜像通常难以自动化操作。在更多的时候，我们使用 Dockerfile 来创建 Docker 镜像。Dockerfile 是一个纯文本文件，它记载了从一个镜像创建另一个新镜像的步骤。撰写好 Dockerfile 文件之后，我们就可以轻而易举的使用 docker build 命令来创建镜像了。Dockerfile 非常简单，仅有以下命令在 Dockerfile 中常被使用： 命令 参数 说明 # - 注释说明 FROM [:] 从一个已有镜像创建，例如ubuntu:latest MAINTAINER Author &#115;&#x6f;&#x6d;&#x65;&#45;&#111;&#110;&#x65;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d; 镜像作者名字，如Max Liu &#x73;&#111;&#x6d;&#101;&#45;&#111;&#110;&#101;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d; RUN 或者[‘cmd1’, ‘cmd2’…] 在镜像创建用的临时容器里执行单行命令 ADD 将本地的添加到镜像容器中的位置 VOLUME 或者[‘/var’, ‘home’] 将指定的路径挂载为数据卷 EXPOSE […] 将指定的端口暴露给主机 ENV 或者 = 指定环境变量值 CMD [“executable”,”param1”,”param2”] 容器启动时默认执行的命令。注意一个Dockerfile中只有最后一个CMD生效。 ENTRYPOINT [“executable”, “param1”, “param2”] 容器的进入点 配置Dockerfile 下面是一个 Dockerfile 的例子：12345# This is a commentFROM ubuntu:14.04MAINTAINER Kate Smith &lt;ksmith@example.com&gt;RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-devRUN gem install sinatra CMD命令 CMD: 命令可用指定 Docker 容器启动时默认的命令1docker run -it ubuntu:latest sh -c &apos;/bin/bash&apos; 其中 sh -c &#39;/bin/bash&#39; 就是手工指定的CMD,否则容器将会使用默认 CMD 指定的命令启动。 ENTRYPOINT命令 用来指定可执行文件、Shell 脚本，同时会并把启动参数或 CMD 指定的默认值，当作附加参数传递给 执行文件、Shell 脚本。12ENTRYPOINT ['/usr/bin/mysql']CMD ['-h 192.168.100.128', '-p'] 执行mysql启动程序，连接192.168.100.128 主机,也可以通过指定参数，来连接别的主机。 因此，我们在使用 Dockerfile 创建文件的时候，可以创建一个 entrypoint.sh 脚本，作为系统入口。在这个文件里面，我们可以进行一些基础性的自举操作，比如检查环境变量，根据需要初始化数据库等等。下面两个文件是我在日常工作的项目中添加的 Dockerfile 和 entrypoint.sh，仅供参考：https://github.com/starlight36/SimpleOA/blob/master/Dockerfilehttps://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh在准备好 Dockerfile 之后，我们就可以创建镜像了： 创建镜像1docker build -t starlight36/simpleoa .","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[]},{"title":"hackmd使用","slug":"hexo/hackmd使用","date":"2016-12-21T10:49:32.000Z","updated":"2017-09-23T17:28:44.000Z","comments":true,"path":"2016/12/21/hexo/hackmd使用/","link":"","permalink":"https://huos3203.github.io/2016/12/21/hexo/hackmd使用/","excerpt":"編輯快速鍵跟又快又方便的Sublime text很像 更多訊息請至 這裡 自動完成提供完整的 Markdown 自動完成與提示 表情符號：輸入 : 顯示提示 程式碼區塊：輸入 3个 ` 加上一個字元 顯示提示 標頭：輸入 # 顯示提示 參考：輸入 [] 顯示提示 外部：輸入 {} 顯示提示 圖片：輸入 ! 顯示提示 標題會使用 第一個第一級標頭 作為筆記標題 標籤如同以下方式來使用標籤，它們會顯示在您的 歷史紀錄 tags: 功能 酷 更新YAML metadata提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結 robots: 設定網路機器人 meta lang: 設定瀏覽器顯示語言 dir: 設定文字方向 breaks: 設定是否使用分行 mathjax: 設定是否使用 mathjax 表情符號您可以像是這樣使用表情符號 :smile: :smiley: :cry: :wink: 完整的表情符號列表 在這裡 待辦清單 [ ] 待辦 [x] 買些沙拉 [x] 刷牙 [ ] 喝水","text":"編輯快速鍵跟又快又方便的Sublime text很像 更多訊息請至 這裡 自動完成提供完整的 Markdown 自動完成與提示 表情符號：輸入 : 顯示提示 程式碼區塊：輸入 3个 ` 加上一個字元 顯示提示 標頭：輸入 # 顯示提示 參考：輸入 [] 顯示提示 外部：輸入 {} 顯示提示 圖片：輸入 ! 顯示提示 標題會使用 第一個第一級標頭 作為筆記標題 標籤如同以下方式來使用標籤，它們會顯示在您的 歷史紀錄 tags: 功能 酷 更新YAML metadata提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結 robots: 設定網路機器人 meta lang: 設定瀏覽器顯示語言 dir: 設定文字方向 breaks: 設定是否使用分行 mathjax: 設定是否使用 mathjax 表情符號您可以像是這樣使用表情符號 :smile: :smiley: :cry: :wink: 完整的表情符號列表 在這裡 待辦清單 [ ] 待辦 [x] 買些沙拉 [x] 刷牙 [ ] 喝水 程式碼區塊我們支援非常多程式語言，使用自動完成來看看有些什麼123456789101112131415var s = \"JavaScript syntax highlighting\";alert(s);function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ' class=\"\"'; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; &#125;&#125; 如果想要 行號，在表明程式語言之後輸入 =您也可以指定開始行號，如下所示，行號從101開始 123456789101112131415var s = \"JavaScript syntax highlighting\";alert(s);function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ' class=\"\"'; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; &#125;&#125; 或是可以接續上一個程式碼區塊的行號，使用 =+ 12var s = \"JavaScript syntax highlighting\";alert(s); 引用區塊標籤 您可以使用以下語法，表明自己的 姓名、時間與顏色 並與其他的引用區塊做區別[name=ChengHan Wu] [time=Sun, Jun 28, 2015 9:59 PM] [color=#907bf7] 也支援巢狀引用區塊喔！[name=ChengHan Wu] [time=Sun, Jun 28, 2015 10:00 PM] [color=red] 外部Youtube Vimeo Gist SlideShare1&#123;%slideshare briansolis/26-disruptive-technology-trends-2016-2018-56796196 %&#125; Speakerdeck1&#123;%speakerdeck sugarenia/xxlcss-how-to-scale-css-and-keep-your-sanity %&#125; PDF注意：請使用 https 的網址，否則可能會被您的瀏覽器阻擋載入1&#123;%pdf https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf %&#125; MathJax您可以使用 MathJax 語法 來產生 LaTeX 數學表達式，如同 math.stackexchange.com： The Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 更多關於 LaTeX 數學表達式 請至這裡 UML 圖表循序圖您可以像是以下使用循序圖： 12345艾莉絲-&gt;包柏: 哈摟，你好嗎？Note right of 包柏: 包柏思考中包柏--&gt;艾莉絲: 我很好，謝謝！Note left of 艾莉絲: 艾莉絲回應艾莉絲-&gt;包柏: 最近過得怎樣？ 流程圖您可以像是以下使用流程圖：123456789st=&gt;start: 開始e=&gt;end: 結束op=&gt;operation: 我的操作op2=&gt;operation: 啦啦啦cond=&gt;condition: 是或否？st-&gt;op-&gt;op2-&gt;condcond(yes)-&gt;econd(no)-&gt;op2 Graphviz123456789101112digraph hierarchy &#123; nodesep=1.0 // increases the separation between nodes node [color=Red,fontname=Courier,shape=box] //All nodes will this shape and colour edge [color=Blue, style=dashed] //All the lines look like this Headteacher-&gt;&#123;Deputy1 Deputy2 BusinessManager&#125; Deputy1-&gt;&#123;Teacher1 Teacher2&#125; BusinessManager-&gt;ITManager &#123;rank=same;ITManager Teacher1 Teacher2&#125; // Put them on the same level&#125; Mermaid123456789gantt title A Gantt Diagram section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d anther task : 24d 更多關於 循序圖 語法 在這裡.更多關於 流程圖 語法 在這裡.更多關於 Graphviz 語法 在這裡更多關於 Mermaid 語法 在這裡 警告區塊:::success耶 :tada:::: :::info這是訊息 :mega:::: :::warning注意 :zap:::: :::danger喔不 :fire:::: 排版標頭123456# h1 標頭## h2 標頭### h3 標頭#### h4 標頭##### h5 標頭###### h6 標頭 水平分隔線 字形替換(c) (C) (r) (R) (tm) (TM) (p) (P) +- 測試.. 測試… 測試….. 測試?….. 測試!…. !!!!!! ???? ,, Remarkable – awesome “Smartypants, 雙引號” ‘Smartypants, 單引號’ 強調這是粗體文字 這是粗體文字 這是斜體文字 這是斜體文字 這是刪除文字 上標： 19^th^ 下標： H~2~O ++這是底線文字++ ==這是標記文字== 引用區塊 引用區塊也可以是巢狀的喔… …可以多層次的使用… …或是用空白隔開 清單項目 在行開頭使用 + - 或是 * 來建立清單 空兩個空白就可以產生子清單 當清單標記使用的字元不同，會強制建立新的清單 Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit 非常簡單！ 編號 Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa 您可以逐次增加項目數字… …或是全部都使用 1. feafw 332 242 2552 e2 從其他範圍開始編號清單 foo bar 程式碼行內 程式碼 縮排程式碼 // Some comments line 1 of code line 2 of code line 3 of code 程式碼區塊 1Sample text here... 語法標色 12345var foo = function (bar) &#123; return bar++;&#125;;console.log(foo(5)); 表格 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向右對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向左對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 置中對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 連結連結文字加上標題的連結文字自動轉換連結 https://github.com/nodeca/pica 圖片如同連結一般，圖片也可以用註腳語法使用參考，可以在稍後的文件中再定義圖片網址 使用指定的大小顯示圖片 註腳註腳 1 連結[^first].註腳 2 連結[^second].行內註腳^[行內註腳的文字] 定義重複的註腳參考[^second]. [^first]: 註腳 也可以標記 還可以有很多段落[^second]: 註腳 文字 定義清單名詞 1 : 定義 1 快速連續項目 名詞 2 加上 行內標記 : 定義 2 { 這些程式碼屬於 定義 2 的一部分 } 定義 2 的第三段落 緊密樣式： 名詞 1 ~ 定義 1 名詞 2 ~ 定義 2a ~ 定義 2b 縮寫這是 HTML 的縮寫範例它會轉換 “HTML”，但是縮寫旁邊其他的部分，例如：”xxxHTMLyyy”，不受影響 *[HTML]: Hyper Text Markup Language","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"Hexo-hello-world","slug":"hexo/Hexo-hello-world","date":"2016-12-20T18:02:13.000Z","updated":"2018-09-13T19:22:55.000Z","comments":true,"path":"2016/12/21/hexo/Hexo-hello-world/","link":"","permalink":"https://huos3203.github.io/2016/12/21/hexo/Hexo-hello-world/","excerpt":"","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start安装 Node.js安装 Node.js 的最佳方式是使用 nvm,或者您也可以下载 node.js安装包来安装。 安装nvm方式一：cURL命令1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 方式二：linux方法Wget命令1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 更新npm命令工具至最新版本1npm install -g npm 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 为了便于在多台电脑上部署博客，可以使用使用git版本库来管理个人博客的内容：具体部署过程：123git clone https://xxxxx/boyer.git boyercd boyernpm install #安装package.json是插件包，使用git管理更加便于管理安装的完整性。 新建完成后，指定文件夹的目录如下： . ├── _config.yml # 网站的 配置 信息，您可以在此配置大部分的参数。 ├── package.json # 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装。 ├── scaffolds # 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source | ├── _drafts | └── _posts └── themes scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Create a new post1$ hexo new \"My New Post\" 1$ hexo new draft \"草稿名\" 1$ hexo publish \"草稿名\" #Moves a draft post from _drafts to _posts folder. More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 在我们开始之前,你必须在 _config.yml 修改设置。一个有效的部署设置必须有 type 字段。例如:12deploy: type: git 你可用同时部署到多个type，Hexo将依次执行每个部署。12345deploy: - type: git repo: - type: heroku repo: 安装插件安装同步到git 插件1$ npm install hexo-deployer-git --save 编辑_config.yml设置：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 安装生成RSS支持插件1$ npm install hexo-generator-feed --save 编辑_config.yml设置：12345feed: type: atom path: atom.xml limit: 20 hub: More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"微信小程序开发-一","slug":"其他/微信小程序开发-一","date":"2016-12-19T22:59:10.000Z","updated":"2018-10-05T21:42:35.000Z","comments":true,"path":"2016/12/20/其他/微信小程序开发-一/","link":"","permalink":"https://huos3203.github.io/2016/12/20/其他/微信小程序开发-一/","excerpt":"创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。 开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。 为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。 项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。 编写代码点击开发者工具左侧导航的“编辑”，看到这个项目文件结构。 三个必不可少的app.js、app.json、app.wxss: .js后缀的是脚本文件 .json后缀的文件是配置文件 .wxss后缀的是样式表文件 微信小程序会读取这些文件，并生成小程序实例。","text":"创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。 开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。 为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。 项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。 编写代码点击开发者工具左侧导航的“编辑”，看到这个项目文件结构。 三个必不可少的app.js、app.json、app.wxss: .js后缀的是脚本文件 .json后缀的文件是配置文件 .wxss后缀的是样式表文件 微信小程序会读取这些文件，并生成小程序实例。 app.js脚本代码app.json 是对整个小程序的全局配置。 可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。想了解更多可用 API，可参考 API 文档 123456789101112131415161718192021222324252627282930//app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) &#125;, getUserInfo:function(cb)&#123; var that = this; if(this.globalData.userInfo)&#123; typeof cb == \"function\" &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo; typeof cb == \"function\" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;); &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) app.json 全局配置可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口\b背景色，配置导航条样式，配置默认标题。123456789101112&#123; \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":&#123; \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" &#125;&#125; 注意该文件不可添加任何注释。更多配置可参考配置详解 app.wxss 公共样式表我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 创建页面在这个教程里，我们有两个页面，index 欢迎页和 logs 小程序启动日志的展示页，他们都在 pages 目录下。 微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成: .js后缀的文件是脚本文件 .json后缀的文件是配置文件（非必须） .wxss后缀的是样式表文件（非必须） .wxml后缀的文件是页面结构文件 index.wxml页面结构：使用了&lt;view/&gt;、&lt;image/&gt;、&lt;text/&gt;来搭建页面结构(container)，绑定数据(userInfo)和交互处理函数(bindViewTap)。12345678910&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; index.js脚本文件在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。1234567891011121314151617181920212223242526//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) index.wxss样式表 页面的样式表是非必要的,该样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。 页面的结构文件中可以直接使用 app.wxss 中指定的样式规则。 123456789101112131415161718192021/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125; index.json配置文件页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。 logs 的页面logs.wxml页面结构123456&lt;!--logs.wxml--&gt;&lt;view class=\"container log-list\"&gt; &lt;block wx:for=\"&#123;&#123;logs&#125;&#125;\" wx:for-item=\"log\"&gt; &lt;text class=\"log-item\"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt; &lt;/block&gt;&lt;/view&gt; logs.js脚本文件logs 页面使用 &lt;block/&gt; 控制标签来组织代码，在 &lt;block/&gt; 上使用 wx:for 绑定 logs 数据，并将 logs 数据循环展开节点123456789101112131415//logs.jsvar util = require('../../utils/util.js')Page(&#123; data: &#123; logs: [] &#125;, onLoad: function () &#123; this.setData(&#123; logs: (wx.getStorageSync('logs') || []).map(function (log) &#123; return util.formatTime(new Date(log)) &#125;) &#125;) &#125;&#125;)运行结果如下： 运行结果如下：","categories":[{"name":"其他","slug":"其他","permalink":"https://huos3203.github.io/categories/其他/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://huos3203.github.io/tags/小程序/"}]},{"title":"GTD任务清单整理技巧","slug":"导图/GTD任务清单整理技巧","date":"2016-01-07T16:00:53.000Z","updated":"2019-04-24T23:21:29.835Z","comments":true,"path":"2016/01/08/导图/GTD任务清单整理技巧/","link":"","permalink":"https://huos3203.github.io/2016/01/08/导图/GTD任务清单整理技巧/","excerpt":"","text":"什么是GTD？GTD 的基本理论是把一个人所要要完成的任务和事件全部从大脑中移出来，记录到纸上。这样，大脑便会不被多余的事情打搅而集中于现在所需完成的事情上面。 GTD守则：收集任务 设置每天最重要的任务 （把所有你需要做的和需要完成的事情全部记录下来，放在一个“收集箱”里） ↓ 过程 （每次按照顺序，一次只做一件事） ↓ 管理任务 （列出有详细内容的to-do列表） ↓ 复习任务 （复习你所有完成的任务，计划方案和等待完成的事情。确保每一件新进入的任务都有很好的安排） ↓ 开始行动！ 建立有强行动性的任务清单任务清单（To-do List）的重要性毋庸置疑，建立有强行动性的任务清单可以让你更清楚地明白自己需要完成的任务，同时还保持了你去完成任务的激情和动力。 分解任务：就像走远路时，以每一段路程为目标，让人更有动力去追求一样。如果你要阅读一本书，便可以将任务分成“读完第一章”，“读完第二章”等等。 使用有力的动词：比如说联系某个人，就要写上“给某某打电话”或者“发邮件给某某”而不是写“联系某某”。 有限的清单：谁都不希望有一张写满几大页的任务清单，你需要找出那些有强动力的行动。 清理已完成的任务：已完成的任务要及时清理，否者会阻碍你的下一步行动任务。 7W3H7W3H是一个用于项目规划和管理的专业术语。公司管理者邀请相关员工一起进行分析讨论，按照7W3H进行各述己见，收集、归纳、再收集、再归纳，这样一种互动、发散性思维的工作方法极大调动下属员工的积极性、责任感。否则，公司管理者单方面出台项目计划，对下属员工解释耗费时力不说，项目计划的有效性、完善性、可行性也都可能存在质疑。 7Wwhat 指目标与内容，包括主体，目标，机能，性能等 why 指原因，包括任务，期望，背景，技术等 who 指人员，包括制造，行销，流通，负责的主体等 where 指地点类，包括 环境，市场，区域，渠道等 when 指时间，包括期限，时机，预期等 whom 买家，消费者，接收者 which 附属品 3Hhow to 如何做，指方式和手段，包括集体方案，详实计划，战略方针 how much 价格成本，投入产出，综效成果 how many 负面效益，各种量（问题，业务，工作） 案例6W1H截自《5个图表解决12大难题》 十二个赛博学习问题赛博学习法是一种动态的学习过程，在这个过程中你（不是你的老师，也不是某些教科书的作者）会掌握控制权，成为你自己教育的“引航员”。这种方法的第一步是对话：你会针对正在学习的材料，提出一系列具体的问题。慢慢地，通过信息的整理和再整理，以及在新材料与你学过的知识之间建立新的联系，你将真正理解材料。用这种方法改进你的笔记，只要回答12个问题就能掌握科教书的要点： 个人常用的工具类","categories":[{"name":"导图","slug":"导图","permalink":"https://huos3203.github.io/categories/导图/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"},{"name":"逻辑思维","slug":"逻辑思维","permalink":"https://huos3203.github.io/tags/逻辑思维/"}]},{"title":"git svn桥接命令的基础","slug":"git/gitsvn桥接命令的基础","date":"2016-01-05T14:18:00.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2016/01/05/git/gitsvn桥接命令的基础/","link":"","permalink":"https://huos3203.github.io/2016/01/05/git/gitsvn桥接命令的基础/","excerpt":"","text":"git svn 通过几个简单的工作流程了解到git svn常见命令：值得警戒的是，在使用 git svn 的时候，你实际是在与 Subversion 交互，Git 比它要高级复杂的多。尽管可以在本地随意的进行分支和合并，最好还是通过衍合保持线性的提交历史， 尽量避免类似与远程 Git 仓库动态交互这样的操作。 避免修改历史再重新推送的做法，也不要同时推送到并行的 Git 仓库来试图与其他 Git 用户合作。 Subersion 只能保存单一的线性提交历史，一不小心就会被搞糊涂。 合作团队中同时有人用 SVN 和 Git，一定要确保所有人都使用 SVN 服务来协作——这会让生活轻松很多。","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"svn","slug":"git/svn","permalink":"https://huos3203.github.io/categories/git/svn/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://huos3203.github.io/tags/命令/"}]},{"title":"Realm数据库引擎-swift","slug":"开源库/Realm数据库引擎-swift","date":"2015-12-16T05:56:15.000Z","updated":"2019-04-24T23:21:29.835Z","comments":true,"path":"2015/12/16/开源库/Realm数据库引擎-swift/","link":"","permalink":"https://huos3203.github.io/2015/12/16/开源库/Realm数据库引擎-swift/","excerpt":"","text":"中心思想：继承RLMObject新建数据模型，添加相应属性，即可使用realm数据库引擎，对用户数据创建持久化，更新，删除等操作。 简介：Realm 是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。 特点：它拥有自己的数据库存储引擎 Realm 并不是对 Core Data 的简单封装，相反地， Realm 并不是基于 Core Data ，也不是基于 SQLite 所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。 Realm 支持 Swift 、 Objective-C 以及 Java 语言来编写（ Android 平台和 iOS 平台使用不同的 SDK ）。 Realm 比使用 SQLite 以及 Core Data 要快很多。 可视化工具Realm Browser ：可以让您轻松地读写 Realm 数据库的逻辑结构以及其中的数据（以 .realm 结尾），虽然 Realm Browser 的功能还十分简陋，真的只能读写而已。 RealmPlugin：是 Xcode 建模插件，通过 Alcatraz安装“RealmPlugin”目的：学习如何导入 Realm 框架、创建数据模型，实现 Swift 执行查询以及插入、更新和删除记录，以及使用既有的数据库。实例学习：测试APP物种监测用于记录这个 “ 动植物王国 ” 当中所发现物种的相关信息，包括种群数量、发现区域、年龄结构等等。 在 Xcode 当中打开我们的起始项目。此时， MapKit已经在项目当中建立好了，而且项目已经拥有了一些简单的创建、更新和删除物种信息的功能. cocoapods安装（Swift 2.1）：在项目中创建Podfile配置文件，添加RealmSwift支持12use_frameworks! //pod &apos;RealmSwift&apos; 执行 pod install下载realmSwift框架，生成.xcworkspace文件，自动重启原始项目。设置Xcode项目在git版本控制中的忽略配置：详见.gitignore use_frameworks! 如果在cocoapods 里面不使用 use_frameworks!,则是通过static libraries 这个方式来管理pod的代码。这样就需要在app-Bridging-Header.h 文件里面去import相应的.h 文件。而如果使用了use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。 开始使用：编译并运行这个应用，然后尝试定位到某个您感兴趣的位置（使用模拟器的位置模拟），然后点击右上角的 “+” 按钮创建一个新的标记点。点选地图上的这个标记点，然后点击其弹出来的气泡，接下来会弹出这个标记点的详细信息。随后，点击类别文本框，就可以看到如下图所示的类别列表了: 使用Realm数据库将类别列表持久化 打开CategoriesTableViewController.swift 文件添加方法： 12345678910111213141516private func populateDefaultCategories() &#123;self.results = CategoryModel.allObjects() // 1 查询数据返回包含类别对象的RLMResults数组if results.count == 0 &#123; // 2 通过返回结果的个数，初始化本地realm数据库let realm = RLMRealm.defaultRealm() // 3 访问默认的 realm 单例对象realm.beginWriteTransaction() // 4 在默认 realm 数据库中启动一个事务let defaultCategories = Categories.allValues // 5 使用Categories 枚举来创建一个含有全部默认类别的数组for category in defaultCategories &#123;// 6 初始化类别实例对象，设置其 name 属性，加入realm中let newCategory = CategoryModel()newCategory.name = categoryrealm.addObject(newCategory)&#125;realm.commitWriteTransaction() // 7 调用 commitWriteTransaction() 方法来关闭事务，并且向数据库提交数据self.results = CategoryModel.allObjects()&#125;&#125; 在 viewDidLoad() 方法的底部加入以下代码： 1populateDefaultCategories()","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://huos3203.github.io/tags/数据库/"},{"name":"realm","slug":"realm","permalink":"https://huos3203.github.io/tags/realm/"}]},{"title":"OC与swift相互调用","slug":"swift/OC与swift相互调用","date":"2015-12-01T11:42:18.000Z","updated":"2019-04-24T23:21:29.825Z","comments":true,"path":"2015/12/01/swift/OC与swift相互调用/","link":"","permalink":"https://huos3203.github.io/2015/12/01/swift/OC与swift相互调用/","excerpt":"","text":"Swift中使用OC的类声明 – 实现配置 桥接的头文件方式一：自动添加桥接头文件 在一个全新的Swift，利用第一次新建提示的方式自动添加桥接头文件。 点确定这后就会生成一个以&lt;produceName-Bridging-Header.h&gt;的头文件。 在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。 把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：123// Use this file to import your target's public headers that you would like to expose to Swift. //MixDemo/MixDemo-Bridging-Header.h #import \"OCChannel.h\" 方式二：手动添加桥接头文件同样的，当你知道这个swift搜索头文件的关系后，就不需要再理会这个-Bridging-Header.h的文件了。完全可以手工建一个并取自己喜欢的名字： 新建一个头文件，名为:OCContainerHeader.h 在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。 把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：123// Use this file to import your target's public headers that you would like to expose to Swift. //MixDemo/MixDemo-Bridging-Header.h #import \"OCChannel.h\" OC如何调用Swift写的类 – 为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记； 选中targets-&gt;build settings -&gt;packing-&gt;Product Module Name 中设置模块名（可以自定义），这个名称很重要 swift 的头文件就是根据这个来命名的，例如：SwiftModule。 在OC头文件类中，添加import “SwiftModule-swift.h”但你在整个工程中是找不到这个文件的，但可以使用CMD+ 鼠标点击可看这个头文件中的内容。 总结：这样，工程中如查Swift要使用OC,则把需要使用的OC类的头文件，全写在MixDemo-Bridging-Header.h里。同样如果OC中所使用的swift类，只需要Clean一把，再编就可以了，但不要忘了导入SwiftModule-swift.h哦（名称自取，但-swift.h是固定的），另外还有一个需要读者注意的。 注： 凡是用Swift写的类，如果不继成自NSObject或NSObject 的派生类，哪么编译后将不会生成对应的转换类。从而使得OC 中找不到相应的声明。如我的例子中 class Act 这样不会被编译到SwiftModule-swift.h中，但写为 class Act : NSObject，就可以编译出相应的声明。另外可以使用@objc加以声明，但这个还是一样，类最好继承NSObject下来。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"OC混编","slug":"swift/OC混编","permalink":"https://huos3203.github.io/categories/swift/OC混编/"}],"tags":[{"name":"混编","slug":"混编","permalink":"https://huos3203.github.io/tags/混编/"}]},{"title":"Swift入门","slug":"swift/Swift入门","date":"2015-11-27T17:18:21.000Z","updated":"2019-04-24T23:21:29.825Z","comments":true,"path":"2015/11/28/swift/Swift入门/","link":"","permalink":"https://huos3203.github.io/2015/11/28/swift/Swift入门/","excerpt":"","text":"苹果官方 中文版背景Apple基于已有的编译器、调试器、框架作为其基础架构。通过ARC(Automatic Reference Counting，自动引用计数)来简化内存管理。我们的框架栈则一直基于Cocoa，且Objective-C进化支持了块、collection literal和模块，允许现代语言的框架无需深入即可使用。(by gashero)感谢这些基础工作，才使得可以在Apple软件开发中引入新的编程语言Swift。 swift有点编译器是按照性能优化的，而语言是为开发优化的 Swift采用了Objective-C的命名参数和动态对象模型。提供了对Cocoa框架和mix-and-match的互操作性。基于这些基础，Swift引入了很多新功能和结合面向过程和面向对象的功能。Swift对新的程序员也是友好的： 它是工业级品质的系统编程语言，却又像脚本语言一样的友好。 它支持playground，允许程序员实验一段Swift代码功能并立即看到结果，而无需麻烦的构建和运行一个应用。Swift集成了现代编程语言思想，以及Apple工程文化的智慧，编译器是按照性能优化的，而语言是为开发优化的，无需互相折中。 swift语法Playground允许你编辑代码并立即看到结果,可以从”Hello, world”开始学起并过渡到整个系统。在Xcode的playground中打开:1println(\"Hello, world\") 在Swift，这就是完整的程序: 无需导入(import)输入输出和字符串处理的系统库。 全局范围的代码就是用于程序的入口，所以你无需编写一个 main() 函数。也无需在每个语句后写分号。 所有这些使得Swift成为Apple软件开发者创新的源泉。 简单值 – 使用 let 来定义常量， var 定义变量提供一个值就可以创建常量或变量，并让编译器推断其类型,一个常量或变量必须与赋值时拥有相同的类型。因此你不用严格定义类型。常量定义类似于函数式编程语言中的变量,常量的值无需在编译时指定，但是至少要赋值一次,赋值后就无法修改。123var myVariable = 42myVariable = 50let myConstant = 42 在上面例子中，编译其会推断myVariable是一个整数类型，因为其初始化值就是个整数。 1. 显示/隐式 初始化数据类型 — 类型与变量名绑定，属于静态类型语言类型与变量名绑定，属于静态类型语言。有助于静态优化。与Python、JavaScript等有所区别。例如：初始化值没有提供足够的信息(或没有初始化值)，可以在变量名后写类型，以冒号分隔。123let imlicitInteger = 70let imlicitDouble = 70.0let explicitDouble: Double = 70 2. 变量 拼接到字符串 – 变量值永远不会隐含转换到其他类型 String(变量名) 123let label = \"The width is \"let width = 94let widthLabel = label + String(width) 以小括号来写值，并用反斜线(“”)放在小括号之前 1234let apples = 3let oranges = 5 //by gasherolet appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 数组和字典的用法 声明并初始化123let emptyArray = String[]()let emptyDictionary = Dictionary&lt;String, Float&gt;()shoppingList = [] //去购物并买些东西 如果数组类型无法推断，你可以写空的数组为 “[]” 和空的字典为 “[:]“。 访问创建一个数组和字典使用方括号 “[]”，访问其元素则是通过方括号中的索引或键。 1234567var shoppingList = [\"catfish\", \"water\", \"tulips\", \"blue paint\"]shoppingList[1] = \"bottle of water\"var occupations = [ \"Malcolm\": \"Captain\", \"Kaylee\": \"Mechanic\",]occupations[\"Jayne\"] = \"Public Relations\" 控制流 – 条件控制，循环控制1. 条件控制 if 条件必须是布尔表达式在 if 语句中，条件必须是布尔表达式，这意味着 if score { … } 是错误的，不能隐含的与0比较。你可以一起使用 if 和 let 来防止值的丢失。这些值是可选的。可选值可以包含一个值或包含一个 nil 来指定值还不存在。写一个问号 “?” 在类型后表示值是可选的。 1234567var optionalString: String? = \"Hello\"optionalString == nilvar optionalName: String? = \"John Appleseed\"var greeting = \"Hello!\"if let name = optionalName &#123; greeting = \"Hello, \\(name)\"&#125; switch 支持多种数据以及多种比较，不限制必须是整数和测试相等 1234567891011let vegetable = \"red pepper\"switch vegetable &#123;case \"celery\": let vegetableComment = \"Add some raisins and make ants on a log.\"case \"cucumber\", \"watercress\": let vegetableComment = \"That would make a good tea sandwich.\"case let x where x.hasSuffix(\"pepper\"): let vegetableComment = \"Is it a spicy \\(x)?\"default: //by gashero let vegetableComment = \"Everything tastes good in soup.\"&#125; 在执行匹配的情况后，程序会从 switch 跳出，而不是继续执行下一个情况。所以不再需要 break 跳出 switch 。 2. 循环控制 for-in 来迭代字典中的每个元素可使用 for-in 来迭代字典中的每个元素，提供一对名字来使用每个键值对。1234567891011121314151617181920212223242526let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;``` 你可以在循环中保持一个索引，通过“..”来表示索引范围或明确声明一个初始值、条件、增量。 这两个循环做相同的事情: ```swiftvar firstForLoop = 0for i in 0..3 &#123; firstForLoop += i&#125;firstForLoopvar secondForLoop = 0for var i = 0; i &lt; 3; ++i &#123; secondForLoop += 1&#125; 使用 .. 构造范围忽略最高值，而用 … 构造的范围则包含两个值。 while 来重复执行代码块直到条件改变使用 while 来重复执行代码块直到条件改变。循环的条件可以放在末尾来确保循环至少执行一次。12345678910var n = 2while n &lt; 100 &#123; n = n * 2&#125;nvar m = 2do &#123; m = m * 2&#125; while m &lt; 100m 函数与闭包 – 函数是闭包的特殊情况1. 闭包 无需名字，只需要放在大括号中即可编写闭包时有多种选项: 使用 in 到特定参数和主体的返回值。 12345numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result &#125;) 单一语句的闭包可以直接返回值例如：当一个闭包的类型是已知时，例如代表回调，你可以忽略其参数和返回值，或两者 1numbers.map(&#123;number in 3 * number&#125;) 通过数字而不是名字来引用一个参数，这对于很短的闭包很有用。例如：一个闭包传递其最后一个参数到函数作为返回值。 1sort([1, 5, 3, 12, 2]) &#123; $0 &gt; $1 &#125; 2. 函数 函数的声明 – 使用func 声明一个函数 使用 -&gt;分隔参数的名字和返回值类型,调用函数使用他的名字加上小括号中的参数列表 1234func greet(name: String, day: String) -&gt; String &#123; return \"Hello \\(name), today is \\(day).\"&#125;greet(\"Bob\", \"Tuesday\") 函数的嵌套内嵌函数可以访问其定义所在函数的变量。你可以使用内嵌函数来组织代码，避免过长和过于复杂： 12345678func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125; 函数接收的参数 可变参数的个数 sumOf(numbers: Int…) -&gt; Int{}函数可以接受可变参数个数，收集到一个数组中 123456789func sumOf(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;//例子sumOf(42, 597, 12) 其他函数作为参数 func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool{} 12345678910111213 func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(numbers, lessThanTen) 函数实际是闭包的特殊情况。你可以写一个闭包而无需名字，只需要放在大括号中即可。使用 in 到特定参数和主体的返回值。 函数的返回值 返回多个值 ： getGasPrices() -&gt; (Double, Double, Double)使用元组(tuple)来返回多个值 123func getGasPrices() -&gt; (Double, Double, Double) &#123; return (3.59, 3.69, 3.79)&#125; 返回另一个函数 ： makeIncrementer() -&gt; (Int -&gt; Int)函数是第一类型的 12345678func makeIncrementer() -&gt; (Int -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment = makeIncrementer()increment(7) 对象与类1. 类的创建 ：class 类名 {} 使用 class 可以创建一个类。一个属性的声明则是在类里作为常量或变量声明的，除了是在类的上下文中。方法和函数也是这么写的。 123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 类的构造器 ： 构造器来在创建实例时设置类，使用 init 来创建 123456789101112class NamedShape &#123; var numberOfSides: Int = 0 var name: String init(name: String) &#123; self.name = name &#125; //by gashero func simpleDescription() -&gt; String &#123; return \"A Shape with \\(numberOfSides) sides.\" &#125;&#125; self 用来区分 name 属性和 name 参数。构造器的声明跟函数一样，除了会创建类的实例。每个属性都需要赋值，无论在声明里还是在构造器里。 类的析构器，来执行对象销毁时的清理工作，使用 deinit 来创建使用 deinit 来创建一个析构器，来执行对象销毁时的清理工作。 超类的继承 子类包括其超类的名字，以冒号分隔。在继承标准根类时无需声明，所以你可以忽略超类。 子类的方法可以通过标记 override 重载超类中的实现，而没有 override 的会被编译器看作是错误,编译器也会检查那些没有被重载的方法。1234567891011121314151617181920class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength: 5.2, name: \"my test square\")test.area()test.simpleDescription() 2. 类的实例创建 : 类名() ,点语法来访问实例的属性和方法通过在类名后加小括号来创建类的实例。使用点语法来访问实例的属性和方法。123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 可选类型 Int?可选绑定 if while 强制取值表达式 expression!可选链表达式 expression? 类型转换运算符 is , as, is?, as! 标示符模式值绑定模式可选模式类型转换模式 实例方法 func类型方法 class func","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"语法","slug":"swift/语法","permalink":"https://huos3203.github.io/categories/swift/语法/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"产品领导者的五种特质","slug":"管理/产品领导者的五种特质","date":"2015-11-27T10:24:44.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"2015/11/27/管理/产品领导者的五种特质/","link":"","permalink":"https://huos3203.github.io/2015/11/27/管理/产品领导者的五种特质/","excerpt":"1.善于观察他们一直在观察用户，不仅仅是借助指标和仪表盘。他们对每件小事情感到好奇： 用户正尝试完成什么？ 为什么用户选择这款产品而非其它产品？ 他们在和这款产品交互之前、之中和之后，做了什么。 他们查看收到的每一条反馈，对每个客户问题做出响应。他们创建让人愉悦的调查，知道该问什么，什么时候该倾听或无视。他们在 Facebook 上和用户交朋友——他们能叫得出用户名字。他们深知，核心用户会成为产品本身的一部分。 他们痴迷于研究。他们知道市场的运作方式、未来走向以及竞争要做什么。他们密切注视着一切，除了没有创建一个显而易见的版本。","text":"1.善于观察他们一直在观察用户，不仅仅是借助指标和仪表盘。他们对每件小事情感到好奇： 用户正尝试完成什么？ 为什么用户选择这款产品而非其它产品？ 他们在和这款产品交互之前、之中和之后，做了什么。 他们查看收到的每一条反馈，对每个客户问题做出响应。他们创建让人愉悦的调查，知道该问什么，什么时候该倾听或无视。他们在 Facebook 上和用户交朋友——他们能叫得出用户名字。他们深知，核心用户会成为产品本身的一部分。 他们痴迷于研究。他们知道市场的运作方式、未来走向以及竞争要做什么。他们密切注视着一切，除了没有创建一个显而易见的版本。 2.技术他们或许没有计算机科学学位，但是凭借其悟性，足以解释事物运作的方式。他们理解软件开发的过程（和复杂度），打造增量改变的文化，还能借助可用的数据点清晰明了地交流。他们对优先级毫不留情。 他们是脚本瘾君子——他们能够不依赖工程师而自动化很多工作。为了检查产品，他们创造工具，最终成为每个人手头最重要的工具。 他们在工程师圈子里保持良好联系——知道从哪儿得到某些工程师的快速帮助、或雇佣到全职的明星工程师。 他们明白，写代码除了开发产品——还能节约大量时间。 3.分析他们或许不是正式的数据科学家，但他们是数据狂热者。他们理解大数据和不良数据的差异。他们对各种分析工具一点儿也不陌生，为了捕捉到有意义的数据，他们知道该增加什么或何时增加。 他们熟悉足够多的数据工具和框架，能够快速分析，并找到见解。他们总是寻找盲点。他们做出数据启迪、而非数据驱动的决定。 他们和数据科学社区保持良好联系——他们知道从哪儿能得到快速的数据科学方面的帮助，以及雇佣到明星数据科学家。 他们明白，大量的数据分析只用 web 浏览器就能快速搞定。 4.聚焦设计他们可能不是视觉设计师，但是理解设计的真谛及其重要性。他们知道，好的设计不单单取决于优秀的设计师，而要在团队内部打造一种强烈的设计文化。他们理解，好的设计花费时间，也知道良好、完美与完成之间的区别。 他们熟悉快速设计的工具，除了编写产品说明，还能够清晰地为振奋人心的想法和概念添加插图。他们不断地寻找设计灵感，他们激发着设计师。 他们和设计社区保持良好联系——他们知道从哪儿能得到快速的兼职设计方面的帮助，以及雇佣到优秀的全职设计师。 他们明白，设计不单单是设计师的工作——它是团队每个人的心态和文化。 5.企业家精神他们或许还没有打造过十亿美元的业务，但是已经上线了、并使得至少一款产品取得了增长（他们自己出钱），并以此为荣，即使没有上线亦如此。他们乐于介绍过程——为什么世界需要他们的产品、他们怎样获取用户、效果不佳的问题在哪儿。 他们相信，世界真的是平的，渴望成功。他们以之前的作品为荣，但是在内心深处藏着更大的欲望，那就是为十亿用户开发产品，让世界变得更美好。 他们明白，在拥有的全部技能中，勇气和坚持不懈才是最重要的两个特点。","categories":[{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/categories/管理/"}],"tags":[{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/tags/管理/"}]},{"title":"UIImage的渲染模式","slug":"iOS/UI/UIImage的渲染模式","date":"2015-11-26T16:15:11.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2015/11/27/iOS/UI/UIImage的渲染模式/","link":"","permalink":"https://huos3203.github.io/2015/11/27/iOS/UI/UIImage的渲染模式/","excerpt":"","text":"设置UIImage的渲染模式：UIImage.renderingMode在 iOS 7 中 UIImage 添加了一个 renderingMode 属性。我们可以使用 imageWithRenderingMode:并传入一个合适的UIImageRenderingMode 来指定这个 image 要不要以 Template 的方式进行渲染。1234567891011121314151617UIImageRenderingModeAutomatic // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。UIImageRenderingModeAlwaysOriginal // 始终绘制图片原始状态，不使用Tint Color。UIImageRenderingModeAlwaysTemplate // 始终根据Tint Color绘制图片，忽略图片的颜色信息。UIImage *img = [UIImage imageNamed:@\"myimage\"];img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];//实际效果，效果依旧显示为baritem的Tint ColorUIBarButtonItem *barButtonItem = [[UIBarButtonItem alloc] initWithImage:setImage style:UIBarButtonItemStylePlain target:self action:@selector(setAction:)];``` 在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在`UIApperance`中，Apple 也为我们对于 `Size Classes` 添加了相应的方法。使用 `+appearanceForTraitCollection:` 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。```objcUIView.appearanceForTraitCollection(UITraitCollection(verticalSizeClass:.Compact)).tintColor = UIColor.redColor() UIView.appearanceForTraitCollection(UITraitCollection(verticalSizeClass:.Regular)).tintColor = UIColor.greenColor()","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"控件","slug":"iOS/控件","permalink":"https://huos3203.github.io/categories/iOS/控件/"}],"tags":[{"name":"坑","slug":"坑","permalink":"https://huos3203.github.io/tags/坑/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"}]},{"title":"敏捷开发总结","slug":"管理/敏捷开发总结","date":"2015-11-20T10:06:38.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"2015/11/20/管理/敏捷开发总结/","link":"","permalink":"https://huos3203.github.io/2015/11/20/管理/敏捷开发总结/","excerpt":"","text":"传统开发模型的局限性什么是敏捷软件开发Scrum概述Scrum角色Scrum活动Scrum实践Scrum工具和模板Scrum常见问题推荐书籍敏捷方法强调以人为本，专注于交付对客户有价值的软件。在高度协作的开发环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行自我调整和完善。 Scrum Team中的三种角色 Product Owner- 产品所有者个人：代表所有的干系人 Scrum Master:个人：负责指导过程的执行 Scrum Team – Scrum团队:承诺完成工作，向干系人交付产品价值 Product Owner- 产品所有者： 1 利益相关方的代表,重点是产品方面，与Scrum Master和Team合作 2 从业务角度出发对需求进行排序 3 合理的调整产品功能和迭代顺序 4 侧重于投资回报 Scrum Master职责:1 为Scrum Team服务,确保每个成员都认同Scrum价值观和游戏规则 2 帮助Scrum Team规划Sprit计划 3 组织每天的Daily Scrum会议 4 负责保证Scrum Team 高效持续运转 5 决策和免除障碍，保证团队不受外来无端的影响 Scrum Team – Scrum团队: 1 尽一切可能去完成任务-发布产品 2 充分理解产品负责人的产品愿景 3 合作完成冲刺(Sprint)中每一个目标 4 更好的支持可能需要进一步开发的产品发布","categories":[{"name":"管理","slug":"管理","permalink":"https://huos3203.github.io/categories/管理/"}],"tags":[{"name":"Scrum","slug":"Scrum","permalink":"https://huos3203.github.io/tags/Scrum/"}]},{"title":"calabash一款跨平台UI测试工具初探","slug":"测试/calabash一款跨平台UI测试工具初探","date":"2015-10-06T08:32:41.000Z","updated":"2019-04-24T23:21:29.835Z","comments":true,"path":"2015/10/06/测试/calabash一款跨平台UI测试工具初探/","link":"","permalink":"https://huos3203.github.io/2015/10/06/测试/calabash一款跨平台UI测试工具初探/","excerpt":"","text":"参考：使用jenkins+calabash+cocoapods搭建ios持续集成环境 calabash 是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。 安装Calabash 1sudo gem install calabash-cucumber 安装Calabash中文支持包 1sudo gem install calabash-cucumber-cn For automatic setup: In a terminal, go to your iOS project 123 cd path-to-my-ios-project (i.e. directory containing .xcodeproj file) ``` 2. Install calabash-cucumber gem (this make take some time because of dependencies) gem install calabash-cucumber 13. Setup your project for Calabash-iOS. calabash-ios setup //Answer the questions and read the output :) 14. Generate a skeleton features folder for your tests calabash-ios gen 1235. In Xcode, build your project using the -cal scheme6. Run the generated test! cucumber 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.&lt;!--more--&gt;#### [cucumber官网](https://cukes.info/) * Feature（功能） * Scenario（情景） * Given（给定） * When（当） * Then（则） #####[运行原理](http://www.educity.cn/se/619226.html) ![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg) cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。 #####结构框架calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。 ![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg) feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。 再看一下其中的内容： my_first.feature Feature： 登陆 Scenario： 输入正确的用户名密码能够正常登陆 When 打开登陆页面 And 输入用户名XXX输入密码XXX And 点击登陆 Then 验证登陆成功 看起来很简单吧，想要验证其他功能也是类似的语言描述即可。 如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢， 那么看一下step_definition，以 输入用户名XXX输入密码XXX为例： When /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot; $/ do |username，password| performAction(&apos;enter_text_into_numbered_field&apos;，username，1) performAction(&apos;enter_text_into_numbered_field&apos;，password，2) end现在应该能明白为什么你需要写汉字的脚本就可以了吧。 在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。 还是以这个登录脚本为例： 假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了#####运行报告alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。 例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告 ![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) 1. my_first.feature: 描述在这个条件下需要做什么事情； Feature: Running a test As an iOS developer I want to have a sample feature file So I can begin testing quickly Scenario: Example steps1 Given I am on the Welcome Screen Then I swipe left And I wait until I don&apos;t see &quot;Please swipe left&quot; And take picture Scenario: Example steps2 Given I am on the Welcome Screen #ASSERTION Then I should see a &quot;login&quot; button #INPUT TEXT Then I enter &quot;my_username&quot; into text field number 1 # Then I touch &quot;Return&quot; #TOGGLE SWITCH Then I toggle the switch Then I touch &quot;Login&quot; And I touch &quot;Second&quot; And take picture 该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. 2. my_first_step.rb: 解释了Given的具体条件 Given /^I am on the Welcome Screen$/ do element_exists(&quot;view&quot;) check_element_exists(&quot;label text:&apos;First View&apos;&quot;) sleep(STEP_PSEAU) end 这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot; [更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)UIAutomationUIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：- 如何找到界面上的一个UI元素- 如何指定针对一个UI元素的操作在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：- name- value- elements- parent- …而整个界面的层级结构如下： arget（设备级别的UI，用于支持晃动，屏幕方向变动等操作） Application（设备上的应用，比方说Status Bar，keyboard等） Main window（应用的界面，比方说导航条） View（界面下的View，比方说UITableView） Element（View下的一个元素） Child element(元素下的一个子元素)下面是一个访问到Child element的例子： UIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：- 点击按钮，例: ***.buttons[“add”].tap()- 输入文本, 例:***.textfields[0].setValue(“new”)- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)- ……关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation) Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下```rubyxcodebuild-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; -schemeAudioDemo-sdk iphonesimulator6.1 -configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; install 启动Instruments，基于第一步生成的应用运行UIAutomation测试 instruments -t \"/Applications/Xcode.app/Contents/Applications/Instruments.app/ Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/ Automation.tracetemplate\" \"/Users/twer/Documents/xcodeworkspace/AudioDemo /build/Applications/TestExample.app\" -e UIASCRIPT &lt;absolute_path_to_the_test_file&gt; 为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: https://github.com/shaune/jasmine-ios-acceptance-tests UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，Fone Monkey,最新版本更新于2010年，估计过时就是其中的一个优秀成果。","categories":[{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/categories/测试/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"UI","slug":"UI","permalink":"https://huos3203.github.io/tags/UI/"},{"name":"测试","slug":"测试","permalink":"https://huos3203.github.io/tags/测试/"}]},{"title":"使用SmartSVN创建版本库","slug":"git/使用SmartSVN创建版本库","date":"2015-10-05T19:16:47.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2015/10/06/git/使用SmartSVN创建版本库/","link":"","permalink":"https://huos3203.github.io/2015/10/06/git/使用SmartSVN创建版本库/","excerpt":"SmartSVN有以下版本： SmartSVN enterprise 9 企业版 SmartSVN foundation 8 基础版 由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。 用基础版来说明创建版本库。参考：Create Repository in SmartSVN – Tutorial 启动SmartSVN SmartSVN foundation 8 基础版 菜单栏Project-&gt; set up Local Repository…需要设置如下两个参数： svnadmin 在终端执行： whereis svnadmin svnserve 在终端执行： whereis svnserve￼ 指定版本库的目录位置： 初始化账户密码： 完成。","text":"SmartSVN有以下版本： SmartSVN enterprise 9 企业版 SmartSVN foundation 8 基础版 由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。 用基础版来说明创建版本库。参考：Create Repository in SmartSVN – Tutorial 启动SmartSVN SmartSVN foundation 8 基础版 菜单栏Project-&gt; set up Local Repository…需要设置如下两个参数： svnadmin 在终端执行： whereis svnadmin svnserve 在终端执行： whereis svnserve￼ 指定版本库的目录位置： 初始化账户密码： 完成。 开始导入项目源码，来跟踪版本变化，实现版本控制。 新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。 菜单栏Project -&gt; Import Into Repository… 选择以上新建的SmartSVN版本库：svn://localhost 查看是否安装SVN服务： svnserve —version SVN随系统一起启动： vi /etc/rc.local //(此文件Mac系统中默认是不存在的，需手动创建) 添加启动SVN服务： svnserve -d -r /data/svn/repos 关闭svn服务: 直接ps aux | grep svn，然后kill -9 进程号 创建库: 打印应用目录命令： whereis svn 新建版本库目录： sudo mkdir -p /data/svn/repos/local chmod u+w 文件名 创建： sudo svnadmin create /data/svn/repos/local 查看文件权限： ls -l 配置版本库的访问权限 cd conf/ 开启密码权限，普通用户/匿名用户 sudo vi svnserve.conf 设置用户：密码 sudo vi passwd 分组设置，组权限 sudo vi authz 启动svnserve服务 sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log 测试端口： telnet localhost 3690 重启必先kill ： sudo kill PID 版本库路径： svn://localhost/local 其他： svn ls svn://svnpath 可以查询snv仓库内容 lsof -i :3690 查看svn是否启动 ps aux | grep ‘svn’ 查找所有svn启动的进程id kill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"svn","slug":"git/svn","permalink":"https://huos3203.github.io/categories/git/svn/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"搭建","slug":"搭建","permalink":"https://huos3203.github.io/tags/搭建/"},{"name":"svn","slug":"svn","permalink":"https://huos3203.github.io/tags/svn/"}]},{"title":"[转]Swift最佳实践","slug":"swift/[转]Swift最佳实践","date":"2015-09-29T17:05:21.000Z","updated":"2019-04-24T23:21:29.825Z","comments":true,"path":"2015/09/30/swift/[转]Swift最佳实践/","link":"","permalink":"https://huos3203.github.io/2015/09/30/swift/[转]Swift最佳实践/","excerpt":"","text":"[英文][SwiftCommunityBestPractices][SwiftCommunityBestPractices]: https://github.com/schwa/Swift-Community-Best-Practices[SwiftCommunity]: http://swift-lang.schwa.io/[swiftCaptureLists]: http://www.russbishop.net/swift-capture-lists[SwiftURL]: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html[驼峰命名法URL]: http://www.wikiwand.com/en/Studly_caps[匈牙利命名法URL]: http://www.wikiwand.com/en/Hungarian_notation 黄金法则 Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。 不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。 最佳实践命名按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: “VehicleController”)。 变量与常量应该使用首字母小写的驼峰命名法(例如: “ vehicleName “ )。 推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。 不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 SNAKE_CASE 这样的名字。 这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)： 123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Nepture&#125; 有必要的话命名不要缩写实际上在 Xcode 的”文本自动补全”功能下你可以轻而易举地键入 类似 ViewController 的长命名。 极为常见的缩写例如: URL 缩写应该是全部大写 ( “URL” )或者酌情全部小写( “url” )。 URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。 注释不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。 (TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接) 类型推导如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如：1var currentLocation = Location() 而非： 1var currentLocation: Location = Location() 内省让编译器自动推断所有的情况，这是可以做到的。在一些领域 self 应该被显式地使用，包括在 init 中设置参数，或者 non-escaping闭包。例如：123456struct Example&#123; let name: String init(name: String) &#123; self.name = name &#125;&#125; 捕获列表的类型推导在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。 12345678910let people = [ (\"Mary\", 42), (\"Susan\", 27), (\"Charlie\", 18),] let strings = people.map() &#123; (name: String, age: Int) -&gt; String in return \"\\(name) is \\(age) years old\"&#125; 如果编译器可以推导出来的话，完全可以把类型删掉：(name: String, age: Int) -&gt; String1234let strings = people.map() &#123; (name, age) in return \"\\(name) is \\(age) years old\"&#125; 使用编号的参数名 (“$0”) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。 Apple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。例如，optionals 被删除或更改为 auto-unwrapping 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。 你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的: 1234dispatch_async(queue) &#123; ()-&gt;Void in print(\"Fired.\")&#125; (以上内容也可以参考:[这里][swiftCaptureLists]) 常量类型定义中使用的常量应当被申明成静态类型。例如:1234567891011struct PhysicsModel &#123; static var speedOfLightInAVacuum = 299_792_458&#125;class Spaceship &#123; static let topSpeed = PhysicsModel.speedOfLightInAVacuum var speed: Double func fullSpeedAhead() &#123; speed = Spaceship.topSpeed &#125;&#125;将常量标示为 static ，允许它们可以被无类型的实例引用。 一般应该避免生成全局范围的常量，单例除外。","categories":[{"name":"swift","slug":"swift","permalink":"https://huos3203.github.io/categories/swift/"},{"name":"语法","slug":"swift/语法","permalink":"https://huos3203.github.io/categories/swift/语法/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://huos3203.github.io/tags/语法/"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2019-04-24T23:21:29.795Z","comments":true,"path":"2015/09/28/git/Mac安装gitLab服务器/","link":"","permalink":"https://huos3203.github.io/2015/09/28/git/Mac安装gitLab服务器/","excerpt":"","text":"必要配置*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组 *开启gitlab用户的远程登录 在系统启动界面:隐藏gitlab用户 sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab 显示git用户 sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList 添加系统账户gitlab生成gitlab服务器目录，即用户根目录进入系统偏好设置…,在管理用户与群组中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab. 安装 Gitlab Shellcd /Users/gitlab sudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git cd gitlab-shell sudo -u gitlab git checkout v1.9.1 sudo -u gitlab cp config.yml.example config.yml 打开 config.yml,然后进行编辑设置 gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）把所有的/home 替换成 /Users sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml 然后执行安装脚本：sudo -u gitlab -H ./bin/install //需在gitlab-shell目录下载执行 安装gitlab先下载gitlab cd /Users/gitlab sudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git cd gitlab sudo -u gitlab git checkout 6-7-stable 配置gitlab sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml sudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml 配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限 # Login to MySQL $ mysql -u root -p # Create the GitLab production database mysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`; # Create the MySQL User change $password to a real password mysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;; # Grant proper permissions to the MySQL User mysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;; 安装 Gitolite帮助管理git内部用户克隆gitlab的gitolite分支源代码： sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite 安装： cd /Users/gitlab sudo -u gitlab -H mkdir bin sudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos; sudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos; sudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub sudo chmod 0444 /Users/gitlab/gitlab.pub sudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot; 为 Git 创建用户： sudo adduser \\ --system \\ --shell /bin/sh \\ --gecos &apos;git version control&apos; \\ --group \\ --disabled-password \\ --home /home/git \\ git 若干问题解决办法：Mac搭建Git服务器—开启SSH Cloning into &apos;/tmp/gitolite-admin&apos;... ssh: connect to host localhost port 22: Connection refused fatal: Could not read from remote repository. SSH无密码登陆设置： $ cd /etc $ chmod 666 sshd_config $ vim sshd_config #PermitRootLogin yes 改为：PermitRootLogin no #UsePAM yes 改为: UsePAM no Remove the # from the following #RSAAuthentication yes #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys #PasswordAuthentication no #PermitEmptyPasswords no","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"gitLab","slug":"git/gitLab","permalink":"https://huos3203.github.io/categories/git/gitLab/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/tags/git/"},{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"gitLab","slug":"gitLab","permalink":"https://huos3203.github.io/tags/gitLab/"},{"name":"搭建","slug":"搭建","permalink":"https://huos3203.github.io/tags/搭建/"}]},{"title":"小米路由常用操作","slug":"智能设备/小米路由常用操作","date":"2015-09-25T23:59:16.000Z","updated":"2019-04-24T23:21:29.835Z","comments":true,"path":"2015/09/26/智能设备/小米路由常用操作/","link":"","permalink":"https://huos3203.github.io/2015/09/26/智能设备/小米路由常用操作/","excerpt":"常用命令 ssh登录 局域网登录: ssh [user@]hostname [command] 例如：ssh root@192.168.31.1 或 远程登录：ssh root@222.35.145.28 -p 2195 回车 输入密码 **修改密码：** root@xiaoqiang:~#passwd 回车 输入新密码 回车 再次输入新密码 远程拷贝数据 scp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx 每次重启路由获取IP: vi /etc/rc.local sh /etc/getIP.sh //启动后，等待20秒，然后，获取当前时间作为文件名称//使用ifconfig 获取路由器的ip信息//使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行// &gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中//通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中//查看该文件，既有路由重启后的当前IP","text":"常用命令 ssh登录 局域网登录: ssh [user@]hostname [command] 例如：ssh root@192.168.31.1 或 远程登录：ssh root@222.35.145.28 -p 2195 回车 输入密码 **修改密码：** root@xiaoqiang:~#passwd 回车 输入新密码 回车 再次输入新密码 远程拷贝数据 scp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx 每次重启路由获取IP: vi /etc/rc.local sh /etc/getIP.sh //启动后，等待20秒，然后，获取当前时间作为文件名称//使用ifconfig 获取路由器的ip信息//使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行// &gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中//通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中//查看该文件，既有路由重启后的当前IP 详见getIP.sh #!/bin/sh sleep 20 current_date=`date +%Y_%m_%d` current_time=`date +%H_%M_%S` echo $current_date echo $current_time #local_ip=`ifconfig |grep &apos;[0-9]\\{1,3\\}.*P-t-P&apos;` local_ip=`ifconfig | grep P-t-P` echo $local_ip &gt; /userdisk/data/my/ip/$current_date:$current_time.txt 修改防火墙设置/etc/config目录下的dropbear和firewall cd /etc/config //把备份文件内容覆盖新文件即可 1.cat dropbear.bak &gt; dropbear 增加如下内容： config dropbear option PasswordAuth &apos;on&apos; option RootPasswordAuth &apos;on&apos; option Interface &apos;wan&apos; option Port &apos;2195&apos; 2.保存文件修改后，再重启dropbear服务，一次输入下面两行命令： /etc/init.d/dropbear reload /etc/init.d/dropbear restart 1.cat firewall.bak &gt; firewall 增加如下内容： config rule option name &apos;Allow-wan-ssh&apos; option src &apos;wan&apos; option proto &apos;tcp&apos; option dest_port &apos;2195&apos; option target &apos;ACCEPT&apos; 2.保存文档的更改后，重启防火墙服务，依次输入以下两条命令： /etc/init.d/firewall reload /etc/init.d/firewall restart 5.由于铁通机制，分配的独立iP，并不能被外网访问 ssh登录数据库 转先确保能访问LLMP搭建的个人网站地址 修复教程： 登录路由： ssh root@192.168.31.1 mm:admin 执行命令：/userdisk/data/lamp.sh fix 再次访问个人网站地址。 LLMP搭建的个人网站地址 。 1./userdisk/data/lamp.sh (安装本插件，一键开启llmp，具体安装过程可见前面的安装步骤） 2./userdisk/data/lamp.sh a（卸载本插件，恢复安装前，注：卸载本插件时路由器会自动重启一次，自动断网几分钟） 3./userdisk/data/lamp.sh fix（升级小米路由器固件后，能瞬间恢复自己搭建的网站功能，另外，如果在极特殊的情况的情况下，本功能无效，可使用如下方法恢复自建网站的功能：先尝试重新安装本插件，如果提示不能重复安装，可先卸载本插件，再重新安装本插件，并按说明3对数据库执行修改密码命令，改回原来的密码，原来自己搭建网站就可恢复使用） 4./userdisk/data/lamp.sh help (插件用法的帮助信息） 登录数据库：ssh mysql@192.168.31.1 -p 2222 正确日志： AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222 The authenticity of host &apos;[192.168.31.1]:2222 ([192.168.31.1]:2222)&apos; can&apos;t be established. RSA key fingerprint is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;[192.168.31.1]:2222&apos; (RSA) to the list of known hosts. mysql@192.168.31.1&apos;s password:admin BusyBox v1.19.4 (2015-05-08 18:41:26 CST) built-in shell (ash) Enter &apos;help&apos; for a list of built-in commands. ~ $ 错误日志：需要修改本地的ssh配置。 vi /Users/admin/.ssh/known_hosts文件 删除包含[192.168.31.1]:2222的一行内容。 重新登录数据库：ssh mysql@192.168.31.1 -p 2222。 AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M. Please contact your system administrator. Add correct host key in /Users/admin/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/admin/.ssh/known_hosts:10 RSA host key for [192.168.31.1]:2222 has changed and you have requested strict checking. Host key verification failed. 客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库","categories":[{"name":"智能设备","slug":"智能设备","permalink":"https://huos3203.github.io/categories/智能设备/"}],"tags":[{"name":"协议","slug":"协议","permalink":"https://huos3203.github.io/tags/协议/"},{"name":"小米路由","slug":"小米路由","permalink":"https://huos3203.github.io/tags/小米路由/"},{"name":"SSH","slug":"SSH","permalink":"https://huos3203.github.io/tags/SSH/"}]},{"title":"Xcode7编译发布问题","slug":"编译/Xcode7编译发布问题","date":"2015-09-25T15:58:17.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"2015/09/25/编译/Xcode7编译发布问题/","link":"","permalink":"https://huos3203.github.io/2015/09/25/编译/Xcode7编译发布问题/","excerpt":"","text":"Xcode7编译发布问题 ERROR ITMS-90535: “Unexpected CFBundleExecutable Key. The bundle at ‘Payload/PBBReader.app/TencentOpenApi_IOS_Bundle.bundle’ does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.” 解决办法：搜索CFBundleExecutable 字段，删除所有第三方框架中的info.plist文件中包含的字段，重新打包上传。 ERROR ITMS-90475: “Invalid Bundle. iPad Multitasking support requires launch story board in bundle ‘pyc.com.cn.pbbReader’.” 苹果邮件：We have discovered one or more issues with your recent delivery for “PBB Reader”. To process your delivery, the following issues must be corrected:Invalid Bundle - A nested bundle doesn’t have the right platforms listed in CFBundleSupportedPlatforms Info.plist key. IOS9访问网络设置：NSAppTransportSecurity 字典，字段：NSAllowsArbitraryLoads 字段值：YES 搜索Target对应的build setting中，把bitCode支持设置为NO iPad 中的多任务适配如果你不想你的 app 可以作为多任务的副 app 被使用的话，你可以在 Info.plist 中添加 UIRequiresFullScreen 并将其设为 YES 对第三方SDK后台运行，有严格的把控，要求bundle资源必须为最新有效，上传包时必要条件 解决办法：退回Xcode6.4,进行打包发布 Cannot proceed with delivery: an existing transporter instance is currently uploading this package把Application Loader(XCode-&gt;Organizer-&gt;Archived Applications-&gt;Submit)中正在上传的文件中断或者删除，再次Submit提示：Cannot proceed with delivery: an existing transporter instance is currently uploading this package。无论如何Clean All、重新Submit都失败，给出上述提示。原因：上传的动作被记录在UploadToken中了。解决方法：（1）打开终端，输入cd，到达个人用户目录下。（2）输入ls -a，可以看到一个隐藏的目录 .itmstransporter（3）cd .itmstransporter/UploadTokens（4）ls ，可以看到一个类似 xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token文件（5）nano xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token，在里面把内容都删除，保存。（6）重新在Organizer里面submit，ok了","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"编译","slug":"xcode/编译","permalink":"https://huos3203.github.io/categories/xcode/编译/"}],"tags":[]},{"title":"Xcode和Jenkins持续集成的几种实现方式","slug":"macOS/Xcode和Jenkins持续集成的几种实现方式","date":"2015-09-18T23:52:06.000Z","updated":"2019-04-24T23:21:29.815Z","comments":true,"path":"2015/09/19/macOS/Xcode和Jenkins持续集成的几种实现方式/","link":"","permalink":"https://huos3203.github.io/2015/09/19/macOS/Xcode和Jenkins持续集成的几种实现方式/","excerpt":"CI服务器写到这儿，对于iOS开发者来说，需要准备好： 一个比较容易获取的源代码仓库(包含源代码) 一套自动化构建脚本 一系列围绕构建的可执行测试 接下来就需要一个CI服务器来根据源代码的变更触发构建，监控测试结果。 目前，业界比较流行的，支持iOS构建的CI服务器有 Travis CI：是一个免费的云服务平台，基本上支持所有目前主流的语言，Object-C自然也在其中，但是只支持github极大的限制了其应用场景。目前国内无法访问，详见 Jenkins：经过多年的发展，其活跃的社区和丰富的插件让其成为了业界最受欢迎的CI服务器。通过使用Xcode插件，可以非常方便在Jenkins中运行iOS项目的构建脚本。","text":"CI服务器写到这儿，对于iOS开发者来说，需要准备好： 一个比较容易获取的源代码仓库(包含源代码) 一套自动化构建脚本 一系列围绕构建的可执行测试 接下来就需要一个CI服务器来根据源代码的变更触发构建，监控测试结果。 目前，业界比较流行的，支持iOS构建的CI服务器有 Travis CI：是一个免费的云服务平台，基本上支持所有目前主流的语言，Object-C自然也在其中，但是只支持github极大的限制了其应用场景。目前国内无法访问，详见 Jenkins：经过多年的发展，其活跃的社区和丰富的插件让其成为了业界最受欢迎的CI服务器。通过使用Xcode插件，可以非常方便在Jenkins中运行iOS项目的构建脚本。 xcode 持续集成的实现Setting Up Xcode Server jenkins使用配置： 下载：http://mirrors.jenkins-ci.org/war/lastest/jenkins.war 运行命令行： 123 nohup java -jar ~/Downloads/jenkins.war —httpPort=8081 —ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp; ``` 3. 写入启动文件中，起别名 vi /Users/(username)/.bash_profile 输入:alias jenkins=”nohup java -jar ~/Downloads/SVNRepos/jenkins.war –httpPort=8081 –ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp;” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191204. 启动时，在命令行中输入：**`jenkins`** 回车 即可启动5. 访问：http://127.0.0.1:8081/6. 重启：http://[jenkins-server]/[command] exit推出，restart重启，reload重载。#### 方法二：安装jenkins还是使用brewbrew install jenkins安装好之后，可以通过使用命令行启动 java -jar /usr/local/opt/jenkins/libexec/jenkins.war如果想**开机自动启动**，需要先执行以下命令，创建启动项： ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents可以编辑一下~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist这个文件 open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist 具体内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;homebrew.mxcl.jenkins&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/java&lt;/string&gt; &lt;string&gt;-Dmail.smtp.starttls.enable=true&lt;/string&gt; &lt;string&gt;-jar&lt;/string&gt; &lt;string&gt;/usr/local/opt/jenkins/libexec/jenkins.war&lt;/string&gt; &lt;string&gt;--httpListenAddress=127.0.0.1&lt;/string&gt; &lt;string&gt;--httpPort=8088&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 想要让局域网都可以访问或修改端口号，需要把—httpListenAddress=127.0.0.1改成自己的局域网IP 手动启动启动项可以执行,制作替身： launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist 之后用浏览器就可以访问 **http://localhost:8088/** 来登录jenkins了#### 方法三：使用tomcat制作替身： cd ~/Downloads/soft/Tomcat/ ln -sfv apache-tomcat-8.0.27 tomcat 将jenkins.war拷贝到 $tomcat/webapp下面。 $tomcat/bin/start.sh 用浏览器打开 **localhost:8080/jenkins** tomcat默认端口号为8080，就可以看到 jenkin运行了。#### 自动化构建和依赖管理[参考](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part1/)作为以GUI和命令行操作结合的完美性著称的苹果公司来说，当然也不会忘记为自己的封闭的iOS系统提供开发环境下命令行编译工具：xcodebuild在介绍xcodebuild之前，需要先弄清楚一些在XCode环境下的一些概念【4】：- **Workspace**：简单来说，Workspace就是一个容器，在该容器中可以存放多个你创建的Xcode Project， 以及其他的项目中需要使用到的文件。使用Workspace的好处有，1),扩展项目的可视域，即可以在多个项目之间跳转，重构，一个项目可以使用另一个项目的输出。Workspace会负责各个Project之间提供各种相互依赖的关系;2),多个项目之间共享Build目录。- **Project**：指一个项目，该项目会负责管理生成一个或者多个软件产品的全部文件和配置，一个Project可以包含多个Target。- **Target**：一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。- **Scheme**：一个定义好构建过程的Target成为一个Scheme。可在Scheme中定义的Target的构建过程有：Build/Run/Test/Profile/Analyze/Archive- **BuildSetting**：配置产品的Build设置，比方说，使用哪个Architectures？使用哪个版本的SDK？。在Xcode Project中，有Project级别的Build Setting，也有Target级别的Build Setting。Build一个产品时一定是针对某个Target的，因此，XCode中总是优先选择Target的Build Setting，如果Target没有配置，则会使用Project的Build Setting。xcodebuild就是用了构建产品的命令行工具，其用法可以归结为3个部分：- 可构建的对象- 构建行为- 一些其他的辅助命令可以构建的对象有，默认情况下会运行project下的第一个target：- workspace：必须和“-scheme”一起使用，构建该workspace下的一个scheme。- project：当根目录下有多个Project的时候，必须使用“-project”指定project，然后会运行- target：构建某个Target- scheme：和“-workspace”一起使用，指定构建的scheme。- ……构建行为包括：- clean:清除build目录下的- build: 构建- test: 测试某个scheme，必须和&quot;-scheme&quot;一起使用- archive:打包，必须和“-scheme”一起使用- ……辅助命令包括：- -sdk：指定构建使用的SDK- -list：列出当前项目下所有的Target和scheme。- -version：版本信息- …...关于xcodebuild更多详细的命令行请参见：[点击](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html)xcodebuild的主要缺陷：- 其脚本输出的可读性极差，- 只能要么完整的运行一个target或者scheme，要么全部不运行。不能指定运行Target中特定的测试。**安装xctool** xctool的安装非常简单，只需要clone xctool的repository到项目根目录就可以使用， 如果你的机器上安装有Homebrew，可以通过“brew install xctool”命令直接安装。（**注意：使用xctool前一定要首先确认xcodebuild已安装且能正确工作**）。**用法**关于xctool的用法就更加人性化了，几乎可以重用所有的xcodebuild的指令，配置。只需要注意一下几点：- xctool不支持target构建，只能使用scheme构建。- 支持“-only”指令运行指定的测试。- 支持多种格式的build报告。例子：```rubypath/to/xctool.sh -workspaceYourWorkspace.xcworkspace -schemeYourSchemetest -only SomeTestTarget:SomeTestClass/testSomeMethod 自动化部署这儿的想谈的“部署”不是传统意义上的直接部署到产品环境的部署，而是指如何把最新版本的应用快速的部署到测试用户的机器上以收集反馈，或者做一些探索性的测试。 在我写第一个iOS应用的时候，我想把应用安装到多个机器上测试的时候，需要非常繁琐的步骤： 需要申请到苹果开发者账号，获得开发者证书。 需要在苹果的开发者网站上注册我想使用的设备。 使用开发者证书打包应用，使用Ad-HOC部署模式，生成ipa文件。 通过ipa文件把应用安装到iTunes上。 通过iTunes把应用同步到多台测试机器上。 如果是测试机器在多个地理位置的时候，还需要把ipa文件发送到对应的地点，每个地点都需要重复的做第4，5步。 这样一个繁琐，且低效的过程让开发者非常痛苦，直到TestFlight的出现。 TestFlightTestFlight：就是一个专门解决上面提到的痛点的云服务方案，它可以帮助开发者： 轻松采集测试用户的UDID和iOS 版本、硬件版本，并发送给开发者。 实时反馈应用是否成功安装到测试机器 轻松部署最新版本应用到测试用机上。 开发者可以灵活选择部署哪个版本到哪部分测试机器上。 使用使用Test Flight服务非常简单，只需要到Test Flight注册一个账号。然后把链接发送给测试设备，测试设备只要打开该链接，并授权给Test Flight，在Test Flight的设备中心就可以看到这些设备。 使用jenkins+calabash+cocoapods搭建ios持续集成环境 calabash 是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。 安装Calabash 1sudo gem install calabash-cucumber 安装Calabash中文支持包 1sudo gem install calabash-cucumber-cn For automatic setup: In a terminal, go to your iOS project 123 cd path-to-my-ios-project (i.e. directory containing .xcodeproj file) ``` 2. Install calabash-cucumber gem (this make take some time because of dependencies) gem install calabash-cucumber 13. Setup your project for Calabash-iOS. calabash-ios setup //Answer the questions and read the output :) 14. Generate a skeleton features folder for your tests calabash-ios gen 1235. In Xcode, build your project using the -cal scheme6. Run the generated test! cucumber ` If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature. cucumber官网* Feature（功能） * Scenario（情景） * Given（给定） * When（当） * Then（则） 运行原理cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。 结构框架calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。再看一下其中的内容： my_first.feature Feature： 登陆 Scenario： 输入正确的用户名密码能够正常登陆 When 打开登陆页面 And 输入用户名XXX输入密码XXX And 点击登陆 Then 验证登陆成功 看起来很简单吧，想要验证其他功能也是类似的语言描述即可。如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，那么看一下step_definition，以 输入用户名XXX输入密码XXX为例： When /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot; $/ do |username，password| performAction(&apos;enter_text_into_numbered_field&apos;，username，1) performAction(&apos;enter_text_into_numbered_field&apos;，password，2) end 现在应该能明白为什么你需要写汉字的脚本就可以了吧。在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。还是以这个登录脚本为例： 假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了 运行报告alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。 例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告 【cucumber解析features文件】 my_first.feature: 描述在这个条件下需要做什么事情； Feature: Running a test As an iOS developer I want to have a sample feature file So I can begin testing quickly Scenario: Example steps1 Given I am on the Welcome Screen Then I swipe left And I wait until I don&apos;t see &quot;Please swipe left&quot; And take picture Scenario: Example steps2 Given I am on the Welcome Screen #ASSERTION Then I should see a &quot;login&quot; button #INPUT TEXT Then I enter &quot;my_username&quot; into text field number 1 # Then I touch &quot;Return&quot; #TOGGLE SWITCH Then I toggle the switch Then I touch &quot;Login&quot; And I touch &quot;Second&quot; And take picture 该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. my_first_step.rb: 解释了Given的具体条件 Given /^I am on the Welcome Screen$/ do element_exists(&quot;view&quot;) check_element_exists(&quot;label text:&apos;First View&apos;&quot;) sleep(STEP_PSEAU) end 这个语句，判定了当前条件”on the Welcome Screen”是否满足，如果element存在，则就在”Welcome Screen”；","categories":[{"name":"macOS","slug":"macOS","permalink":"https://huos3203.github.io/categories/macOS/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://huos3203.github.io/tags/TDD/"},{"name":"BDD","slug":"BDD","permalink":"https://huos3203.github.io/tags/BDD/"}]},{"title":"mupdf集成pyc加密算法","slug":"编译/mupdf集成pyc加密算法","date":"2015-08-14T10:45:35.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"2015/08/14/编译/mupdf集成pyc加密算法/","link":"","permalink":"https://huos3203.github.io/2015/08/14/编译/mupdf集成pyc加密算法/","excerpt":"加密算法中区分64位123456789#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64 #ifndef uint32 #define uint32 unsigned int #endif#else #ifndef uint32 #define uint32 unsigned long int #endif#endif 把SMS4.h文件内容合并到include/mupdf/fitz/stream.h文件中，然后删除SMS4.h文件 把SMS4.c文件内容合并到source/fitz/stream-open.c 文件中，然后删除SMS4.c 在include/mupdf/fitz/stream.h增加以下内容: 用于方法声明，供其他类使用。","text":"加密算法中区分64位123456789#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64 #ifndef uint32 #define uint32 unsigned int #endif#else #ifndef uint32 #define uint32 unsigned long int #endif#endif 把SMS4.h文件内容合并到include/mupdf/fitz/stream.h文件中，然后删除SMS4.h文件 把SMS4.c文件内容合并到source/fitz/stream-open.c 文件中，然后删除SMS4.c 在include/mupdf/fitz/stream.h增加以下内容: 用于方法声明，供其他类使用。 12345678910 void set_key_info(char* key, long long code_len); int pbb_read(int fd, unsigned char *buf, int size); int fpbb_read(unsigned char *buf, int count, int size, FILE* fp); ``` 4. 替换source/pdf/pdf-write.c 2530：fread 替换为 fpbb_read5. 替换source/fitz/stream-prog.c 57: read 替换为 pbb_read6. 替换source/fitz/stream-open.c 73: read 替换为 pbb_read 7. 配置document Type public.data,public.centent传递秘钥： char keycode[] = {-12,7,106,95,82,118,-64,-78,-98,5,-3,-128,-28,95,-84,120};long long keylength = 37761;set_key_info(keycode, keylength);12345678910111213141516 #### ijkplayer- https://github.com/kolyvan/kxmovie.git - https://github.com/Bilibili/ijkplayer.git- 支持所有视频格式的操作： - cd ijkplyer-master/config/ - rm module.sh - ln -s module-default.sh module.sh- 加密集成 - 处理文件的目录位置：ijkplyer-master/ios/ffmpeg-arm64,armv7,armv7s,i386,x86_64/libavformat目录 - 把pyckey.h,sms4.h文件内容移动到处理文件目录中的avformat.h文件中 - 把pyckey.c, sms4.c文件内容移动到处理文件目录中的file.c文件中 - 将extra.tar.gz解压，放入ijkplayer-master/extra目录下 - 暴漏头文件，编辑目录中的Makefile文件 - - HEADERS = 新增.h文件，例如:url.h - - OBJS = 新增.o文件，例如:url.o 注意：要替换ios目录下针对不同内核的目录arm64,armv7,armv7s,i386，都需要操作如上步骤。 12 然后，在IOS目录下执行编译命令脚本集合文件: ./compile-ffmpeg.sh clean ./compile-ffmpeg.sh all` 将ijkplayer集成到自己的项目中 将ijkplayer-master/ios、目录下的IJKMediaPlayer目录拷贝到自己项目的同目录下 打开自己的项目，将IJKMediaPlayer.xcodeproj项目文件拖入自己项目中 选择项目名称，配置Targets 选中 build phases标签，添加 Target Dpendencies ，选中IJKMediaFramework 添加即可。 因为移动了IJK项目目录到本项目，需要重新配置IJKMediaPlayer中文件关联设置 需要将ijkplayer-master/目录下的ijkmedia目录中的ijkplayer目录和ijksdl目录(Android.mk除外)，拷贝到IJKMediaPlyaer项目的IJKMediaPlyaer/IJKMediaPllayer/ijkmedia/目录下 需要将编译后得到的静态库（ijkplayer-master/ios/build/universal/目录）拷贝至IJKMediaPlayer目录：$(PROJECT_DIR)/ffmpeg/universal/lib 选中IJKMediaPlayer项目名称，配置Targets 选中 build Setting标签：设置HeaderSearch Paths:$(PROJECT_DIR)/IJKMediaPlayer/ijkmedia $(PROJECT_DIR)/ffmpeg/universal/include设置Library Search Paths:$(PROJECT_DIR)/ffmpeg/universal/lib","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[{"name":"加密","slug":"加密","permalink":"https://huos3203.github.io/tags/加密/"}]},{"title":"快速正确的安装Ruby,Rails运行环境","slug":"shell/快速正确的安装Ruby,Rails运行环境","date":"2015-01-21T23:00:39.000Z","updated":"2019-04-24T23:21:29.825Z","comments":true,"path":"2015/01/22/shell/快速正确的安装Ruby,Rails运行环境/","link":"","permalink":"https://huos3203.github.io/2015/01/22/shell/快速正确的安装Ruby,Rails运行环境/","excerpt":"安装ruby环境：方法一：下载源码，编译安装：配置中制定安装目录方法二：使用rvm安装：可以提供一个便捷的多版本 Ruby 环境的管理和切换方法三：使用macport安装 port install ruby 详细教程 问题：ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rakestackoverflow方法测试结果没走通。最终通过OS X 10.11中Rootless的实现与解释以及关闭方法解决. Gem介绍Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。 Ruby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。","text":"安装ruby环境：方法一：下载源码，编译安装：配置中制定安装目录方法二：使用rvm安装：可以提供一个便捷的多版本 Ruby 环境的管理和切换方法三：使用macport安装 port install ruby 详细教程 问题：ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rakestackoverflow方法测试结果没走通。最终通过OS X 10.11中Rootless的实现与解释以及关闭方法解决. Gem介绍Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。 Ruby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。 升级RubyGem1$ gem update --system 安装新的Gem1234$ gem install rai//指定安装某一版本的Gem包gem install [gemname] --version=1.3.2 在安装过程中可以看到如下提示，说明它是从rubygems.org内去寻找并安装gem package的。Fetching source index for http://rubygems.org/ gem 的安装方式MacPorts安装和使用http://ccvita.com/434.htmlhttp://guide.macports.orghttp://www.fantageek.com/318/install-pkg-config-for-mac-osx/ Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。 安装后，配置： sudo vi /etc/profile export PATH=/opt/local/bin:$PATH export PATH=/opt/local/sbin:$PATH MacPorts使用 http://witcheryne.iteye.com/blog/991821 更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。sudo port -v selfupdate 搜索索引中的软件 port search name 安装新软件sudo port install name 卸载软件sudo port uninstall name 查看有更新的软件以及版本port outdated 升级可以更新的软件sudo port upgrade outdated 实例：Eclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装 sudo port install subversion-javahlbindings installed 列出全部或者指定的已经安装的软件： port installed port -v installed atlas dependents 查看哪些软件时依赖与这个软件的 删除一个软件时候，最好先执行一下这个命令. port dependents openssl","categories":[{"name":"shell","slug":"shell","permalink":"https://huos3203.github.io/categories/shell/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"脚本","slug":"脚本","permalink":"https://huos3203.github.io/tags/脚本/"},{"name":"安装","slug":"安装","permalink":"https://huos3203.github.io/tags/安装/"}]},{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2019-04-24T23:21:29.795Z","comments":true,"path":"2015/01/20/git/Git中的储藏工具stash/","link":"","permalink":"https://huos3203.github.io/2015/01/20/git/Git中的储藏工具stash/","excerpt":"Stashing 储藏工作 应用储藏 被暂存的文件重新暂存 应用后，移除储藏的内容 取消储藏(Un-applying a Stash) 新建stash-unapply别名 从储藏中创建分支 Git工具 - 储藏（Stashing）git 原文场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。 问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。 解决：git stash 命令。 “Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。 储藏工作 进入项目目录，修改某个文件，有可能还暂存其中的一个变更。 git status 命令,查看中间状态：123456789101112$ git status# On branch master# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## modified: index.html## Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: lib/simplegit.rb# 切换分支，但不提交step 1 中的变更，所以储藏这些变更。执行git stash 命令，往堆栈中推送一个新的储藏：12345$ git stashSaved working directory and index state \\ \"WIP on master: 049d078 added the index file\"HEAD is now at 049d078 added the index file(To restore them type \"git stash apply\") 执行step 2查看目录库，中间状态就不见了：123$ git status#######On branch masternothing to commit, working directory clean 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。 使用git stash list要查看现有的储藏：1234$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert \"added file_size\"stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log 在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。应用储藏 执行git stash apply命令, 可以重新应用最近的一次储藏；执行git stash apply stash@{2}命令，即通过指定储藏的名字，来应用更早的储藏。12345678$ git stash apply# On branch master# Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: index.html# modified: lib/simplegit.rb#","text":"Stashing 储藏工作 应用储藏 被暂存的文件重新暂存 应用后，移除储藏的内容 取消储藏(Un-applying a Stash) 新建stash-unapply别名 从储藏中创建分支 Git工具 - 储藏（Stashing）git 原文场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。 问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。 解决：git stash 命令。 “Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。 储藏工作 进入项目目录，修改某个文件，有可能还暂存其中的一个变更。 git status 命令,查看中间状态：123456789101112$ git status# On branch master# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## modified: index.html## Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: lib/simplegit.rb# 切换分支，但不提交step 1 中的变更，所以储藏这些变更。执行git stash 命令，往堆栈中推送一个新的储藏：12345$ git stashSaved working directory and index state \\ \"WIP on master: 049d078 added the index file\"HEAD is now at 049d078 added the index file(To restore them type \"git stash apply\") 执行step 2查看目录库，中间状态就不见了：123$ git status#######On branch masternothing to commit, working directory clean 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。 使用git stash list要查看现有的储藏：1234$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert \"added file_size\"stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log 在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。应用储藏 执行git stash apply命令, 可以重新应用最近的一次储藏；执行git stash apply stash@{2}命令，即通过指定储藏的名字，来应用更早的储藏。12345678$ git stash apply# On branch master# Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: index.html# modified: lib/simplegit.rb#可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。 被暂存的文件重新暂存 执行git stash apply命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。执行git stash apply –index命令,即可让被暂存的文件重新暂存。–index选项告诉命令重新应用被暂存的变更：123456789101112$ git stash apply --index# On branch master# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## modified: index.html## Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: lib/simplegit.rb# 应用后，移除储藏的内容 apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。执行git stash drop 储藏的名字命令，，即可从栈中彻底移除储藏内容：123456$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert \"added file_size\"stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log$ git stash drop stash@&#123;0&#125;Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)你也可以运行 git stash pop命令，来重新应用储藏，同时立刻将其从堆栈中移走。 取消储藏(Un-applying a Stash) 在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply的命令，但是可以通过取消该储藏的补丁达到同样的效果：1$ git stash show -p stash@&#123;0&#125; | git apply -R同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：1$ git stash show -p | git apply -R 新建stash-unapply别名 你可能会想要新建一个別名，在你的 Git 里增加一个stash-unapply 命，这样更有效率。例如：1234$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'$ git stash apply$ #... work work work$ git stash-unapply 从储藏中创建分支 如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。1234567891011121314$ git stash branch testchangesSwitched to a new branch \"testchanges\"# On branch testchanges# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## modified: index.html## Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)## modified: lib/simplegit.rb#Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。","categories":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/categories/git/"},{"name":"工具","slug":"git/工具","permalink":"https://huos3203.github.io/categories/git/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huos3203.github.io/tags/git/"},{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"坑","slug":"坑","permalink":"https://huos3203.github.io/tags/坑/"}]},{"title":"XMPP简单研究[转]","slug":"开源库/XMPP简单研究[转]","date":"2015-01-06T14:36:06.000Z","updated":"2019-04-24T23:21:29.835Z","comments":true,"path":"2015/01/06/开源库/XMPP简单研究[转]/","link":"","permalink":"https://huos3203.github.io/2015/01/06/开源库/XMPP简单研究[转]/","excerpt":"最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等） 后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。 其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。 实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。￼","text":"最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等） 后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。 其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。 实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。￼第二个方案就是使用已有的 IM 互通方案，自己提供一个特有的 Game-IM 网络，跟已有的 IM 网络互通。比较流行的 IM 互通协议用基于 SIP 的 SIMPLE 和起源于 Jabber 的 XMPP 。 我最常用的 IM 是 google talk ，本身就实现了标准的 XMPP Client 和 XMPP Server 协议；而我们的 网易 popo 也实现了 XMPP 的 s2s 网关。我想研究一下 XMPP 是个不错的选择。 花了一整天的时间，把 XMPP 核心协议 仔细通读了一遍，收获颇多。原来以为 XMPP 是个可怕的巨无霸。我对 XML 原本也没有太多好感。最后，看法有所改变。 其实，XMPP 仅仅是定义了一个网络服务间相互通讯的协议。它已经把服务间需要关心的东西减少到了最少。具体的应用每家服务提供商可以随意扩展。popo 在制作新版本时，我曾多次建议采用已有的标准协议，再此基础上开发自己的东西。当时或许大家都认为标准协议容易促手促脚，我当时也没啥研究，没有多言。今天看来，我更觉得这是一个决策失误。本来我们有一个很好的机会，利用 popo 联系起网易的各种服务，现在这条路将走的更为艰辛。其实，XMPP 定义的东西，即使自己去设计也会定义出类似的一套来。而把各种网络服务互通本该是发展的重点，为 IM Client 增添专有花哨的特性就有些舍本逐末了。更为恼火的是，popo 到现在也没有一个很好的非 Windows 平台解决方案。怎能让诸多把握着互联网上部分话语权的技术人士接受？（或者，同在杭州的 IT 圈子，popo 的开发人员是不是应该看看支付宝的同行们做了些什么？） 谈谈我对 XMPP 的粗浅理解。这些仅仅建立在我对 RFC3920 的一天阅读的基础上，难免会有错误，不足以做技术参考。 XMPP 抽象出一个在互联网上唯一的对象实体，用 JID 来表达。通常一个 JID 由三部分组成，node@domain/resource 。比 email 的表达形式多了一个 /resource 。这是因为 email 地址本身虽然可以表达一个实体，都是往往不够表达这个实体下的具体服务。就好比一个 ip 地址可以表示一台机器，但是我们还需要 port 号来表达这台机器具体提供的服务一样。 用过 gtalk 的人应该很喜欢 gtalk 可以在不同的地方同时登陆这个不错的特性。用过以后，才能体会，无论是 qq 还是 msn 还是 popo ，只允许一个登陆是多么愚蠢的设定。gtalk 其实遵守了标准的 XMPP 协议，它用来区别一个帐号（一般是一个 gmail 邮件地址）的多处登陆，正是利用了不同的 resource 标识。 XMPP 规范的最重要的一条通信协议就是，如何把消息从一个 JID 发送到另一个 JID (message)。这有点像 email 协议，但不同的是，它强调了实时性和安全性（虽然不是必须的）。因为 JID 可以在不同的 domain 下，这就需要 domain 间相互协作。对于 IM 网络来说（XMPP 远不只用于 IM 协议），就是不同的 IM 服务间互通。 对于 domain 下的 xmpp 服务的发现，利用了 DNS 协议的一些功能。xmpp 的 s2s 服务提供位置，放在了 DNS 的 SRV 记录里。你可以用 nslookup 做个试验，启动 nslookup ，输入 set type=SRV 然后查询 _xmpp-server._tcp.gmail.com 你会发现 gmail.com 的 xmpp s2s 服务地址已经端口号 5269 。同样，也可以查询 _xmpp-server._tcp.163.com 或 _xmpp-server._tcp.popo.163.com 查到网易 popo 的 xmpp 中转服务器地址。 btw, 查询 _xmpp-client._tcp.gmail.com 可以查到 gtalk 的 client 登陆地址，而网易 popo 则没有提供 xmpp client 登陆点。 按 RFC3920 所述，在 xmpp server 互联的时候，会优先尝试获取 domain 的 SRV 记录，如果失败就直接去连默认的 6259 端口。然后就可以开始握手协议。 xmpp 比较强调 s2s 的安全性，所以推荐的握手都是建立在 TLS 层之上，使用 SASL 认证。TLS 层需要服务器有一个数字证书，为了安全可信，建议是找个根证书签名。不过自己签名也行，只需要服务器缓存证书即可。握手过程在 RFC3920 中描述的非常细致，可以按照其编码，问题不大。需要注意的是，这里的 XML 流格式要求很精确，不允许传输多余的东西。我一度认为采用 XML 会导致协议的实现上非常臃肿，其实不然。采用 XML 只是一个表象，适合人阅读和调错而已。RFC 中特别要求不去实现 XML 中的某某特性就是一例。我们不应该为了 XML 而去 XML 。 其实 XMPP 的 c2s 和 s2s 并无太大区别，s2s 做的人手我想是因为开源项目和开源库比较少吧。而开源的 client 实现则是一大堆。c2s 和 s2s 的通讯都是基于那几条协议而已，s2s 的实现难点在于握手比较复杂（其实 c2s 也一样，只是很多库帮你做好了）。c2s 是共享一个 tcp 连接做双向通讯；而 s2s 则是用两条 TCP 连接。两条连接也一定程度上避免了 s2s 的欺骗，当然真正的安全来至于 TLS 和 SASL 的保障。DNS 毕竟是一个很脆弱的东西。 除了点对点消息外，XMPP 定义了消息的组播。也就是一个 JID 可以以自己的名义发布消息 (presence)。而服务器来决定该发给谁。发送目标是由订阅消息决定的。其它多个 JID 可以订阅某个 JID 的消息。对于 IM 来说，最常用的就是上线下线等状态变化消息了。 第三条即是对某个 JID 的状态进行设置和获取 (iq)。于 IM 应用来说，设置签名，昵称，状态等都依赖于它。 XMPP 的核心协议无非规定了以上三种通讯协议，此外规范了服务器间互连的握手认证方案。然后给出了一些错误信息的表述方法。稍微了解过之后，很容易编写。如果希望重造轮子的话，对于 C 语言开发者来说，最繁琐的可能是 XML 的解析于生成。我自己稍微考察了一下，有个叫 LoudMouth 的库还不错。 如果实现 s2s 网关的话，有些细节做起来可能很麻烦，比如查询 DNS 的 SRV 记录。这个在 jabberd 1.x 里其实有独立的模块实现好了，取来用即可 (见 dnsrv) 。而 TLS SASL 层的实现则早就有现成的开源库了。 实现一个 jabber server 或许比你想象的还简单。in.jabberd 居然只用 600 多行 C 代码就从零实现了一个 jabber 服务器。当然功能非常的简陋了。 至于我想做的东西，我希望一个在名为 xyz 的梦幻西游服务器上的 12345 号玩家，一旦选择绑定他的 popo 帐号 player@popo.163.com ，他在他的 popo 上就会收到名叫 12345.xyz@xyq.163.com 的好友请求。当他通过好友认证后，就可以从这个通道获取游戏里的信息，也可以对游戏帐号做有限的操作。我想有了这样一项服务，对玩家对运营商都会有极大的好处的。其他资源：使用 XMPP 构建一个基于 web 的通知工具","categories":[{"name":"开源库","slug":"开源库","permalink":"https://huos3203.github.io/categories/开源库/"}],"tags":[]},{"title":"代码实现AutoLayout相关特性","slug":"iOS/UI/代码实现AutoLayout相关特性","date":"2014-09-02T15:53:11.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/09/02/iOS/UI/代码实现AutoLayout相关特性/","link":"","permalink":"https://huos3203.github.io/2014/09/02/iOS/UI/代码实现AutoLayout相关特性/","excerpt":"按比例缩放按比例缩放，这是在Interface Builder中无法设置的内容。而在代码中，有如下两种实现方式: 使用NSLayoutConstraint类型的初始化函数中的multiplier参数就可以非常简单的设置按比例缩放。 同时也可以设置不同NSLayoutAttribute参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。 现在就拿一个简单的UIButton做示例，在ViewController中创建一个UIButton字段：1UIButton *btn; 需求 1： 要求UIButton水平居中，始终距离父View底部20单位，其高度是父View高度的三分之一。 使用KVO来监控UIButton的大小并实时输出到屏幕上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad&#123; [super viewDidLoad]; //创建UIButton，不需要设置frame btn = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [btn setTitle:@\"mgen\" forState:UIControlStateNormal]; btn.backgroundColor = [UIColor greenColor]; [self.view addSubview:btn]; //禁止自动转换AutoresizingMask btn.translatesAutoresizingMaskIntoConstraints = NO; //居中 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]]; //距离底部20单位 //注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1 constant:-20]]; //定义高度是父View的三分之一 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.3 constant:0]]; //注册KVO方法 [btn addObserver:self forKeyPath:@\"bounds\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionInitial context:nil]; &#125;&lt;!--more--&gt;//KVO回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == btn &amp;&amp; [keyPath isEqualToString:@\"bounds\"]) &#123; [btn setTitle:NSStringFromCGSize(btn.bounds.size) forState:UIControlStateNormal]; &#125;&#125; 运行结果：","text":"按比例缩放按比例缩放，这是在Interface Builder中无法设置的内容。而在代码中，有如下两种实现方式: 使用NSLayoutConstraint类型的初始化函数中的multiplier参数就可以非常简单的设置按比例缩放。 同时也可以设置不同NSLayoutAttribute参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。 现在就拿一个简单的UIButton做示例，在ViewController中创建一个UIButton字段：1UIButton *btn; 需求 1： 要求UIButton水平居中，始终距离父View底部20单位，其高度是父View高度的三分之一。 使用KVO来监控UIButton的大小并实时输出到屏幕上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad&#123; [super viewDidLoad]; //创建UIButton，不需要设置frame btn = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [btn setTitle:@\"mgen\" forState:UIControlStateNormal]; btn.backgroundColor = [UIColor greenColor]; [self.view addSubview:btn]; //禁止自动转换AutoresizingMask btn.translatesAutoresizingMaskIntoConstraints = NO; //居中 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]]; //距离底部20单位 //注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1 constant:-20]]; //定义高度是父View的三分之一 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.3 constant:0]]; //注册KVO方法 [btn addObserver:self forKeyPath:@\"bounds\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionInitial context:nil]; &#125;&lt;!--more--&gt;//KVO回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (object == btn &amp;&amp; [keyPath isEqualToString:@\"bounds\"]) &#123; [btn setTitle:NSStringFromCGSize(btn.bounds.size) forState:UIControlStateNormal]; &#125;&#125; 运行结果： 需求 2： 在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。 涉及到的相关特性： 优先级：当两个Constraint同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置Constraint的优先级来解决。优先级对应NSLayoutConstraint类型的priority属性，默认值是UILayoutPriorityRequired，数值上等于1000. 设置一个低的值代表更低的优先级。 最小值的定义：使用NSLayoutRelationGreaterThanOrEqual作为NSLayoutConstraint类型创建时的relatedBy参数。 修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：12345678910111213141516171819202122//定义高度是父View的三分之一//设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750NSLayoutConstraint *con = [NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.3 constant:0];con.priority = UILayoutPriorityDefaultHigh;[self.view addConstraint:con];//设置btn最小高度为150[btn addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationGreaterThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:150]];运行后，横向屏幕中的Button高度成了150： intrinsicContentSize 控件的内置大小控件的内置大小是由控件本身的内容所决定的，比如一个UILabel的文字很长，那么该UILabel的内置大小自然会很长。在代码中获取控件的内置大小的方法： 通过UIView的intrinsicContentSize属性来获取； 通过invalidateIntrinsicContentSize方法来在下次UI规划事件中重新计算intrinsicContentSize。 注意：如果直接创建一个原始的UIView对象，它的内置大小为0。 先写一个辅助方法来快速设置UIView的边距限制：123456789101112//设置Autolayout中的边距辅助方法- (void)setEdge:(UIView*)superview view:(UIView*)view attr:(NSLayoutAttribute)attr constant:(CGFloat)constant&#123; [superview addConstraint:[NSLayoutConstraint constraintWithItem:view attribute:attr relatedBy:NSLayoutRelationEqual toItem:superview attribute:attr multiplier:1.0 constant:constant] ];&#125;接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：12345678910//view1UIView *view1 = [UIView new];view1.backgroundColor = [UIColor yellowColor];//不允许AutoresizingMask转换成Autolayoutview1.translatesAutoresizingMaskIntoConstraints = NO;[self.view addSubview:view1];//设置左，上，右边距为20.[self setEdge:self.view view:view1 attr:NSLayoutAttributeLeft constant:20];[self setEdge:self.view view:view1 attr:NSLayoutAttributeTop constant:20];[self setEdge:self.view view:view1 attr:NSLayoutAttributeRight constant:-20];但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，UIView默认是没有intrinsicContentSize的。 创建一个自定义的UIView来改写intrinsicContentSize：MyView:然后在.m文件中改写intrinsicContentSize方法，并返回有效值，比如这样：12345//改写UIView的intrinsicContentSize- (CGSize)intrinsicContentSize&#123; return CGSizeMake(70, 40);&#125; 接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：1MyView *view1 = [MyView new]; 再次运行代码，View会按照要求显示在屏幕上：按照同样的方式，在下方添加另一个MyView，要求其距离父控件边距左，下，右各为20，代码：12345678910//view2 MyView *view2 = [MyView new]; view2.backgroundColor = [UIColor yellowColor]; //不允许AutoresizingMask转换成Autolayout view2.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:view2]; //设置左，下，右边距为20. [self setEdge:self.view view:view2 attr:NSLayoutAttributeLeft constant:20]; [self setEdge:self.view view:view2 attr:NSLayoutAttributeBottom constant:-20]; [self setEdge:self.view view:view2 attr:NSLayoutAttributeRight constant:-20]; 需求： 通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 这里要求view2在view1之下的20单位，所以创建NSLayoutConstraint中view2参数在前面。 view2的attribute参数是NSLayoutAttributeTop，而view1的attribute参数是NSLayoutAttributeBottom 拉伸view2,而不拉伸view1。 控件的Content Hugging Priority拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。 控件的Content Compression Resistance Priority拒绝压缩内置空间(intrinsicContentSize)的优先级。优先级越高，控件的内置空间(intrinsicContentSize)会越不容易被压缩。 123456789//设置两个View上下间距为20[self.view addConstraint:[NSLayoutConstraint constraintWithItem:view2 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:view1 attribute:NSLayoutAttributeBottom multiplier:1.0 constant:20] ]; OK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。 使用控件的Content Hugging Priority，如下图：如图,把view1（上图中被拉伸的，在上面的View）的Content Hugging Priority设置一个更高的值，那么当Autolayout遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。可以直接通过UIView的setContentHuggingPriority:forAxis方法来设置控件的Content Hugging Priority，其中forAxis参数代表横向和纵向，本例中只需要设置纵向，所以传入UILayoutConstraintAxisVertical。整句代码：12//提高view1的Content Hugging Priority[view1 setContentHuggingPriority:UILayoutPriorityDefaultHigh forAxis:UILayoutConstraintAxisVertical];","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"SB","slug":"xcode/SB","permalink":"https://huos3203.github.io/categories/xcode/SB/"}],"tags":[{"name":"Storyboard","slug":"Storyboard","permalink":"https://huos3203.github.io/tags/Storyboard/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://huos3203.github.io/tags/AutoLayout/"},{"name":"布局","slug":"布局","permalink":"https://huos3203.github.io/tags/布局/"}]},{"title":"在IOS中自定义URLSchemes教程","slug":"iOS/在IOS中自定义URLSchemes教程","date":"2014-08-28T20:32:48.000Z","updated":"2019-04-24T23:21:29.815Z","comments":true,"path":"2014/08/29/iOS/在IOS中自定义URLSchemes教程/","link":"","permalink":"https://huos3203.github.io/2014/08/29/iOS/在IOS中自定义URLSchemes教程/","excerpt":"URL SchemesiPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！ 首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。 注册自定义URL协议首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。 默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。 Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:","text":"URL SchemesiPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！ 首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。 注册自定义URL协议首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。 默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。 Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array: 类型为Array: Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。完成后如图所示： 另两种视图浏览方式：在info.plist页面上右击，选择Raw Keys/Values显示如下： xml 处理URL现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。 使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】 Using the simulator, here’s how to call the app: Run the application from within Xcode Once installed, the custom URL scheme will now be registered Close the app via the Hardware menu in simulator and choose Home Start Safari Enter the URL scheme defined previously in the browser address bar (see below) 通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】 按钮的实现：12345678910111213141516171819 - (void)buttonPressed:(UIButton *)button&#123; NSString *customURL = @\"iOSDevTips://\"; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:customURL]]) &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]]; &#125; else &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"URL error\" message:[NSString stringWithFormat: @\"No custom URL defined for %@\", customURL] delegate:self cancelButtonTitle:@\"Ok\" otherButtonTitles:nil]; [alert show]; &#125; &#125;Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).The openURL:method starts the application and passes the URL into the app. The current application is exited during this process. 通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL SchemeChances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with. The NSURLclass which is the basis for calling from one app to another conforms to the RFC 1808 (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well. In the application with the custom URL scheme, the app delegate must implement the method with the signature below:123- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotationThe trick to passing in parameters from one app to another is via the URL.For example, assume we are using the following custom URL schemeand want to pass in a value for a ‘token’ and a flag indicating registration state, we could create URL as follows:1NSString *customURL = @\"iOSDevTips://?token=123abct&amp;registered=1\";As in web development, the string ?token=123abct&amp;registered=1 is known as the query string. Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows:123456789- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; NSLog(@\"Calling Application Bundle ID: %@\", sourceApplication); NSLog(@\"URL scheme:%@\", [url scheme]); NSLog(@\"URL query: %@\", [url query]); return YES;&#125;The output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows:123Calling Application Bundle ID: com.3Sixty.CallCustomURLURL scheme:iOSDevTipsURL query: token=123abct&amp;registered=1Take note of the ‘Calling Application Bundle ID’ as you could use this to ensure that only an application that you define can interact directly with your app. Let’s change up the delegate method to verify the calling application Bundle ID is known:123456789101112131415- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; // Check the calling application Bundle ID if ([sourceApplication isEqualToString:@\"com.3Sixty.CallCustomURL\"]) &#123; NSLog(@\"Calling Application Bundle ID: %@\", sourceApplication); NSLog(@\"URL scheme:%@\", [url scheme]); NSLog(@\"URL query: %@\", [url query]); return YES; &#125; else return NO;&#125;It’s important to note that you cannot prevent another application from calling your app via custom URL scheme, however you can skip any further processing and return NO as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) URL scheme. Although this will guarantee you app won’t be called, it will make it more unlikely. Custom URL Scheme Example Projects I realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s. Download Xcode project for app with Custom URL schemeDownload Xcode project for app to call custom URL scheme","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"schemes","slug":"iOS/schemes","permalink":"https://huos3203.github.io/categories/iOS/schemes/"}],"tags":[{"name":"协议","slug":"协议","permalink":"https://huos3203.github.io/tags/协议/"},{"name":"scheme","slug":"scheme","permalink":"https://huos3203.github.io/tags/scheme/"}]},{"title":"XcodeHeaderDoc教程","slug":"xcode/XcodeHeaderDoc教程","date":"2014-08-28T15:18:41.000Z","updated":"2019-04-24T23:21:29.825Z","comments":true,"path":"2014/08/28/xcode/XcodeHeaderDoc教程/","link":"","permalink":"https://huos3203.github.io/2014/08/28/xcode/XcodeHeaderDoc教程/","excerpt":"HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。 另外，Xcode 还会在 quick look 面板中以HeaderDoc风格显示你的注释。 通过本教程，将学习如下几点： 如何书写 HeaderDoc 风格的注释 分如何在 Xcode 中预览文档 如何生成 HTML 文档 如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具) 准备工作下载本教程中用到的 示例项目 这个简单的示例程序只包含了两个类： Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。 MathAPI: 包含了1个方法，用于累加两个数。现在，这两个类还没有任何注释。以便演示如何通过 HeaderDoc 为这两个类创建文档。","text":"HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。 另外，Xcode 还会在 quick look 面板中以HeaderDoc风格显示你的注释。 通过本教程，将学习如下几点： 如何书写 HeaderDoc 风格的注释 分如何在 Xcode 中预览文档 如何生成 HTML 文档 如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具) 准备工作下载本教程中用到的 示例项目 这个简单的示例程序只包含了两个类： Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。 MathAPI: 包含了1个方法，用于累加两个数。现在，这两个类还没有任何注释。以便演示如何通过 HeaderDoc 为这两个类创建文档。 HeaderDoc 注释 HeaderDoc 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式：这3中语法在 Xcode 中产生同样效果的文档 注释 1. 一般用于单行注释 /// Your documentation comment will go here 注释 2. /** * Your documentation comment will go here */ 注释 3: 一般用于较长的注释块 /*! * Your documentation comment will go here */ 注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。 HeaderDoc 标签当 HeaderDoc 发现上述3种注释，它就开始寻找其中的HeaderDoc 标签。HeaderDoc 标签 用来修饰HeaderDoc 注释。 HeaderDoc 标签以 @ 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。HeaderDoc 标签可以分为两种： 顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。 顶级标签，例如 @typedef，用于表示 typedef 定义的类型，比如枚举、结构体和函数指针。 HeaderDoc 能够根据上下文自动产生顶级标签，因此通常不是必须的。 二级标签:这些标签才是具体的注释内容。 @brief: 简单描述你准备文档化的数据的类型，方法等等。 @abstract: 等于 @brief。 @discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。 @param: 描述方法、回调或函数的参数名称。 @return: 描述方法或函数的返回值。（等同于 @result） 具体实现 属性的文档化用 Xcode 打开DocumentationExamples 项目, 打开ViewController.h,在 car 属性的前面，加入一行注释: /*! * @brief The ViewController class&apos; car object. */ @property (nonatomic) Car *car; 编译项目。编译结束，按住 alt/option 键，点击car 变量名。你将看到pop菜单中显示了刚才的注释内容。 另一种方法:切换到Utitlities 面板的Quick Help 检查器窗口。点击 car 变量名，通过Quick Help,你将看到如下效果： 方法的文档化MathAPI包含一个方法需要文档化。打开MathAPI.h,找到addNumber:toNumber:。 这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示： /*! * @discussion A really simple way to calculate the sum of two numbers. * @param firstNumber An NSInteger to be used in the summation of two numbers * @param secondNumber The second half of the equation. * @return The sum of the two numbers passed in. */ + (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber; 编译，再 alt + 左键： 问题: 在 Xcode 文本编辑窗口，很多地方都支持 alt+左键。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。 你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。 * @warning Please make note that this method is only good for adding non-negative numbers. 编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下： Code Snippets，让一切变得更简单:一个snippet 是一个可以重用的代码块（存储在 snippet 库中）。Snippets 甚至可以包含一些需要你去填充的占位符。这意味着, 可以用 snipppet来进行文档化。 在 MathAPI.h 中，在原有的注释上面加入以下内容： /*! * @discussion * @param * @return */ 注意，当粘贴上述代码时，“”之间的内容会变成一个token,意味着可以通过 tab 键在 token 之间来回切换。就像编写代码时的自动完成功能。 学习使用Code Snippets工具 打开 Utilities 面板中的 CodeSnippets Library 检查器窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如开始拖）: 将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个自动完成快捷方式。要修改某个snippet时,直接点击 Code Snippet Library 中的 snippet，然后点 Edit 按钮。按照如下形式填写： 要想让 snippet 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入doccomment，然后回车，该snippet 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下: /*! * @discussion A really simple way to calculate the sum of two numbers. * @param firstNumber An NSInteger to be used in the summation of two numbers. * @param secondNumber The second half of the equation. * @warning Please make note that this method is only good for adding non-negative numbers. * @return The sum of the two numbers passed in. */ @param 标签和 @warning 标签需要手动书写。 Typedefs的文档化 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。 还记得 @typedef 标签吗？这个顶级标签稍微特殊一点。它可以对typedef enum 或者 typedef struct 的类型进行注释。根据注释的对象的不同，它会包含与定义的类型相关的二级标签。 以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。 找到 enum OldCarType。它包含两个常量，是用于古典汽车的。在typedef 声明之上，将原来的注释替换为： /*! * @typedef OldCarType * @brief A list of older car types. * @constant OldCarTypeModelT A cool old car. * @constant OldCarTypeModelA A sophisticated old car. */ typedef enum { /// A cool, old car. OldCarTypeModelT, /// A sophisticated older car. OldCarTypeModelA } OldCarType; 编译，然后在 OldCarType 或上OldCarTypeModelT使用alt + 左键。 在这个类中只有一个 NS_ENUM，因此接下来进行进行文档化。常量已经注释了，只要对整个NS_ENUM 进行一个总体的注释就可以了。 /*! * @typedefCarType * @brief Alist of newer car types. * @constantCarTypeHatchback Hatchbacks are fun, but small. * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc. * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back. */ 注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 typedef enum 一样的文档特性，虽然NS_ENUM 实际上是声明 enums 的推荐的方法。 typedef block 文档化/*! * @brief A block that makes the car drive. * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;] */ typedef void(^driveCompletion)(CGFloat distance); typedef block 的文档化和之前的并无多少不同，它包含了： 一个 @brief 标签，简单说明了一下这个块的作用。 一个 @param 标签，说明调用块时需要传递的参数。 添加格式化代码到文档中例如，Car 类的 driveCarWithComplete: 方法。 这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。 这需要使用 @code 标签。在 driveCarWithCompletion方法声明之前添加如下内容： /*! * @brief The car will drive, and then execute the drive block * @param completion A driveCompletion block * @code [car driveCarWithCompletion:^(CGFloat distance){ NSLog(@&quot;Distance driven %f&quot;, distance); }]; */ 编译，在方法名上使用alt+左键。如下图所示： 检查文档学会了如何添加注释，如果 Xcode 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“CLANG_WARN_DOCUMENTATION_COMMENTS”,可以用于检查 HeaderDoc 格式的注释。 打开 DocumentationExamples的项目设置，点击 Build Settings，找到 DocumentationComments, 将值设置为 YES。如下，打开 MathAPI.h，将第一个 @param 标签的参数名由firstNumber 修改为 thirdNumber,然后编译。有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。 特殊注释Xcode 还支持几种特殊注释，对于你或者使用你代码的人非常有用。 打开 Car.m，在 driveCarWithCompletion: 方法中，在调用completion 块之前添加下列注释： // FIXME: This is broken // !!!: Holy cow, it should be checked! // ???: Perhaps check if the block is not nil first? 这里出现了3中注释： FIXME: 某个地方需要修正 !!!: 某个地方需要注意。 ???: 代码中有问题，或者代码是可疑的。 这些注释不但有助于浏览代码，而且 Xcode 绘制 Jump Bar 中显示它们。点击Jump Bar，如下图所示： 你将看到这3个注释以粗体显示： 到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。 #用headerdoc2html 创建 HTML文档文档化是由一个 HeaderDoc 工具完成的。当 Xcode 安装时，它就已经安装好了。它除了解释已添加的注释，显示一个弹出菜单以及将注释在Quick Help 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。 本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考HeaderDoc 用户指南. 打开终端，转到 DocumentationExamples 项目目录： cd /path/to/your/folder 确保该路径下包含了 Xcodeproject 文件(“DocumentationExamples.xcodeproj”)。 然后用下列命令创建 HTML 文档： headerdoc2html -o ~/Desktop/documentation DocumentationExamples/ 此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html： headerdoc2html 脚本有两个参数： So what justhappened? Well, you ran the headerdoc2htmlscript with 2 options: -o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。 DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码） 问题: 最新版本headerdoc2html有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。 最新版本的headerdoc2html 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。 这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，HeaderDoc还会创建一个主目录索引。返回终端，导航至新建的 documentation 目录，输入： cd ~/Desktop/documentation 然后输入命令，创建内容索引: gatherheaderdoc . gatherheaderdoc自动查找目录，为 . 目录（表示当前目录）创建索引。用 Finder 打开 documentation 目录。你会发现多出一个 masterTOC.html 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！ #VVDocumenter-Xcode 最后的内容是 VVDocumenter-Xcode，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 Code Snippet 更容易。 首先，从 Github 下载插件。 你所需要做的全部工作就是打开项目，然后 Build。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。 然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 addNumber:toNumber 方法的注释块，然后在方法声明上面输入： /// VVDocumenter-Xcode 将自动创建注释块，包括所有必要的 @param 标签以及自动完成 token。 打开 Car.h，删除 NS_ENUM CarType 的注释，以及每个常量的注释。在NS_ENUM 声明之上，输入： /// 这回，它会在 enum 之上创建 discussion 标签，甚至还每个常量上面放入了必要的注释！ VVDocumenter-Xcode 使你的生活更加轻松。如果你想定制VVDocumenter-Xcode，在Xcode中，使用 Window&gt;VVDocumenter菜单。 这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！接下来做什么？ 最终完成的示例项目在 这里下载。 在你自己的代码中进行文档化。尝试自己编写 code snippet 并使用VVDocumentor。","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"文档","slug":"xcode/文档","permalink":"https://huos3203.github.io/categories/xcode/文档/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"}]},{"title":"Storyboard之Segue","slug":"iOS/UI/Storyboard之Segue","date":"2014-07-22T10:59:49.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/07/22/iOS/UI/Storyboard之Segue/","link":"","permalink":"https://huos3203.github.io/2014/07/22/iOS/UI/Storyboard之Segue/","excerpt":"Segue原理:在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作： 实例化目标视图控制器 实例化一个新segue对象，该对象持有所有的信息 调用源视图控制器的prepareForSegue:sender:方法， 调用segue的 perform 方法将目标控制器带到屏幕上。这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。 在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。","text":"Segue原理:在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作： 实例化目标视图控制器 实例化一个新segue对象，该对象持有所有的信息 调用源视图控制器的prepareForSegue:sender:方法， 调用segue的 perform 方法将目标控制器带到屏幕上。这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。 在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。123456789101112131415- (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([[segue identifier] isEqualToString:@\"ShowSightingsDetails\"]) &#123; //当用户选择表视图中的一行时，触发**segue**事件，传输数据到目标视图控制器，使目标控制器上能显示`sighting` DetailViewController *detailViewController = [segue destinationViewController]; detailViewController.sighting = [self.dataController objectInListAtIndex:[self.tableView indexPathForSelectedRow].row]; &#125; if ([[segue identifier] isEqualToString:@\"ShowAddSightingView\"]) &#123; AddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:0]; addSightingViewController.delegate = self; &#125; &#125; 在storyboard中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的segue。这两个segue通过它们的identifier属性进行判断，具体解释如下： identifier为”ShowSightingsDetails“时，目标视图控制器是一个展示明细信息的视图控制器,使用的segue类型为push。这种通常用于navigator视图控制器中。 在identifier为”ShowAddSightingView“时，目标视图控制器管理的是一个新加的sighting信息视图，我们称之为add视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。 实现方式是采用delegate，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。 在add视图控制器上，有两个按钮，用于执行cancel和done操作。这两个按钮操作的方法在主视图控制器中实现。1234567891011121314//- (void)addSightingViewControllerDidCancel:(AddSightingViewController *)controller &#123; [self dismissViewControllerAnimated:YES completion:NULL]; &#125; // - (void)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(NSString *)name location:(NSString *)location &#123; if ([name length] || [location length]) &#123; [self.dataController addBirdSightingWithName:name location:location]; [[self tableView] reloadData]; &#125; [self dismissModalViewControllerAnimated:YES]; &#125;在add视图控制器实现代码中，调用它的委托中这两个方法。 segue三种类型:modal segue、push segue、custom segue modal segue是一个视图控制器（源）为了完成一个任务而模态地（modally）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(navigation view controller)的栈中的一部分。在任务完成后，使用delegate将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。 这个过程的实现代码可以看成是present和dismiss两个操作。 push segue是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(navigation view controller)一起使用。新压入的视图控制器会有一个回退按钮，可以退回来上一层。 这个过程的实现代码可以看成是push和pop两个操作。","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"SB","slug":"xcode/SB","permalink":"https://huos3203.github.io/categories/xcode/SB/"}],"tags":[{"name":"转场","slug":"转场","permalink":"https://huos3203.github.io/tags/转场/"},{"name":"Storyboard","slug":"Storyboard","permalink":"https://huos3203.github.io/tags/Storyboard/"}]},{"title":"TextKit之便笺实战","slug":"iOS/UI/TextKit之便笺实战","date":"2014-07-03T17:29:00.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/07/04/iOS/UI/TextKit之便笺实战/","link":"","permalink":"https://huos3203.github.io/2014/07/04/iOS/UI/TextKit之便笺实战/","excerpt":"便笺练习功能点:通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。 动态样式（Dynamic type） 凸版印刷效果（Letterpress effects） 环绕路径（Exclusion paths） 动态文本格式及存储（Dynamic text formatting and storage） 这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。效果图:App开始运行后自动生成一组便笺实例并利用tableViewController显示出来。Storyboards和segues会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。项目开发包：Notepad.zip 动态样式动态样式（Dynamic type）是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。选择 通用-&gt;文字大小 或 通用-&gt;辅助功能 来查看app中的字体设置。 iOS 7 支持通过粗体、设置字体大小等方式提高支持动态文本的应用的易读性。例如UIFont新增的一个方法： preferredFontForTextStyle 用来根据用户对字体大小的设置来自动制定字体样式。下面表格中是六种可用字体样式的示例：最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。 使用系统动态字体样式使用动态文本，是通过给文本字体设置字体样式style而不是指定具体的字体名称和大小。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。 preferredFontForTextStyle:方法设置字体样式 打开 NoteEditorViewController.m/swift 在viewDidLoad：方法实现的最后面加入以下代码：1self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; 1self.textView.font = UIFont.preferredFont(forTextStyle: .body) 打开 NotesListViewController.m/swift 在 tableView:cellForRowAtIndexPath: 方法中增加如下代码:1cell.textLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; 1cell.textLabel?.font = UIFont.preferredFont(forTextStyle: .headline) 上面两行代码都用到了新版iOS的字体样式. 字体样式：通过语义法命名字体，例如 UIFontTextStyleSubHeadline, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。 APP响应用户字体设置 设置系统字体返回到通用-&gt;文字大小重新修改字体设置.再运行App, Note页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。 设置系统字体生效当我们返回到通用-&gt;文字大小重新修改字体设置. 再打开Note页面, 会发现app并没有立即对字体设置的变化做出相应反应。 监听系统通知：实现APP响应用户字体设置当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，preferredFontForTextStyle:方法返回的字体也会变化。 添加监听系统通知UIContentSizeCategoryDidChangeNotification通知APP响应用户字体设置的变化打开 NoteEditorViewController.m 并在 viewDidLoad 方法的实现的最后加入以下代码：12345[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(preferredContentSizeChanged:) name:UIContentSizeCategoryDidChangeNotification object:nil]; 12//字体变化通知:调用preferredContentSizeChanged:方法NotificationCenter.default.addObserver(self, selector: #selector(NoteEditorViewController.preferredContentSizeChanged(_:)), name: NSNotification.Name.UIContentSizeCategoryDidChange, object: nil) 添加系统通知响应事件收到用于指定本类接收字体设定变化的通知后，调用preferredContentSizeChanged:方法在NoteEditorViewController.m中viewDidLoad方法之后紧接着添加以下方法：1234- (void)preferredContentSizeChanged:(NSNotification *)notification&#123; self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];&#125; 12345//字体变化通知时调用func preferredContentSizeChanged(_ notification:NSNotification)&#123; self.textView.font = UIFont.preferredFont(forTextStyle: .body)&#125; 这一方法作用是根据新的字体设置来设定textView中的字体。Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。","text":"便笺练习功能点:通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。 动态样式（Dynamic type） 凸版印刷效果（Letterpress effects） 环绕路径（Exclusion paths） 动态文本格式及存储（Dynamic text formatting and storage） 这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。效果图:App开始运行后自动生成一组便笺实例并利用tableViewController显示出来。Storyboards和segues会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。项目开发包：Notepad.zip 动态样式动态样式（Dynamic type）是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。选择 通用-&gt;文字大小 或 通用-&gt;辅助功能 来查看app中的字体设置。 iOS 7 支持通过粗体、设置字体大小等方式提高支持动态文本的应用的易读性。例如UIFont新增的一个方法： preferredFontForTextStyle 用来根据用户对字体大小的设置来自动制定字体样式。下面表格中是六种可用字体样式的示例：最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。 使用系统动态字体样式使用动态文本，是通过给文本字体设置字体样式style而不是指定具体的字体名称和大小。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。 preferredFontForTextStyle:方法设置字体样式 打开 NoteEditorViewController.m/swift 在viewDidLoad：方法实现的最后面加入以下代码：1self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; 1self.textView.font = UIFont.preferredFont(forTextStyle: .body) 打开 NotesListViewController.m/swift 在 tableView:cellForRowAtIndexPath: 方法中增加如下代码:1cell.textLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; 1cell.textLabel?.font = UIFont.preferredFont(forTextStyle: .headline) 上面两行代码都用到了新版iOS的字体样式. 字体样式：通过语义法命名字体，例如 UIFontTextStyleSubHeadline, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。 APP响应用户字体设置 设置系统字体返回到通用-&gt;文字大小重新修改字体设置.再运行App, Note页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。 设置系统字体生效当我们返回到通用-&gt;文字大小重新修改字体设置. 再打开Note页面, 会发现app并没有立即对字体设置的变化做出相应反应。 监听系统通知：实现APP响应用户字体设置当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，preferredFontForTextStyle:方法返回的字体也会变化。 添加监听系统通知UIContentSizeCategoryDidChangeNotification通知APP响应用户字体设置的变化打开 NoteEditorViewController.m 并在 viewDidLoad 方法的实现的最后加入以下代码：12345[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(preferredContentSizeChanged:) name:UIContentSizeCategoryDidChangeNotification object:nil]; 12//字体变化通知:调用preferredContentSizeChanged:方法NotificationCenter.default.addObserver(self, selector: #selector(NoteEditorViewController.preferredContentSizeChanged(_:)), name: NSNotification.Name.UIContentSizeCategoryDidChange, object: nil) 添加系统通知响应事件收到用于指定本类接收字体设定变化的通知后，调用preferredContentSizeChanged:方法在NoteEditorViewController.m中viewDidLoad方法之后紧接着添加以下方法：1234- (void)preferredContentSizeChanged:(NSNotification *)notification&#123; self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];&#125; 12345//字体变化通知时调用func preferredContentSizeChanged(_ notification:NSNotification)&#123; self.textView.font = UIFont.preferredFont(forTextStyle: .body)&#125; 这一方法作用是根据新的字体设置来设定textView中的字体。Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。 更新布局现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示： 这是动态样式有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。在NotesListViewController.m中实现tableView:heightForRowAtIndexPath: 代理方法:12345678910- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static UILabel* label; if (!label) &#123; label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, FLT_MAX, FLT_MAX)]; label.text = @\"test\"; &#125; label.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; [label sizeToFit]; //自适应文本内容大小 return label.frame.size.height * 1.7;&#125;123456789override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat&#123; let label = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: FLT_MAX, height: FLT_MAX)) label.text = \"test\" let font = UIFont.preferredFont(forTextStyle: .headline) label.font = font label.sizeToFit() return label.frame.size.height * 1.7&#125; 以上代码创建了一个共享的——或者说静态的——UILabel实例，设定它的字体和表中单元格内文本字体一致。然后调用它的sizeToFit方法，使这个label的frame恰好能放得下它的内容文字, 然后把这个label的高度乘个1.7作为表内单元格高度。Build并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示： 凸版印刷效果（Letterpress effects）凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。 注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。 打开NotesListViewController.m 将tableView:cellForRowAtIndexPath:方法中的代码用以下代码替换:123456789101112131415161718static NSString *CellIdentifier = @\"Cell\";UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];Note* note = [self notes][indexPath.row];UIFont* font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];UIColor* textColor = [UIColor colorWithRed:0.175f green:0.458f blue:0.831f alpha:1.0f];NSDictionary *attrs = @&#123; NSForegroundColorAttributeName : textColor, NSFontAttributeName : font, NSTextEffectAttributeName : NSTextEffectLetterpressStyle&#125;;NSAttributedString* attrString = [[NSAttributedString alloc] initWithString:note.title attributes:attrs];cell.textLabel.attributedText = attrString;return cell;123456789101112131415override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell&#123; let cell = tableView.dequeueReusableCell(withIdentifier: \"noteListCell\", for: indexPath) // Configure the cell... let note = notes[indexPath.row] as! NoteModel //cell.textLabel?.text = note.title let font = UIFont.preferredFont(forTextStyle: .headline) let textColor = UIColor.init(red: 0.175, green: 0.458, blue: 0.831, alpha: 1.0) //字体凸版印刷效果 let store:[String:Any] = [NSForegroundColorAttributeName:textColor, NSFontAttributeName:font, NSTextEffectAttributeName:NSTextEffectLetterpressStyle] cell.textLabel?.attributedText = NSAttributedString.init(string: note.title, attributes: store) return cell&#125; 上面的代码为单元格的标题创建了一个使用了凸版印刷效果的NSAttributedString。 Build并运行app， 表格将显示凸版印刷效果，如下图所示：凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。 环绕路径（Exclusion paths）文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。Text Kit允许你通过环绕路径（exclusion paths）将文字按照复杂路径和形状分布。 在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期： 首先添加一个视图 创建一个环绕路径，使文字按照这个路径分布。 添加视图打开 NoteEditorViewController.m 在顶部的imports和接口实现中添加变量加入以下代码：123456#import \"TimeIndicatorView.h\"@implementation NoteEditorViewController&#123; TimeIndicatorView* _timeView;&#125;实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去在NoteEditorViewController.m的viewDidLoad方法的最后添加以下代码：objc12_timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp];[self.view addSubview:_timeView]; 设置视图位置及自动适应布局：viewDidLayoutSubviews当NoteEditor视图的控件调用系统方法viewDidLayoutSubviews方法，对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。在控件接收到文本内容的尺寸发生了变化的时候调用updateTimeIndicatorFrame： 第一调用updateSize来设定_timeView的尺寸 第二将_timeView放在右上角在NoteEditorViewController.m 的最后添加如下代码：objc12345678910- (void)viewDidLayoutSubviews &#123; [self updateTimeIndicatorFrame];&#125;- (void)updateTimeIndicatorFrame&#123; [_timeView updateSize]; _timeView.frame = CGRectOffset(_timeView.frame, self.view.frame.size.width - _timeView.frame.size.width, 0.0);&#125; swift1234567891011121314//视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。override func viewDidLayoutSubviews() &#123; updateTimeIndicatorFrame()&#125;func updateTimeIndicatorFrame() &#123; //第一调用updateSize来设定_timeView的尺寸 timeIndicatorView.updateSize() //通过偏移frame参数，将timeIndicatorView放在右上角 timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width, dy: 0.0)&#125; 响应系统偏好设置字体样式修改NoteEditorViewController.m中preferredContentSizeChanged:方法如下：12345- (void)preferredContentSizeChanged:(NSNotification *)n &#123; self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; [self updateTimeIndicatorFrame];&#125;Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示： 文本环绕视图 根据日期视图_timeView创建基于贝赛尔路径的环绕路径 设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。 curvePathWithOrigin:创建文本容器的赛尔路径根据日期视图_timeView创建基于贝赛尔路径的环绕路径添加curvePathWithOrigin:方法，定义文本遵循的环绕路径：objc12345678- (UIBezierPath *)curvePathWithOrigin:(CGPoint)origin&#123; return [UIBezierPath bezierPathWithArcCenter:origin radius: [self radiusToSurroundFrame:_label.frame] startAngle: -180.0f endAngle: 180.0f clockwise: YES];&#125;swift1234567891011121314func curvePathWithOrigin(origin:CGPoint)-&gt;UIBezierPath&#123; //画弧形 let path = UIBezierPath.init(arcCenter: origin, radius: radiusToSurroundFrame(frame: timeLabel.frame), startAngle: -180, //-180.0 endAngle: 180.0, //CGFloat(M_PI * 2), //180.0 clockwise: true) // UIColor.blueColor().set() // path.fill() // UIColor.blueColor().set() return path&#125; 设置文本容器的环绕路径：exclusionPathsexclusionPaths是NSArray类型，因此一个文本容器是可以支持多个环绕路径，文本环绕路径发生改变后会通知文本管理器，然后环绕路径的变化就可以动态地，甚至是动画式地体现到文本上！在updateTimeIndicatorFrame方法实现的最后面添加如下代码：objc1234&#123; UIBezierPath* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center]; _textView.textContainer.exclusionPaths = @[exclusionPath];&#125;swift1234&#123; let exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center) ibTextView.textContainer.exclusionPaths = [exclusionPath]&#125;Build并运行app，选择一个便笺项，如下图所示： 动态文本格式及存储（Dynamic text formatting and storage）你已经看到了Text Kit可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？实现类似markdown语法的效果： 把波浪线(~)之间的文本变为艺术字体 把下划线(_)之间的文本变为斜体 为破折号(-)之间的文本添加删除线 把字母全部大写的单词变为红色 Text Kit文本系统工作机制Text Kit 堆栈存储、处理以及显示文本：当你创建UITextView, UILabel or UITextField的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。 NSTextStorage文本存储器: 作为一个NSMutableAttributedString的子类，动态处理的文本可以通过attributedString的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义NSTextStorage的子类，当文本发生变化时，动态地对文本属性做出相应改变。 NSLayoutManager布局引擎: 获取存储的文本并经过修饰处理再显示在屏幕上； NSTextContainer文本容器: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的UITextView. 可以创建 NSTextContainer的子类来定义一个复杂的形状，然后在这个形状内处理文本。 NSTextStorage文本存储器动态添加文本属性 需要创建一个NSTextStorage的子类，用以在用户输入文本的时候，动态地添加文本属性。 将UITextView的默认文本存储器,用自定义的实现替换掉。 创建文本存储器NSTextStorage子类新建NSTextStorage的子类，类命名为SyntaxHighlightTextStorage打开SyntaxHighlightTextStorage.m并添加实例变量并初始化：123456789101112131415#import \"SyntaxHighlightTextStorage.h\"@implementation SyntaxHighlightTextStorage&#123; NSMutableAttributedString * _backingStore;&#125;- (id)init&#123; if (self = [super init]) &#123; _backingStore = [NSMutableAttributedString new]; &#125; return self;&#125;@end swift123456class SyntaxHighlightTextStorage: NSTextStorage&#123; //文本存储器子类必须提供它自己的“数据持久化层”。 var backingStore = NSMutableAttributedString()&#125; 重载文本存储器的数据持久化层方法要使用NSMutableAttributedString作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”：1234567891011- (NSString *)string&#123; return [_backingStore string];&#125;- (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range&#123; return [_backingStore attributesAtIndex:location effectiveRange:range];&#125;swift123456789101112131415override var string: String&#123; return backingStore.string&#125;override func attributes(at location: Int, effectiveRange range: NSRangePointer?) -&gt; [String : Any]&#123; if range == nil &#123; return [:] &#125; //print(\"backingStore:location\\(location),effectiveRange:\\(range!)\") return backingStore.attributes(at: location, effectiveRange: range!)&#125;上面两个方法直接把任务代理给了后台存储。 重载编辑文本时通知布局管理器的方法同样的，这些方法也是把任务代理给后台存储。它们通过调用beginEditing / edited / endEditing这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。最后，还在这个文件中，重载以下方法：123456789101112131415161718192021- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str&#123; NSLog(@\"replaceCharactersInRange:%@ withString:%@\", NSStringFromRange(range), str); [self beginEditing]; [_backingStore replaceCharactersInRange:range withString:str]; [self edited:NSTextStorageEditedCharacters | NSTextStorageEditedAttributes range:range changeInLength:str.length - range.length]; [self endEditing];&#125;- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range&#123; NSLog(@\"setAttributes:%@ range:%@\", attrs, NSStringFromRange(range)); [self beginEditing]; [_backingStore setAttributes:attrs range:range]; [self edited:NSTextStorageEditedAttributes range:range changeInLength:0]; [self endEditing];&#125; swift123456789101112131415161718override func replaceCharacters(in range: NSRange, with str: String)&#123; print(\"replaceCharactersInRange:\\(NSStringFromRange(range)) withString:\\(str)\") beginEditing() backingStore.replaceCharacters(in: range, with: str) edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.count - range.length) endEditing()&#125;override func setAttributes(_ attrs: [String : Any]?, range: NSRange)&#123; //Sets the attributes for the characters in the specified range to the specified attributes. print(\"setAttributes:\\(attrs!) range:\\(NSStringFromRange(range))\") beginEditing() backingStore.setAttributes(attrs!, range: range) edited(.editedAttributes, range: range, changeInLength: 0) endEditing()&#125; 类族介绍类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类NSArray和NSNumber类似的就是一族类的公共接口。 上例中NSTextStorage文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方attributedString数据的后台存储。 Apple使用类族来封装同一个公共抽象超类下的私有具体子类，抽象超类声明了客户在创建私有子类实例时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。 创建UITextView使用自定义Text Kit堆栈现在有了一个自定义的NSTextStorage，还需创建一个UITextView来使用它。 storyboard创建UITextView时，Text Kit组件只读问题从storyboard编辑器实例化UITextView会自动创建NSTextStorage, NSLayoutManager和NSTextContainer (例如Text Kit堆栈)实例以及所有的这三个只读属性。虽然没有办法从storyboard编辑器中改变这种设定，但可以手动编程创建UITextView和Text Kit堆栈。 在UITextView中使用自定义的SyntaxHighlightTextStorage清理IB相关设置 在IB中打开Main.storyboard 找到NoteEditorViewController。 删除UITextView实例。然后，打开NoteEditorViewController.m删除UITextView outlet。既然不再为文本视图使用IBOutlet，而是要编程添加，所以也就不需要这些代码了。从viewDidLoad 方法中删除以下代码：123self.textView.text = self.note.contents;self.textView.delegate = self;self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; 手动创建UITextView和Text Kit堆栈 在NoteEditorViewController.m最上面，添加下面一行代码:objc1#import \"SyntaxHighlightTextStorage.h\" 在NoteEditorViewController.m中TimeIndicatorView实例变量后面紧接着添加以下代码：12SyntaxHighlightTextStorage* _textStorage;UITextView* _textView; 文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。 创建Text Kit堆栈 创建自定义的NSTextStorage文本存储器实例，一个用来承载便笺内容的NSAttributedString 创建一个NSLayoutManager布局管理器，并添加到文本存储器。 创建一个NSTextContainer文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来 最后用你自定义的文本容器和代理组创建实际的文本视图， 并把文本视图添加为子视图在NoteEditorViewController.m中，添加下面方法：1234567891011121314151617181920212223242526272829- (void)createTextView&#123; // 1. Create the text storage that backs the editor NSDictionary* attrs = @&#123;NSFontAttributeName: [UIFont preferredFontForTextStyle:UIFontTextStyleBody]&#125;; NSAttributedString* attrString = [[NSAttributedString alloc] initWithString:_note.contents attributes:attrs]; _textStorage = [SyntaxHighlightTextStorage new]; [_textStorage appendAttributedString:attrString]; CGRect newTextViewRect = self.view.bounds; // 2. Create the layout manager NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init]; // 3. Create a text container CGSize containerSize = CGSizeMake(newTextViewRect.size.width, CGFLOAT_MAX); NSTextContainer *container = [[NSTextContainer alloc] initWithSize:containerSize]; container.widthTracksTextView = YES; [layoutManager addTextContainer:container]; [_textStorage addLayoutManager:layoutManager]; // 4. Create a UITextView _textView = [[UITextView alloc] initWithFrame:newTextViewRect textContainer:container]; _textView.delegate = self; [self.view addSubview:_textView];&#125; swift1234567891011121314151617181920212223242526272829303132333435363738//创建文本区域func createTextView()&#123; // 1. Create the text storage that backs the editor let bodyFont = UIFont.preferredFont(forTextStyle: UIFontTextStyle.body) let attrs = [NSFontAttributeName:bodyFont] let attrString = NSAttributedString(string: note.contents,attributes: attrs) textStorage = SyntaxHighlightTextStorage() textStorage.append(attrString) // --------使用Storyboard声明TextView时,只需一行，可惜为只读属性---------- textStorage.addLayoutManager(ibTextView.layoutManager) /**--------使用代码声明TextView时，4步骤---------- let newTextViewRect = view.bounds // 2. Create the layout manager let layoutManager = NSLayoutManager() // 3. Create a text container //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。 let containerSize = CGSize.init(width: newTextViewRect.size.width, height: CGFloat.greatestFiniteMagnitude) let container = NSTextContainer.init(size: containerSize) //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized. container.widthTracksTextView = true // layoutManager.addTextContainer(container) textStorage.addLayoutManager(layoutManager) // 4. Create a UITextView textView = UITextView()//.init(frame: newTextViewRect, textContainer: container) textView.isScrollEnabled = true textView.delegate = self view.addSubview(textView) */&#125; 现在回顾之前那个图表所展示的四个关键类(文本存储器storage, 布局管理器layout manager, 文本容器container 和文本视图textView)之间的关系，是不是觉得理解起来容易多了。 注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFLOAT_MAX，它的值可以是无限大。不管怎么说，它的高度足够让UITextView上下滚动以容纳很长的文本。 在viewDidLoad方法中调用超类的viewDidLoad方法的语句后面添加以下一行代码：1[self createTextView];然后修改preferredContentSizeChanged的第一行代码为：1_textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; 自定义视图实现在storyboard中自动布局约束的效果用自定义的实例变量来替换掉旧的outlet属性。自定义视图不会自动继承storyboard中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。 可以在viewDidLayoutSubviews方法的最后添加以下代码来实现：1_textView.frame = self.view.bounds;Build并运行app，打开一个便笺项，在Xcode控制台上有SyntaxHighlightTextStorage生成的运行日志，用来告诉你这些文本处理的代码确实被调用：看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。 通过正则修改文本存储器的动态格式（Dynamic formatting）接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体： processEditing：将文本的变化通知给布局管理器processEditing 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。打开SyntaxHighlightTextStorage.m 添加以下方法：12345-(void)processEditing&#123; [self performReplacementsForRange:[self editedRange]]; [super processEditing];&#125; ####NSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range上面的代码拓展了受黑体格式类型影响的文本范围。因为changedRange一般只是作用到单独的一个字符； 而lineRangeForRange 则扩展到一整行在 processEditing方法之后紧接着添加以下代码：12345678- (void)performReplacementsForRange:(NSRange)changedRange&#123; NSRange extendedRange = NSUnionRange(changedRange, [[_backingStore string] lineRangeForRange:NSMakeRange(changedRange.location, 0)]); extendedRange = NSUnionRange(changedRange, [[_backingStore string] lineRangeForRange:NSMakeRange(NSMaxRange(changedRange), 0)]); [self applyStylesToRange:extendedRange];&#125;swift1234567891011121314151617181920//在指定的区域中进行替换func performReplacementsForRange(_ changedRange:NSRange)&#123; //定位正在编辑文本的位置区间 let locationRange = NSMakeRange(changedRange.location, 0) //定位到文本当前行的位置区间 let range1 = (backingStore.string as NSString).lineRange(for: locationRange) //扩展范围 var extendedRange = NSUnionRange(changedRange, range1) let maxRange = NSMakeRange(NSMaxRange(changedRange), 0) let range2 = (backingStore.string as NSString).lineRange(for: maxRange) extendedRange = NSUnionRange(changedRange, range2) print(\"在指定的区域中进行替换:\\(extendedRange)\") applyStylesToRange(searchRange: extendedRange)&#125; 在 performReplacementsForRange方法之后紧接着添加以下代码：1234567891011121314151617181920212223242526272829303132333435363738- (void)applyStylesToRange:(NSRange)searchRange&#123; // 1. create some fonts UIFontDescriptor* fontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; UIFontDescriptor* boldFontDescriptor = [fontDescriptor fontDescriptorWithSymbolicTraits:UIFontDescriptorTraitBold]; UIFont* boldFont = [UIFont fontWithDescriptor:boldFontDescriptor size: 0.0]; UIFont* normalFont = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; // 2. match items surrounded by asterisks NSString* regexStr = @\"(*w+(sw+)**)s\"; NSRegularExpression* regex = [NSRegularExpression regularExpressionWithPattern:regexStr options:0 error:nil]; NSDictionary* boldAttributes = @&#123; NSFontAttributeName : boldFont &#125;; NSDictionary* normalAttributes = @&#123; NSFontAttributeName : normalFont &#125;; // 3. iterate over each match, making the text bold [regex enumerateMatchesInString:[_backingStore string] options:0 range:searchRange usingBlock:^(NSTextCheckingResult *match, NSMatchingFlags flags, BOOL *stop)&#123; NSRange matchRange = [match rangeAtIndex:1]; [self addAttributes:boldAttributes range:matchRange]; // 4. reset the style to the original if (NSMaxRange(matchRange)+1 &lt; self.length) &#123; [self addAttributes:normalAttributes range:NSMakeRange(NSMaxRange(matchRange)+1, 1)]; &#125; &#125;];&#125;上面的代码有以下作用： 创建一个粗体及一个正常字体并使用字体描述器（Font descriptors）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。 创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。 对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。 将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。 注： 字体描述器（Font descriptors）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化UIFont实例便可获取字体规格的细节。 Build并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示： ##进一步添加样式为限定文本添加风格的基本原则很简单：使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。在SyntaxHighlightTextStorage.m中添加以下实例变量：12345678910111213141516171819202122232425262728293031323334- (void) createHighlightPatterns &#123; UIFontDescriptor *scriptFontDescriptor = [UIFontDescriptor fontDescriptorWithFontAttributes: @&#123;UIFontDescriptorFamilyAttribute: @\"Zapfino\"&#125;]; // 1. base our script font on the preferred body font size UIFontDescriptor* bodyFontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; NSNumber* bodyFontSize = bodyFontDescriptor. fontAttributes[UIFontDescriptorSizeAttribute]; UIFont* scriptFont = [UIFont fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]]; // 2. create the attributes NSDictionary* boldAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitBold]; NSDictionary* italicAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitItalic]; NSDictionary* strikeThroughAttributes = @&#123; NSStrikethroughStyleAttributeName : @1&#125;; NSDictionary* scriptAttributes = @&#123; NSFontAttributeName : scriptFont&#125;; NSDictionary* redTextAttributes = @&#123; NSForegroundColorAttributeName : [UIColor redColor]&#125;; // construct a dictionary of replacements based on regexes _replacements = @&#123; @\"(\\*w+(sw+)\\*\\*)s\" : boldAttributes, @\"(_w+(sw+)\\*_)s\" : italicAttributes, @\"([0-9]+.)s\" : boldAttributes, @\"(-w+(sw+)\\*-)s\" : strikeThroughAttributes, @\"(~w+(sw+)\\*~)s\" : scriptAttributes, @\"s([A-Z]&#123;2,&#125;)s\" : redTextAttributes&#125;;&#125; 这个方法的作用： 首先，它使用Zapfino字体来创建了“script”风格。Font descriptors会决定当前正文的首选字体，以保证script不会影响到用户的字体大小设置。 然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 createAttributesForFontStyle:withTrait:。 最后，它将创建一个NSDictionary并将正则表达式映射到上面声明的属性上。 如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。 以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：(*w+(sw+)**)s上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：(*w+(sw+)**)s现在，逐步来分析这个正则表达式：12345(* —— 匹配星号符 w+ —— 后接一个或多个 “word”式 字符串 (sw+)* —— 后接零个或多组空格然后再接 “word” 式字符串 *) —— 后接星号符 s —— 以空格结尾 注：如果你想对正则表达式有更多了解，请参考 NSRegularExpression tutorial and cheat sheet. 现在你需要调用createHighlightPatterns：将SyntaxHighlightTextStorage.m 中的init方法更新如下：12345678- (id)init&#123; if (self = [super init]) &#123; _backingStore = [NSMutableAttributedString new]; [self createHighlightPatterns]; &#125; return self;&#125; 在SyntaxHighlightTextStorage.m方法中添加以下代码：1234567891011- (NSDictionary*)createAttributesForFontStyle:(NSString*)style withTrait:(uint32_t)trait &#123; UIFontDescriptor *fontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; UIFontDescriptor *descriptorWithTrait = [fontDescriptor fontDescriptorWithSymbolicTraits:trait]; UIFont* font = [UIFont fontWithDescriptor:descriptorWithTrait size: 0.0]; return @&#123; NSFontAttributeName : font &#125;;&#125; 上面的代码作用是将提供的字体样式作用到正文字体上。它给fontWithDescriptor:size: 提供的size值为0，这样做会迫使UIFont返回用户设置的字体大小。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"控件","slug":"iOS/控件","permalink":"https://huos3203.github.io/categories/iOS/控件/"}],"tags":[{"name":"TextKit","slug":"TextKit","permalink":"https://huos3203.github.io/tags/TextKit/"},{"name":"案例","slug":"案例","permalink":"https://huos3203.github.io/tags/案例/"}]},{"title":"iOS Document Interaction 编程指南","slug":"iOS/iOSDocumentInteraction编程指南","date":"2014-07-01T23:12:01.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/07/02/iOS/iOSDocumentInteraction编程指南/","link":"","permalink":"https://huos3203.github.io/2014/07/02/iOS/iOSDocumentInteraction编程指南/","excerpt":"关于 Document Interaction iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的UIDocumentInteractionController类，以及Quick Look框架。 ######预览文档和呈现选项菜单如果app需要打开自身并不支持的文件时，就需要使用UIDocumentInteractionController。一个document interaction controller通过Quick Look框架判断文档是否能被另一个app打开和预览。也就是说，app可以通过documentinteraction controller提供一些支持打开该文件方式的菜单。 具体实现需要以下步骤： 需要通过其他APP打开的文件，来实例化UIDocumentInteractionController实例对象。 在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。 用户交互，如触摸这个控件，则调用documentinteractioncontroller对象。 三种交互界面: 1. 预览文件的内容。 2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。 3. 一个菜单，仅包含“以其它方式打开”操作。 同时，documentinteractioncontroller内置了一些手势，必要时可以直接实现它们。 ######使用documentinteractioncontroller的场景:与文件交互的app都可以使用。 需要从网络下载文件的APP:例如，email程序需要打开和预览邮件附件。 不下载文件的APP:例如，APP需要支持文件共享（参考“File-Sharing Support” in iOS Technology Overview), 即可以对同步到app Documents/Shared目录下的文件使用documentinteractioncontroller。","text":"关于 Document Interaction iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的UIDocumentInteractionController类，以及Quick Look框架。 ######预览文档和呈现选项菜单如果app需要打开自身并不支持的文件时，就需要使用UIDocumentInteractionController。一个document interaction controller通过Quick Look框架判断文档是否能被另一个app打开和预览。也就是说，app可以通过documentinteraction controller提供一些支持打开该文件方式的菜单。 具体实现需要以下步骤： 需要通过其他APP打开的文件，来实例化UIDocumentInteractionController实例对象。 在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。 用户交互，如触摸这个控件，则调用documentinteractioncontroller对象。 三种交互界面: 1. 预览文件的内容。 2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。 3. 一个菜单，仅包含“以其它方式打开”操作。 同时，documentinteractioncontroller内置了一些手势，必要时可以直接实现它们。 ######使用documentinteractioncontroller的场景:与文件交互的app都可以使用。 需要从网络下载文件的APP:例如，email程序需要打开和预览邮件附件。 不下载文件的APP:例如，APP需要支持文件共享（参考“File-Sharing Support” in iOS Technology Overview), 即可以对同步到app Documents/Shared目录下的文件使用documentinteractioncontroller。 创建Document Interaction Controller创建时，通过需要其他APP打开的文件，来实例化UIDocumentInteractionController实例对象，并设置它的delegate属性。delegate对象负责告诉document interaction controller呈现视图时需要的信息，以及当视图显示和用户交互时要执行的动作。如以下代码所示。注意方法的调用者必须返回对象。实例化document interaction controller123456789- (UIDocumentInteractionController *) setupControllerWithURL: (NSURL) fileURL usingDelegate: (id &lt;UIDocumentInteractionControllerDelegate&gt;) interactionDelegate &#123; UIDocumentInteractionController *interactionController = [UIDocumentInteractionController interactionControllerWithURL: fileURL]; interactionController.delegate = interactionDelegate; return interactionController;&#125; 实例创建后，可以通过它的属性来读取与之关联的文件信息，包括文件名、类型和URL。该实例中还有一个icons属性，其中包含了多个 UIImage 对象,可以用于表示该文档的多个大小的图标。这些信息可用于UI。 如果用其他APP打开该文件，可以利用该实例的 annotation 属性，该属性包含了其他APP所需的附加信息。当然信息的格式必须能够被该APP识别。例如:当程序想与套件中的其他程序进行交互时，就可以使用annotation 属性。当被调用应用程序打开一个文件时，option 字典中会包含 annotation 的值，可以使用UIApplicationLaunchOptionsAnnotationKey 作为键在option字典中检索它。 呈现 Document Interaction Controller用户可以通过 Document interaction controller实例，来预览该文件，或者通过弹出菜单让用户选择相应的动作。 模式化显示文件预览窗口，调用如下方法: 模式化预览窗口调用的方法 Declared In UIDocumentInteractionController.h12//Displays a full-screen preview of the target document.- (BOOL)presentPreviewAnimated:(BOOL)animated; 预览窗口是以模式视图显示的，同时必须实现以下协议方法: Declared In UIDocumentInteractionController.h12//Called when a document interaction controller needs the starting point for animating the display of a document preview.- (UIViewController *) documentInteractionControllerViewControllerForPreview: (UIDocumentInteractionController *) controller 注:该方法最终需要返回一个VC，来作为预览窗口的父窗口。假如没有实现该方法，或者在该方法中返回 nil，或者返回的VC无法呈现模式窗口，则该预览窗口不会显示。最终会被documentinteractioncontroller会自动解散它呈现出来的窗口。或调用系统提供销毁模态视图的方法，手动销毁如下： Declared In UIDocumentInteractionController.h1234//Dismisses the currently active menu.- (void)dismissMenuAnimated:(BOOL)animated //Dismisses the currently active document preview.- (void)dismissPreviewAnimated:(BOOL)animated 通过弹出菜单提示用户选择相应动作，调用如下方法: 弹出\"通过其他方式打开\"菜单 Declared In UIDocumentInteractionController.h1234//Displays an options menu and anchors it to the specified location in the view.- (BOOL)presentOptionsMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated//Displays an options menu and anchors it to the specified bar button item.- (BOOL)presentOptionsMenuFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated 提示用户用其他程序打开该文件，调用如下方法:提示用户用其他程序打开 Declared In UIDocumentInteractionController.h1234//Displays a menu for opening the document and anchors that menu to the specified view.- (BOOL)presentOpenInMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated//Displays a menu for opening the document and anchors that menu to the specified bar button item.- (BOOL)presentOpenInMenuFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated 以上几种方法都会显示一个视图或一个预览窗口或是弹出菜单。任何一个方法的调用，都要检查返回值。返回值为 NO，表示这个视图没有任何内容，将不能显示。例如，presentOpenInMenuFromRect:inView:animated:方法返回NO,表明已安装的程序中没有任何程序能够打开该文档。 注册应用程序支持的文档类型如果你的程序可以打开某种特定的文件类型，则可以通过Info.plist文件注册程序所能打开的文档类型。当其他程序向系统询问哪些程序可以识别该类型的文件时，你的程序就会被列到选项菜单中，供用户选择。 有如下概念: 需要在程序的Info.plist文件中添加新字段CFBundleDocumentTypes 键 (查看 “CoreFoundation Keys”) 。系统会将该键中包含的内容进行登记，这样其他程序就可以通过document interaction controller访问到这些信息。 CFBundleDocumentTypes 键是一个dictionary数组，一个dictionary表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软office文档），这样就可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。 CFBundleDocumentTypes 数组中的每个dictionary包含以下键：字典键名称1234CFBundleTypeName //指定文档类型名称。CFBundleTypeIconFiles //是一个数组，包含多个图片文件名，用于作为该文档的图标。LSItemContentTypes //是一个数组，包含多个 UTI 类型的字符串。UTI 类型是本文档类型（组）所包含的文件类型。LSHandlerRank //表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。在应用程序的角度而言，一个文档类型其实就是一种文件类型（或者多个文件类型），该程序将一个文档类型的文件都视作同样的东西对待。例如，一个图片处理程序可能将各种图片文件都看成不同的文档类型，这样便于根据每个类型进行相应的优化。但是，对于字处理程序来说，它并不关心真正的图形格式，它把所有的图片格式都作为一个文档类型对待。 CFBundleDocumentTypes字典数组示例:自定义文件格式的文档类型123456789101112131415&lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;My File Format&lt;/string&gt; &lt;key&gt;CFBundleTypeIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;MySmallIcon.png&lt;/string&gt; &lt;string&gt;MyLargeIcon.png&lt;/string&gt; &lt;/array&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.example.myformat&lt;/string&gt; &lt;/array&gt; &lt;key&gt;LSHandlerRank&lt;/key&gt; &lt;string&gt;Owner&lt;/string&gt;&lt;/dict&gt; 打开支持的文件类型系统可能会请求某个程序打开某种文件，并呈现给用户。这种情况通常发生在某个应用程序调用 document interaction controller 去处理某个文件的时候。这时应用程序可以通过委托方法:获得文件的信息 Declared In UIApplication.hlink12//Tells the delegate that the launch process is almost done and the app is almost ready to run.- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 注:如果你的程序要处理某些自定义的文件类型，就必须实现这个委托方法（而不是applicationDidFinishLaunching:方法) 并用这个方法启动应用程序 该方法的option包含了要打开的文件的相关信息，可以通过以下键名一一解析：123UIApplicationLaunchOptionsURLKey //该文件的NSURLUIApplicationLaunchOptionsSourceApplicationKey //发送请求的应用程序的Bundle IDUIApplicationLaunchOptionsSourceApplicationKey //源程序向目标程序传递的与该文件相关的属性列表对象如果 UIApplicationLaunchOptionsURLKey 键存在，你的程序应当立即用该URL打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。 使用 Quick Look 框架Quick Look框架提供了增强的预览功能，可以选择呈现预览窗口时的动画风格，并可以像预览单个文件一样预览多个文件。该框架主要提供了 QLPreviewController 类。该类依赖于委托对象响应预览动作，以及一个用于提供预览文件的数据源，内置了所支持的文件类型的 AirPrint 打印。 Quick Look Previews 中的预览及打印从 iOS 4.2 开始，QLPreviewController 提供了包含了一个 action 按钮（即打印按钮）的预览视图。对于 QLPreviewController 能预览的文件，不用编写任何打印代码，只需点击action按钮就能直接打印该文档。 通过以下方式显示QLPreviewController: 通过导航控制器，将预览窗口以“push 方式”显示。 通过 UIViewController 的 presentModalViewController:animated:方法，将预览窗口以模态窗口的方式全屏显示。 显示一个document interaction controller(如 “预览及打开文件” 中所述），再在选项菜单中选择“Quick Look”即可。 预览窗口中会包括一个标题，显示文件 URL 的最后一段路径。如果要重载标题，可以定制PreviewItem 类，并实现QLPreviewItem 协议中的 previewItemTitle方法。 QLPreviewController能够预览下列文件： iWork 文档 Microsoft Office 文档(Office ‘97 以后版本) Rich Text Format (RTF) 文档 PDF 文档 图片 文本文件，其 uniform type identifier (UTI) 在 public.text 文件中定义 (查看UniformType Identifiers 参考) Comma-separated value (csv) 文件 使用QLPreviewController，必须指定数据源对象（即实现 QLPreviewControllerDataSource 协议，请查看QLPreviewControllerDataSource协议参考）。数据源为 QLPreviewController提供预览对象（preivew item），及指明它们的数量以便在一个预览导航列表中包含它们。在这个列表中包含多个对象，在模态预览窗口（全屏显示）显示了导航箭头，以便用户在多个预览对象间切换。对于用导航控制器“push方式”显示的QLPreviewController，你可以在导航条上提供按钮以便在预览对象列表见切换。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"API","slug":"iOS/API","permalink":"https://huos3203.github.io/categories/iOS/API/"}],"tags":[{"name":"指南","slug":"指南","permalink":"https://huos3203.github.io/tags/指南/"}]},{"title":"instrument之Zombie工具","slug":"调试/instrument之Zombie工具","date":"2014-07-01T19:54:02.000Z","updated":"2019-04-24T23:21:29.845Z","comments":true,"path":"2014/07/02/调试/instrument之Zombie工具/","link":"","permalink":"https://huos3203.github.io/2014/07/02/调试/instrument之Zombie工具/","excerpt":"Zombie:针对僵尸对象导致应用程序崩溃，即已经deallocated的对象，它们的retainCount计数器已经为0，通过正常的手段是无法在debug中跟踪和观察到的。 如果你开启了 Zombie Enabled ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点： -[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt;","text":"Zombie:针对僵尸对象导致应用程序崩溃，即已经deallocated的对象，它们的retainCount计数器已经为0，通过正常的手段是无法在debug中跟踪和观察到的。 如果你开启了 Zombie Enabled ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点： -[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt; 虽然可以看到内存地址，知道是某个指针导致了 Zombie 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经deallocated，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针： （GDB）po &lt;内存地址&gt; 仍然会得到一个 message sent to deallocated instance 的错误消息。 可以在 Instrument 用 Zombie 模板，来观察到这些 Zombie 对象。 提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出Zombie对象，Zombie模板对物理设备无效。 使用操作如下：点击 Xcode 的 Project –&gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。 点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。 从列表中找到 retain count 在变为 -1 之前的那行,打开 View -&gt; Extended detail，将显示导致了过渡释放的代码调用： 双击这句代码，将在源文件中高亮显示该语句： 现在，知道问题出在哪里了吧？","categories":[{"name":"xcode","slug":"xcode","permalink":"https://huos3203.github.io/categories/xcode/"},{"name":"instrument","slug":"xcode/instrument","permalink":"https://huos3203.github.io/categories/xcode/instrument/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://huos3203.github.io/tags/工具/"},{"name":"Storyboard","slug":"Storyboard","permalink":"https://huos3203.github.io/tags/Storyboard/"}]},{"title":"UIDevice类介绍","slug":"iOS/UIDevice类介绍","date":"2014-06-17T15:12:53.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/06/17/iOS/UIDevice类介绍/","link":"","permalink":"https://huos3203.github.io/2014/06/17/iOS/UIDevice类介绍/","excerpt":"UIDevice.h设备的基本属性123456789+ (UIDevice *)currentDevice; // 获取当前设备NSString *name; // e.g. \"My iPhone\" NSString *model; // e.g. @\"iPhone\", @\"iPod touch\" NSString *localizedModel; // localized version of model NSString *systemName; // e.g. @\"iOS\" NSString *systemVersion; // e.g. @\"4.0\" UIDeviceOrientation orientation; //除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown NSUUID *identifierForVendor //可用于唯一标识该设备，同一供应商不同应用具有相同的UUID 方向属性值1234567UIDeviceOrientationUnknown,UIDeviceOrientationPortrait, // 竖向，头向上UIDeviceOrientationPortraitUpsideDown, // 竖向，头向下UIDeviceOrientationLandscapeLeft, // 横向，头向左UIDeviceOrientationLandscapeRight, // 横向，头向右UIDeviceOrientationFaceUp, // 平放，屏幕朝下UIDeviceOrientationFaceDown // 平放，屏幕朝下 //使用内置的宏定义的函数，根据orientation判断设备方向,返回值类型BOOL.纵向宏定义,返回YES:纵向1#define UIDeviceOrientationIsPortrait(orientation) ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown)横向宏定义,返回YES:横向1#define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight)","text":"UIDevice.h设备的基本属性123456789+ (UIDevice *)currentDevice; // 获取当前设备NSString *name; // e.g. \"My iPhone\" NSString *model; // e.g. @\"iPhone\", @\"iPod touch\" NSString *localizedModel; // localized version of model NSString *systemName; // e.g. @\"iOS\" NSString *systemVersion; // e.g. @\"4.0\" UIDeviceOrientation orientation; //除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown NSUUID *identifierForVendor //可用于唯一标识该设备，同一供应商不同应用具有相同的UUID 方向属性值1234567UIDeviceOrientationUnknown,UIDeviceOrientationPortrait, // 竖向，头向上UIDeviceOrientationPortraitUpsideDown, // 竖向，头向下UIDeviceOrientationLandscapeLeft, // 横向，头向左UIDeviceOrientationLandscapeRight, // 横向，头向右UIDeviceOrientationFaceUp, // 平放，屏幕朝下UIDeviceOrientationFaceDown // 平放，屏幕朝下 //使用内置的宏定义的函数，根据orientation判断设备方向,返回值类型BOOL.纵向宏定义,返回YES:纵向1#define UIDeviceOrientationIsPortrait(orientation) ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown)横向宏定义,返回YES:横向1#define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight) 横竖屏相关参数,方法与通知 检测当前设备是否生成设备转向通知1BOOL generatesDeviceOrientationNotifications 设备方向开始改变时，触发该方法，可以重写实现一些操作。1- (void)beginGeneratingDeviceOrientationNotifications; 设备结束方向改变时，触发的事件，可以重写该实现一些操作。1- (void)endGeneratingDeviceOrientationNotifications; 通知屏幕方向变化通知1UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification; ####手机电池相关属性与通知 电池属性电池属性123BOOL batteryMonitoringEnabled // 是否启动电池监控，默认为NO UIDeviceBatteryState batteryState //电池状态float batteryLevel //电量百分比， 0 .. 1.0,监控禁用时为-1 电池状态UIDeviceBatteryState属性值1234UIDeviceBatteryStateUnknown, //禁用电池监控UIDeviceBatteryStateUnplugged, // 未充电UIDeviceBatteryStateCharging, // 正在充电UIDeviceBatteryStateFull, // 满电 电池通知电池状态变化通知1UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification NS_AVAILABLE_IOS(3_0); 电池电量变化通知1UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification NS_AVAILABLE_IOS(3_0); 设备的其他属性及方法123456789BOOL proximityMonitoringEnabled // 是否启动接近监控（例如接电话时脸靠近屏幕），默认为NOBOOL proximityState // 如果设备不具备接近感应器，则总是返回NOBOOL multitaskingSupported // 是否支持多任务UIUserInterfaceIdiom userInterfaceIdiom // 当前用户界面模式- (void)playInputClick // 播放一个输入的声音 //用户界面类型iOS3.2以上有效1234#if __IPHONE_3_2 &lt;= __IPHONE_OS_VERSION_MAX_ALLOWED UIUserInterfaceIdiomPhone, // iPhone 和 iPod touch 风格 UIUserInterfaceIdiomPad, // iPad 风格#endif获取当前用户界面模式的宏定义1#define UI_USER_INTERFACE_IDIOM() ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] ? [[UIDevice currentDevice] userInterfaceIdiom] : UIUserInterfaceIdiomPhone) 一些协议的定义12345@protocol UIInputViewAudioFeedback@optional// 实现该方法，返回YES则自定义的视图能够播放输入的声音@property (nonatomic, readonly) BOOL enableInputClicksWhenVisible; @end 其他通知接近状态变化通知1UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"设备","slug":"iOS/设备","permalink":"https://huos3203.github.io/categories/iOS/设备/"}],"tags":[{"name":"设备","slug":"设备","permalink":"https://huos3203.github.io/tags/设备/"}]},{"title":"IOS7新宠TextKit","slug":"iOS/UI/IOS7新宠TextKit","date":"2014-06-16T22:24:48.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/06/17/iOS/UI/IOS7新宠TextKit/","link":"","permalink":"https://huos3203.github.io/2014/06/17/iOS/UI/IOS7新宠TextKit/","excerpt":"Text KitText Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。 更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。 IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：","text":"Text KitText Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。 更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。 IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示： Text Kit中4个重要的角色 Text Views: 用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。 Text containers: 对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。 Layout manager: 对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。 Text storage: 对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应关系:如果将文字显示为多列，或多页，可以按照下图关系，使用多个NSTextContainer:如果针对不同的排版方式，可以按照下图关系，使用多个NSLayoutManager:通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。如下图，为了更直观理解，对UITextView的组成做了分解: Text Kit示例 打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。 打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。 打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; //创建一个平移手势对象，该对象可以调用imagePanned：方法 UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; [self.imageView addGestureRecognizer:panGes]; self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];&#125; 在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。 translatedBezierPath方法实现如下：1234567- (UIBezierPath *)translatedBezierPath&#123; CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect]; return newButterflyPath;&#125; 在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。 imagePanned:方法实现如下：12345678910111213141516171819202122232425262728- (void)imagePanned:(id)sender&#123; if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) &#123; UIPanGestureRecognizer *localSender = sender; if (localSender.state == UIGestureRecognizerStateBegan) &#123; self.gestureStartingPoint = [localSender translationInView:self.textView]; self.gestureStartingCenter = self.imageView.center; &#125; else if (localSender.state == UIGestureRecognizerStateChanged) &#123; CGPoint currentPoint = [localSender translationInView:self.textView]; CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; CGPoint newCenter = self.gestureStartingCenter; newCenter.x += distanceX; newCenter.y += distanceY; self.imageView.center = newCenter; self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; &#125; else if (localSender.state == UIGestureRecognizerStateEnded) &#123; self.gestureStartingPoint = CGPointZero; self.gestureStartingCenter = CGPointZero; &#125; &#125;&#125; 在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。示例效果:","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[{"name":"TextKit","slug":"TextKit","permalink":"https://huos3203.github.io/tags/TextKit/"},{"name":"概念","slug":"概念","permalink":"https://huos3203.github.io/tags/概念/"}]},{"title":"IOS7的变革","slug":"iOS/IOS7的变革","date":"2014-06-11T10:17:19.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/06/11/iOS/IOS7的变革/","link":"","permalink":"https://huos3203.github.io/2014/06/11/iOS/IOS7的变革/","excerpt":"性能提高以及被遗弃的功能新增截屏通知:UIApplicationUserDidTakeScreenshotNotification在IOS 7之前，开发者使用了一种很赞的方法，来拦截截屏事件的.比如，Snapchat的实现原理: 用户通过Snapchat发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，截屏将打断触控操作，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。 在iOS 7中，专门为截屏完成后提供了一个通知: UIApplicationUserDidTakeScreenshotNotification.同时，也规避了IOS 6中截屏将打断触控操作的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。注册截屏完成后通知:注册监听事件，接收截屏完成后的通知1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mymethod:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; Note: 1.This notification is posted after the screenshot is taken. 2.This notification does not contain a userInfo dictionary. 新增手势: UIScreenEdgePanGestureRecognizerUIScreenEdgePanGestureRecognizer inherits from UIPanGestureRecognizer and lets you detect gestures starting near the edge of the screen.Using this new gesture recognizer is quite simple, as shown below:123456UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)];// accept gestures that start from the left; we're probably building another hamburger menu!recognizer.edges = UIRectEdgeLeft; [self.view addGestureRecognizer:recognizer];","text":"性能提高以及被遗弃的功能新增截屏通知:UIApplicationUserDidTakeScreenshotNotification在IOS 7之前，开发者使用了一种很赞的方法，来拦截截屏事件的.比如，Snapchat的实现原理: 用户通过Snapchat发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，截屏将打断触控操作，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。 在iOS 7中，专门为截屏完成后提供了一个通知: UIApplicationUserDidTakeScreenshotNotification.同时，也规避了IOS 6中截屏将打断触控操作的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。注册截屏完成后通知:注册监听事件，接收截屏完成后的通知1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mymethod:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; Note: 1.This notification is posted after the screenshot is taken. 2.This notification does not contain a userInfo dictionary. 新增手势: UIScreenEdgePanGestureRecognizerUIScreenEdgePanGestureRecognizer inherits from UIPanGestureRecognizer and lets you detect gestures starting near the edge of the screen.Using this new gesture recognizer is quite simple, as shown below:123456UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)];// accept gestures that start from the left; we're probably building another hamburger menu!recognizer.edges = UIRectEdgeLeft; [self.view addGestureRecognizer:recognizer]; 新增返回类型 – instancetype 苹果改变了大部分 initializer和简易构造函数（convenience constructors），instancetype可以代替id作返回类型。 instancetype 作用： 1.作为从Objective-C方法的返回类型。 2.在编译时，该方法的返回类型将是该方法所属的类的实例，编译器就会对返回的实例做一些检查，有bug及时发现及时解决。这一点优于id类型。 3.在调用子类方法时，就可以省去对返回值的强制类型转换。 举例:123456NSDictionary *d = [NSArray arrayWithObjects:@(1),@(2), nil];NSLog(@\"%i\", d.count);``` 这段代码显然有错误，但在Xcode4.6上是可以编译通过的。是由于Objective-C是动态性语言。``` objc+ (id)arrayWithObjects:(id)firstObj, ...; 并且，arrayWithObjects:返回id类型：是运行时的动态类型，编译器无法知道它的真实类型，即使调用一个id类型没有的方法，也不会产生编译警告。 那么，为什么arrayWithObjects:方法的返回类型还是id类型？来看看NSArray子类：12@interface MyArray : NSArray@end Now consider the use of your new subclass in the code below:123456 MyArray *array = [MyArray arrayWithObjects:@(1), @(2), nil];``` 如果方法`arrayWithObjects:`返回值的类型是`NSArray *`，那么子类`MyArray`就需要被强制转换为所需的类`NSArray`。这是正是`instancetype`返回类型的用武之地。在iPhone 7.0 SDK的NSArray中的头文件，已更新为：``` objc + (instancetype)arrayWithObjects:(id)firstObj, ...; 唯一的区别是返回类instancetype取代id。这种新的返回类型会告知编译器，返回值是该方法所属的类的实例对象。也就是说:当NSArray调用arrayWithObjects:时，返回类型推断为NSArray*;当MyArray调用arrayWithObjects:时，返回类型推断为MyArray*。 instancetype解决id类型的问题，同时也继承id类型功能。如果编译在Xcode 5的原代码，你会看到下面的警告：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 warning: incompatible pointer types initializing 'NSDictionary *' with an expression of type 'NSArray *' [-Wincompatible-pointer-types] NSDictionary *d = [NSArray arrayWithObjects:@(1), @(2), nil]; ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ``` w00t — now that’s helpful! You now have the opportunity to fix the problem before it turns into a crash later down the line. Initializers are also candidates for using this new return type. The compiler has warned you for some time now if you set the return type of an initializer to that of an incompatible type. But presumably it’s just implicitly converting the id return type to instancetype under the hood. You should still use instancetype for initializers though, because it’s better to be explicit for habit’s sake. Strive to use instancetype as much as possible going forward; it’s become a standard for Apple — and you never know when it will save you some painful debugging time later on. ### UIScrollView新增属性：`UIScrollViewKeyboardDismissMode`像Messages app一样在滚动的时候，将键盘隐藏，是一种非常好的体验。 在以前，将这项功能整合到app很难，现在仅仅只需要在Storyboard中简单的改变一个属性值，或者增加一行代码即可。这个属性使用了新的`UIScrollViewKeyboardDismissMode` enum枚举类型。这个enum枚举类型可能的值如下： ``` objc UIScrollViewKeyboardDismissMode枚举值 // the keyboard is not dismissed automatically when scrolling UIScrollViewKeyboardDismissModeNone // dismisses the keyboard when a drag begins UIScrollViewKeyboardDismissModeOnDrag // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss UIScrollViewKeyboardDismissModeInteractive ``` 在storyboard中设置该属性值: ![UIScrollViewKeyboardDismissMode](/images/UIScrollViewKeyboardDismissMode.png) ### UIKit使用[NSAttributedString]((http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/)显示HTML，[TextKit](http://)在app中使用Webviews有时会让人非常沮丧，即使只是显示少量的HTML内容 ,Webviews也会消耗大量的内存。现在提供了一种全新的简单易用的方式来展示HTML内容，适用于任意的`UIKit`控件，如`UILabel`或`UITextField`等。 1.用少量HTML片段，初始化`NSAttributedString`对象:&#123;% codeblock lang:objc Time to be Awesome - awesome.rb %&#125; NSString *html = @\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\";NSDictionary *options = @&#123;NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType&#125;;&#123;% endcodeblock %&#125; ``` objc 用少量HTML片段，初始化`NSAttributedString`对象 http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/NSString *html = @\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\";NSDictionary *options = @&#123;NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType&#125;;NSData *htmlData = [html dataUsingEncoding:NSUTF8StringEncoding];NSAttributedString *attrString = [[NSAttributedString alloc] initWithData:htmlData options:options documentAttributes:nil error:nil];``` NSDocumentTypeDocumentAttribute包括:&lt;!--https://gist.githubusercontent.com/huos3203/ecba275d5e4404678354/raw/1636f62209b056b4acbe07021f596e1ffd5ef301/%E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5--&gt; NSPlainTextDocumentType //Plain text document. NSRTFTextDocumentType //Rich text format document. NSRTFDTextDocumentType //Rich text format with attachments document.2.相反，也可以将`NSAttributedString`对象，解析成HTML片段：&#123;% gist ecba275d5e4404678354 %E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5.m %&#125; ### NSLinkAttributeName让标签（UILabel,UITextView）支持超链接 首先，创建一个`NSAttributedString`对象,然后，调用`addAttribute:value:range:`方法，添加 `NSLinkAttributeName`属性并赋值，如下： ``` objc UITextView支持超链接 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@\"This is an example by @marcelofabri_\"]; [attributedString addAttribute:NSLinkAttributeName value:@\"username://marcelofabri_\" range:[[attributedString string] rangeOfString:@\"@marcelofabri_\"]]; NSDictionary *linkAttributes = @&#123;NSForegroundColorAttributeName: [UIColor greenColor], NSUnderlineColorAttributeName: [UIColor lightGrayColor], NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)&#125;; // assume that textView is a UITextView previously created (either by code or Interface Builder) textView.linkTextAttributes = linkAttributes; // customizes the appearance of links textView.attributedText = attributedString; textView.delegate = self; 当然，也可以使用UITextViewDelegate新增的协议方法shouldInteractWithURL，来自定义点击事件：协议方法shouldInteractWithURL12345678910- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123; if ([[URL scheme] isEqualToString:@\"username\"]) &#123; NSString *username = [URL host]; // do something with this username // ... return NO; &#125; return YES; // let the system open this URL &#125; Tint images with UIImage.renderingModeTinting is a big part of the new look and feel of iOS 7, and you have control whether your image is tinted or not when rendered.UIImage now has a read-only property named renderingMode as well as a new method imageWithRenderingMode: which uses the new enum UIImageRenderingMode containing the following possible values:123456// Use the default rendering mode for the context where the image is used UIImageRenderingModeAutomatic // Always draw the original image, without treating it as a template UIImageRenderingModeAlwaysOriginal // Always draw the image as a template image, ignoring its color information UIImageRenderingModeAlwaysTemplate The code below shows how easy it is to create an image with a given rendering mode:12UIImage *img = [UIImage imageNamed:@\"myimage\"]; img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; The default value of renderingMode is UIImageRenderingModeAutomatic.Whether the image will be tinted or not depends on where it’s being displayed as shown by the examples below: Usage of tintColor vs barTintColorIn iOS 7 you can tint your entire app with a given color or even implement color themes to help your app stand out from the rest.Setting the tint color of your app is as easy as using the new property tintColor of UIView.Does that property sound familiar? it should — some classes such as UINavigationBar, UISearchBar, UITabBar and UIToolbar already had a property with this name. They now have a new property: barTintColor.In order to avoid getting tripped up by the new property, you should perform the following check if your app needs to support iOS 6 or earlier: bar通过判断是否包含setBarTintColor:确定系统版本12345678910111213141516171819202122232425UINavigationBar *bar = self.navigationController.navigationBar;UIColor *color = [UIColor greenColor];if ([bar respondsToSelector:@selector(setBarTintColor:)]) &#123; // iOS 7+ bar.barTintColor = color;&#125; else &#123; // iOS 6 or earlier bar.tintColor = color;&#125;``` ### Check which wireless routes are availableThe ability to customize a video player (and friends) has evolved throughout the past few iOS versions. As an example, prior to iOS 6 you couldn’t change the AirPlay icon on a `MPVolumeView`. In iOS 7, you’re finally able to know if a remote device is available via AirPlay, Bluetooth, or some other wireless mechanism. This allows your app to behave appropriately, such as hiding an AirPlay icon when that service isn’t available on other devices. The following two new properties and notifications have been added to MPVolumeView: ``` objc // is there a route that the device can connect to? @property (nonatomic, readonly) BOOL wirelessRoutesAvailable; // is the device currently connected? @property (nonatomic, readonly) BOOL wirelessRouteActive; NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification; NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification; -[NSArray firstObject]的实现-[NSArray firstObject]可能是Objective-C中被调用做多的API。 在iOS4.0中firstObject已经被使用，但是那时仅仅是一个私有方法。在iOS7以前，常用方法：1234NSArray *arr = @[]; id item = [arr firstObject]; // 前你需要做以下工作 id item = [arr count] &gt; 0 ? arr[0] : nil; 因为上面的方式很常用，一般创建一个类别实现该方法firstObject增加到NSArray中。 这个方法的问题:方法名必须是唯一的，否则,这个方法所引发的问题无法预估。所以在NSArray中最好不要重载firstObject方法，是有风险的。 UIButtonTypeRoundRect被UIButtonTypeSystem取代 UIPasteboard由共享变为沙盒化了UIPasteboard过去是用来做app之间的数据分享的。开发者一般使用它来存储标识符，比如:OpenUDID。但在在iOS7中，使用 +[UIPasteboard pasteboardWithName:create:]和 +[UIPasteboard pasteboardWithUniqueName]创建剪贴板，而且只对相同的app group可见，这样再和其他的相关app分享以前的OpenUDID等标识符时，就会出现问题。 MAC地址:被统一化在IOS7之前，生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。 一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。然而，苹果并不希望有人通过MAC地址来分辨用户，在iOS7以上，查询MAC地址，它现在只会返回02:00:00:00:00:00。目前，苹果推荐开发者使用以下两种方式，来获取作为框架和应用的唯一标示符：1234567891011121314151617181920212223 NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString]; NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];``` `identifierForVendor`：由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。`advertisingIdentifier`：返回给在这个设备上所有软件供应商公用的唯一值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。 #### app启动麦克风，需争征得用户同意 以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。 现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。 以下的代码是用来查询用户是否允许app使用麦克风： ``` objc //第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据 // 其他时候调用方法的时候，则不会提醒用户 // 而会传递之前的值来要求用户同意 [[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) &#123; if (granted) &#123; // 用户同意获取数据 &#125; else &#123; // 可以显示一个提示框告诉用户这个app没有得到允许？ &#125; &#125; ]; 如果没有经过用户同意，就调用麦克风，iOS系统自动弹出以下警示栏：","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"},{"name":"特性","slug":"iOS/特性","permalink":"https://huos3203.github.io/categories/iOS/特性/"}],"tags":[{"name":"IOS7","slug":"IOS7","permalink":"https://huos3203.github.io/tags/IOS7/"}]},{"title":"在IOS中像SnapChat一样监控screenshots","slug":"iOS/在IOS中像SnapChat一样监控screenshots","date":"2014-06-10T18:45:37.000Z","updated":"2019-04-24T23:21:29.815Z","comments":true,"path":"2014/06/11/iOS/在IOS中像SnapChat一样监控screenshots/","link":"","permalink":"https://huos3203.github.io/2014/06/11/iOS/在IOS中像SnapChat一样监控screenshots/","excerpt":"A number of Stack Overflowquestions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.","text":"A number of Stack Overflowquestions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.The process is pretty simple, and relies on a quirk of iOS: taking a screenshot cancels all touches on the screen. Because of that, anything that you want to protect will require you to have the user to touch the screen to see. If that works for your purposes, the general solution is to simply intercept the touch cancellation, and quickly remove any sensitive information from the screen. If you’re also implementing a screenshot counter, as with SnapChat, you will also need to take into account the other cases when a touch might be cancelled: from a system gesture (Notification Center or the iPad’s multitasking gestures), or by activating other pieces of system UI (the power down menu, or the multitasking switcher). On a technical level, the two basic pieces are UILongPressGestureRecognizer (or -touchesCancelled:withEvent:, if you want) and UIApplicationDelegate. In your long press handler, you should hide your sensitive information when the gesture recognizer’s state is UIGestureRecognizerStateCancelled, and if you want to track the number of screenshots, increment a counter. Then, in the UIApplicationDelegate, decrement that counter when you receive the -applicationWillEnterBackground: or -applicationDidResignActive: notification to account for the other possibilities for a cancelled touch. You might also need to handle other situations where a touch could be cancelled, if other parts of your app might cause that to happen.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[{"name":"截屏","slug":"截屏","permalink":"https://huos3203.github.io/tags/截屏/"}]},{"title":"IOS7截屏问题","slug":"iOS/IOS7截屏问题","date":"2014-06-10T18:29:31.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/06/11/iOS/IOS7截屏问题/","link":"","permalink":"https://huos3203.github.io/2014/06/11/iOS/IOS7截屏问题/","excerpt":"iOS 7截图最新变化: 不再影响用户其他操作 在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。","text":"iOS 7截图最新变化: 不再影响用户其他操作 在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。 用户在应用中打开 Snapchat 照片，查看照片时用户需要单指按在屏幕上让照片处于打开的状态。如果用户试图截图，那么照片马上就会关闭。这是 Snapchat 用来检测“非法”截图的办法。用户拍了照片发送给好友后，这些照片会根据用户所预先设定的时间按时自动销毁。如果接收方在此期间试图进行截图的话，用户也将得到通知。 Snapchat在美国青少年群体中十分流行，因为它拥有一种独特的“阅后即焚”机制。用户通过该应用发送的照片将会在数秒内自动被删除，而且它还将采用一种特殊手段阻止照片接收者截屏，并将其截屏企图报告给发送者。在 iOS 6 中，截屏将打断触控操作，而用户观看 Snapchat 照片时，必须将手指按在屏幕上。 在 iOS 7 中截图的操作不会迫使 SnapChat 查看照片的窗口关闭，也就是说当用户截图时系统也不会发出提醒通知。截图不会影响用户在屏幕上的操作，照片不会关闭应用也无法识别截图的动作。如果一名 iOS 6 用户试图截图 iOS 7 用户会收到通知，而反过来的话 iOS 6 用户则不会受到通知。这对于 Snapchat 来说，绝对是个恶梦，因为该服务的风靡与阅后即焚机制关系很大。 虽然 iOS 7 的这个变化对于 iOS 7 Snapchat 用户来说有一定的意义，但是这也对 Snapchat 等应用提出更高的要求，他们必须研究出新的办法来检测截图操作，确保这个新特性不会对他们的应用产生影响。 所幸 iOS 7 beta 4 的发布可以让开发商放下心来。9to5Mac 的 Scott Buscemi 不久前宣布，新版本中新增了一个截屏侦测 API。开发者并未透露这个其具体特性，但他暗示说这个 API 对 Snapchat 来说非常至关重要. UIApplication.h // This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons) UIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0); 据悉，iOS 7 beta 2 发布之后，此前一些无法实现的有趣操作也随之变得可行。由于 iOS 6 的截屏将取消触控操作，使得用户难以截取拉了半截的锁屏界面。而在 iOS 7 beta 2 中，一切变得容易起来（见下图）。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://huos3203.github.io/categories/iOS/"}],"tags":[{"name":"截屏","slug":"截屏","permalink":"https://huos3203.github.io/tags/截屏/"}]},{"title":"初步搭建Octopress","slug":"hexo/初步搭建Octopress","date":"2014-06-09T23:26:22.000Z","updated":"2019-04-24T23:21:29.805Z","comments":true,"path":"2014/06/10/hexo/初步搭建Octopress/","link":"","permalink":"https://huos3203.github.io/2014/06/10/hexo/初步搭建Octopress/","excerpt":"软件支持： Github:后台新建项目，点击下载 iTerm2:可以替代mac终端，相当强大。下载 ruby:ruby安装包 下载 Mou:MarkDown编辑软件，可用于后期发布博客文章。下载 Xcode：它将帮助你安装好Unix环境需要的开发包。 ￼","text":"软件支持： Github:后台新建项目，点击下载 iTerm2:可以替代mac终端，相当强大。下载 ruby:ruby安装包 下载 Mou:MarkDown编辑软件，可用于后期发布博客文章。下载 Xcode：它将帮助你安装好Unix环境需要的开发包。 ￼ 学习目的：要求:搭建一个独立博客网站,首先要有台连接到英特网服务器,要有前端的页面和后端的数据库,以及域名等. github可以提供给我们的是,github一个免费的代码托管仓库,它支持用户html页面的显示,用户可以上传HTML文件,然后在远程像访问网页一样访问它。 这时，博客还缺具有管理能力的网站后台,github不提供数据库等，对于博客这种数据规模很小,便可返璞归真,用回静态页面。 Octopress:能将易于编写的Markdown的文本，翻译成为繁琐的html页面，同时帮助用户管理html页面并发布到github page上。 搭建环境： Github:既然要托管到github,那么便要有github的环境. 检查本机的git环境,在命令行输入 git--version Octopress:是基于Jekyll的,需要ruby的环境编译。检查本机ruby环境，命令行：ruby-vruby的version1.9.3以上,新版的Mac,这些都是有装的。 gcc和make,ruby的环境需要gcc,这个会通过安装xcode的command line tool来完成安装 检查本机gcc环境，命令行：gcc -v 安装Octpress:通过Git安装: 下载Octopress：gitclonegit://github.com/imathis/octopress.git octopress 进入Octopress目录：cd octopress 安装必要的依赖包： gem install bundler rbenv rehash # If you use rbenv, rehash to be able to run the bundle command bundle install 最后安装Octopress:rake install 配置： 修改配置文件_config.yml： 配置个人站点的信息：url:git远程库地址，title:博客题目,author:作者名,等。 注意：最好将twitter相关的配置信息全部删掉,否则由于GFW的原因,将会造成页面load很慢。 修改定制文件：/source/_includes/custom/head.html把google的自定义字体去掉,原因同上。 写博客：博文是用markdown语法，另外扩充一些插件，网上相关介绍很多，例如：这个 新建Markdown文件: rake new_post[&#39;文章名&#39;]或 rake new_page[&#39;404&#39;] 翻译Mardown为静态文件: rake generate 检测文件变化： rake watch 启动本机测试端口4000： rake preview 发布至git库： rake deploy 添加多说： 需要在多说网注册个帐号，添加站点，获取站点 short_name. ######底部评论： 在 _config.yml 中添加123#duoshuo commentsduoshuo_comments: trueduoshuo_short_name: yourname 在source/_layouts/post.html中的 disqus代码： 123456&#123; % if site.disqus_short_name and page.comments == true % &#125; &lt;section&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;div id=\"disqus_thread\" aria-live=\"polite\"&gt;&#123; % include post/disqus_thread.html % &#125;&lt;/div&gt; &lt;/section&gt;&#123; % endif % &#125; 下方添加 多说评论 模块: 123456&#123; % if site.duoshuo_short_name and site.duoshuo_comments == true and page.comments == true % &#125;&lt;section&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;div id=\"comments\" aria-live=\"polite\"&gt;&#123; % include post/duoshuo.html % &#125;&lt;/div&gt; &lt;/section&gt;&#123; % endif % &#125; 然后就按路径创建一个source/_includes/post/duoshuo.html 1234567891011121314&lt;!-- Duoshuo Comment BEGIN --&gt;&lt;div class=\"ds-thread\" data-title=\"\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var duoshuoQuery = &#123;short_name:\"\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript'; ds.async = true; ds.src = 'http://static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)();&lt;/script&gt;&lt;!-- Duoshuo Comment END --&gt; 随后，再修改 _includes/article.html 文件,123&#123; % if site.disqus_short_name and page.comments != false and post.comments !=false and site.disqus_show_comment_count == true % &#125; | &lt;a href=\"&#123; % if index % &#125;&#123;&#123; root_url &#125;&#125;&#123;&#123; post.url &#125;&#125;&#123; % endif % &#125;#disqus_thread\"&gt;Comments&lt;/a&gt;&#123; % endif % &#125; 下方添加如下多说评论链接路径： 1234&#123; % if site.duoshuo_short_name and page.comments != false and post.comments != false and site.duoshuo_comments == true % &#125;| &lt;a href=\"&#123; % if index % &#125;&#123; % endif % &#125;#comments\"&gt;Comments&lt;/a&gt;&#123; % endif % &#125; ######首页侧边栏插入最新评论 首先在 _config.yml 中再插入如下代码 123456duoshuo_asides_num: 10 # 侧边栏评论显示条目数duoshuo_asides_avatars: 0 # 侧边栏评论是否显示头像duoshuo_asides_time: 0 # 侧边栏评论是否显示时间duoshuo_asides_title: 0 # 侧边栏评论是否显示标题duoshuo_asides_admin: 0 # 侧边栏评论是否显示作者评论duoshuo_asides_length: 18 # 侧边栏评论截取的长度 再创建 _includes/custom/asides/recent_comments.html 1234567891011121314151617181920212223242526&lt;section&gt;&lt;h1&gt;Recent Comments&lt;/h1&gt; &lt;ul class=\"ds-recent-comments\" data-num-items=\"\" data-show-avatars=\"\" data-show-time=\"\" data-show-title=\"\" data-show-admin=\"\" data-excerpt-length=\"\"&gt;&lt;/ul&gt; &#123; % if index % &#125;&lt;!-- 多说js加载开始，一个页面只需要加载一次 --&gt; &lt;script type=\"text/javascript\"&gt; var duoshuoQuery = &#123;short_name:\"\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript'; ds.async = true; ds.src = 'http://static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说js加载结束，一个页面只需要加载一次 --&gt; &#123; % endif % &#125;&lt;/section&gt; 最后修改：_config.yml 配置: 方式一：在 blog_index_asides 行或 page_asides 行或 post_asides 添加： 12345blog_index_asides:[custom/asides/recent_comments.html]或page_asides:[custom/asides/recent_comments.html]或post_asides:[custom/asides/recent_comments.html] 方式二：将路径添加到 default_asides:[…] 中 1default_asides: [custom/asides/recent_comments.html, asides/recent_posts.html, ...] Update 1多说评论似乎升级了系统，无法自动获取到页面文章标题，所以手动在评论页插入 data-title。--2013.09.10 Tips: 发布图文： 如果在文章中上传图片： * 直接copy到/source/images目录即可。便可以以相对路径(/images/imgname.png)的形式，在文章中引用。 * 或找一个图库站点，例如flickr之类，然后在文章中引用该图片远程路径即可。 域名：如果有自己的域名空间，可以将域名指向自己的博客，步骤如下： * **配置DNS(需购买域名)**:在域名管理中，新建一个CNAME指向，将自己的域名指向yourname.github.com. * **给repo配置域名**:在source目录里，新建一个名为CNAME的文件，然后将自己的域名输入即可。 * 将内容push到github后，大概需审核一个小时左右生效，然后就可以使用自己的域名访问该博客了。 添加百度统计和google analytics 从百度统计获取脚本,然后添加到文件source/_includes/after_footer.html文件中。 从google analytics获取跟踪ID,然后将这个ID添加到_config.yml文件的google_analytics_tracking_id后面即可。 Octopress目录结构，及之间的关系： ￼ 原理： Octopress版本库： gh-pages分支：用于存放生成的最终网页。 source分支:用于存放最初的markdown文件。 职责详述：平时写作和提交都在source分支下，当需要发布时，rake deploy 命令会将内容生成到public这个目录，然后将这个目录中的内容push到gh-pages分支中。 其中sass和source:这是博客的源代码文件目录。发布时，需要把源代码也上传到github上,这样便可以多台机写博客了。 _deploy:是通过octopress生成的静态页面的博客文件夹,我们可以看到它的里面也有.git的文件。 cd进到该目录,使用git remote ­v查看12origin http://github.com/....github.io(fetch)origin http://github.com/....github.io(push) 它会在我们使用rake deploy时自动push到该远程库的gh-pages分支。这时就不需要再手动push。只需要将博客源代码手动push到该远程库的source分支中. 以上细节可参照Octopress根目录中Rakefile配置信息 使用多台电脑的同时写博客 需要先拿把source code拿下来 git pull origin source check in更新,将本地 source分支上的代码，合并到远程仓库上123git add .git commit -m &apos;yourmessage&apos;git push origin source 版本管理你可以先去github上新建一个空的Repo（最好是private的，否则可能会被其他人拿到你的source），拿到repo的url，然后到octopress目录下执行下面这些操作：1234567# 因为你是从octopress github上clone的，所以需要把origin这个branch换一个名字git remote rename origin octopressgit remote add origin (your github url)# 把你的github branch作为默认的branchgit config branch.master.remote origin# 把你的octopress导入到github上去git push -u origin master 如果你新增加了博客或者修改了某些内容，你可以把你的改动commit到github上去：123git add sourcegit commit -a -m &apos;new blog or edit some blog&apos;git push -u origin master 如果octopress有更新，你可以直接pull octopress这个branch进行更新即可12git pull octopress mastergit push -u origin master","categories":[{"name":"hexo","slug":"hexo","permalink":"https://huos3203.github.io/categories/hexo/"}],"tags":[{"name":"octopress","slug":"octopress","permalink":"https://huos3203.github.io/tags/octopress/"},{"name":"blog","slug":"blog","permalink":"https://huos3203.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://huos3203.github.io/tags/github/"},{"name":"mou","slug":"mou","permalink":"https://huos3203.github.io/tags/mou/"},{"name":"ruby","slug":"ruby","permalink":"https://huos3203.github.io/tags/ruby/"}]}]}