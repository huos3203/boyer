<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>git on Even - A super concise theme for Hugo</title>
    <link>https://it-boyer.github.io/tags/git/</link>
    <description>Recent content in git on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 Feb 2017 18:19:48 +0000</lastBuildDate>
    
	<atom:link href="https://it-boyer.github.io/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>用Git将代码恢复到一个历史的版本</title>
      <link>https://it-boyer.github.io/post/git/%E7%94%A8git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Fri, 10 Feb 2017 18:19:48 +0000</pubDate>
      
      <guid>https://it-boyer.github.io/post/git/%E7%94%A8git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果： 目的：在当前分支上，将代码恢复到一个历史的提交版本上。 暴力的方</description>
    </item>
    
    <item>
      <title>迁移SVN库到git库保留branchs和tags</title>
      <link>https://it-boyer.github.io/post/git/%E8%BF%81%E7%A7%BBsvn%E5%BA%93%E5%88%B0git%E5%BA%93%E4%BF%9D%E7%95%99branchs%E5%92%8Ctags/</link>
      <pubDate>Wed, 18 Jan 2017 12:21:46 +0000</pubDate>
      
      <guid>https://it-boyer.github.io/post/git/%E8%BF%81%E7%A7%BBsvn%E5%BA%93%E5%88%B0git%E5%BA%93%E4%BF%9D%E7%95%99branchs%E5%92%8Ctags/</guid>
      <description>SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository. 首先导入一个本地存储</description>
    </item>
    
    <item>
      <title>Mac安装gitLab服务器</title>
      <link>https://it-boyer.github.io/post/git/mac%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Sun, 27 Sep 2015 19:25:38 +0800</pubDate>
      
      <guid>https://it-boyer.github.io/post/git/mac%E5%AE%89%E8%A3%85gitlab%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>必要配置 *创建一个名称为&amp;quot;gitlab&amp;quot;管理员用户，然后再创建一个名称为&amp;quot;gitlab&amp;quot;的群组 *开启</description>
    </item>
    
    <item>
      <title>Git中的储藏工具stash</title>
      <link>https://it-boyer.github.io/post/git/git%E4%B8%AD%E7%9A%84%E5%82%A8%E8%97%8F%E5%B7%A5%E5%85%B7stash/</link>
      <pubDate>Mon, 19 Jan 2015 19:57:04 +0800</pubDate>
      
      <guid>https://it-boyer.github.io/post/git/git%E4%B8%AD%E7%9A%84%E5%82%A8%E8%97%8F%E5%B7%A5%E5%85%B7stash/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#Stashing&#34;&gt;Stashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#work&#34;&gt;储藏工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#apply&#34;&gt;应用储藏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#applyIndex&#34;&gt;被暂存的文件重新暂存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#drop&#34;&gt;应用后，移除储藏的内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unapply&#34;&gt;取消储藏(Un-applying a Stash)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stash-unapply&#34;&gt;新建stash-unapply别名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stashBranch&#34;&gt;从储藏中创建分支&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;a-name-stashing-git工具-储藏-stashing-a-git&#34;&gt;&lt;a name=&#34;Stashing&#34;&gt;Git工具 - 储藏（Stashing）&lt;/a&gt;git&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-工具-储藏与清理&#34;&gt;原文&lt;/a&gt;
场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。&lt;/p&gt;

&lt;p&gt;问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。&lt;/p&gt;

&lt;p&gt;解决：&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git stash &lt;/font&gt;&lt;/strong&gt;命令。&lt;/p&gt;

&lt;p&gt;“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。&lt;/p&gt;

&lt;h3 id=&#34;a-name-work-储藏工作-a&#34;&gt;&lt;a name=&#34;work&#34;&gt;储藏工作&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;进入项目目录，修改某个文件，有可能还暂存其中的一个变更。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git status &lt;/font&gt;&lt;/strong&gt;命令,查看中间状态：
{%codeblock lang:bash %}
$ git status&lt;/p&gt;

&lt;h1 id=&#34;on-branch-master&#34;&gt;On branch master&lt;/h1&gt;

&lt;h1 id=&#34;changes-to-be-committed&#34;&gt;Changes to be committed:&lt;/h1&gt;

&lt;h1 id=&#34;use-git-reset-head-file-to-unstage&#34;&gt;(use &amp;ldquo;git reset HEAD &lt;file&gt;&amp;hellip;&amp;rdquo; to unstage)&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1 id=&#34;modified-index-html&#34;&gt;modified:   index.html&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1 id=&#34;changes-not-staged-for-commit&#34;&gt;Changes not staged for commit:&lt;/h1&gt;

&lt;h1 id=&#34;use-git-add-file-to-update-what-will-be-committed&#34;&gt;(use &amp;ldquo;git add &lt;file&gt;&amp;hellip;&amp;rdquo; to update what will be committed)&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1 id=&#34;modified-lib-simplegit-rb&#34;&gt;modified:   lib/simplegit.rb&lt;/h1&gt;

&lt;p&gt;#
{%endcodeblock%}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换分支，但不提交step 1 中的变更，所以储藏这些变更。
执行&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git stash &lt;/font&gt;&lt;/strong&gt;命令，往堆栈中推送一个新的储藏：
{%codeblock lang:bash %}
$ git stash
Saved working directory and index state &lt;br /&gt;
&amp;ldquo;WIP on master: 049d078 added the index file&amp;rdquo;
HEAD is now at 049d078 added the index file
(To restore them type &amp;ldquo;git stash apply&amp;rdquo;)
{%endcodeblock%}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行step 2查看目录库，中间状态就不见了：
{%codeblock lang:bash %}
$ git status
#######On branch master
nothing to commit, working directory clean
{%endcodeblock%}
这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git stash list&lt;/font&gt;&lt;/strong&gt;要查看现有的储藏：
{%codeblock lang:bash%}
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert &amp;ldquo;added file_size&amp;rdquo;
stash@{2}: WIP on master: 21d80a5 added number to log
{%endcodeblock%}
在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。&lt;/p&gt;

&lt;h3 id=&#34;a-name-apply-应用储藏-a&#34;&gt;&lt;a name=&#34;apply&#34;&gt;应用储藏&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;执行&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git stash apply&lt;/font&gt;&lt;/strong&gt;命令, 可以重新应用最近的一次储藏；
执行&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;git stash apply stash@{2}&lt;/font&gt;&lt;/strong&gt;命令，即通过指定储藏的名字，来应用更早的储藏。
{%codeblock lang:bash%}
$ git stash apply&lt;/p&gt;

&lt;h1 id=&#34;on-branch-master-1&#34;&gt;On branch master&lt;/h1&gt;

&lt;h1 id=&#34;changes-not-staged-for-commit-1&#34;&gt;Changes not staged for commit:&lt;/h1&gt;

&lt;h1 id=&#34;use-git-add-file-to-update-what-will-be-committed-1&#34;&gt;(use &amp;ldquo;git add &lt;file&gt;&amp;hellip;&amp;rdquo; to update what will be committed)&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1 id=&#34;modified-index-html-1&#34;&gt;modified:   index.html&lt;/h1&gt;

&lt;h1 id=&#34;modified-lib-simplegit-rb-1&#34;&gt;modified:   lib/simplegit.rb&lt;/h1&gt;

&lt;p&gt;#
{%endcodeblock%}&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>